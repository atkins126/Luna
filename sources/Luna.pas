{==============================================================================
        .
     .--:         :
    ----        :---:
  .-----         .-.
 .------          .
 -------.
.--------               :
.---------             .:.
 ----------:            .
 :-----------:
  --------------:.         .:.
   :------------------------
    .---------------------.
       :---------------:.
          ..:::::::..
              ...
     _
    | |    _  _  _ _   __ _
    | |__ | || || ' \ / _` |
    |____| \_,_||_||_|\__,_|
         Game Toolkit™

Copyright © 2022 tinyBigGAMES™ LLC
All Rights Reserved.

Website: https://tinybiggames.com
Email  : support@tinybiggames.com

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software in
   a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

2. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

3. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

4. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

5. All video, audio, graphics and other content accessed through the
   software in this distro is the property of the applicable content owner
   and may be protected by applicable copyright law. This License gives
   Customer no rights to such content, and Company disclaims any liability
   for misuse of content.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
============================================================================= }

unit Luna;

interface

{$REGION 'Defines'}

{$WARN SYMBOL_DEPRECATED OFF}
{$WARN SYMBOL_PLATFORM OFF}

{$WARN UNIT_PLATFORM OFF}
{$WARN UNIT_DEPRECATED OFF}

{$MINENUMSIZE 4}
{$ALIGN ON}

{$Z4}
{$A8}

{$INLINE AUTO}

{$IFNDEF WIN64}
  {$MESSAGE Error 'Unsupported platform'}
{$ENDIF}

{$ENDREGION}

{$REGION 'uses'}
uses
  System.SysUtils,
  System.Generics.Collections,
  System.Classes,
  System.IOUtils,
  System.Math,
  System.JSON,
  System.Net.HttpClient,
  System.NetEncoding,
  System.Net.URLClient,
  System.Variants,
  Vcl.OleServer,
  Vcl.OleCtrls,
  WinApi.Windows,
  System.Win.ComObj,
  System.Win.StdVCL,
  WinApi.ShellAPI,
  Winapi.ActiveX;
{$ENDREGION}

{$REGION 'Luna.Deps'}
const
  NK_INCLUDE_FIXED_TYPES = 1;
  NK_INCLUDE_STANDARD_IO = 1;
  NK_INCLUDE_STANDARD_VARARGS = 1;
  NK_INCLUDE_DEFAULT_ALLOCATOR = 1;
  NK_INCLUDE_VERTEX_BUFFER_OUTPUT = 1;
  NK_INCLUDE_FONT_BAKING = 1;
  NK_INCLUDE_DEFAULT_FONT = 1;
  HAVE_WINAPIFAMILY_H = 1;
  { TODO : Unable to convert function-like macro: }
  (* WINAPI_FAMILY_PARTITION ( Partitions ) ( Partitions ) *)
  WINAPI_FAMILY_DESKTOP_APP = 100;
  WINAPI_FAMILY = WINAPI_FAMILY_DESKTOP_APP;
  WINAPI_PARTITION_DESKTOP = (WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP);
  { TODO : Macro uses commented-out symbol "WINAPI_FAMILY_PARTITION": }
  (* WINAPI_FAMILY_WINRT ( ! WINAPI_FAMILY_PARTITION ( WINAPI_PARTITION_DESKTOP ) && WINAPI_FAMILY_PARTITION ( WINAPI_PARTITION_APP ) ) *)
  { TODO : Macro refers to system symbol "__WINDOWS__": }
  (* __WINDOWS__ 1 *)
  { TODO : Macro refers to system symbol "__WIN32__": }
  (* __WIN32__ 1 *)
  { TODO : Macro refers to system symbol "__cdecl": }
  (* SDLCALL __cdecl *)
  { TODO : Macro refers to system symbol "__inline": }
  (* SDL_INLINE __inline *)
  { TODO : Macro refers to system symbol "__inline__": }
  (* __inline__ __inline *)
  { TODO : Macro refers to system symbol "__forceinline": }
  (* SDL_FORCE_INLINE __forceinline *)
  { TODO : Macro refers to system symbol "__declspec": }
  (* SDL_NORETURN __declspec ( noreturn ) *)
  { TODO : Macro probably uses invalid symbol "void": }
  (* NULL ( ( void * ) 0 ) *)
  { TODO : Macro refers to system symbol "__has_attribute": }
  (* _HAS_FALLTHROUGH __has_attribute ( __fallthrough__ ) *)
  { TODO : Macro refers to system symbol "__attribute__": }
  (* SDL_FALLTHROUGH __attribute__ ( ( __fallthrough__ ) ) *)
  HAVE_WINSDKVER_H = 1;
  HAVE_SDKDDKVER_H = 1;
  HAVE_STDINT_H = 1;
  SIZEOF_VOIDP = 8;
  HAVE_GCC_ATOMICS = 1;
  HAVE_DDRAW_H = 1;
  HAVE_DINPUT_H = 1;
  HAVE_DSOUND_H = 1;
  HAVE_DXGI_H = 1;
  HAVE_XINPUT_H = 1;
  HAVE_WINDOWS_GAMING_INPUT_H = 1;
  HAVE_D3D11_H = 1;
  HAVE_ROAPI_H = 1;
  HAVE_SHELLSCALINGAPI_H = 1;
  HAVE_MMDEVICEAPI_H = 1;
  HAVE_AUDIOCLIENT_H = 1;
  HAVE_TPCSHRD_H = 1;
  HAVE_SENSORSAPI_H = 1;
  HAVE_IMMINTRIN_H = 1;
  HAVE_STDARG_H = 1;
  HAVE_STDDEF_H = 1;
  SDL_AUDIO_DRIVER_WASAPI = 1;
  SDL_AUDIO_DRIVER_DSOUND = 1;
  SDL_AUDIO_DRIVER_WINMM = 1;
  SDL_AUDIO_DRIVER_DISK = 1;
  SDL_AUDIO_DRIVER_DUMMY = 1;
  SDL_JOYSTICK_DINPUT = 1;
  SDL_JOYSTICK_HIDAPI = 1;
  SDL_JOYSTICK_RAWINPUT = 1;
  SDL_JOYSTICK_VIRTUAL = 1;
  SDL_JOYSTICK_WGI = 1;
  SDL_JOYSTICK_XINPUT = 1;
  SDL_HAPTIC_DINPUT = 1;
  SDL_HAPTIC_XINPUT = 1;
  SDL_SENSOR_WINDOWS = 1;
  SDL_LOADSO_WINDOWS = 1;
  SDL_THREAD_GENERIC_COND_SUFFIX = 1;
  SDL_THREAD_WINDOWS = 1;
  SDL_TIMER_WINDOWS = 1;
  SDL_VIDEO_DRIVER_DUMMY = 1;
  SDL_VIDEO_DRIVER_WINDOWS = 1;
  SDL_VIDEO_RENDER_D3D = 1;
  SDL_VIDEO_RENDER_D3D11 = 1;
  SDL_VIDEO_OPENGL = 1;
  SDL_VIDEO_OPENGL_WGL = 1;
  SDL_VIDEO_RENDER_OGL = 1;
  SDL_VIDEO_RENDER_OGL_ES2 = 1;
  SDL_VIDEO_OPENGL_ES2 = 1;
  SDL_VIDEO_OPENGL_EGL = 1;
  SDL_VIDEO_VULKAN = 1;
  SDL_POWER_WINDOWS = 1;
  SDL_FILESYSTEM_WINDOWS = 1;
  SIZE_MAX = $ffffffffffffffff;
  SDL_SIZE_MAX = SIZE_MAX;
  { TODO : Unable to convert function-like macro: }
  (* _SDL_HAS_BUILTIN ( x ) __has_builtin ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_arraysize ( array ) ( sizeof ( array ) / sizeof ( array [ 0 ] ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_TABLESIZE ( table ) SDL_arraysize ( table ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_STRINGIFY_ARG ( arg ) # arg *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_reinterpret_cast ( type , expression ) ( ( type ) ( expression ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_static_cast ( type , expression ) ( ( type ) ( expression ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_const_cast ( type , expression ) ( ( type ) ( expression ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_FOURCC ( A , B , C , D ) ( ( SDL_static_cast ( Uint32 , SDL_static_cast ( Uint8 , ( A ) ) ) << 0 ) | ( SDL_static_cast ( Uint32 , SDL_static_cast ( Uint8 , ( B ) ) ) << 8 ) | ( SDL_static_cast ( Uint32 , SDL_static_cast ( Uint8 , ( C ) ) ) << 16 ) | ( SDL_static_cast ( Uint32 , SDL_static_cast ( Uint8 , ( D ) ) ) << 24 ) ) *)
  SDL_MAX_SINT8 = $7F;
  SDL_MIN_SINT8 = (not $7F);
  SDL_MAX_UINT8 = $FF;
  SDL_MIN_UINT8 = $00;
  SDL_MAX_SINT16 = $7FFF;
  SDL_MIN_SINT16 = (not $7FFF);
  SDL_MAX_UINT16 = $FFFF;
  SDL_MIN_UINT16 = $0000;
  SDL_MAX_SINT32 = $7FFFFFFF;
  SDL_MIN_SINT32 = (not $7FFFFFFF);
  SDL_MAX_UINT32 = $FFFFFFFF;
  SDL_MIN_UINT32 = $00000000;
  SDL_MAX_SINT64 = $7FFFFFFFFFFFFFFF;
  SDL_MIN_SINT64 = (not $7FFFFFFFFFFFFFFF);
  SDL_MAX_UINT64 = $FFFFFFFFFFFFFFFF;
  SDL_MIN_UINT64 = $0000000000000000;
  SDL_FLT_EPSILON = 1.1920928955078125e-07;
  (* SDL_IN_BYTECAP ( x ) _In_bytecount_ ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_INOUT_Z_CAP ( x ) _Inout_z_cap_ ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_OUT_Z_CAP ( x ) _Out_z_cap_ ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_OUT_CAP ( x ) _Out_cap_ ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_OUT_BYTECAP ( x ) _Out_bytecap_ ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_OUT_Z_BYTECAP ( x ) _Out_z_bytecap_ ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* _SAL2_Source_ ( Name , args , annotes ) _SA_annotes3 ( SAL_name , # Name , "" , "2" ) _Group_ ( annotes _SAL_nop_impl_ ) *)
  { TODO : Unable to convert macro: }
  (* _Printf_format_string_ _SAL2_Source_ ( _Printf_format_string_ , ( ) , _Printf_format_string_impl_ ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_PRINTF_VARARG_FUNC ( fmtargnumber ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SCANF_VARARG_FUNC ( fmtargnumber ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_COMPILE_TIME_ASSERT ( name , x ) _Static_assert ( x , # x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_stack_alloc ( type , count ) ( type * ) SDL_malloc ( sizeof ( type ) * ( count ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_stack_free ( data ) SDL_free ( data ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_min ( x , y ) ( ( ( x ) < ( y ) ) ? ( x ) : ( y ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_max ( x , y ) ( ( ( x ) > ( y ) ) ? ( x ) : ( y ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_clamp ( x , a , b ) ( ( ( x ) < ( a ) ) ? ( a ) : ( ( ( x ) > ( b ) ) ? ( b ) : ( x ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_zero ( x ) SDL_memset ( & ( x ) , 0 , sizeof ( ( x ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_zerop ( x ) SDL_memset ( ( x ) , 0 , sizeof ( * ( x ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_zeroa ( x ) SDL_memset ( ( x ) , 0 , sizeof ( ( x ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_copyp ( dst , src ) { SDL_COMPILE_TIME_ASSERT ( SDL_copyp , sizeof ( * ( dst ) ) == sizeof ( * ( src ) ) ) ; } SDL_memcpy ( ( dst ) , ( src ) , sizeof ( * ( src ) ) ) *)
  M_PI = 3.14159265358979323846264338327950288;
  { TODO : Macro probably uses invalid symbol "size_t": }
  (* SDL_ICONV_ERROR ( size_t ) - 1 *)
  { TODO : Macro probably uses invalid symbol "size_t": }
  (* SDL_ICONV_E2BIG ( size_t ) - 2 *)
  { TODO : Macro probably uses invalid symbol "size_t": }
  (* SDL_ICONV_EILSEQ ( size_t ) - 3 *)
  { TODO : Macro probably uses invalid symbol "size_t": }
  (* SDL_ICONV_EINVAL ( size_t ) - 4 *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_iconv_utf8_locale ( S ) SDL_iconv_string ( "" , "UTF-8" , S , SDL_strlen ( S ) + 1 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_iconv_utf8_ucs2 ( S ) ( Uint16 * ) SDL_iconv_string ( "UCS-2-INTERNAL" , "UTF-8" , S , SDL_strlen ( S ) + 1 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_iconv_utf8_ucs4 ( S ) ( Uint32 * ) SDL_iconv_string ( "UCS-4-INTERNAL" , "UTF-8" , S , SDL_strlen ( S ) + 1 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_iconv_wchar_utf8 ( S ) SDL_iconv_string ( "UTF-8" , "WCHAR_T" , ( char * ) S , ( SDL_wcslen ( S ) + 1 ) * sizeof ( wchar_t ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_size_mul_overflow ( a , b , ret ) ( _SDL_size_mul_overflow_builtin ( a , b , ret ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_size_add_overflow ( a , b , ret ) ( _SDL_size_add_overflow_builtin ( a , b , ret ) ) *)
  { TODO : Macro probably uses invalid symbol "main": }
  (* main SDL_main *)
  SDL_ASSERT_LEVEL = 1;
  { TODO : Unable to convert function-like macro: }
  (* SDL_TriggerBreakpoint ( ) __debugbreak ( ) *)
  { TODO : Macro refers to system symbol "__func__": }
  (* SDL_FUNCTION __func__ *)
  { TODO : Macro refers to system symbol "__FILE__": }
  (* SDL_FILE __FILE__ *)
  { TODO : Macro refers to system symbol "__LINE__": }
  (* SDL_LINE __LINE__ *)
  { TODO : Unable to convert macro: }
  (* SDL_NULL_WHILE_LOOP_CONDITION ( 0 , 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_disabled_assert ( condition ) do { ( void ) sizeof ( ( condition ) ) ; } while ( SDL_NULL_WHILE_LOOP_CONDITION ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_enabled_assert ( condition ) do { while ( ! ( condition ) ) { static struct SDL_AssertData sdl_assert_data = { 0 , 0 , # condition , 0 , 0 , 0 , 0 } ; const SDL_AssertState sdl_assert_state = SDL_ReportAssertion ( & sdl_assert_data , SDL_FUNCTION , SDL_FILE , SDL_LINE ) ; if ( sdl_assert_state == SDL_ASSERTION_RETRY ) { continue ; /* go again. */ } else if ( sdl_assert_state == SDL_ASSERTION_BREAK ) { SDL_TriggerBreakpoint ( ) ; } break ; /* not retrying. */ } } while ( SDL_NULL_WHILE_LOOP_CONDITION ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_assert ( condition ) SDL_disabled_assert ( condition ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_assert_release ( condition ) SDL_enabled_assert ( condition ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_assert_paranoid ( condition ) SDL_disabled_assert ( condition ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_assert_always ( condition ) SDL_enabled_assert ( condition ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_CompilerBarrier ( ) \
{ SDL_SpinLock _tmp = 0 ; SDL_AtomicLock ( & _tmp ) ; SDL_AtomicUnlock ( & _tmp ) ; } *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_MemoryBarrierRelease ( ) SDL_CompilerBarrier ( ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_MemoryBarrierAcquire ( ) SDL_CompilerBarrier ( ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_CPUPauseInstruction ( ) __asm__ __volatile__ ( "pause\n" ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_AtomicIncRef ( a ) SDL_AtomicAdd ( a , 1 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_AtomicDecRef ( a ) ( SDL_AtomicAdd ( a , - 1 ) == 1 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_OutOfMemory ( ) SDL_Error ( SDL_ENOMEM ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_Unsupported ( ) SDL_Error ( SDL_UNSUPPORTED ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_InvalidParamError ( param ) SDL_SetError ( "Parameter '%s' is invalid" , ( param ) ) *)
  SDL_LIL_ENDIAN = 1234;
  SDL_BIG_ENDIAN = 4321;
  SDL_BYTEORDER = SDL_LIL_ENDIAN;
  SDL_FLOATWORDORDER = SDL_BYTEORDER;
  { TODO : Macro uses commented-out symbol "_SDL_HAS_BUILTIN": }
  (* HAS_BUILTIN_BSWAP16 ( _SDL_HAS_BUILTIN ( __builtin_bswap16 ) ) || ( __GNUC__ > 4 || ( __GNUC__ == 4 && __GNUC_MINOR__ >= 8 ) ) *)
  { TODO : Macro uses commented-out symbol "_SDL_HAS_BUILTIN": }
  (* HAS_BUILTIN_BSWAP32 ( _SDL_HAS_BUILTIN ( __builtin_bswap32 ) ) || ( __GNUC__ > 4 || ( __GNUC__ == 4 && __GNUC_MINOR__ >= 3 ) ) *)
  { TODO : Macro uses commented-out symbol "_SDL_HAS_BUILTIN": }
  (* HAS_BUILTIN_BSWAP64 ( _SDL_HAS_BUILTIN ( __builtin_bswap64 ) ) || ( __GNUC__ > 4 || ( __GNUC__ == 4 && __GNUC_MINOR__ >= 3 ) ) *)
  { TODO : Macro refers to system symbol "__GNUC__": }
  (* HAS_BROKEN_BSWAP ( __GNUC__ == 2 && __GNUC_MINOR__ <= 95 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_Swap16 ( x ) __builtin_bswap16 ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_Swap32 ( x ) __builtin_bswap32 ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_Swap64 ( x ) __builtin_bswap64 ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SwapLE16 ( X ) ( X ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SwapLE32 ( X ) ( X ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SwapLE64 ( X ) ( X ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SwapFloatLE ( X ) ( X ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SwapBE16 ( X ) SDL_Swap16 ( X ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SwapBE32 ( X ) SDL_Swap32 ( X ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SwapBE64 ( X ) SDL_Swap64 ( X ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SwapFloatBE ( X ) SDL_SwapFloat ( X ) *)
  SDL_MUTEX_TIMEDOUT = 1;
  SDL_MUTEX_MAXWAIT = (not 0);
  { TODO : Unable to convert function-like macro: }
  (* SDL_mutexP ( m ) SDL_LockMutex ( m ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_mutexV ( m ) SDL_UnlockMutex ( m ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_CreateThread ( fn , name , data ) SDL_CreateThread ( fn , name , data , ( pfnSDL_CurrentBeginThread ) SDL_beginthread , ( pfnSDL_CurrentEndThread ) SDL_endthread ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_CreateThreadWithStackSize ( fn , name , stacksize , data ) SDL_CreateThreadWithStackSize ( fn , name , data , ( pfnSDL_CurrentBeginThread ) _beginthreadex , ( pfnSDL_CurrentEndThread ) SDL_endthread ) *)
  SDL_RWOPS_UNKNOWN = 0;
  SDL_RWOPS_WINFILE = 1;
  SDL_RWOPS_STDFILE = 2;
  SDL_RWOPS_JNIFILE = 3;
  SDL_RWOPS_MEMORY = 4;
  SDL_RWOPS_MEMORY_RO = 5;
  RW_SEEK_SET = 0;
  RW_SEEK_CUR = 1;
  RW_SEEK_END = 2;
  SDL_AUDIO_MASK_BITSIZE = ($FF);
  SDL_AUDIO_MASK_DATATYPE = (1 shl 8);
  SDL_AUDIO_MASK_ENDIAN = (1 shl 12);
  SDL_AUDIO_MASK_SIGNED = (1 shl 15);
  { TODO : Unable to convert function-like macro: }
  (* SDL_AUDIO_BITSIZE ( x ) ( x & SDL_AUDIO_MASK_BITSIZE ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_AUDIO_ISFLOAT ( x ) ( x & SDL_AUDIO_MASK_DATATYPE ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_AUDIO_ISBIGENDIAN ( x ) ( x & SDL_AUDIO_MASK_ENDIAN ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_AUDIO_ISSIGNED ( x ) ( x & SDL_AUDIO_MASK_SIGNED ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_AUDIO_ISINT ( x ) ( ! SDL_AUDIO_ISFLOAT ( x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_AUDIO_ISLITTLEENDIAN ( x ) ( ! SDL_AUDIO_ISBIGENDIAN ( x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_AUDIO_ISUNSIGNED ( x ) ( ! SDL_AUDIO_ISSIGNED ( x ) ) *)
  AUDIO_U8 = $0008;
  AUDIO_S8 = $8008;
  AUDIO_U16LSB = $0010;
  AUDIO_S16LSB = $8010;
  AUDIO_U16MSB = $1010;
  AUDIO_S16MSB = $9010;
  AUDIO_U16 = AUDIO_U16LSB;
  AUDIO_S16 = AUDIO_S16LSB;
  AUDIO_S32LSB = $8020;
  AUDIO_S32MSB = $9020;
  AUDIO_S32 = AUDIO_S32LSB;
  AUDIO_F32LSB = $8120;
  AUDIO_F32MSB = $9120;
  AUDIO_F32 = AUDIO_F32LSB;
  AUDIO_U16SYS = AUDIO_U16LSB;
  AUDIO_S16SYS = AUDIO_S16LSB;
  AUDIO_S32SYS = AUDIO_S32LSB;
  AUDIO_F32SYS = AUDIO_F32LSB;
  SDL_AUDIO_ALLOW_FREQUENCY_CHANGE = $00000001;
  SDL_AUDIO_ALLOW_FORMAT_CHANGE = $00000002;
  SDL_AUDIO_ALLOW_CHANNELS_CHANGE = $00000004;
  SDL_AUDIO_ALLOW_SAMPLES_CHANGE = $00000008;
  SDL_AUDIO_ALLOW_ANY_CHANGE = (SDL_AUDIO_ALLOW_FREQUENCY_CHANGE or SDL_AUDIO_ALLOW_FORMAT_CHANGE or SDL_AUDIO_ALLOW_CHANNELS_CHANGE or SDL_AUDIO_ALLOW_SAMPLES_CHANGE);
  SDL_AUDIOCVT_MAX_FILTERS = 9;
  { TODO : Unable to convert function-like macro: }
  (* SDL_LoadWAV ( file , spec , audio_buf , audio_len ) SDL_LoadWAV_RW ( SDL_RWFromFile ( file , "rb" ) , 1 , spec , audio_buf , audio_len ) *)
  SDL_MIX_MAXVOLUME = 128;
  SDL_CACHELINE_SIZE = 128;
  SDL_ALPHA_OPAQUE = 255;
  SDL_ALPHA_TRANSPARENT = 0;
  { TODO : Unable to convert function-like macro: }
  (* SDL_DEFINE_PIXELFOURCC ( A , B , C , D ) SDL_FOURCC ( A , B , C , D ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_DEFINE_PIXELFORMAT ( type , order , layout , bits , bytes ) ( ( 1 << 28 ) | ( ( type ) << 24 ) | ( ( order ) << 20 ) | ( ( layout ) << 16 ) | ( ( bits ) << 8 ) | ( ( bytes ) << 0 ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_PIXELFLAG ( X ) ( ( ( X ) >> 28 ) & 0x0F ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_PIXELTYPE ( X ) ( ( ( X ) >> 24 ) & 0x0F ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_PIXELORDER ( X ) ( ( ( X ) >> 20 ) & 0x0F ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_PIXELLAYOUT ( X ) ( ( ( X ) >> 16 ) & 0x0F ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_BITSPERPIXEL ( X ) ( ( ( X ) >> 8 ) & 0xFF ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_BYTESPERPIXEL ( X ) ( SDL_ISPIXELFORMAT_FOURCC ( X ) ? ( ( ( ( X ) == SDL_PIXELFORMAT_YUY2 ) || ( ( X ) == SDL_PIXELFORMAT_UYVY ) || ( ( X ) == SDL_PIXELFORMAT_YVYU ) ) ? 2 : 1 ) : ( ( ( X ) >> 0 ) & 0xFF ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_ISPIXELFORMAT_INDEXED ( format ) ( ! SDL_ISPIXELFORMAT_FOURCC ( format ) && ( ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_INDEX1 ) || ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_INDEX4 ) || ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_INDEX8 ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_ISPIXELFORMAT_PACKED ( format ) ( ! SDL_ISPIXELFORMAT_FOURCC ( format ) && ( ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_PACKED8 ) || ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_PACKED16 ) || ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_PACKED32 ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_ISPIXELFORMAT_ARRAY ( format ) ( ! SDL_ISPIXELFORMAT_FOURCC ( format ) && ( ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_ARRAYU8 ) || ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_ARRAYU16 ) || ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_ARRAYU32 ) || ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_ARRAYF16 ) || ( SDL_PIXELTYPE ( format ) == SDL_PIXELTYPE_ARRAYF32 ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_ISPIXELFORMAT_ALPHA ( format ) ( ( SDL_ISPIXELFORMAT_PACKED ( format ) && ( ( SDL_PIXELORDER ( format ) == SDL_PACKEDORDER_ARGB ) || ( SDL_PIXELORDER ( format ) == SDL_PACKEDORDER_RGBA ) || ( SDL_PIXELORDER ( format ) == SDL_PACKEDORDER_ABGR ) || ( SDL_PIXELORDER ( format ) == SDL_PACKEDORDER_BGRA ) ) ) || ( SDL_ISPIXELFORMAT_ARRAY ( format ) && ( ( SDL_PIXELORDER ( format ) == SDL_ARRAYORDER_ARGB ) || ( SDL_PIXELORDER ( format ) == SDL_ARRAYORDER_RGBA ) || ( SDL_PIXELORDER ( format ) == SDL_ARRAYORDER_ABGR ) || ( SDL_PIXELORDER ( format ) == SDL_ARRAYORDER_BGRA ) ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_ISPIXELFORMAT_FOURCC ( format ) ( ( format ) && ( SDL_PIXELFLAG ( format ) != 1 ) ) *)
  SDL_SWSURFACE = 0;
  SDL_PREALLOC = $00000001;
  SDL_RLEACCEL = $00000002;
  SDL_DONTFREE = $00000004;
  SDL_SIMD_ALIGNED = $00000008;
  { TODO : Unable to convert function-like macro: }
  (* SDL_MUSTLOCK ( S ) ( ( ( S ) -> flags & SDL_RLEACCEL ) != 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_LoadBMP ( file ) SDL_LoadBMP_RW ( SDL_RWFromFile ( file , "rb" ) , 1 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_SaveBMP ( surface , file ) SDL_SaveBMP_RW ( surface , SDL_RWFromFile ( file , "wb" ) , 1 ) *)
  SDL_WINDOWPOS_UNDEFINED_MASK = $1FFF0000;
  SDL_WINDOWPOS_UNDEFINED = SDL_WINDOWPOS_UNDEFINED_MASK or 0;
  { TODO : Unable to convert function-like macro: }
  (* SDL_WINDOWPOS_UNDEFINED_DISPLAY ( X ) ( SDL_WINDOWPOS_UNDEFINED_MASK | ( X ) ) *)
  { TODO : Macro uses commented-out symbol "SDL_WINDOWPOS_UNDEFINED_DISPLAY": }
  (* SDL_WINDOWPOS_UNDEFINED SDL_WINDOWPOS_UNDEFINED_DISPLAY ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_WINDOWPOS_ISUNDEFINED ( X ) ( ( ( X ) & 0xFFFF0000 ) == SDL_WINDOWPOS_UNDEFINED_MASK ) *)
  SDL_WINDOWPOS_CENTERED_MASK = $2FFF0000;
  SDL_WINDOWPOS_CENTERED = SDL_WINDOWPOS_CENTERED_MASK or 0;
  { TODO : Unable to convert function-like macro: }
  (* SDL_WINDOWPOS_CENTERED_DISPLAY ( X ) ( SDL_WINDOWPOS_CENTERED_MASK | ( X ) ) *)
  { TODO : Macro uses commented-out symbol "SDL_WINDOWPOS_CENTERED_DISPLAY": }
  (* SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED_DISPLAY ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_WINDOWPOS_ISCENTERED ( X ) ( ( ( X ) & 0xFFFF0000 ) == SDL_WINDOWPOS_CENTERED_MASK ) *)
  SDLK_SCANCODE_MASK = (1 shl 30);
  { TODO : Unable to convert function-like macro: }
  (* SDL_SCANCODE_TO_KEYCODE ( X ) ( X | SDLK_SCANCODE_MASK ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_BUTTON ( X ) ( 1 << ( ( X ) - 1 ) ) *)
  SDL_BUTTON_LEFT = 1;
  SDL_BUTTON_MIDDLE = 2;
  SDL_BUTTON_RIGHT = 3;
  SDL_BUTTON_X1 = 4;
  SDL_BUTTON_X2 = 5;
  { TODO : Macro uses commented-out symbol "SDL_BUTTON": }
  (* SDL_BUTTON_LMASK SDL_BUTTON ( SDL_BUTTON_LEFT ) *)
  { TODO : Macro uses commented-out symbol "SDL_BUTTON": }
  (* SDL_BUTTON_MMASK SDL_BUTTON ( SDL_BUTTON_MIDDLE ) *)
  { TODO : Macro uses commented-out symbol "SDL_BUTTON": }
  (* SDL_BUTTON_RMASK SDL_BUTTON ( SDL_BUTTON_RIGHT ) *)
  { TODO : Macro uses commented-out symbol "SDL_BUTTON": }
  (* SDL_BUTTON_X1MASK SDL_BUTTON ( SDL_BUTTON_X1 ) *)
  { TODO : Macro uses commented-out symbol "SDL_BUTTON": }
  (* SDL_BUTTON_X2MASK SDL_BUTTON ( SDL_BUTTON_X2 ) *)
  SDL_IPHONE_MAX_GFORCE = 5.0;
  SDL_VIRTUAL_JOYSTICK_DESC_VERSION = 1;
  SDL_JOYSTICK_AXIS_MAX = 32767;
  SDL_JOYSTICK_AXIS_MIN = -32768;
  SDL_HAT_CENTERED = $00;
  SDL_HAT_UP = $01;
  SDL_HAT_RIGHT = $02;
  SDL_HAT_DOWN = $04;
  SDL_HAT_LEFT = $08;
  SDL_HAT_RIGHTUP = (SDL_HAT_RIGHT or SDL_HAT_UP);
  SDL_HAT_RIGHTDOWN = (SDL_HAT_RIGHT or SDL_HAT_DOWN);
  SDL_HAT_LEFTUP = (SDL_HAT_LEFT or SDL_HAT_UP);
  SDL_HAT_LEFTDOWN = (SDL_HAT_LEFT or SDL_HAT_DOWN);
  SDL_STANDARD_GRAVITY = 9.80665;
  { TODO : Unable to convert function-like macro: }
  (* SDL_GameControllerAddMappingsFromFile ( file ) SDL_GameControllerAddMappingsFromRW ( SDL_RWFromFile ( file , "rb" ) , 1 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_QuitRequested ( ) ( SDL_PumpEvents ( ) , ( SDL_PeepEvents ( NULL , 0 , SDL_PEEKEVENT , SDL_QUIT , SDL_QUIT ) > 0 ) ) *)
  SDL_TOUCH_MOUSEID = -1;
  SDL_MOUSE_TOUCHID = -1;
  SDL_RELEASED = 0;
  SDL_PRESSED = 1;
  SDL_TEXTEDITINGEVENT_TEXT_SIZE = (32);
  SDL_TEXTINPUTEVENT_TEXT_SIZE = (32);
  SDL_QUERY = -1;
  SDL_IGNORE = 0;
  SDL_DISABLE = 0;
  SDL_ENABLE = 1;
  { TODO : Unable to convert function-like macro: }
  (* SDL_GetEventState ( type ) SDL_EventState ( type , SDL_QUERY ) *)
  SDL_HAPTIC_CONSTANT = (1 shl 0);
  SDL_HAPTIC_SINE = (1 shl 1);
  SDL_HAPTIC_LEFTRIGHT = (1 shl 2);
  SDL_HAPTIC_TRIANGLE = (1 shl 3);
  SDL_HAPTIC_SAWTOOTHUP = (1 shl 4);
  SDL_HAPTIC_SAWTOOTHDOWN = (1 shl 5);
  SDL_HAPTIC_RAMP = (1 shl 6);
  SDL_HAPTIC_SPRING = (1 shl 7);
  SDL_HAPTIC_DAMPER = (1 shl 8);
  SDL_HAPTIC_INERTIA = (1 shl 9);
  SDL_HAPTIC_FRICTION = (1 shl 10);
  SDL_HAPTIC_CUSTOM = (1 shl 11);
  SDL_HAPTIC_GAIN = (1 shl 12);
  SDL_HAPTIC_AUTOCENTER = (1 shl 13);
  SDL_HAPTIC_STATUS = (1 shl 14);
  SDL_HAPTIC_PAUSE = (1 shl 15);
  SDL_HAPTIC_POLAR = 0;
  SDL_HAPTIC_CARTESIAN = 1;
  SDL_HAPTIC_SPHERICAL = 2;
  SDL_HAPTIC_STEERING_AXIS = 3;
  SDL_HAPTIC_INFINITY = 4294967295;
  SDL_HINT_ACCELEROMETER_AS_JOYSTICK = 'SDL_ACCELEROMETER_AS_JOYSTICK';
  SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED = 'SDL_ALLOW_ALT_TAB_WHILE_GRABBED';
  SDL_HINT_ALLOW_TOPMOST = 'SDL_ALLOW_TOPMOST';
  SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION = 'SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION';
  SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION = 'SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION';
  SDL_HINT_ANDROID_BLOCK_ON_PAUSE = 'SDL_ANDROID_BLOCK_ON_PAUSE';
  SDL_HINT_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO = 'SDL_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO';
  SDL_HINT_ANDROID_TRAP_BACK_BUTTON = 'SDL_ANDROID_TRAP_BACK_BUTTON';
  SDL_HINT_APP_NAME = 'SDL_APP_NAME';
  SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS = 'SDL_APPLE_TV_CONTROLLER_UI_EVENTS';
  SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION = 'SDL_APPLE_TV_REMOTE_ALLOW_ROTATION';
  SDL_HINT_AUDIO_CATEGORY = 'SDL_AUDIO_CATEGORY';
  SDL_HINT_AUDIO_DEVICE_APP_NAME = 'SDL_AUDIO_DEVICE_APP_NAME';
  SDL_HINT_AUDIO_DEVICE_STREAM_NAME = 'SDL_AUDIO_DEVICE_STREAM_NAME';
  SDL_HINT_AUDIO_DEVICE_STREAM_ROLE = 'SDL_AUDIO_DEVICE_STREAM_ROLE';
  SDL_HINT_AUDIO_RESAMPLING_MODE = 'SDL_AUDIO_RESAMPLING_MODE';
  SDL_HINT_AUTO_UPDATE_JOYSTICKS = 'SDL_AUTO_UPDATE_JOYSTICKS';
  SDL_HINT_AUTO_UPDATE_SENSORS = 'SDL_AUTO_UPDATE_SENSORS';
  SDL_HINT_BMP_SAVE_LEGACY_FORMAT = 'SDL_BMP_SAVE_LEGACY_FORMAT';
  SDL_HINT_DISPLAY_USABLE_BOUNDS = 'SDL_DISPLAY_USABLE_BOUNDS';
  SDL_HINT_EMSCRIPTEN_ASYNCIFY = 'SDL_EMSCRIPTEN_ASYNCIFY';
  SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT = 'SDL_EMSCRIPTEN_KEYBOARD_ELEMENT';
  SDL_HINT_ENABLE_STEAM_CONTROLLERS = 'SDL_ENABLE_STEAM_CONTROLLERS';
  SDL_HINT_EVENT_LOGGING = 'SDL_EVENT_LOGGING';
  SDL_HINT_FORCE_RAISEWINDOW = 'SDL_HINT_FORCE_RAISEWINDOW';
  SDL_HINT_FRAMEBUFFER_ACCELERATION = 'SDL_FRAMEBUFFER_ACCELERATION';
  SDL_HINT_GAMECONTROLLERCONFIG = 'SDL_GAMECONTROLLERCONFIG';
  SDL_HINT_GAMECONTROLLERCONFIG_FILE = 'SDL_GAMECONTROLLERCONFIG_FILE';
  SDL_HINT_GAMECONTROLLERTYPE = 'SDL_GAMECONTROLLERTYPE';
  SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES = 'SDL_GAMECONTROLLER_IGNORE_DEVICES';
  SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT = 'SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT';
  SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS = 'SDL_GAMECONTROLLER_USE_BUTTON_LABELS';
  SDL_HINT_GRAB_KEYBOARD = 'SDL_GRAB_KEYBOARD';
  SDL_HINT_IDLE_TIMER_DISABLED = 'SDL_IOS_IDLE_TIMER_DISABLED';
  SDL_HINT_IME_INTERNAL_EDITING = 'SDL_IME_INTERNAL_EDITING';
  SDL_HINT_IME_SHOW_UI = 'SDL_IME_SHOW_UI';
  SDL_HINT_IME_SUPPORT_EXTENDED_TEXT = 'SDL_IME_SUPPORT_EXTENDED_TEXT';
  SDL_HINT_IOS_HIDE_HOME_INDICATOR = 'SDL_IOS_HIDE_HOME_INDICATOR';
  SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS = 'SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS';
  SDL_HINT_JOYSTICK_HIDAPI = 'SDL_JOYSTICK_HIDAPI';
  SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE = 'SDL_JOYSTICK_HIDAPI_GAMECUBE';
  SDL_HINT_JOYSTICK_GAMECUBE_RUMBLE_BRAKE = 'SDL_JOYSTICK_GAMECUBE_RUMBLE_BRAKE';
  SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS = 'SDL_JOYSTICK_HIDAPI_JOY_CONS';
  SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS = 'SDL_JOYSTICK_HIDAPI_COMBINE_JOY_CONS';
  SDL_HINT_JOYSTICK_HIDAPI_LUNA = 'SDL_JOYSTICK_HIDAPI_LUNA';
  SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC = 'SDL_JOYSTICK_HIDAPI_NINTENDO_CLASSIC';
  SDL_HINT_JOYSTICK_HIDAPI_SHIELD = 'SDL_JOYSTICK_HIDAPI_SHIELD';
  SDL_HINT_JOYSTICK_HIDAPI_PS3 = 'SDL_JOYSTICK_HIDAPI_PS3';
  SDL_HINT_JOYSTICK_HIDAPI_PS4 = 'SDL_JOYSTICK_HIDAPI_PS4';
  SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE = 'SDL_JOYSTICK_HIDAPI_PS4_RUMBLE';
  SDL_HINT_JOYSTICK_HIDAPI_PS5 = 'SDL_JOYSTICK_HIDAPI_PS5';
  SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED = 'SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED';
  SDL_HINT_JOYSTICK_HIDAPI_PS5_RUMBLE = 'SDL_JOYSTICK_HIDAPI_PS5_RUMBLE';
  SDL_HINT_JOYSTICK_HIDAPI_STADIA = 'SDL_JOYSTICK_HIDAPI_STADIA';
  SDL_HINT_JOYSTICK_HIDAPI_STEAM = 'SDL_JOYSTICK_HIDAPI_STEAM';
  SDL_HINT_JOYSTICK_HIDAPI_SWITCH = 'SDL_JOYSTICK_HIDAPI_SWITCH';
  SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED = 'SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED';
  SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED = 'SDL_JOYSTICK_HIDAPI_JOYCON_HOME_LED';
  SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED = 'SDL_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED';
  SDL_HINT_JOYSTICK_HIDAPI_WII = 'SDL_JOYSTICK_HIDAPI_WII';
  SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED = 'SDL_JOYSTICK_HIDAPI_WII_PLAYER_LED';
  SDL_HINT_JOYSTICK_HIDAPI_XBOX = 'SDL_JOYSTICK_HIDAPI_XBOX';
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_360 = 'SDL_JOYSTICK_HIDAPI_XBOX_360';
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED = 'SDL_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED';
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS = 'SDL_JOYSTICK_HIDAPI_XBOX_360_WIRELESS';
  SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE = 'SDL_JOYSTICK_HIDAPI_XBOX_ONE';
  SDL_HINT_JOYSTICK_RAWINPUT = 'SDL_JOYSTICK_RAWINPUT';
  SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT = 'SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT';
  SDL_HINT_JOYSTICK_ROG_CHAKRAM = 'SDL_JOYSTICK_ROG_CHAKRAM';
  SDL_HINT_JOYSTICK_THREAD = 'SDL_JOYSTICK_THREAD';
  SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER = 'SDL_KMSDRM_REQUIRE_DRM_MASTER';
  SDL_HINT_JOYSTICK_DEVICE = 'SDL_JOYSTICK_DEVICE';
  SDL_HINT_LINUX_DIGITAL_HATS = 'SDL_LINUX_DIGITAL_HATS';
  SDL_HINT_LINUX_HAT_DEADZONES = 'SDL_LINUX_HAT_DEADZONES';
  SDL_HINT_LINUX_JOYSTICK_CLASSIC = 'SDL_LINUX_JOYSTICK_CLASSIC';
  SDL_HINT_LINUX_JOYSTICK_DEADZONES = 'SDL_LINUX_JOYSTICK_DEADZONES';
  SDL_HINT_MAC_BACKGROUND_APP = 'SDL_MAC_BACKGROUND_APP';
  SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK = 'SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK';
  SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH = 'SDL_MAC_OPENGL_ASYNC_DISPATCH';
  SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS = 'SDL_MOUSE_DOUBLE_CLICK_RADIUS';
  SDL_HINT_MOUSE_DOUBLE_CLICK_TIME = 'SDL_MOUSE_DOUBLE_CLICK_TIME';
  SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH = 'SDL_MOUSE_FOCUS_CLICKTHROUGH';
  SDL_HINT_MOUSE_NORMAL_SPEED_SCALE = 'SDL_MOUSE_NORMAL_SPEED_SCALE';
  SDL_HINT_MOUSE_RELATIVE_MODE_CENTER = 'SDL_MOUSE_RELATIVE_MODE_CENTER';
  SDL_HINT_MOUSE_RELATIVE_MODE_WARP = 'SDL_MOUSE_RELATIVE_MODE_WARP';
  SDL_HINT_MOUSE_RELATIVE_SCALING = 'SDL_MOUSE_RELATIVE_SCALING';
  SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE = 'SDL_MOUSE_RELATIVE_SPEED_SCALE';
  SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE = 'SDL_MOUSE_RELATIVE_SYSTEM_SCALE';
  SDL_HINT_MOUSE_RELATIVE_WARP_MOTION = 'SDL_MOUSE_RELATIVE_WARP_MOTION';
  SDL_HINT_MOUSE_TOUCH_EVENTS = 'SDL_MOUSE_TOUCH_EVENTS';
  SDL_HINT_MOUSE_AUTO_CAPTURE = 'SDL_MOUSE_AUTO_CAPTURE';
  SDL_HINT_NO_SIGNAL_HANDLERS = 'SDL_NO_SIGNAL_HANDLERS';
  SDL_HINT_OPENGL_ES_DRIVER = 'SDL_OPENGL_ES_DRIVER';
  SDL_HINT_ORIENTATIONS = 'SDL_IOS_ORIENTATIONS';
  SDL_HINT_POLL_SENTINEL = 'SDL_POLL_SENTINEL';
  SDL_HINT_PREFERRED_LOCALES = 'SDL_PREFERRED_LOCALES';
  SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION = 'SDL_QTWAYLAND_CONTENT_ORIENTATION';
  SDL_HINT_QTWAYLAND_WINDOW_FLAGS = 'SDL_QTWAYLAND_WINDOW_FLAGS';
  SDL_HINT_RENDER_BATCHING = 'SDL_RENDER_BATCHING';
  SDL_HINT_RENDER_LINE_METHOD = 'SDL_RENDER_LINE_METHOD';
  SDL_HINT_RENDER_DIRECT3D11_DEBUG = 'SDL_RENDER_DIRECT3D11_DEBUG';
  SDL_HINT_RENDER_DIRECT3D_THREADSAFE = 'SDL_RENDER_DIRECT3D_THREADSAFE';
  SDL_HINT_RENDER_DRIVER = 'SDL_RENDER_DRIVER';
  SDL_HINT_RENDER_LOGICAL_SIZE_MODE = 'SDL_RENDER_LOGICAL_SIZE_MODE';
  SDL_HINT_RENDER_OPENGL_SHADERS = 'SDL_RENDER_OPENGL_SHADERS';
  SDL_HINT_RENDER_SCALE_QUALITY = 'SDL_RENDER_SCALE_QUALITY';
  SDL_HINT_RENDER_VSYNC = 'SDL_RENDER_VSYNC';
  SDL_HINT_PS2_DYNAMIC_VSYNC = 'SDL_PS2_DYNAMIC_VSYNC';
  SDL_HINT_RETURN_KEY_HIDES_IME = 'SDL_RETURN_KEY_HIDES_IME';
  SDL_HINT_RPI_VIDEO_LAYER = 'SDL_RPI_VIDEO_LAYER';
  SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME = 'SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME';
  SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL = 'SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL';
  SDL_HINT_THREAD_PRIORITY_POLICY = 'SDL_THREAD_PRIORITY_POLICY';
  SDL_HINT_THREAD_STACK_SIZE = 'SDL_THREAD_STACK_SIZE';
  SDL_HINT_TIMER_RESOLUTION = 'SDL_TIMER_RESOLUTION';
  SDL_HINT_TOUCH_MOUSE_EVENTS = 'SDL_TOUCH_MOUSE_EVENTS';
  SDL_HINT_VITA_TOUCH_MOUSE_DEVICE = 'SDL_HINT_VITA_TOUCH_MOUSE_DEVICE';
  SDL_HINT_TV_REMOTE_AS_JOYSTICK = 'SDL_TV_REMOTE_AS_JOYSTICK';
  SDL_HINT_VIDEO_ALLOW_SCREENSAVER = 'SDL_VIDEO_ALLOW_SCREENSAVER';
  SDL_HINT_VIDEO_DOUBLE_BUFFER = 'SDL_VIDEO_DOUBLE_BUFFER';
  SDL_HINT_VIDEO_EGL_ALLOW_TRANSPARENCY = 'SDL_VIDEO_EGL_ALLOW_TRANSPARENCY';
  SDL_HINT_VIDEO_EXTERNAL_CONTEXT = 'SDL_VIDEO_EXTERNAL_CONTEXT';
  SDL_HINT_VIDEO_HIGHDPI_DISABLED = 'SDL_VIDEO_HIGHDPI_DISABLED';
  SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES = 'SDL_VIDEO_MAC_FULLSCREEN_SPACES';
  SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS = 'SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS';
  SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR = 'SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR';
  SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR = 'SDL_VIDEO_WAYLAND_PREFER_LIBDECOR';
  SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION = 'SDL_VIDEO_WAYLAND_MODE_EMULATION';
  SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT = 'SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT';
  SDL_HINT_VIDEO_FOREIGN_WINDOW_OPENGL = 'SDL_VIDEO_FOREIGN_WINDOW_OPENGL';
  SDL_HINT_VIDEO_FOREIGN_WINDOW_VULKAN = 'SDL_VIDEO_FOREIGN_WINDOW_VULKAN';
  SDL_HINT_VIDEO_WIN_D3DCOMPILER = 'SDL_VIDEO_WIN_D3DCOMPILER';
  SDL_HINT_VIDEO_X11_FORCE_EGL = 'SDL_VIDEO_X11_FORCE_EGL';
  SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR = 'SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR';
  SDL_HINT_VIDEO_X11_NET_WM_PING = 'SDL_VIDEO_X11_NET_WM_PING';
  SDL_HINT_VIDEO_X11_WINDOW_VISUALID = 'SDL_VIDEO_X11_WINDOW_VISUALID';
  SDL_HINT_VIDEO_X11_XINERAMA = 'SDL_VIDEO_X11_XINERAMA';
  SDL_HINT_VIDEO_X11_XRANDR = 'SDL_VIDEO_X11_XRANDR';
  SDL_HINT_VIDEO_X11_XVIDMODE = 'SDL_VIDEO_X11_XVIDMODE';
  SDL_HINT_WAVE_FACT_CHUNK = 'SDL_WAVE_FACT_CHUNK';
  SDL_HINT_WAVE_RIFF_CHUNK_SIZE = 'SDL_WAVE_RIFF_CHUNK_SIZE';
  SDL_HINT_WAVE_TRUNCATION = 'SDL_WAVE_TRUNCATION';
  SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING = 'SDL_WINDOWS_DISABLE_THREAD_NAMING';
  SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP = 'SDL_WINDOWS_ENABLE_MESSAGELOOP';
  SDL_HINT_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS = 'SDL_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS';
  SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL = 'SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL';
  SDL_HINT_WINDOWS_INTRESOURCE_ICON = 'SDL_WINDOWS_INTRESOURCE_ICON';
  SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL = 'SDL_WINDOWS_INTRESOURCE_ICON_SMALL';
  SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4 = 'SDL_WINDOWS_NO_CLOSE_ON_ALT_F4';
  SDL_HINT_WINDOWS_USE_D3D9EX = 'SDL_WINDOWS_USE_D3D9EX';
  SDL_HINT_WINDOWS_DPI_AWARENESS = 'SDL_WINDOWS_DPI_AWARENESS';
  SDL_HINT_WINDOWS_DPI_SCALING = 'SDL_WINDOWS_DPI_SCALING';
  SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN = 'SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN';
  SDL_HINT_WINDOW_NO_ACTIVATION_WHEN_SHOWN = 'SDL_WINDOW_NO_ACTIVATION_WHEN_SHOWN';
  SDL_HINT_WINRT_HANDLE_BACK_BUTTON = 'SDL_WINRT_HANDLE_BACK_BUTTON';
  SDL_HINT_WINRT_PRIVACY_POLICY_LABEL = 'SDL_WINRT_PRIVACY_POLICY_LABEL';
  SDL_HINT_WINRT_PRIVACY_POLICY_URL = 'SDL_WINRT_PRIVACY_POLICY_URL';
  SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT = 'SDL_X11_FORCE_OVERRIDE_REDIRECT';
  SDL_HINT_XINPUT_ENABLED = 'SDL_XINPUT_ENABLED';
  SDL_HINT_DIRECTINPUT_ENABLED = 'SDL_DIRECTINPUT_ENABLED';
  SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING = 'SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING';
  SDL_HINT_AUDIO_INCLUDE_MONITORS = 'SDL_AUDIO_INCLUDE_MONITORS';
  SDL_HINT_X11_WINDOW_TYPE = 'SDL_X11_WINDOW_TYPE';
  SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE = 'SDL_QUIT_ON_LAST_WINDOW_CLOSE';
  SDL_HINT_VIDEODRIVER = 'SDL_VIDEODRIVER';
  SDL_HINT_AUDIODRIVER = 'SDL_AUDIODRIVER';
  SDL_HINT_KMSDRM_DEVICE_INDEX = 'SDL_KMSDRM_DEVICE_INDEX';
  SDL_HINT_TRACKPAD_IS_TOUCH_ONLY = 'SDL_TRACKPAD_IS_TOUCH_ONLY';
  SDL_MAX_LOG_MESSAGE = 4096;
  SDL_NONSHAPEABLE_WINDOW = -1;
  SDL_INVALID_SHAPE_ARGUMENT = -2;
  SDL_WINDOW_LACKS_SHAPE = -3;
  { TODO : Unable to convert function-like macro: }
  (* SDL_SHAPEMODEALPHA ( mode ) ( mode == ShapeModeDefault || mode == ShapeModeBinarizeAlpha || mode == ShapeModeReverseBinarizeAlpha ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_TICKS_PASSED ( A , B ) ( ( Sint32 ) ( ( B ) - ( A ) ) <= 0 ) *)
  SDL_MAJOR_VERSION = 2;
  SDL_MINOR_VERSION = 25;
  SDL_PATCHLEVEL = 0;
  { TODO : Unable to convert function-like macro: }
  (* SDL_VERSION ( x ) \
{ ( x ) -> major = SDL_MAJOR_VERSION ; ( x ) -> minor = SDL_MINOR_VERSION ; ( x ) -> patch = SDL_PATCHLEVEL ; \
} *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_VERSIONNUM ( X , Y , Z ) ( ( X ) * 1000 + ( Y ) * 100 + ( Z ) ) *)
  { TODO : Macro uses commented-out symbol "SDL_VERSIONNUM": }
  (* SDL_COMPILEDVERSION SDL_VERSIONNUM ( SDL_MAJOR_VERSION , SDL_MINOR_VERSION , SDL_PATCHLEVEL ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_VERSION_ATLEAST ( X , Y , Z ) ( ( SDL_MAJOR_VERSION >= X ) && ( SDL_MAJOR_VERSION > X || SDL_MINOR_VERSION >= Y ) && ( SDL_MAJOR_VERSION > X || SDL_MINOR_VERSION > Y || SDL_PATCHLEVEL >= Z ) ) *)
  SDL_INIT_TIMER = $00000001;
  SDL_INIT_AUDIO = $00000010;
  SDL_INIT_VIDEO = $00000020;
  SDL_INIT_JOYSTICK = $00000200;
  SDL_INIT_HAPTIC = $00001000;
  SDL_INIT_GAMECONTROLLER = $00002000;
  SDL_INIT_EVENTS = $00004000;
  SDL_INIT_SENSOR = $00008000;
  SDL_INIT_NOPARACHUTE = $00100000;
  SDL_INIT_EVERYTHING = (SDL_INIT_TIMER or SDL_INIT_AUDIO or SDL_INIT_VIDEO or SDL_INIT_EVENTS or SDL_INIT_JOYSTICK or SDL_INIT_HAPTIC or SDL_INIT_GAMECONTROLLER or SDL_INIT_SENSOR);
  SDL_IMAGE_MAJOR_VERSION = 2;
  SDL_IMAGE_MINOR_VERSION = 7;
  SDL_IMAGE_PATCHLEVEL = 0;
  { TODO : Unable to convert function-like macro: }
  (* SDL_IMAGE_VERSION ( X ) \
{ ( X ) -> major = SDL_IMAGE_MAJOR_VERSION ; ( X ) -> minor = SDL_IMAGE_MINOR_VERSION ; ( X ) -> patch = SDL_IMAGE_PATCHLEVEL ; \
} *)
  { TODO : Macro uses commented-out symbol "SDL_VERSIONNUM": }
  (* SDL_IMAGE_COMPILEDVERSION SDL_VERSIONNUM ( SDL_IMAGE_MAJOR_VERSION , SDL_IMAGE_MINOR_VERSION , SDL_IMAGE_PATCHLEVEL ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_IMAGE_VERSION_ATLEAST ( X , Y , Z ) ( ( SDL_IMAGE_MAJOR_VERSION >= X ) && ( SDL_IMAGE_MAJOR_VERSION > X || SDL_IMAGE_MINOR_VERSION >= Y ) && ( SDL_IMAGE_MAJOR_VERSION > X || SDL_IMAGE_MINOR_VERSION > Y || SDL_IMAGE_PATCHLEVEL >= Z ) ) *)
  SDL_MIXER_MAJOR_VERSION = 2;
  SDL_MIXER_MINOR_VERSION = 7;
  SDL_MIXER_PATCHLEVEL = 0;
  { TODO : Unable to convert function-like macro: }
  (* SDL_MIXER_VERSION ( X ) \
{ ( X ) -> major = SDL_MIXER_MAJOR_VERSION ; ( X ) -> minor = SDL_MIXER_MINOR_VERSION ; ( X ) -> patch = SDL_MIXER_PATCHLEVEL ; \
} *)
  MIX_MAJOR_VERSION = SDL_MIXER_MAJOR_VERSION;
  MIX_MINOR_VERSION = SDL_MIXER_MINOR_VERSION;
  MIX_PATCHLEVEL = SDL_MIXER_PATCHLEVEL;
  { TODO : Unable to convert function-like macro: }
  (* MIX_VERSION ( X ) SDL_MIXER_VERSION ( X ) *)
  { TODO : Macro uses commented-out symbol "SDL_VERSIONNUM": }
  (* SDL_MIXER_COMPILEDVERSION SDL_VERSIONNUM ( SDL_MIXER_MAJOR_VERSION , SDL_MIXER_MINOR_VERSION , SDL_MIXER_PATCHLEVEL ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_MIXER_VERSION_ATLEAST ( X , Y , Z ) ( ( SDL_MIXER_MAJOR_VERSION >= X ) && ( SDL_MIXER_MAJOR_VERSION > X || SDL_MIXER_MINOR_VERSION >= Y ) && ( SDL_MIXER_MAJOR_VERSION > X || SDL_MIXER_MINOR_VERSION > Y || SDL_MIXER_PATCHLEVEL >= Z ) ) *)
  MIX_CHANNELS = 8;
  MIX_DEFAULT_FREQUENCY = 44100;
  MIX_DEFAULT_FORMAT = AUDIO_S16LSB;
  MIX_DEFAULT_CHANNELS = 2;
  MIX_MAX_VOLUME = SDL_MIX_MAXVOLUME;
  MIX_CHANNEL_POST = (-2);
  MIX_EFFECTSMAXSPEED = 'MIX_EFFECTSMAXSPEED';
  { TODO : Macro uses commented-out symbol "SDL_OutOfMemory": }
  (* Mix_OutOfMemory SDL_OutOfMemory *)
  SDL_NET_MAJOR_VERSION = 2;
  SDL_NET_MINOR_VERSION = 3;
  SDL_NET_PATCHLEVEL = 0;
  { TODO : Unable to convert function-like macro: }
  (* SDL_NET_VERSION ( X ) \
{ ( X ) -> major = SDL_NET_MAJOR_VERSION ; ( X ) -> minor = SDL_NET_MINOR_VERSION ; ( X ) -> patch = SDL_NET_PATCHLEVEL ; \
} *)
  { TODO : Macro uses commented-out symbol "SDL_VERSIONNUM": }
  (* SDL_NET_COMPILEDVERSION SDL_VERSIONNUM ( SDL_NET_MAJOR_VERSION , SDL_NET_MINOR_VERSION , SDL_NET_PATCHLEVEL ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_NET_VERSION_ATLEAST ( X , Y , Z ) ( ( SDL_NET_MAJOR_VERSION >= X ) && ( SDL_NET_MAJOR_VERSION > X || SDL_NET_MINOR_VERSION >= Y ) && ( SDL_NET_MAJOR_VERSION > X || SDL_NET_MINOR_VERSION > Y || SDL_NET_PATCHLEVEL >= Z ) ) *)
  INADDR_ANY = $00000000;
  INADDR_NONE = $FFFFFFFF;
  INADDR_LOOPBACK = $7f000001;
  INADDR_BROADCAST = $FFFFFFFF;
  SDLNET_MAX_UDPCHANNELS = 32;
  SDLNET_MAX_UDPADDRESSES = 4;
  { TODO : Unable to convert function-like macro: }
  (* SDLNet_SocketReady ( sock ) _SDLNet_SocketReady ( ( SDLNet_GenericSocket ) ( sock ) ) *)
  SDL_DATA_ALIGNED = 0;
  { TODO : Unable to convert function-like macro: }
  (* SDLNet_Write16 ( value , areap ) _SDLNet_Write16 ( value , areap ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDLNet_Write32 ( value , areap ) _SDLNet_Write32 ( value , areap ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDLNet_Read16 ( areap ) _SDLNet_Read16 ( areap ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDLNet_Read32 ( areap ) _SDLNet_Read32 ( areap ) *)
  SDL_TTF_MAJOR_VERSION = 2;
  SDL_TTF_MINOR_VERSION = 21;
  SDL_TTF_PATCHLEVEL = 0;
  { TODO : Unable to convert function-like macro: }
  (* SDL_TTF_VERSION ( X ) \
{ ( X ) -> major = SDL_TTF_MAJOR_VERSION ; ( X ) -> minor = SDL_TTF_MINOR_VERSION ; ( X ) -> patch = SDL_TTF_PATCHLEVEL ; \
} *)
  TTF_MAJOR_VERSION = SDL_TTF_MAJOR_VERSION;
  TTF_MINOR_VERSION = SDL_TTF_MINOR_VERSION;
  TTF_PATCHLEVEL = SDL_TTF_PATCHLEVEL;
  { TODO : Unable to convert function-like macro: }
  (* TTF_VERSION ( X ) SDL_TTF_VERSION ( X ) *)
  { TODO : Macro uses commented-out symbol "SDL_VERSIONNUM": }
  (* SDL_TTF_COMPILEDVERSION SDL_VERSIONNUM ( SDL_TTF_MAJOR_VERSION , SDL_TTF_MINOR_VERSION , SDL_TTF_PATCHLEVEL ) *)
  { TODO : Unable to convert function-like macro: }
  (* SDL_TTF_VERSION_ATLEAST ( X , Y , Z ) ( ( SDL_TTF_MAJOR_VERSION >= X ) && ( SDL_TTF_MAJOR_VERSION > X || SDL_TTF_MINOR_VERSION >= Y ) && ( SDL_TTF_MAJOR_VERSION > X || SDL_TTF_MINOR_VERSION > Y || SDL_TTF_PATCHLEVEL >= Z ) ) *)
  UNICODE_BOM_NATIVE = $FEFF;
  UNICODE_BOM_SWAPPED = $FFFE;
  TTF_STYLE_NORMAL = $00;
  TTF_STYLE_BOLD = $01;
  TTF_STYLE_ITALIC = $02;
  TTF_STYLE_UNDERLINE = $04;
  TTF_STYLE_STRIKETHROUGH = $08;
  TTF_HINTING_NORMAL = 0;
  TTF_HINTING_LIGHT = 1;
  TTF_HINTING_MONO = 2;
  TTF_HINTING_NONE = 3;
  TTF_HINTING_LIGHT_SUBPIXEL = 4;
  TTF_WRAPPED_ALIGN_LEFT = 0;
  TTF_WRAPPED_ALIGN_CENTER = 1;
  TTF_WRAPPED_ALIGN_RIGHT = 2;
  { TODO : Unable to convert function-like macro: }
  (* TTF_RenderText ( font , text , fg , bg ) TTF_RenderText_Shaded ( font , text , fg , bg ) *)
  { TODO : Unable to convert function-like macro: }
  (* TTF_RenderUTF8 ( font , text , fg , bg ) TTF_RenderUTF8_Shaded ( font , text , fg , bg ) *)
  { TODO : Unable to convert function-like macro: }
  (* TTF_RenderUNICODE ( font , text , fg , bg ) TTF_RenderUNICODE_Shaded ( font , text , fg , bg ) *)
  NK_UNDEFINED = (-1.0);
  NK_UTF_INVALID = $FFFD;
  NK_UTF_SIZE = 4;
  NK_INPUT_MAX = 16;
  NK_MAX_NUMBER_BUFFER = 64;
  NK_SCROLLBAR_HIDING_TIMEOUT = 4.0;
  { TODO : Macro probably uses invalid symbol "extern": }
  (* NK_API extern *)
  { TODO : Macro probably uses invalid symbol "static": }
  (* NK_LIB static *)
  { TODO : Macro probably uses invalid symbol "static": }
  (* NK_INTERN static *)
  { TODO : Macro probably uses invalid symbol "static": }
  (* NK_STORAGE static *)
  { TODO : Macro probably uses invalid symbol "static": }
  (* NK_GLOBAL static *)
  { TODO : Unable to convert function-like macro: }
  (* NK_FLAG ( x ) ( 1 << ( x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_STRINGIFY ( x ) # x *)
  { TODO : Unable to convert function-like macro: }
  (* NK_MACRO_STRINGIFY ( x ) NK_STRINGIFY ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_STRING_JOIN_IMMEDIATE ( arg1 , arg2 ) arg1 ## arg2 *)
  { TODO : Unable to convert function-like macro: }
  (* NK_STRING_JOIN_DELAY ( arg1 , arg2 ) NK_STRING_JOIN_IMMEDIATE ( arg1 , arg2 ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_STRING_JOIN ( arg1 , arg2 ) NK_STRING_JOIN_DELAY ( arg1 , arg2 ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_UNIQUE_NAME ( name ) NK_STRING_JOIN ( name , __COUNTER__ ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_STATIC_ASSERT ( exp ) typedef char NK_UNIQUE_NAME ( _dummy_array ) [ ( exp ) ? 1 : - 1 ] *)
  { TODO : Macro refers to system symbol "__FILE__": }
  (* NK_FILE_LINE __FILE__ ":" NK_MACRO_STRINGIFY ( __COUNTER__ ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_MIN ( a , b ) ( ( a ) < ( b ) ? ( a ) : ( b ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_MAX ( a , b ) ( ( a ) < ( b ) ? ( b ) : ( a ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_CLAMP ( i , v , x ) ( NK_MAX ( NK_MIN ( v , x ) , i ) ) *)
  { TODO : Macro uses commented-out symbol "_Printf_format_string_": }
  (* NK_PRINTF_FORMAT_STRING _Printf_format_string_ *)
  { TODO : Unable to convert function-like macro: }
  (* NK_PRINTF_VARARG_FUNC ( fmtargnumber ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_PRINTF_VALIST_FUNC ( fmtargnumber ) *)
  { TODO : Macro probably uses invalid symbol "int8_t": }
  (* NK_INT8 int8_t *)
  { TODO : Macro probably uses invalid symbol "uint8_t": }
  (* NK_UINT8 uint8_t *)
  { TODO : Macro probably uses invalid symbol "int16_t": }
  (* NK_INT16 int16_t *)
  { TODO : Macro probably uses invalid symbol "uint16_t": }
  (* NK_UINT16 uint16_t *)
  { TODO : Macro probably uses invalid symbol "int32_t": }
  (* NK_INT32 int32_t *)
  { TODO : Macro probably uses invalid symbol "uint32_t": }
  (* NK_UINT32 uint32_t *)
  { TODO : Macro probably uses invalid symbol "uintptr_t": }
  (* NK_SIZE_TYPE uintptr_t *)
  { TODO : Macro probably uses invalid symbol "uintptr_t": }
  (* NK_POINTER_TYPE uintptr_t *)
  { TODO : Macro probably uses invalid symbol "int": }
  (* NK_BOOL int *)
  { TODO : Unable to convert function-like macro: }
  (* nk_foreach ( c , ctx ) for ( ( c ) = nk__begin ( ctx ) ; ( c ) != 0 ; ( c ) = nk__next ( ctx , c ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_draw_foreach ( cmd , ctx , b ) for ( ( cmd ) = nk__draw_begin ( ctx , b ) ; ( cmd ) != 0 ; ( cmd ) = nk__draw_next ( cmd , b , ctx ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_tree_push ( ctx , type , title , state ) nk_tree_push_hashed ( ctx , type , title , state , NK_FILE_LINE , nk_strlen ( NK_FILE_LINE ) , __LINE__ ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_tree_push_id ( ctx , type , title , state , id ) nk_tree_push_hashed ( ctx , type , title , state , NK_FILE_LINE , nk_strlen ( NK_FILE_LINE ) , id ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_tree_image_push ( ctx , type , img , title , state ) nk_tree_image_push_hashed ( ctx , type , img , title , state , NK_FILE_LINE , nk_strlen ( NK_FILE_LINE ) , __LINE__ ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_tree_image_push_id ( ctx , type , img , title , state , id ) nk_tree_image_push_hashed ( ctx , type , img , title , state , NK_FILE_LINE , nk_strlen ( NK_FILE_LINE ) , id ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_tree_element_push ( ctx , type , title , state , sel ) nk_tree_element_push_hashed ( ctx , type , title , state , sel , NK_FILE_LINE , nk_strlen ( NK_FILE_LINE ) , __LINE__ ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_tree_element_push_id ( ctx , type , title , state , sel , id ) nk_tree_element_push_hashed ( ctx , type , title , state , sel , NK_FILE_LINE , nk_strlen ( NK_FILE_LINE ) , id ) *)
  { TODO : Macro probably uses invalid symbol "nk_strtod": }
  (* NK_STRTOD nk_strtod *)
  NK_TEXTEDIT_UNDOSTATECOUNT = 99;
  NK_TEXTEDIT_UNDOCHARCOUNT = 999;
  { TODO : Unable to convert macro: }
  (* NK_VERTEX_LAYOUT_END NK_VERTEX_ATTRIBUTE_COUNT , NK_FORMAT_COUNT , 0 *)
  { TODO : Unable to convert function-like macro: }
  (* nk_draw_list_foreach ( cmd , can , b ) for ( ( cmd ) = nk__draw_list_begin ( can , b ) ; ( cmd ) != 0 ; ( cmd ) = nk__draw_list_next ( cmd , b , can ) ) *)
  NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS = 16;
  NK_CHART_MAX_SLOT = 4;
  NK_WINDOW_MAX_NAME = 64;
  NK_BUTTON_BEHAVIOR_STACK_SIZE = 8;
  NK_FONT_STACK_SIZE = 8;
  NK_STYLE_ITEM_STACK_SIZE = 16;
  NK_FLOAT_STACK_SIZE = 32;
  NK_VECTOR_STACK_SIZE = 16;
  NK_FLAGS_STACK_SIZE = 32;
  NK_COLOR_STACK_SIZE = 32;
  { TODO : Unable to convert function-like macro: }
  (* NK_CONFIGURATION_STACK_TYPE ( prefix , name , type ) struct nk_config_stack_ ## name ## _element { prefix ## _ ## type * address ; prefix ## _ ## type old_value ; } *)
  { TODO : Unable to convert function-like macro: }
  (* NK_CONFIG_STACK ( type , size ) struct nk_config_stack_ ## type { int head ; struct nk_config_stack_ ## type ## _element elements [ size ] ; } *)
  { TODO : Macro probably uses invalid symbol "nk_float": }
  (* nk_float float *)
  { TODO : Macro uses commented-out symbol "NK_MAX": }
  (* NK_VALUE_PAGE_CAPACITY ( ( ( NK_MAX ( sizeof ( struct nk_window ) , sizeof ( struct nk_panel ) ) / sizeof ( nk_uint ) ) ) / 2 ) *)
  NK_PI = 3.141592654;
  NK_MAX_FLOAT_PRECISION = 2;
  { TODO : Unable to convert function-like macro: }
  (* NK_UNUSED ( x ) ( ( void ) ( x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_SATURATE ( x ) ( NK_MAX ( 0 , NK_MIN ( 1.0f , x ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_LEN ( a ) ( sizeof ( a ) / sizeof ( a ) [ 0 ] ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_ABS ( a ) ( ( ( a ) < 0 ) ? - ( a ) : ( a ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_BETWEEN ( x , a , b ) ( ( a ) <= ( x ) && ( x ) < ( b ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_INBOX ( px , py , x , y , w , h ) ( NK_BETWEEN ( px , x , x + w ) && NK_BETWEEN ( py , y , y + h ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_INTERSECT ( x0 , y0 , w0 , h0 , x1 , y1 , w1 , h1 ) ( ( x1 < ( x0 + w0 ) ) && ( x0 < ( x1 + w1 ) ) && ( y1 < ( y0 + h0 ) ) && ( y0 < ( y1 + h1 ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_CONTAINS ( x , y , w , h , bx , by , bw , bh ) ( NK_INBOX ( x , y , bx , by , bw , bh ) && NK_INBOX ( x + w , y + h , bx , by , bw , bh ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_vec2_sub ( a , b ) nk_vec2 ( ( a ) . x - ( b ) . x , ( a ) . y - ( b ) . y ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_vec2_add ( a , b ) nk_vec2 ( ( a ) . x + ( b ) . x , ( a ) . y + ( b ) . y ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_vec2_len_sqr ( a ) ( ( a ) . x * ( a ) . x + ( a ) . y * ( a ) . y ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_vec2_muls ( a , t ) nk_vec2 ( ( a ) . x * ( t ) , ( a ) . y * ( t ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_ptr_add ( t , p , i ) ( ( t * ) ( ( void * ) ( ( nk_byte * ) ( p ) + ( i ) ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_ptr_add_const ( t , p , i ) ( ( const t * ) ( ( const void * ) ( ( const nk_byte * ) ( p ) + ( i ) ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* nk_zero_struct ( s ) nk_zero ( & s , sizeof ( s ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_UINT_TO_PTR ( x ) ( ( void * ) ( __PTRDIFF_TYPE__ ) ( x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_PTR_TO_UINT ( x ) ( ( nk_size ) ( __PTRDIFF_TYPE__ ) ( x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_ALIGN_PTR ( x , mask ) ( NK_UINT_TO_PTR ( ( NK_PTR_TO_UINT ( ( nk_byte * ) ( x ) + ( mask - 1 ) ) & ~ ( mask - 1 ) ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_ALIGN_PTR_BACK ( x , mask ) ( NK_UINT_TO_PTR ( ( NK_PTR_TO_UINT ( ( nk_byte * ) ( x ) ) & ~ ( mask - 1 ) ) ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_OFFSETOF ( st , m ) ( __builtin_offsetof ( st , m ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_ALIGNOF ( t ) NK_OFFSETOF ( struct { char c ; t _h ; } , _h ) *)
  { TODO : Unable to convert function-like macro: }
  (* NK_CONTAINER_OF ( ptr , type , member ) ( type * ) ( ( void * ) ( ( char * ) ( 1 ? ( ptr ) : & ( ( type * ) 0 ) -> member ) - NK_OFFSETOF ( type , member ) ) ) *)
  { TODO : Macro refers to system symbol "__declspec": }
  (* PLM_API __declspec ( dllexport ) *)
  PLM_PACKET_INVALID_TS = -1;
  PLM_AUDIO_SAMPLES_PER_FRAME = 1152;
  PLM_BUFFER_DEFAULT_SIZE = (128*1024);
  { TODO : Macro refers to system symbol "__declspec": }
  (* MZEXPORT __declspec ( dllexport ) *)
  Z_BZIP2ED = 12;
  ZIP_OK = (0);
  ZIP_EOF = (0);
  ZIP_ERRNO = (-1);
  ZIP_PARAMERROR = (-102);
  ZIP_BADZIPFILE = (-103);
  ZIP_INTERNALERROR = (-104);
  Z_DEFLATED = 8;
  Z_DEFAULT_STRATEGY = 0;
  APPEND_STATUS_CREATE = (0);
  APPEND_STATUS_CREATEAFTER = (1);
  APPEND_STATUS_ADDINZIP = (2);
  SDL2_GFXPRIMITIVES_MAJOR = 1;
  SDL2_GFXPRIMITIVES_MINOR = 0;
  SDL2_GFXPRIMITIVES_MICRO = 4;
  { TODO : Macro probably uses invalid symbol "extern": }
  (* SDL2_GFXPRIMITIVES_SCOPE extern *)

type
  SDL_bool = Integer;
  PSDL_bool = ^SDL_bool;

const
  SDL_FALSE = 0;
  SDL_TRUE = 1;

type
  SDL_DUMMY_ENUM = Integer;
  PSDL_DUMMY_ENUM = ^SDL_DUMMY_ENUM;

const
  DUMMY_ENUM_VALUE = 0;

type
  SDL_AssertState = Integer;
  PSDL_AssertState = ^SDL_AssertState;

const
  (** Retry the assert immediately. *)
  SDL_ASSERTION_RETRY = 0;
  (** Make the debugger trigger a breakpoint. *)
  SDL_ASSERTION_BREAK = 1;
  (** Terminate the program. *)
  SDL_ASSERTION_ABORT = 2;
  (** Ignore the assert. *)
  SDL_ASSERTION_IGNORE = 3;
  (** Ignore the assert from now on. *)
  SDL_ASSERTION_ALWAYS_IGNORE = 4;

type
  SDL_errorcode = Integer;
  PSDL_errorcode = ^SDL_errorcode;

const
  SDL_ENOMEM = 0;
  SDL_EFREAD = 1;
  SDL_EFWRITE = 2;
  SDL_EFSEEK = 3;
  SDL_UNSUPPORTED = 4;
  SDL_LASTERROR = 5;

(**
 *  The SDL thread priority.
 *
 *  SDL will make system changes as necessary in order to apply the thread priority.
 *  Code which attempts to control thread state related to priority should be aware
 *  that calling SDL_SetThreadPriority may alter such state.
 *  SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of this behavior.
 *
 *  \note On many systems you require special privileges to set high or time critical priority.
 *)
type
  SDL_ThreadPriority = Integer;
  PSDL_ThreadPriority = ^SDL_ThreadPriority;

const
  SDL_THREAD_PRIORITY_LOW = 0;
  SDL_THREAD_PRIORITY_NORMAL = 1;
  SDL_THREAD_PRIORITY_HIGH = 2;
  SDL_THREAD_PRIORITY_TIME_CRITICAL = 3;

type
  SDL_AudioStatus = Integer;
  PSDL_AudioStatus = ^SDL_AudioStatus;

const
  SDL_AUDIO_STOPPED = 0;
  SDL_AUDIO_PLAYING = 1;
  SDL_AUDIO_PAUSED = 2;

(** Pixel type. *)
type
  SDL_PixelType = Integer;
  PSDL_PixelType = ^SDL_PixelType;

const
  SDL_PIXELTYPE_UNKNOWN = 0;
  SDL_PIXELTYPE_INDEX1 = 1;
  SDL_PIXELTYPE_INDEX4 = 2;
  SDL_PIXELTYPE_INDEX8 = 3;
  SDL_PIXELTYPE_PACKED8 = 4;
  SDL_PIXELTYPE_PACKED16 = 5;
  SDL_PIXELTYPE_PACKED32 = 6;
  SDL_PIXELTYPE_ARRAYU8 = 7;
  SDL_PIXELTYPE_ARRAYU16 = 8;
  SDL_PIXELTYPE_ARRAYU32 = 9;
  SDL_PIXELTYPE_ARRAYF16 = 10;
  SDL_PIXELTYPE_ARRAYF32 = 11;

(** Bitmap pixel order, high bit -> low bit. *)
type
  SDL_BitmapOrder = Integer;
  PSDL_BitmapOrder = ^SDL_BitmapOrder;

const
  SDL_BITMAPORDER_NONE = 0;
  SDL_BITMAPORDER_4321 = 1;
  SDL_BITMAPORDER_1234 = 2;

(** Packed component order, high bit -> low bit. *)
type
  SDL_PackedOrder = Integer;
  PSDL_PackedOrder = ^SDL_PackedOrder;

const
  SDL_PACKEDORDER_NONE = 0;
  SDL_PACKEDORDER_XRGB = 1;
  SDL_PACKEDORDER_RGBX = 2;
  SDL_PACKEDORDER_ARGB = 3;
  SDL_PACKEDORDER_RGBA = 4;
  SDL_PACKEDORDER_XBGR = 5;
  SDL_PACKEDORDER_BGRX = 6;
  SDL_PACKEDORDER_ABGR = 7;
  SDL_PACKEDORDER_BGRA = 8;

(** Array component order, low byte -> high byte. *)
type
  SDL_ArrayOrder = Integer;
  PSDL_ArrayOrder = ^SDL_ArrayOrder;

const
  SDL_ARRAYORDER_NONE = 0;
  SDL_ARRAYORDER_RGB = 1;
  SDL_ARRAYORDER_RGBA = 2;
  SDL_ARRAYORDER_ARGB = 3;
  SDL_ARRAYORDER_BGR = 4;
  SDL_ARRAYORDER_BGRA = 5;
  SDL_ARRAYORDER_ABGR = 6;

(** Packed component layout. *)
type
  SDL_PackedLayout = Integer;
  PSDL_PackedLayout = ^SDL_PackedLayout;

const
  SDL_PACKEDLAYOUT_NONE = 0;
  SDL_PACKEDLAYOUT_332 = 1;
  SDL_PACKEDLAYOUT_4444 = 2;
  SDL_PACKEDLAYOUT_1555 = 3;
  SDL_PACKEDLAYOUT_5551 = 4;
  SDL_PACKEDLAYOUT_565 = 5;
  SDL_PACKEDLAYOUT_8888 = 6;
  SDL_PACKEDLAYOUT_2101010 = 7;
  SDL_PACKEDLAYOUT_1010102 = 8;

type
  SDL_PixelFormatEnum = Integer;
  PSDL_PixelFormatEnum = ^SDL_PixelFormatEnum;

const
  SDL_PIXELFORMAT_UNKNOWN = 0;
  SDL_PIXELFORMAT_INDEX1LSB = 286261504;
  SDL_PIXELFORMAT_INDEX1MSB = 287310080;
  SDL_PIXELFORMAT_INDEX4LSB = 303039488;
  SDL_PIXELFORMAT_INDEX4MSB = 304088064;
  SDL_PIXELFORMAT_INDEX8 = 318769153;
  SDL_PIXELFORMAT_RGB332 = 336660481;
  SDL_PIXELFORMAT_XRGB4444 = 353504258;
  SDL_PIXELFORMAT_RGB444 = 353504258;
  SDL_PIXELFORMAT_XBGR4444 = 357698562;
  SDL_PIXELFORMAT_BGR444 = 357698562;
  SDL_PIXELFORMAT_XRGB1555 = 353570562;
  SDL_PIXELFORMAT_RGB555 = 353570562;
  SDL_PIXELFORMAT_XBGR1555 = 357764866;
  SDL_PIXELFORMAT_BGR555 = 357764866;
  SDL_PIXELFORMAT_ARGB4444 = 355602434;
  SDL_PIXELFORMAT_RGBA4444 = 356651010;
  SDL_PIXELFORMAT_ABGR4444 = 359796738;
  SDL_PIXELFORMAT_BGRA4444 = 360845314;
  SDL_PIXELFORMAT_ARGB1555 = 355667970;
  SDL_PIXELFORMAT_RGBA5551 = 356782082;
  SDL_PIXELFORMAT_ABGR1555 = 359862274;
  SDL_PIXELFORMAT_BGRA5551 = 360976386;
  SDL_PIXELFORMAT_RGB565 = 353701890;
  SDL_PIXELFORMAT_BGR565 = 357896194;
  SDL_PIXELFORMAT_RGB24 = 386930691;
  SDL_PIXELFORMAT_BGR24 = 390076419;
  SDL_PIXELFORMAT_XRGB8888 = 370546692;
  SDL_PIXELFORMAT_RGB888 = 370546692;
  SDL_PIXELFORMAT_RGBX8888 = 371595268;
  SDL_PIXELFORMAT_XBGR8888 = 374740996;
  SDL_PIXELFORMAT_BGR888 = 374740996;
  SDL_PIXELFORMAT_BGRX8888 = 375789572;
  SDL_PIXELFORMAT_ARGB8888 = 372645892;
  SDL_PIXELFORMAT_RGBA8888 = 373694468;
  SDL_PIXELFORMAT_ABGR8888 = 376840196;
  SDL_PIXELFORMAT_BGRA8888 = 377888772;
  SDL_PIXELFORMAT_ARGB2101010 = 372711428;
  SDL_PIXELFORMAT_RGBA32 = 376840196;
  SDL_PIXELFORMAT_ARGB32 = 377888772;
  SDL_PIXELFORMAT_BGRA32 = 372645892;
  SDL_PIXELFORMAT_ABGR32 = 373694468;
  (** Planar mode: Y + V + U  (3 planes) *)
  SDL_PIXELFORMAT_YV12 = 842094169;
  (** Planar mode: Y + U + V  (3 planes) *)
  SDL_PIXELFORMAT_IYUV = 1448433993;
  (** Packed mode: Y0+U0+Y1+V0 (1 plane) *)
  SDL_PIXELFORMAT_YUY2 = 844715353;
  (** Packed mode: U0+Y0+V0+Y1 (1 plane) *)
  SDL_PIXELFORMAT_UYVY = 1498831189;
  (** Packed mode: Y0+V0+Y1+U0 (1 plane) *)
  SDL_PIXELFORMAT_YVYU = 1431918169;
  (** Planar mode: Y + U/V interleaved  (2 planes) *)
  SDL_PIXELFORMAT_NV12 = 842094158;
  (** Planar mode: Y + V/U interleaved  (2 planes) *)
  SDL_PIXELFORMAT_NV21 = 825382478;
  (** Android video texture format *)
  SDL_PIXELFORMAT_EXTERNAL_OES = 542328143;

(**
 *  \brief The blend mode used in SDL_RenderCopy() and drawing operations.
 *)
type
  SDL_BlendMode = Integer;
  PSDL_BlendMode = ^SDL_BlendMode;

const
  (** no blending
                                                dstRGBA = srcRGBA *)
  SDL_BLENDMODE_NONE = 0;
  (** alpha blending
                                                dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
                                                dstA = srcA + (dstA * (1-srcA)) *)
  SDL_BLENDMODE_BLEND = 1;
  (** additive blending
                                                dstRGB = (srcRGB * srcA) + dstRGB
                                                dstA = dstA *)
  SDL_BLENDMODE_ADD = 2;
  (** color modulate
                                                dstRGB = srcRGB * dstRGB
                                                dstA = dstA *)
  SDL_BLENDMODE_MOD = 4;
  (** color multiply
                                                dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))
                                                dstA = (srcA * dstA) + (dstA * (1-srcA)) *)
  SDL_BLENDMODE_MUL = 8;
  SDL_BLENDMODE_INVALID = 2147483647;

(**
 *  \brief The blend operation used when combining source and destination pixel components
 *)
type
  SDL_BlendOperation = Integer;
  PSDL_BlendOperation = ^SDL_BlendOperation;

const
  (** dst + src: supported by all renderers *)
  SDL_BLENDOPERATION_ADD = 1;
  (** dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES *)
  SDL_BLENDOPERATION_SUBTRACT = 2;
  (** src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES *)
  SDL_BLENDOPERATION_REV_SUBTRACT = 3;
  (** min(dst, src) : supported by D3D9, D3D11 *)
  SDL_BLENDOPERATION_MINIMUM = 4;
  (** max(dst, src) : supported by D3D9, D3D11 *)
  SDL_BLENDOPERATION_MAXIMUM = 5;

(**
 *  \brief The normalized factor used to multiply pixel components
 *)
type
  SDL_BlendFactor = Integer;
  PSDL_BlendFactor = ^SDL_BlendFactor;

const
  (** 0, 0, 0, 0 *)
  SDL_BLENDFACTOR_ZERO = 1;
  (** 1, 1, 1, 1 *)
  SDL_BLENDFACTOR_ONE = 2;
  (** srcR, srcG, srcB, srcA *)
  SDL_BLENDFACTOR_SRC_COLOR = 3;
  (** 1-srcR, 1-srcG, 1-srcB, 1-srcA *)
  SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4;
  (** srcA, srcA, srcA, srcA *)
  SDL_BLENDFACTOR_SRC_ALPHA = 5;
  (** 1-srcA, 1-srcA, 1-srcA, 1-srcA *)
  SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6;
  (** dstR, dstG, dstB, dstA *)
  SDL_BLENDFACTOR_DST_COLOR = 7;
  (** 1-dstR, 1-dstG, 1-dstB, 1-dstA *)
  SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8;
  (** dstA, dstA, dstA, dstA *)
  SDL_BLENDFACTOR_DST_ALPHA = 9;
  (** 1-dstA, 1-dstA, 1-dstA, 1-dstA *)
  SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10;

(**
 * \brief The formula used for converting between YUV and RGB
 *)
type
  SDL_YUV_CONVERSION_MODE = Integer;
  PSDL_YUV_CONVERSION_MODE = ^SDL_YUV_CONVERSION_MODE;

const
  (** Full range JPEG *)
  SDL_YUV_CONVERSION_JPEG = 0;
  (** BT.601 (the default) *)
  SDL_YUV_CONVERSION_BT601 = 1;
  (** BT.709 *)
  SDL_YUV_CONVERSION_BT709 = 2;
  (** BT.601 for SD content, BT.709 for HD content *)
  SDL_YUV_CONVERSION_AUTOMATIC = 3;

(**
 *  \brief The flags on a window
 *
 *  \sa SDL_GetWindowFlags()
 *)
type
  SDL_WindowFlags = Integer;
  PSDL_WindowFlags = ^SDL_WindowFlags;

const
  (** fullscreen window *)
  SDL_WINDOW_FULLSCREEN = 1;
  (** window usable with OpenGL context *)
  SDL_WINDOW_OPENGL = 2;
  (** window is visible *)
  SDL_WINDOW_SHOWN = 4;
  (** window is not visible *)
  SDL_WINDOW_HIDDEN = 8;
  (** no window decoration *)
  SDL_WINDOW_BORDERLESS = 16;
  (** window can be resized *)
  SDL_WINDOW_RESIZABLE = 32;
  (** window is minimized *)
  SDL_WINDOW_MINIMIZED = 64;
  (** window is maximized *)
  SDL_WINDOW_MAXIMIZED = 128;
  (** window has grabbed mouse input *)
  SDL_WINDOW_MOUSE_GRABBED = 256;
  (** window has input focus *)
  SDL_WINDOW_INPUT_FOCUS = 512;
  (** window has mouse focus *)
  SDL_WINDOW_MOUSE_FOCUS = 1024;
  SDL_WINDOW_FULLSCREEN_DESKTOP = 4097;
  (** window not created by SDL *)
  SDL_WINDOW_FOREIGN = 2048;
  (** window should be created in high-DPI mode if supported.
                                                       On macOS NSHighResolutionCapable must be set true in the
                                                       application's Info.plist for this to have any effect. *)
  SDL_WINDOW_ALLOW_HIGHDPI = 8192;
  (** window has mouse captured (unrelated to MOUSE_GRABBED) *)
  SDL_WINDOW_MOUSE_CAPTURE = 16384;
  (** window should always be above others *)
  SDL_WINDOW_ALWAYS_ON_TOP = 32768;
  (** window should not be added to the taskbar *)
  SDL_WINDOW_SKIP_TASKBAR = 65536;
  (** window should be treated as a utility window *)
  SDL_WINDOW_UTILITY = 131072;
  (** window should be treated as a tooltip *)
  SDL_WINDOW_TOOLTIP = 262144;
  (** window should be treated as a popup menu *)
  SDL_WINDOW_POPUP_MENU = 524288;
  (** window has grabbed keyboard input *)
  SDL_WINDOW_KEYBOARD_GRABBED = 1048576;
  (** window usable for Vulkan surface *)
  SDL_WINDOW_VULKAN = 268435456;
  (** window usable for Metal view *)
  SDL_WINDOW_METAL = 536870912;
  (** equivalent to SDL_WINDOW_MOUSE_GRABBED for compatibility *)
  SDL_WINDOW_INPUT_GRABBED = 256;

(**
 *  \brief Event subtype for window events
 *)
type
  SDL_WindowEventID = Integer;
  PSDL_WindowEventID = ^SDL_WindowEventID;

const
  (** Never used *)
  SDL_WINDOWEVENT_NONE = 0;
  (** Window has been shown *)
  SDL_WINDOWEVENT_SHOWN = 1;
  (** Window has been hidden *)
  SDL_WINDOWEVENT_HIDDEN = 2;
  (** Window has been exposed and should be
                                           redrawn *)
  SDL_WINDOWEVENT_EXPOSED = 3;
  (** Window has been moved to data1, data2
   *)
  SDL_WINDOWEVENT_MOVED = 4;
  (** Window has been resized to data1xdata2 *)
  SDL_WINDOWEVENT_RESIZED = 5;
  (** The window size has changed, either as
                                           a result of an API call or through the
                                           system or user changing the window size. *)
  SDL_WINDOWEVENT_SIZE_CHANGED = 6;
  (** Window has been minimized *)
  SDL_WINDOWEVENT_MINIMIZED = 7;
  (** Window has been maximized *)
  SDL_WINDOWEVENT_MAXIMIZED = 8;
  (** Window has been restored to normal size
                                           and position *)
  SDL_WINDOWEVENT_RESTORED = 9;
  (** Window has gained mouse focus *)
  SDL_WINDOWEVENT_ENTER = 10;
  (** Window has lost mouse focus *)
  SDL_WINDOWEVENT_LEAVE = 11;
  (** Window has gained keyboard focus *)
  SDL_WINDOWEVENT_FOCUS_GAINED = 12;
  (** Window has lost keyboard focus *)
  SDL_WINDOWEVENT_FOCUS_LOST = 13;
  (** The window manager requests that the window be closed *)
  SDL_WINDOWEVENT_CLOSE = 14;
  (** Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore) *)
  SDL_WINDOWEVENT_TAKE_FOCUS = 15;
  (** Window had a hit test that wasn't SDL_HITTEST_NORMAL. *)
  SDL_WINDOWEVENT_HIT_TEST = 16;
  (** The ICC profile of the window's display has changed. *)
  SDL_WINDOWEVENT_ICCPROF_CHANGED = 17;
  (** Window has been moved to display data1. *)
  SDL_WINDOWEVENT_DISPLAY_CHANGED = 18;

(**
 *  \brief Event subtype for display events
 *)
type
  SDL_DisplayEventID = Integer;
  PSDL_DisplayEventID = ^SDL_DisplayEventID;

const
  (** Never used *)
  SDL_DISPLAYEVENT_NONE = 0;
  (** Display orientation has changed to data1 *)
  SDL_DISPLAYEVENT_ORIENTATION = 1;
  (** Display has been added to the system *)
  SDL_DISPLAYEVENT_CONNECTED = 2;
  (** Display has been removed from the system *)
  SDL_DISPLAYEVENT_DISCONNECTED = 3;

(**
 *  \brief Display orientation
 *)
type
  SDL_DisplayOrientation = Integer;
  PSDL_DisplayOrientation = ^SDL_DisplayOrientation;

const
  (** The display orientation can't be determined *)
  SDL_ORIENTATION_UNKNOWN = 0;
  (** The display is in landscape mode, with the right side up, relative to portrait mode *)
  SDL_ORIENTATION_LANDSCAPE = 1;
  (** The display is in landscape mode, with the left side up, relative to portrait mode *)
  SDL_ORIENTATION_LANDSCAPE_FLIPPED = 2;
  (** The display is in portrait mode *)
  SDL_ORIENTATION_PORTRAIT = 3;
  (** The display is in portrait mode, upside down *)
  SDL_ORIENTATION_PORTRAIT_FLIPPED = 4;

(**
 *  \brief Window flash operation
 *)
type
  SDL_FlashOperation = Integer;
  PSDL_FlashOperation = ^SDL_FlashOperation;

const
  (** Cancel any window flash state *)
  SDL_FLASH_CANCEL = 0;
  (** Flash the window briefly to get attention *)
  SDL_FLASH_BRIEFLY = 1;
  (** Flash the window until it gets focus *)
  SDL_FLASH_UNTIL_FOCUSED = 2;

(**
 *  \brief OpenGL configuration attributes
 *)
type
  SDL_GLattr = Integer;
  PSDL_GLattr = ^SDL_GLattr;

const
  SDL_GL_RED_SIZE = 0;
  SDL_GL_GREEN_SIZE = 1;
  SDL_GL_BLUE_SIZE = 2;
  SDL_GL_ALPHA_SIZE = 3;
  SDL_GL_BUFFER_SIZE = 4;
  SDL_GL_DOUBLEBUFFER = 5;
  SDL_GL_DEPTH_SIZE = 6;
  SDL_GL_STENCIL_SIZE = 7;
  SDL_GL_ACCUM_RED_SIZE = 8;
  SDL_GL_ACCUM_GREEN_SIZE = 9;
  SDL_GL_ACCUM_BLUE_SIZE = 10;
  SDL_GL_ACCUM_ALPHA_SIZE = 11;
  SDL_GL_STEREO = 12;
  SDL_GL_MULTISAMPLEBUFFERS = 13;
  SDL_GL_MULTISAMPLESAMPLES = 14;
  SDL_GL_ACCELERATED_VISUAL = 15;
  SDL_GL_RETAINED_BACKING = 16;
  SDL_GL_CONTEXT_MAJOR_VERSION = 17;
  SDL_GL_CONTEXT_MINOR_VERSION = 18;
  SDL_GL_CONTEXT_EGL = 19;
  SDL_GL_CONTEXT_FLAGS = 20;
  SDL_GL_CONTEXT_PROFILE_MASK = 21;
  SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 22;
  SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 23;
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 24;
  SDL_GL_CONTEXT_RESET_NOTIFICATION = 25;
  SDL_GL_CONTEXT_NO_ERROR = 26;
  SDL_GL_FLOATBUFFERS = 27;

type
  SDL_GLprofile = Integer;
  PSDL_GLprofile = ^SDL_GLprofile;

const
  SDL_GL_CONTEXT_PROFILE_CORE = 1;
  SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 2;
  (** GLX_CONTEXT_ES2_PROFILE_BIT_EXT *)
  SDL_GL_CONTEXT_PROFILE_ES = 4;

type
  SDL_GLcontextFlag = Integer;
  PSDL_GLcontextFlag = ^SDL_GLcontextFlag;

const
  SDL_GL_CONTEXT_DEBUG_FLAG = 1;
  SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2;
  SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 4;
  SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 8;

type
  SDL_GLcontextReleaseFlag = Integer;
  PSDL_GLcontextReleaseFlag = ^SDL_GLcontextReleaseFlag;

const
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0;
  SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 1;

type
  SDL_GLContextResetNotification = Integer;
  PSDL_GLContextResetNotification = ^SDL_GLContextResetNotification;

const
  SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0;
  SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 1;

(**
 * Possible return values from the SDL_HitTest callback.
 *
 * \sa SDL_HitTest
 *)
type
  SDL_HitTestResult = Integer;
  PSDL_HitTestResult = ^SDL_HitTestResult;

const
  (** Region is normal. No special properties. *)
  SDL_HITTEST_NORMAL = 0;
  (** Region can drag entire window. *)
  SDL_HITTEST_DRAGGABLE = 1;
  SDL_HITTEST_RESIZE_TOPLEFT = 2;
  SDL_HITTEST_RESIZE_TOP = 3;
  SDL_HITTEST_RESIZE_TOPRIGHT = 4;
  SDL_HITTEST_RESIZE_RIGHT = 5;
  SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6;
  SDL_HITTEST_RESIZE_BOTTOM = 7;
  SDL_HITTEST_RESIZE_BOTTOMLEFT = 8;
  SDL_HITTEST_RESIZE_LEFT = 9;

(**
 *  \brief The SDL keyboard scancode representation.
 *
 *  Values of this type are used to represent keyboard keys, among other places
 *  in the \link SDL_Keysym::scancode key.keysym.scancode \endlink field of the
 *  SDL_Event structure.
 *
 *  The values in this enumeration are based on the USB usage page standard:
 *  https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
 *)
type
  SDL_Scancode = Integer;
  PSDL_Scancode = ^SDL_Scancode;

const
  SDL_SCANCODE_UNKNOWN = 0;
  SDL_SCANCODE_A = 4;
  SDL_SCANCODE_B = 5;
  SDL_SCANCODE_C = 6;
  SDL_SCANCODE_D = 7;
  SDL_SCANCODE_E = 8;
  SDL_SCANCODE_F = 9;
  SDL_SCANCODE_G = 10;
  SDL_SCANCODE_H = 11;
  SDL_SCANCODE_I = 12;
  SDL_SCANCODE_J = 13;
  SDL_SCANCODE_K = 14;
  SDL_SCANCODE_L = 15;
  SDL_SCANCODE_M = 16;
  SDL_SCANCODE_N = 17;
  SDL_SCANCODE_O = 18;
  SDL_SCANCODE_P = 19;
  SDL_SCANCODE_Q = 20;
  SDL_SCANCODE_R = 21;
  SDL_SCANCODE_S = 22;
  SDL_SCANCODE_T = 23;
  SDL_SCANCODE_U = 24;
  SDL_SCANCODE_V = 25;
  SDL_SCANCODE_W = 26;
  SDL_SCANCODE_X = 27;
  SDL_SCANCODE_Y = 28;
  SDL_SCANCODE_Z = 29;
  SDL_SCANCODE_1 = 30;
  SDL_SCANCODE_2 = 31;
  SDL_SCANCODE_3 = 32;
  SDL_SCANCODE_4 = 33;
  SDL_SCANCODE_5 = 34;
  SDL_SCANCODE_6 = 35;
  SDL_SCANCODE_7 = 36;
  SDL_SCANCODE_8 = 37;
  SDL_SCANCODE_9 = 38;
  SDL_SCANCODE_0 = 39;
  SDL_SCANCODE_RETURN = 40;
  SDL_SCANCODE_ESCAPE = 41;
  SDL_SCANCODE_BACKSPACE = 42;
  SDL_SCANCODE_TAB = 43;
  SDL_SCANCODE_SPACE = 44;
  SDL_SCANCODE_MINUS = 45;
  SDL_SCANCODE_EQUALS = 46;
  SDL_SCANCODE_LEFTBRACKET = 47;
  SDL_SCANCODE_RIGHTBRACKET = 48;
  (** Located at the lower left of the return
   *   key on ISO keyboards and at the right end
   *   of the QWERTY row on ANSI keyboards.
   *   Produces REVERSE SOLIDUS (backslash) and
   *   VERTICAL LINE in a US layout, REVERSE
   *   SOLIDUS and VERTICAL LINE in a UK Mac
   *   layout, NUMBER SIGN and TILDE in a UK
   *   Windows layout, DOLLAR SIGN and POUND SIGN
   *   in a Swiss German layout, NUMBER SIGN and
   *   APOSTROPHE in a German layout, GRAVE
   *   ACCENT and POUND SIGN in a French Mac
   *   layout, and ASTERISK and MICRO SIGN in a
   *   French Windows layout.
   *)
  SDL_SCANCODE_BACKSLASH = 49;
  (** ISO USB keyboards actually use this code
   *   instead of 49 for the same key, but all
   *   OSes I've seen treat the two codes
   *   identically. So, as an implementor, unless
   *   your keyboard generates both of those
   *   codes and your OS treats them differently,
   *   you should generate SDL_SCANCODE_BACKSLASH
   *   instead of this code. As a user, you
   *   should not rely on this code because SDL
   *   will never generate it with most (all?)
   *   keyboards.
   *)
  SDL_SCANCODE_NONUSHASH = 50;
  SDL_SCANCODE_SEMICOLON = 51;
  SDL_SCANCODE_APOSTROPHE = 52;
  (** Located in the top left corner (on both ANSI
   *   and ISO keyboards). Produces GRAVE ACCENT and
   *   TILDE in a US Windows layout and in US and UK
   *   Mac layouts on ANSI keyboards, GRAVE ACCENT
   *   and NOT SIGN in a UK Windows layout, SECTION
   *   SIGN and PLUS-MINUS SIGN in US and UK Mac
   *   layouts on ISO keyboards, SECTION SIGN and
   *   DEGREE SIGN in a Swiss German layout (Mac:
   *   only on ISO keyboards), CIRCUMFLEX ACCENT and
   *   DEGREE SIGN in a German layout (Mac: only on
   *   ISO keyboards), SUPERSCRIPT TWO and TILDE in a
   *   French Windows layout, COMMERCIAL AT and
   *   NUMBER SIGN in a French Mac layout on ISO
   *   keyboards, and LESS-THAN SIGN and GREATER-THAN
   *   SIGN in a Swiss German, German, or French Mac
   *   layout on ANSI keyboards.
   *)
  SDL_SCANCODE_GRAVE = 53;
  SDL_SCANCODE_COMMA = 54;
  SDL_SCANCODE_PERIOD = 55;
  SDL_SCANCODE_SLASH = 56;
  SDL_SCANCODE_CAPSLOCK = 57;
  SDL_SCANCODE_F1 = 58;
  SDL_SCANCODE_F2 = 59;
  SDL_SCANCODE_F3 = 60;
  SDL_SCANCODE_F4 = 61;
  SDL_SCANCODE_F5 = 62;
  SDL_SCANCODE_F6 = 63;
  SDL_SCANCODE_F7 = 64;
  SDL_SCANCODE_F8 = 65;
  SDL_SCANCODE_F9 = 66;
  SDL_SCANCODE_F10 = 67;
  SDL_SCANCODE_F11 = 68;
  SDL_SCANCODE_F12 = 69;
  SDL_SCANCODE_PRINTSCREEN = 70;
  SDL_SCANCODE_SCROLLLOCK = 71;
  SDL_SCANCODE_PAUSE = 72;
  (** insert on PC, help on some Mac keyboards (but
                                     does send code 73, not 117) *)
  SDL_SCANCODE_INSERT = 73;
  SDL_SCANCODE_HOME = 74;
  SDL_SCANCODE_PAGEUP = 75;
  SDL_SCANCODE_DELETE = 76;
  SDL_SCANCODE_END = 77;
  SDL_SCANCODE_PAGEDOWN = 78;
  SDL_SCANCODE_RIGHT = 79;
  SDL_SCANCODE_LEFT = 80;
  SDL_SCANCODE_DOWN = 81;
  SDL_SCANCODE_UP = 82;
  (** num lock on PC, clear on Mac keyboards
   *)
  SDL_SCANCODE_NUMLOCKCLEAR = 83;
  SDL_SCANCODE_KP_DIVIDE = 84;
  SDL_SCANCODE_KP_MULTIPLY = 85;
  SDL_SCANCODE_KP_MINUS = 86;
  SDL_SCANCODE_KP_PLUS = 87;
  SDL_SCANCODE_KP_ENTER = 88;
  SDL_SCANCODE_KP_1 = 89;
  SDL_SCANCODE_KP_2 = 90;
  SDL_SCANCODE_KP_3 = 91;
  SDL_SCANCODE_KP_4 = 92;
  SDL_SCANCODE_KP_5 = 93;
  SDL_SCANCODE_KP_6 = 94;
  SDL_SCANCODE_KP_7 = 95;
  SDL_SCANCODE_KP_8 = 96;
  SDL_SCANCODE_KP_9 = 97;
  SDL_SCANCODE_KP_0 = 98;
  SDL_SCANCODE_KP_PERIOD = 99;
  (** This is the additional key that ISO
   *   keyboards have over ANSI ones,
   *   located between left shift and Y.
   *   Produces GRAVE ACCENT and TILDE in a
   *   US or UK Mac layout, REVERSE SOLIDUS
   *   (backslash) and VERTICAL LINE in a
   *   US or UK Windows layout, and
   *   LESS-THAN SIGN and GREATER-THAN SIGN
   *   in a Swiss German, German, or French
   *   layout. *)
  SDL_SCANCODE_NONUSBACKSLASH = 100;
  (** windows contextual menu, compose *)
  SDL_SCANCODE_APPLICATION = 101;
  (** The USB document says this is a status flag,
   *   not a physical key - but some Mac keyboards
   *   do have a power key. *)
  SDL_SCANCODE_POWER = 102;
  SDL_SCANCODE_KP_EQUALS = 103;
  SDL_SCANCODE_F13 = 104;
  SDL_SCANCODE_F14 = 105;
  SDL_SCANCODE_F15 = 106;
  SDL_SCANCODE_F16 = 107;
  SDL_SCANCODE_F17 = 108;
  SDL_SCANCODE_F18 = 109;
  SDL_SCANCODE_F19 = 110;
  SDL_SCANCODE_F20 = 111;
  SDL_SCANCODE_F21 = 112;
  SDL_SCANCODE_F22 = 113;
  SDL_SCANCODE_F23 = 114;
  SDL_SCANCODE_F24 = 115;
  SDL_SCANCODE_EXECUTE = 116;
  SDL_SCANCODE_HELP = 117;
  SDL_SCANCODE_MENU = 118;
  SDL_SCANCODE_SELECT = 119;
  SDL_SCANCODE_STOP = 120;
  (** redo *)
  SDL_SCANCODE_AGAIN = 121;
  SDL_SCANCODE_UNDO = 122;
  SDL_SCANCODE_CUT = 123;
  SDL_SCANCODE_COPY = 124;
  SDL_SCANCODE_PASTE = 125;
  SDL_SCANCODE_FIND = 126;
  SDL_SCANCODE_MUTE = 127;
  SDL_SCANCODE_VOLUMEUP = 128;
  SDL_SCANCODE_VOLUMEDOWN = 129;
  SDL_SCANCODE_KP_COMMA = 133;
  SDL_SCANCODE_KP_EQUALSAS400 = 134;
  (** used on Asian keyboards, see
                                              footnotes in USB doc *)
  SDL_SCANCODE_INTERNATIONAL1 = 135;
  SDL_SCANCODE_INTERNATIONAL2 = 136;
  (** Yen *)
  SDL_SCANCODE_INTERNATIONAL3 = 137;
  SDL_SCANCODE_INTERNATIONAL4 = 138;
  SDL_SCANCODE_INTERNATIONAL5 = 139;
  SDL_SCANCODE_INTERNATIONAL6 = 140;
  SDL_SCANCODE_INTERNATIONAL7 = 141;
  SDL_SCANCODE_INTERNATIONAL8 = 142;
  SDL_SCANCODE_INTERNATIONAL9 = 143;
  (** Hangul/English toggle *)
  SDL_SCANCODE_LANG1 = 144;
  (** Hanja conversion *)
  SDL_SCANCODE_LANG2 = 145;
  (** Katakana *)
  SDL_SCANCODE_LANG3 = 146;
  (** Hiragana *)
  SDL_SCANCODE_LANG4 = 147;
  (** Zenkaku/Hankaku *)
  SDL_SCANCODE_LANG5 = 148;
  (** reserved *)
  SDL_SCANCODE_LANG6 = 149;
  (** reserved *)
  SDL_SCANCODE_LANG7 = 150;
  (** reserved *)
  SDL_SCANCODE_LANG8 = 151;
  (** reserved *)
  SDL_SCANCODE_LANG9 = 152;
  (** Erase-Eaze *)
  SDL_SCANCODE_ALTERASE = 153;
  SDL_SCANCODE_SYSREQ = 154;
  SDL_SCANCODE_CANCEL = 155;
  SDL_SCANCODE_CLEAR = 156;
  SDL_SCANCODE_PRIOR = 157;
  SDL_SCANCODE_RETURN2 = 158;
  SDL_SCANCODE_SEPARATOR = 159;
  SDL_SCANCODE_OUT = 160;
  SDL_SCANCODE_OPER = 161;
  SDL_SCANCODE_CLEARAGAIN = 162;
  SDL_SCANCODE_CRSEL = 163;
  SDL_SCANCODE_EXSEL = 164;
  SDL_SCANCODE_KP_00 = 176;
  SDL_SCANCODE_KP_000 = 177;
  SDL_SCANCODE_THOUSANDSSEPARATOR = 178;
  SDL_SCANCODE_DECIMALSEPARATOR = 179;
  SDL_SCANCODE_CURRENCYUNIT = 180;
  SDL_SCANCODE_CURRENCYSUBUNIT = 181;
  SDL_SCANCODE_KP_LEFTPAREN = 182;
  SDL_SCANCODE_KP_RIGHTPAREN = 183;
  SDL_SCANCODE_KP_LEFTBRACE = 184;
  SDL_SCANCODE_KP_RIGHTBRACE = 185;
  SDL_SCANCODE_KP_TAB = 186;
  SDL_SCANCODE_KP_BACKSPACE = 187;
  SDL_SCANCODE_KP_A = 188;
  SDL_SCANCODE_KP_B = 189;
  SDL_SCANCODE_KP_C = 190;
  SDL_SCANCODE_KP_D = 191;
  SDL_SCANCODE_KP_E = 192;
  SDL_SCANCODE_KP_F = 193;
  SDL_SCANCODE_KP_XOR = 194;
  SDL_SCANCODE_KP_POWER = 195;
  SDL_SCANCODE_KP_PERCENT = 196;
  SDL_SCANCODE_KP_LESS = 197;
  SDL_SCANCODE_KP_GREATER = 198;
  SDL_SCANCODE_KP_AMPERSAND = 199;
  SDL_SCANCODE_KP_DBLAMPERSAND = 200;
  SDL_SCANCODE_KP_VERTICALBAR = 201;
  SDL_SCANCODE_KP_DBLVERTICALBAR = 202;
  SDL_SCANCODE_KP_COLON = 203;
  SDL_SCANCODE_KP_HASH = 204;
  SDL_SCANCODE_KP_SPACE = 205;
  SDL_SCANCODE_KP_AT = 206;
  SDL_SCANCODE_KP_EXCLAM = 207;
  SDL_SCANCODE_KP_MEMSTORE = 208;
  SDL_SCANCODE_KP_MEMRECALL = 209;
  SDL_SCANCODE_KP_MEMCLEAR = 210;
  SDL_SCANCODE_KP_MEMADD = 211;
  SDL_SCANCODE_KP_MEMSUBTRACT = 212;
  SDL_SCANCODE_KP_MEMMULTIPLY = 213;
  SDL_SCANCODE_KP_MEMDIVIDE = 214;
  SDL_SCANCODE_KP_PLUSMINUS = 215;
  SDL_SCANCODE_KP_CLEAR = 216;
  SDL_SCANCODE_KP_CLEARENTRY = 217;
  SDL_SCANCODE_KP_BINARY = 218;
  SDL_SCANCODE_KP_OCTAL = 219;
  SDL_SCANCODE_KP_DECIMAL = 220;
  SDL_SCANCODE_KP_HEXADECIMAL = 221;
  SDL_SCANCODE_LCTRL = 224;
  SDL_SCANCODE_LSHIFT = 225;
  (** alt, option *)
  SDL_SCANCODE_LALT = 226;
  (** windows, command (apple), meta *)
  SDL_SCANCODE_LGUI = 227;
  SDL_SCANCODE_RCTRL = 228;
  SDL_SCANCODE_RSHIFT = 229;
  (** alt gr, option *)
  SDL_SCANCODE_RALT = 230;
  (** windows, command (apple), meta *)
  SDL_SCANCODE_RGUI = 231;
  (** I'm not sure if this is really not covered
   *   by any of the above, but since there's a
   *   special KMOD_MODE for it I'm adding it here
   *)
  SDL_SCANCODE_MODE = 257;
  SDL_SCANCODE_AUDIONEXT = 258;
  SDL_SCANCODE_AUDIOPREV = 259;
  SDL_SCANCODE_AUDIOSTOP = 260;
  SDL_SCANCODE_AUDIOPLAY = 261;
  SDL_SCANCODE_AUDIOMUTE = 262;
  SDL_SCANCODE_MEDIASELECT = 263;
  SDL_SCANCODE_WWW = 264;
  SDL_SCANCODE_MAIL = 265;
  SDL_SCANCODE_CALCULATOR = 266;
  SDL_SCANCODE_COMPUTER = 267;
  SDL_SCANCODE_AC_SEARCH = 268;
  SDL_SCANCODE_AC_HOME = 269;
  SDL_SCANCODE_AC_BACK = 270;
  SDL_SCANCODE_AC_FORWARD = 271;
  SDL_SCANCODE_AC_STOP = 272;
  SDL_SCANCODE_AC_REFRESH = 273;
  SDL_SCANCODE_AC_BOOKMARKS = 274;
  SDL_SCANCODE_BRIGHTNESSDOWN = 275;
  SDL_SCANCODE_BRIGHTNESSUP = 276;
  (** display mirroring/dual display
                                             switch, video mode switch *)
  SDL_SCANCODE_DISPLAYSWITCH = 277;
  SDL_SCANCODE_KBDILLUMTOGGLE = 278;
  SDL_SCANCODE_KBDILLUMDOWN = 279;
  SDL_SCANCODE_KBDILLUMUP = 280;
  SDL_SCANCODE_EJECT = 281;
  SDL_SCANCODE_SLEEP = 282;
  SDL_SCANCODE_APP1 = 283;
  SDL_SCANCODE_APP2 = 284;
  SDL_SCANCODE_AUDIOREWIND = 285;
  SDL_SCANCODE_AUDIOFASTFORWARD = 286;
  (** Usually situated below the display on phones and
                                        used as a multi-function feature key for selecting
                                        a software defined function shown on the bottom left
                                        of the display. *)
  SDL_SCANCODE_SOFTLEFT = 287;
  (** Usually situated below the display on phones and
                                         used as a multi-function feature key for selecting
                                         a software defined function shown on the bottom right
                                         of the display. *)
  SDL_SCANCODE_SOFTRIGHT = 288;
  (** Used for accepting phone calls. *)
  SDL_SCANCODE_CALL = 289;
  (** Used for rejecting phone calls. *)
  SDL_SCANCODE_ENDCALL = 290;
  (** not a key, just marks the number of scancodes
                                   for array bounds *)
  SDL_NUM_SCANCODES = 512;

type
  SDL_KeyCode = Integer;
  PSDL_KeyCode = ^SDL_KeyCode;

const
  SDLK_UNKNOWN = 0;
  SDLK_RETURN = 13;
  SDLK_ESCAPE = 27;
  SDLK_BACKSPACE = 8;
  SDLK_TAB = 9;
  SDLK_SPACE = 32;
  SDLK_EXCLAIM = 33;
  SDLK_QUOTEDBL = 34;
  SDLK_HASH = 35;
  SDLK_PERCENT = 37;
  SDLK_DOLLAR = 36;
  SDLK_AMPERSAND = 38;
  SDLK_QUOTE = 39;
  SDLK_LEFTPAREN = 40;
  SDLK_RIGHTPAREN = 41;
  SDLK_ASTERISK = 42;
  SDLK_PLUS = 43;
  SDLK_COMMA = 44;
  SDLK_MINUS = 45;
  SDLK_PERIOD = 46;
  SDLK_SLASH = 47;
  SDLK_0 = 48;
  SDLK_1 = 49;
  SDLK_2 = 50;
  SDLK_3 = 51;
  SDLK_4 = 52;
  SDLK_5 = 53;
  SDLK_6 = 54;
  SDLK_7 = 55;
  SDLK_8 = 56;
  SDLK_9 = 57;
  SDLK_COLON = 58;
  SDLK_SEMICOLON = 59;
  SDLK_LESS = 60;
  SDLK_EQUALS = 61;
  SDLK_GREATER = 62;
  SDLK_QUESTION = 63;
  SDLK_AT = 64;
  SDLK_LEFTBRACKET = 91;
  SDLK_BACKSLASH = 92;
  SDLK_RIGHTBRACKET = 93;
  SDLK_CARET = 94;
  SDLK_UNDERSCORE = 95;
  SDLK_BACKQUOTE = 96;
  SDLK_a = 97;
  SDLK_b = 98;
  SDLK_c = 99;
  SDLK_d = 100;
  SDLK_e = 101;
  SDLK_f = 102;
  SDLK_g = 103;
  SDLK_h = 104;
  SDLK_i = 105;
  SDLK_j = 106;
  SDLK_k = 107;
  SDLK_l = 108;
  SDLK_m = 109;
  SDLK_n = 110;
  SDLK_o = 111;
  SDLK_p = 112;
  SDLK_q = 113;
  SDLK_r = 114;
  SDLK_s = 115;
  SDLK_t = 116;
  SDLK_u = 117;
  SDLK_v = 118;
  SDLK_w = 119;
  SDLK_x = 120;
  SDLK_y = 121;
  SDLK_z = 122;
  SDLK_CAPSLOCK = 1073741881;
  SDLK_F1 = 1073741882;
  SDLK_F2 = 1073741883;
  SDLK_F3 = 1073741884;
  SDLK_F4 = 1073741885;
  SDLK_F5 = 1073741886;
  SDLK_F6 = 1073741887;
  SDLK_F7 = 1073741888;
  SDLK_F8 = 1073741889;
  SDLK_F9 = 1073741890;
  SDLK_F10 = 1073741891;
  SDLK_F11 = 1073741892;
  SDLK_F12 = 1073741893;
  SDLK_PRINTSCREEN = 1073741894;
  SDLK_SCROLLLOCK = 1073741895;
  SDLK_PAUSE = 1073741896;
  SDLK_INSERT = 1073741897;
  SDLK_HOME = 1073741898;
  SDLK_PAGEUP = 1073741899;
  SDLK_DELETE = 127;
  SDLK_END = 1073741901;
  SDLK_PAGEDOWN = 1073741902;
  SDLK_RIGHT = 1073741903;
  SDLK_LEFT = 1073741904;
  SDLK_DOWN = 1073741905;
  SDLK_UP = 1073741906;
  SDLK_NUMLOCKCLEAR = 1073741907;
  SDLK_KP_DIVIDE = 1073741908;
  SDLK_KP_MULTIPLY = 1073741909;
  SDLK_KP_MINUS = 1073741910;
  SDLK_KP_PLUS = 1073741911;
  SDLK_KP_ENTER = 1073741912;
  SDLK_KP_1 = 1073741913;
  SDLK_KP_2 = 1073741914;
  SDLK_KP_3 = 1073741915;
  SDLK_KP_4 = 1073741916;
  SDLK_KP_5 = 1073741917;
  SDLK_KP_6 = 1073741918;
  SDLK_KP_7 = 1073741919;
  SDLK_KP_8 = 1073741920;
  SDLK_KP_9 = 1073741921;
  SDLK_KP_0 = 1073741922;
  SDLK_KP_PERIOD = 1073741923;
  SDLK_APPLICATION = 1073741925;
  SDLK_POWER = 1073741926;
  SDLK_KP_EQUALS = 1073741927;
  SDLK_F13 = 1073741928;
  SDLK_F14 = 1073741929;
  SDLK_F15 = 1073741930;
  SDLK_F16 = 1073741931;
  SDLK_F17 = 1073741932;
  SDLK_F18 = 1073741933;
  SDLK_F19 = 1073741934;
  SDLK_F20 = 1073741935;
  SDLK_F21 = 1073741936;
  SDLK_F22 = 1073741937;
  SDLK_F23 = 1073741938;
  SDLK_F24 = 1073741939;
  SDLK_EXECUTE = 1073741940;
  SDLK_HELP = 1073741941;
  SDLK_MENU = 1073741942;
  SDLK_SELECT = 1073741943;
  SDLK_STOP = 1073741944;
  SDLK_AGAIN = 1073741945;
  SDLK_UNDO = 1073741946;
  SDLK_CUT = 1073741947;
  SDLK_COPY = 1073741948;
  SDLK_PASTE = 1073741949;
  SDLK_FIND = 1073741950;
  SDLK_MUTE = 1073741951;
  SDLK_VOLUMEUP = 1073741952;
  SDLK_VOLUMEDOWN = 1073741953;
  SDLK_KP_COMMA = 1073741957;
  SDLK_KP_EQUALSAS400 = 1073741958;
  SDLK_ALTERASE = 1073741977;
  SDLK_SYSREQ = 1073741978;
  SDLK_CANCEL = 1073741979;
  SDLK_CLEAR = 1073741980;
  SDLK_PRIOR = 1073741981;
  SDLK_RETURN2 = 1073741982;
  SDLK_SEPARATOR = 1073741983;
  SDLK_OUT = 1073741984;
  SDLK_OPER = 1073741985;
  SDLK_CLEARAGAIN = 1073741986;
  SDLK_CRSEL = 1073741987;
  SDLK_EXSEL = 1073741988;
  SDLK_KP_00 = 1073742000;
  SDLK_KP_000 = 1073742001;
  SDLK_THOUSANDSSEPARATOR = 1073742002;
  SDLK_DECIMALSEPARATOR = 1073742003;
  SDLK_CURRENCYUNIT = 1073742004;
  SDLK_CURRENCYSUBUNIT = 1073742005;
  SDLK_KP_LEFTPAREN = 1073742006;
  SDLK_KP_RIGHTPAREN = 1073742007;
  SDLK_KP_LEFTBRACE = 1073742008;
  SDLK_KP_RIGHTBRACE = 1073742009;
  SDLK_KP_TAB = 1073742010;
  SDLK_KP_BACKSPACE = 1073742011;
  SDLK_KP_A = 1073742012;
  SDLK_KP_B = 1073742013;
  SDLK_KP_C = 1073742014;
  SDLK_KP_D = 1073742015;
  SDLK_KP_E = 1073742016;
  SDLK_KP_F = 1073742017;
  SDLK_KP_XOR = 1073742018;
  SDLK_KP_POWER = 1073742019;
  SDLK_KP_PERCENT = 1073742020;
  SDLK_KP_LESS = 1073742021;
  SDLK_KP_GREATER = 1073742022;
  SDLK_KP_AMPERSAND = 1073742023;
  SDLK_KP_DBLAMPERSAND = 1073742024;
  SDLK_KP_VERTICALBAR = 1073742025;
  SDLK_KP_DBLVERTICALBAR = 1073742026;
  SDLK_KP_COLON = 1073742027;
  SDLK_KP_HASH = 1073742028;
  SDLK_KP_SPACE = 1073742029;
  SDLK_KP_AT = 1073742030;
  SDLK_KP_EXCLAM = 1073742031;
  SDLK_KP_MEMSTORE = 1073742032;
  SDLK_KP_MEMRECALL = 1073742033;
  SDLK_KP_MEMCLEAR = 1073742034;
  SDLK_KP_MEMADD = 1073742035;
  SDLK_KP_MEMSUBTRACT = 1073742036;
  SDLK_KP_MEMMULTIPLY = 1073742037;
  SDLK_KP_MEMDIVIDE = 1073742038;
  SDLK_KP_PLUSMINUS = 1073742039;
  SDLK_KP_CLEAR = 1073742040;
  SDLK_KP_CLEARENTRY = 1073742041;
  SDLK_KP_BINARY = 1073742042;
  SDLK_KP_OCTAL = 1073742043;
  SDLK_KP_DECIMAL = 1073742044;
  SDLK_KP_HEXADECIMAL = 1073742045;
  SDLK_LCTRL = 1073742048;
  SDLK_LSHIFT = 1073742049;
  SDLK_LALT = 1073742050;
  SDLK_LGUI = 1073742051;
  SDLK_RCTRL = 1073742052;
  SDLK_RSHIFT = 1073742053;
  SDLK_RALT = 1073742054;
  SDLK_RGUI = 1073742055;
  SDLK_MODE = 1073742081;
  SDLK_AUDIONEXT = 1073742082;
  SDLK_AUDIOPREV = 1073742083;
  SDLK_AUDIOSTOP = 1073742084;
  SDLK_AUDIOPLAY = 1073742085;
  SDLK_AUDIOMUTE = 1073742086;
  SDLK_MEDIASELECT = 1073742087;
  SDLK_WWW = 1073742088;
  SDLK_MAIL = 1073742089;
  SDLK_CALCULATOR = 1073742090;
  SDLK_COMPUTER = 1073742091;
  SDLK_AC_SEARCH = 1073742092;
  SDLK_AC_HOME = 1073742093;
  SDLK_AC_BACK = 1073742094;
  SDLK_AC_FORWARD = 1073742095;
  SDLK_AC_STOP = 1073742096;
  SDLK_AC_REFRESH = 1073742097;
  SDLK_AC_BOOKMARKS = 1073742098;
  SDLK_BRIGHTNESSDOWN = 1073742099;
  SDLK_BRIGHTNESSUP = 1073742100;
  SDLK_DISPLAYSWITCH = 1073742101;
  SDLK_KBDILLUMTOGGLE = 1073742102;
  SDLK_KBDILLUMDOWN = 1073742103;
  SDLK_KBDILLUMUP = 1073742104;
  SDLK_EJECT = 1073742105;
  SDLK_SLEEP = 1073742106;
  SDLK_APP1 = 1073742107;
  SDLK_APP2 = 1073742108;
  SDLK_AUDIOREWIND = 1073742109;
  SDLK_AUDIOFASTFORWARD = 1073742110;
  SDLK_SOFTLEFT = 1073742111;
  SDLK_SOFTRIGHT = 1073742112;
  SDLK_CALL = 1073742113;
  SDLK_ENDCALL = 1073742114;

(**
 * \brief Enumeration of valid key mods (possibly OR'd together).
 *)
type
  SDL_Keymod = Integer;
  PSDL_Keymod = ^SDL_Keymod;

const
  KMOD_NONE = 0;
  KMOD_LSHIFT = 1;
  KMOD_RSHIFT = 2;
  KMOD_LCTRL = 64;
  KMOD_RCTRL = 128;
  KMOD_LALT = 256;
  KMOD_RALT = 512;
  KMOD_LGUI = 1024;
  KMOD_RGUI = 2048;
  KMOD_NUM = 4096;
  KMOD_CAPS = 8192;
  KMOD_MODE = 16384;
  KMOD_SCROLL = 32768;
  KMOD_CTRL = 192;
  KMOD_SHIFT = 3;
  KMOD_ALT = 768;
  KMOD_GUI = 3072;
  KMOD_RESERVED = 32768;

(**
 * \brief Cursor types for SDL_CreateSystemCursor().
 *)
type
  SDL_SystemCursor = Integer;
  PSDL_SystemCursor = ^SDL_SystemCursor;

const
  (** Arrow *)
  SDL_SYSTEM_CURSOR_ARROW = 0;
  (** I-beam *)
  SDL_SYSTEM_CURSOR_IBEAM = 1;
  (** Wait *)
  SDL_SYSTEM_CURSOR_WAIT = 2;
  (** Crosshair *)
  SDL_SYSTEM_CURSOR_CROSSHAIR = 3;
  (** Small wait cursor (or Wait if not available) *)
  SDL_SYSTEM_CURSOR_WAITARROW = 4;
  (** Double arrow pointing northwest and southeast *)
  SDL_SYSTEM_CURSOR_SIZENWSE = 5;
  (** Double arrow pointing northeast and southwest *)
  SDL_SYSTEM_CURSOR_SIZENESW = 6;
  (** Double arrow pointing west and east *)
  SDL_SYSTEM_CURSOR_SIZEWE = 7;
  (** Double arrow pointing north and south *)
  SDL_SYSTEM_CURSOR_SIZENS = 8;
  (** Four pointed arrow pointing north, south, east, and west *)
  SDL_SYSTEM_CURSOR_SIZEALL = 9;
  (** Slashed circle or crossbones *)
  SDL_SYSTEM_CURSOR_NO = 10;
  (** Hand *)
  SDL_SYSTEM_CURSOR_HAND = 11;
  SDL_NUM_SYSTEM_CURSORS = 12;

(**
 * \brief Scroll direction types for the Scroll event
 *)
type
  SDL_MouseWheelDirection = Integer;
  PSDL_MouseWheelDirection = ^SDL_MouseWheelDirection;

const
  (** The scroll direction is normal *)
  SDL_MOUSEWHEEL_NORMAL = 0;
  (** The scroll direction is flipped / natural *)
  SDL_MOUSEWHEEL_FLIPPED = 1;

type
  SDL_JoystickType = Integer;
  PSDL_JoystickType = ^SDL_JoystickType;

const
  SDL_JOYSTICK_TYPE_UNKNOWN = 0;
  SDL_JOYSTICK_TYPE_GAMECONTROLLER = 1;
  SDL_JOYSTICK_TYPE_WHEEL = 2;
  SDL_JOYSTICK_TYPE_ARCADE_STICK = 3;
  SDL_JOYSTICK_TYPE_FLIGHT_STICK = 4;
  SDL_JOYSTICK_TYPE_DANCE_PAD = 5;
  SDL_JOYSTICK_TYPE_GUITAR = 6;
  SDL_JOYSTICK_TYPE_DRUM_KIT = 7;
  SDL_JOYSTICK_TYPE_ARCADE_PAD = 8;
  SDL_JOYSTICK_TYPE_THROTTLE = 9;

type
  SDL_JoystickPowerLevel = Integer;
  PSDL_JoystickPowerLevel = ^SDL_JoystickPowerLevel;

const
  SDL_JOYSTICK_POWER_UNKNOWN = -1;
  SDL_JOYSTICK_POWER_EMPTY = 0;
  SDL_JOYSTICK_POWER_LOW = 1;
  SDL_JOYSTICK_POWER_MEDIUM = 2;
  SDL_JOYSTICK_POWER_FULL = 3;
  SDL_JOYSTICK_POWER_WIRED = 4;
  SDL_JOYSTICK_POWER_MAX = 5;

type
  SDL_SensorType = Integer;
  PSDL_SensorType = ^SDL_SensorType;

const
  (** Returned for an invalid sensor *)
  SDL_SENSOR_INVALID = -1;
  (** Unknown sensor type *)
  SDL_SENSOR_UNKNOWN = 0;
  (** Accelerometer *)
  SDL_SENSOR_ACCEL = 1;
  (** Gyroscope *)
  SDL_SENSOR_GYRO = 2;
  (** Accelerometer for left Joy-Con controller and Wii nunchuk *)
  SDL_SENSOR_ACCEL_L = 3;
  (** Gyroscope for left Joy-Con controller *)
  SDL_SENSOR_GYRO_L = 4;
  (** Accelerometer for right Joy-Con controller *)
  SDL_SENSOR_ACCEL_R = 5;
  (** Gyroscope for right Joy-Con controller *)
  SDL_SENSOR_GYRO_R = 6;

type
  SDL_GameControllerType = Integer;
  PSDL_GameControllerType = ^SDL_GameControllerType;

const
  SDL_CONTROLLER_TYPE_UNKNOWN = 0;
  SDL_CONTROLLER_TYPE_XBOX360 = 1;
  SDL_CONTROLLER_TYPE_XBOXONE = 2;
  SDL_CONTROLLER_TYPE_PS3 = 3;
  SDL_CONTROLLER_TYPE_PS4 = 4;
  SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO = 5;
  SDL_CONTROLLER_TYPE_VIRTUAL = 6;
  SDL_CONTROLLER_TYPE_PS5 = 7;
  SDL_CONTROLLER_TYPE_AMAZON_LUNA = 8;
  SDL_CONTROLLER_TYPE_GOOGLE_STADIA = 9;
  SDL_CONTROLLER_TYPE_NVIDIA_SHIELD = 10;
  SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_JOYCON_LEFT = 11;
  SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT = 12;
  SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_JOYCON_PAIR = 13;

type
  SDL_GameControllerBindType = Integer;
  PSDL_GameControllerBindType = ^SDL_GameControllerBindType;

const
  SDL_CONTROLLER_BINDTYPE_NONE = 0;
  SDL_CONTROLLER_BINDTYPE_BUTTON = 1;
  SDL_CONTROLLER_BINDTYPE_AXIS = 2;
  SDL_CONTROLLER_BINDTYPE_HAT = 3;

(**
 *  The list of axes available from a controller
 *
 *  Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,
 *  and are centered within ~8000 of zero, though advanced UI will allow users to set
 *  or autodetect the dead zone, which varies between controllers.
 *
 *  Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX.
 *)
type
  SDL_GameControllerAxis = Integer;
  PSDL_GameControllerAxis = ^SDL_GameControllerAxis;

const
  SDL_CONTROLLER_AXIS_INVALID = -1;
  SDL_CONTROLLER_AXIS_LEFTX = 0;
  SDL_CONTROLLER_AXIS_LEFTY = 1;
  SDL_CONTROLLER_AXIS_RIGHTX = 2;
  SDL_CONTROLLER_AXIS_RIGHTY = 3;
  SDL_CONTROLLER_AXIS_TRIGGERLEFT = 4;
  SDL_CONTROLLER_AXIS_TRIGGERRIGHT = 5;
  SDL_CONTROLLER_AXIS_MAX = 6;

(**
 *  The list of buttons available from a controller
 *)
type
  SDL_GameControllerButton = Integer;
  PSDL_GameControllerButton = ^SDL_GameControllerButton;

const
  SDL_CONTROLLER_BUTTON_INVALID = -1;
  SDL_CONTROLLER_BUTTON_A = 0;
  SDL_CONTROLLER_BUTTON_B = 1;
  SDL_CONTROLLER_BUTTON_X = 2;
  SDL_CONTROLLER_BUTTON_Y = 3;
  SDL_CONTROLLER_BUTTON_BACK = 4;
  SDL_CONTROLLER_BUTTON_GUIDE = 5;
  SDL_CONTROLLER_BUTTON_START = 6;
  SDL_CONTROLLER_BUTTON_LEFTSTICK = 7;
  SDL_CONTROLLER_BUTTON_RIGHTSTICK = 8;
  SDL_CONTROLLER_BUTTON_LEFTSHOULDER = 9;
  SDL_CONTROLLER_BUTTON_RIGHTSHOULDER = 10;
  SDL_CONTROLLER_BUTTON_DPAD_UP = 11;
  SDL_CONTROLLER_BUTTON_DPAD_DOWN = 12;
  SDL_CONTROLLER_BUTTON_DPAD_LEFT = 13;
  SDL_CONTROLLER_BUTTON_DPAD_RIGHT = 14;
  SDL_CONTROLLER_BUTTON_MISC1 = 15;
  SDL_CONTROLLER_BUTTON_PADDLE1 = 16;
  SDL_CONTROLLER_BUTTON_PADDLE2 = 17;
  SDL_CONTROLLER_BUTTON_PADDLE3 = 18;
  SDL_CONTROLLER_BUTTON_PADDLE4 = 19;
  SDL_CONTROLLER_BUTTON_TOUCHPAD = 20;
  SDL_CONTROLLER_BUTTON_MAX = 21;

type
  SDL_TouchDeviceType = Integer;
  PSDL_TouchDeviceType = ^SDL_TouchDeviceType;

const
  SDL_TOUCH_DEVICE_INVALID = -1;
  SDL_TOUCH_DEVICE_DIRECT = 0;
  SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE = 1;
  SDL_TOUCH_DEVICE_INDIRECT_RELATIVE = 2;

(**
 * The types of events that can be delivered.
 *)
type
  SDL_EventType = Integer;
  PSDL_EventType = ^SDL_EventType;

const
  (** Unused (do not remove) *)
  SDL_FIRSTEVENT = 0;
  (** User-requested quit *)
  SDL_QUIT_ = 256;
  (** The application is being terminated by the OS
                                       Called on iOS in applicationWillTerminate()
                                       Called on Android in onDestroy()
   *)
  SDL_APP_TERMINATING = 257;
  (** The application is low on memory, free memory if possible.
                                       Called on iOS in applicationDidReceiveMemoryWarning()
                                       Called on Android in onLowMemory()
   *)
  SDL_APP_LOWMEMORY = 258;
  (** The application is about to enter the background
                                       Called on iOS in applicationWillResignActive()
                                       Called on Android in onPause()
   *)
  SDL_APP_WILLENTERBACKGROUND = 259;
  (** The application did enter the background and may not get CPU for some time
                                       Called on iOS in applicationDidEnterBackground()
                                       Called on Android in onPause()
   *)
  SDL_APP_DIDENTERBACKGROUND = 260;
  (** The application is about to enter the foreground
                                       Called on iOS in applicationWillEnterForeground()
                                       Called on Android in onResume()
   *)
  SDL_APP_WILLENTERFOREGROUND = 261;
  (** The application is now interactive
                                       Called on iOS in applicationDidBecomeActive()
                                       Called on Android in onResume()
   *)
  SDL_APP_DIDENTERFOREGROUND = 262;
  (** The user's locale preferences have changed. *)
  SDL_LOCALECHANGED = 263;
  (** Display state change *)
  SDL_DISPLAYEVENT_ = 336;
  (** Window state change *)
  SDL_WINDOWEVENT_ = 512;
  (** System specific event *)
  SDL_SYSWMEVENT_ = 513;
  (** Key pressed *)
  SDL_KEYDOWN = 768;
  (** Key released *)
  SDL_KEYUP = 769;
  (** Keyboard text editing (composition) *)
  SDL_TEXTEDITING = 770;
  (** Keyboard text input *)
  SDL_TEXTINPUT = 771;
  (** Keymap changed due to a system event such as an
                                       input language or keyboard layout change.
   *)
  SDL_KEYMAPCHANGED = 772;
  (** Extended keyboard text editing (composition) *)
  SDL_TEXTEDITING_EXT = 773;
  (** Mouse moved *)
  SDL_MOUSEMOTION = 1024;
  (** Mouse button pressed *)
  SDL_MOUSEBUTTONDOWN = 1025;
  (** Mouse button released *)
  SDL_MOUSEBUTTONUP = 1026;
  (** Mouse wheel motion *)
  SDL_MOUSEWHEEL = 1027;
  (** Joystick axis motion *)
  SDL_JOYAXISMOTION = 1536;
  (** Joystick trackball motion *)
  SDL_JOYBALLMOTION = 1537;
  (** Joystick hat position change *)
  SDL_JOYHATMOTION = 1538;
  (** Joystick button pressed *)
  SDL_JOYBUTTONDOWN = 1539;
  (** Joystick button released *)
  SDL_JOYBUTTONUP = 1540;
  (** A new joystick has been inserted into the system *)
  SDL_JOYDEVICEADDED = 1541;
  (** An opened joystick has been removed *)
  SDL_JOYDEVICEREMOVED = 1542;
  (** Joystick battery level change *)
  SDL_JOYBATTERYUPDATED = 1543;
  (** Game controller axis motion *)
  SDL_CONTROLLERAXISMOTION = 1616;
  (** Game controller button pressed *)
  SDL_CONTROLLERBUTTONDOWN = 1617;
  (** Game controller button released *)
  SDL_CONTROLLERBUTTONUP = 1618;
  (** A new Game controller has been inserted into the system *)
  SDL_CONTROLLERDEVICEADDED = 1619;
  (** An opened Game controller has been removed *)
  SDL_CONTROLLERDEVICEREMOVED = 1620;
  (** The controller mapping was updated *)
  SDL_CONTROLLERDEVICEREMAPPED = 1621;
  (** Game controller touchpad was touched *)
  SDL_CONTROLLERTOUCHPADDOWN = 1622;
  (** Game controller touchpad finger was moved *)
  SDL_CONTROLLERTOUCHPADMOTION = 1623;
  (** Game controller touchpad finger was lifted *)
  SDL_CONTROLLERTOUCHPADUP = 1624;
  (** Game controller sensor was updated *)
  SDL_CONTROLLERSENSORUPDATE = 1625;
  SDL_FINGERDOWN = 1792;
  SDL_FINGERUP = 1793;
  SDL_FINGERMOTION = 1794;
  SDL_DOLLARGESTURE = 2048;
  SDL_DOLLARRECORD = 2049;
  SDL_MULTIGESTURE = 2050;
  (** The clipboard or primary selection changed *)
  SDL_CLIPBOARDUPDATE = 2304;
  (** The system requests a file open *)
  SDL_DROPFILE = 4096;
  (** text/plain drag-and-drop event *)
  SDL_DROPTEXT = 4097;
  (** A new set of drops is beginning (NULL filename) *)
  SDL_DROPBEGIN = 4098;
  (** Current set of drops is now complete (NULL filename) *)
  SDL_DROPCOMPLETE = 4099;
  (** A new audio device is available *)
  SDL_AUDIODEVICEADDED = 4352;
  (** An audio device has been removed. *)
  SDL_AUDIODEVICEREMOVED = 4353;
  (** A sensor was updated *)
  SDL_SENSORUPDATE_ = 4608;
  (** The render targets have been reset and their contents need to be updated *)
  SDL_RENDER_TARGETS_RESET = 8192;
  (** The device has been reset and all textures need to be recreated *)
  SDL_RENDER_DEVICE_RESET = 8193;
  (** Signals the end of an event poll cycle *)
  SDL_POLLSENTINEL = 32512;
  (** Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
   *  and should be allocated with SDL_RegisterEvents()
   *)
  SDL_USEREVENT_ = 32768;
  (**
   *  This last event is only for bounding internal arrays
   *)
  SDL_LASTEVENT = 65535;

type
  SDL_eventaction = Integer;
  PSDL_eventaction = ^SDL_eventaction;

const
  SDL_ADDEVENT = 0;
  SDL_PEEKEVENT = 1;
  SDL_GETEVENT = 2;

(**
 *  \brief  An enumeration of hint priorities
 *)
type
  SDL_HintPriority = Integer;
  PSDL_HintPriority = ^SDL_HintPriority;

const
  SDL_HINT_DEFAULT = 0;
  SDL_HINT_NORMAL = 1;
  SDL_HINT_OVERRIDE = 2;

(**
 *  \brief The predefined log categories
 *
 *  By default the application category is enabled at the INFO level,
 *  the assert category is enabled at the WARN level, test is enabled
 *  at the VERBOSE level and all other categories are enabled at the
 *  CRITICAL level.
 *)
type
  SDL_LogCategory = Integer;
  PSDL_LogCategory = ^SDL_LogCategory;

const
  SDL_LOG_CATEGORY_APPLICATION = 0;
  SDL_LOG_CATEGORY_ERROR = 1;
  SDL_LOG_CATEGORY_ASSERT = 2;
  SDL_LOG_CATEGORY_SYSTEM = 3;
  SDL_LOG_CATEGORY_AUDIO = 4;
  SDL_LOG_CATEGORY_VIDEO = 5;
  SDL_LOG_CATEGORY_RENDER = 6;
  SDL_LOG_CATEGORY_INPUT = 7;
  SDL_LOG_CATEGORY_TEST = 8;
  SDL_LOG_CATEGORY_RESERVED1 = 9;
  SDL_LOG_CATEGORY_RESERVED2 = 10;
  SDL_LOG_CATEGORY_RESERVED3 = 11;
  SDL_LOG_CATEGORY_RESERVED4 = 12;
  SDL_LOG_CATEGORY_RESERVED5 = 13;
  SDL_LOG_CATEGORY_RESERVED6 = 14;
  SDL_LOG_CATEGORY_RESERVED7 = 15;
  SDL_LOG_CATEGORY_RESERVED8 = 16;
  SDL_LOG_CATEGORY_RESERVED9 = 17;
  SDL_LOG_CATEGORY_RESERVED10 = 18;
  SDL_LOG_CATEGORY_CUSTOM = 19;

(**
 *  \brief The predefined log priorities
 *)
type
  SDL_LogPriority = Integer;
  PSDL_LogPriority = ^SDL_LogPriority;

const
  SDL_LOG_PRIORITY_VERBOSE = 1;
  SDL_LOG_PRIORITY_DEBUG = 2;
  SDL_LOG_PRIORITY_INFO = 3;
  SDL_LOG_PRIORITY_WARN = 4;
  SDL_LOG_PRIORITY_ERROR = 5;
  SDL_LOG_PRIORITY_CRITICAL = 6;
  SDL_NUM_LOG_PRIORITIES = 7;

(**
 * SDL_MessageBox flags. If supported will display warning icon, etc.
 *)
type
  SDL_MessageBoxFlags = Integer;
  PSDL_MessageBoxFlags = ^SDL_MessageBoxFlags;

const
  (** error dialog *)
  SDL_MESSAGEBOX_ERROR = 16;
  (** warning dialog *)
  SDL_MESSAGEBOX_WARNING = 32;
  (** informational dialog *)
  SDL_MESSAGEBOX_INFORMATION = 64;
  (** buttons placed left to right *)
  SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT = 128;
  (** buttons placed right to left *)
  SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT = 256;

(**
 * Flags for SDL_MessageBoxButtonData.
 *)
type
  SDL_MessageBoxButtonFlags = Integer;
  PSDL_MessageBoxButtonFlags = ^SDL_MessageBoxButtonFlags;

const
  (** Marks the default button when return is hit *)
  SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 1;
  (** Marks the default button when escape is hit *)
  SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 2;

type
  SDL_MessageBoxColorType = Integer;
  PSDL_MessageBoxColorType = ^SDL_MessageBoxColorType;

const
  SDL_MESSAGEBOX_COLOR_BACKGROUND = 0;
  SDL_MESSAGEBOX_COLOR_TEXT = 1;
  SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2;
  SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3;
  SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4;
  SDL_MESSAGEBOX_COLOR_MAX = 5;

(**
 *  The basic state for the system's power supply.
 *)
type
  SDL_PowerState = Integer;
  PSDL_PowerState = ^SDL_PowerState;

const
  (** cannot determine power status *)
  SDL_POWERSTATE_UNKNOWN = 0;
  (** Not plugged in, running on the battery *)
  SDL_POWERSTATE_ON_BATTERY = 1;
  (** Plugged in, no battery available *)
  SDL_POWERSTATE_NO_BATTERY = 2;
  (** Plugged in, charging battery *)
  SDL_POWERSTATE_CHARGING = 3;
  (** Plugged in, battery charged *)
  SDL_POWERSTATE_CHARGED = 4;

(**
 * Flags used when creating a rendering context
 *)
type
  SDL_RendererFlags = Integer;
  PSDL_RendererFlags = ^SDL_RendererFlags;

const
  (** The renderer is a software fallback *)
  SDL_RENDERER_SOFTWARE = 1;
  (** The renderer uses hardware
                                                       acceleration *)
  SDL_RENDERER_ACCELERATED = 2;
  (** Present is synchronized
                                                       with the refresh rate *)
  SDL_RENDERER_PRESENTVSYNC = 4;
  (** The renderer supports
                                                       rendering to texture *)
  SDL_RENDERER_TARGETTEXTURE = 8;

(**
 * The scaling mode for a texture.
 *)
type
  SDL_ScaleMode = Integer;
  PSDL_ScaleMode = ^SDL_ScaleMode;

const
  (** nearest pixel sampling *)
  SDL_ScaleModeNearest = 0;
  (** linear filtering *)
  SDL_ScaleModeLinear = 1;
  (** anisotropic filtering *)
  SDL_ScaleModeBest = 2;

(**
 * The access pattern allowed for a texture.
 *)
type
  SDL_TextureAccess = Integer;
  PSDL_TextureAccess = ^SDL_TextureAccess;

const
  (** Changes rarely, not lockable *)
  SDL_TEXTUREACCESS_STATIC = 0;
  (** Changes frequently, lockable *)
  SDL_TEXTUREACCESS_STREAMING = 1;
  (** Texture can be used as a render target *)
  SDL_TEXTUREACCESS_TARGET = 2;

(**
 * The texture channel modulation used in SDL_RenderCopy().
 *)
type
  SDL_TextureModulate = Integer;
  PSDL_TextureModulate = ^SDL_TextureModulate;

const
  (** No modulation *)
  SDL_TEXTUREMODULATE_NONE = 0;
  (** srcC = srcC * color *)
  SDL_TEXTUREMODULATE_COLOR = 1;
  (** srcA = srcA * alpha *)
  SDL_TEXTUREMODULATE_ALPHA = 2;

(**
 * Flip constants for SDL_RenderCopyEx
 *)
type
  SDL_RendererFlip = Integer;
  PSDL_RendererFlip = ^SDL_RendererFlip;

const
  (** Do not flip *)
  SDL_FLIP_NONE = 0;
  (** flip horizontally *)
  SDL_FLIP_HORIZONTAL = 1;
  (** flip vertically *)
  SDL_FLIP_VERTICAL = 2;

(** \brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union. *)
type
  WindowShapeMode = Integer;
  PWindowShapeMode = ^WindowShapeMode;

const
  (** \brief The default mode, a binarized alpha cutoff of 1. *)
  ShapeModeDefault = 0;
  (** \brief A binarized alpha cutoff with a given integer value. *)
  ShapeModeBinarizeAlpha = 1;
  (** \brief A binarized alpha cutoff with a given integer value, but with the opposite comparison. *)
  ShapeModeReverseBinarizeAlpha = 2;
  (** \brief A color key is applied. *)
  ShapeModeColorKey = 3;

(**
 * Initialization flags
 *)
type
  IMG_InitFlags = Integer;
  PIMG_InitFlags = ^IMG_InitFlags;

const
  IMG_INIT_JPG = 1;
  IMG_INIT_PNG = 2;
  IMG_INIT_TIF = 4;
  IMG_INIT_WEBP = 8;
  IMG_INIT_JXL = 16;
  IMG_INIT_AVIF = 32;

(**
 * Initialization flags
 *)
type
  MIX_InitFlags = Integer;
  PMIX_InitFlags = ^MIX_InitFlags;

const
  MIX_INIT_FLAC = 1;
  MIX_INIT_MOD = 2;
  MIX_INIT_MP3 = 8;
  MIX_INIT_OGG = 16;
  MIX_INIT_MID = 32;
  MIX_INIT_OPUS = 64;

(**
 * The different fading types supported
 *)
type
  Mix_Fading = Integer;
  PMix_Fading = ^Mix_Fading;

const
  MIX_NO_FADING = 0;
  MIX_FADING_OUT = 1;
  MIX_FADING_IN = 2;

(**
 * These are types of music files (not libraries used to load them)
 *)
type
  Mix_MusicType = Integer;
  PMix_MusicType = ^Mix_MusicType;

const
  MUS_NONE = 0;
  MUS_CMD = 1;
  MUS_WAV = 2;
  MUS_MOD = 3;
  MUS_MID = 4;
  MUS_OGG = 5;
  MUS_MP3 = 6;
  MUS_MP3_MAD_UNUSED = 7;
  MUS_FLAC = 8;
  MUS_MODPLUG_UNUSED = 9;
  MUS_OPUS = 10;

(**
 * Direction flags
 *
 * \sa TTF_SetFontDirection
 *)
type
  TTF_Direction = Integer;
  PTTF_Direction = ^TTF_Direction;

const
  TTF_DIRECTION_LTR = 0;
  TTF_DIRECTION_RTL = 1;
  TTF_DIRECTION_TTB = 2;
  TTF_DIRECTION_BTT = 3;

const
  nk_false = 0;
  nk_true = 1;

type
  nk_heading = Integer;
  Pnk_heading = ^nk_heading;

const
  NK_UP = 0;
  NK_RIGHT = 1;
  NK_DOWN = 2;
  NK_LEFT = 3;

type
  nk_button_behavior = Integer;
  Pnk_button_behavior = ^nk_button_behavior;

const
  NK_BUTTON_DEFAULT = 0;
  NK_BUTTON_REPEATER = 1;

type
  nk_modify = Integer;
  Pnk_modify = ^nk_modify;

const
  NK_FIXED = 0;
  NK_MODIFIABLE = 1;

type
  nk_orientation = Integer;
  Pnk_orientation = ^nk_orientation;

const
  NK_VERTICAL = 0;
  NK_HORIZONTAL = 1;

type
  nk_collapse_states = Integer;
  Pnk_collapse_states = ^nk_collapse_states;

const
  NK_MINIMIZED = 0;
  NK_MAXIMIZED = 1;

type
  nk_show_states = Integer;
  Pnk_show_states = ^nk_show_states;

const
  NK_HIDDEN = 0;
  NK_SHOWN = 1;

type
  nk_chart_type = Integer;
  Pnk_chart_type = ^nk_chart_type;

const
  NK_CHART_LINES = 0;
  NK_CHART_COLUMN = 1;
  NK_CHART_MAX = 2;

type
  nk_chart_event = Integer;
  Pnk_chart_event = ^nk_chart_event;

const
  NK_CHART_HOVERING = 1;
  NK_CHART_CLICKED = 2;

type
  nk_color_format = Integer;
  Pnk_color_format = ^nk_color_format;

const
  NK_RGB = 0;
  NK_RGBA = 1;

type
  nk_popup_type = Integer;
  Pnk_popup_type = ^nk_popup_type;

const
  NK_POPUP_STATIC = 0;
  NK_POPUP_DYNAMIC = 1;

type
  nk_layout_format = Integer;
  Pnk_layout_format = ^nk_layout_format;

const
  NK_DYNAMIC = 0;
  NK_STATIC = 1;

type
  nk_tree_type = Integer;
  Pnk_tree_type = ^nk_tree_type;

const
  NK_TREE_NODE = 0;
  NK_TREE_TAB = 1;

type
  nk_symbol_type = Integer;
  Pnk_symbol_type = ^nk_symbol_type;

const
  NK_SYMBOL_NONE = 0;
  NK_SYMBOL_X = 1;
  NK_SYMBOL_UNDERSCORE = 2;
  NK_SYMBOL_CIRCLE_SOLID = 3;
  NK_SYMBOL_CIRCLE_OUTLINE = 4;
  NK_SYMBOL_RECT_SOLID = 5;
  NK_SYMBOL_RECT_OUTLINE = 6;
  NK_SYMBOL_TRIANGLE_UP = 7;
  NK_SYMBOL_TRIANGLE_DOWN = 8;
  NK_SYMBOL_TRIANGLE_LEFT = 9;
  NK_SYMBOL_TRIANGLE_RIGHT = 10;
  NK_SYMBOL_PLUS = 11;
  NK_SYMBOL_MINUS = 12;
  NK_SYMBOL_MAX = 13;

type
  nk_keys = Integer;
  Pnk_keys = ^nk_keys;

const
  NK_KEY_NONE = 0;
  NK_KEY_SHIFT = 1;
  NK_KEY_CTRL = 2;
  NK_KEY_DEL = 3;
  NK_KEY_ENTER = 4;
  NK_KEY_TAB = 5;
  NK_KEY_BACKSPACE = 6;
  NK_KEY_COPY = 7;
  NK_KEY_CUT = 8;
  NK_KEY_PASTE = 9;
  NK_KEY_UP = 10;
  NK_KEY_DOWN = 11;
  NK_KEY_LEFT = 12;
  NK_KEY_RIGHT = 13;
  NK_KEY_TEXT_INSERT_MODE = 14;
  NK_KEY_TEXT_REPLACE_MODE = 15;
  NK_KEY_TEXT_RESET_MODE = 16;
  NK_KEY_TEXT_LINE_START = 17;
  NK_KEY_TEXT_LINE_END = 18;
  NK_KEY_TEXT_START = 19;
  NK_KEY_TEXT_END = 20;
  NK_KEY_TEXT_UNDO = 21;
  NK_KEY_TEXT_REDO = 22;
  NK_KEY_TEXT_SELECT_ALL = 23;
  NK_KEY_TEXT_WORD_LEFT = 24;
  NK_KEY_TEXT_WORD_RIGHT = 25;
  NK_KEY_SCROLL_START = 26;
  NK_KEY_SCROLL_END = 27;
  NK_KEY_SCROLL_DOWN = 28;
  NK_KEY_SCROLL_UP = 29;
  NK_KEY_MAX = 30;

type
  nk_buttons = Integer;
  Pnk_buttons = ^nk_buttons;

const
  NK_BUTTON_LEFT = 0;
  NK_BUTTON_MIDDLE = 1;
  NK_BUTTON_RIGHT = 2;
  NK_BUTTON_DOUBLE = 3;
  NK_BUTTON_MAX = 4;

type
  nk_anti_aliasing = Integer;
  Pnk_anti_aliasing = ^nk_anti_aliasing;

const
  NK_ANTI_ALIASING_OFF = 0;
  NK_ANTI_ALIASING_ON = 1;

type
  nk_convert_result = Integer;
  Pnk_convert_result = ^nk_convert_result;

const
  NK_CONVERT_SUCCESS = 0;
  NK_CONVERT_INVALID_PARAM = 1;
  NK_CONVERT_COMMAND_BUFFER_FULL = 2;
  NK_CONVERT_VERTEX_BUFFER_FULL = 4;
  NK_CONVERT_ELEMENT_BUFFER_FULL = 8;

type
  nk_panel_flags = Integer;
  Pnk_panel_flags = ^nk_panel_flags;

const
  NK_WINDOW_BORDER = 1;
  NK_WINDOW_MOVABLE = 2;
  NK_WINDOW_SCALABLE = 4;
  NK_WINDOW_CLOSABLE = 8;
  NK_WINDOW_MINIMIZABLE = 16;
  NK_WINDOW_NO_SCROLLBAR = 32;
  NK_WINDOW_TITLE = 64;
  NK_WINDOW_SCROLL_AUTO_HIDE = 128;
  NK_WINDOW_BACKGROUND = 256;
  NK_WINDOW_SCALE_LEFT = 512;
  NK_WINDOW_NO_INPUT = 1024;

type
  nk_widget_layout_states = Integer;
  Pnk_widget_layout_states = ^nk_widget_layout_states;

const
  NK_WIDGET_INVALID = 0;
  NK_WIDGET_VALID = 1;
  NK_WIDGET_ROM = 2;

type
  nk_widget_states = Integer;
  Pnk_widget_states = ^nk_widget_states;

const
  NK_WIDGET_STATE_MODIFIED = 2;
  NK_WIDGET_STATE_INACTIVE = 4;
  NK_WIDGET_STATE_ENTERED = 8;
  NK_WIDGET_STATE_HOVER = 16;
  NK_WIDGET_STATE_ACTIVED = 32;
  NK_WIDGET_STATE_LEFT = 64;
  NK_WIDGET_STATE_HOVERED = 18;
  NK_WIDGET_STATE_ACTIVE = 34;

type
  nk_text_align = Integer;
  Pnk_text_align = ^nk_text_align;

const
  NK_TEXT_ALIGN_LEFT = 1;
  NK_TEXT_ALIGN_CENTERED = 2;
  NK_TEXT_ALIGN_RIGHT = 4;
  NK_TEXT_ALIGN_TOP = 8;
  NK_TEXT_ALIGN_MIDDLE = 16;
  NK_TEXT_ALIGN_BOTTOM = 32;

type
  nk_text_alignment = Integer;
  Pnk_text_alignment = ^nk_text_alignment;

const
  NK_TEXT_LEFT = 17;
  NK_TEXT_CENTERED = 18;
  NK_TEXT_RIGHT = 20;

type
  nk_edit_flags = Integer;
  Pnk_edit_flags = ^nk_edit_flags;

const
  NK_EDIT_DEFAULT = 0;
  NK_EDIT_READ_ONLY = 1;
  NK_EDIT_AUTO_SELECT = 2;
  NK_EDIT_SIG_ENTER = 4;
  NK_EDIT_ALLOW_TAB = 8;
  NK_EDIT_NO_CURSOR = 16;
  NK_EDIT_SELECTABLE = 32;
  NK_EDIT_CLIPBOARD = 64;
  NK_EDIT_CTRL_ENTER_NEWLINE = 128;
  NK_EDIT_NO_HORIZONTAL_SCROLL = 256;
  NK_EDIT_ALWAYS_INSERT_MODE = 512;
  NK_EDIT_MULTILINE = 1024;
  NK_EDIT_GOTO_END_ON_ACTIVATE = 2048;

type
  nk_edit_types = Integer;
  Pnk_edit_types = ^nk_edit_types;

const
  NK_EDIT_SIMPLE = 512;
  NK_EDIT_FIELD = 608;
  NK_EDIT_BOX = 1640;
  NK_EDIT_EDITOR = 1128;

type
  nk_edit_events = Integer;
  Pnk_edit_events = ^nk_edit_events;

const
  NK_EDIT_ACTIVE = 1;
  NK_EDIT_INACTIVE = 2;
  NK_EDIT_ACTIVATED = 4;
  NK_EDIT_DEACTIVATED = 8;
  NK_EDIT_COMMITED = 16;

type
  nk_style_colors = Integer;
  Pnk_style_colors = ^nk_style_colors;

const
  NK_COLOR_TEXT = 0;
  NK_COLOR_WINDOW = 1;
  NK_COLOR_HEADER = 2;
  NK_COLOR_BORDER = 3;
  NK_COLOR_BUTTON = 4;
  NK_COLOR_BUTTON_HOVER = 5;
  NK_COLOR_BUTTON_ACTIVE = 6;
  NK_COLOR_TOGGLE = 7;
  NK_COLOR_TOGGLE_HOVER = 8;
  NK_COLOR_TOGGLE_CURSOR = 9;
  NK_COLOR_SELECT = 10;
  NK_COLOR_SELECT_ACTIVE = 11;
  NK_COLOR_SLIDER = 12;
  NK_COLOR_SLIDER_CURSOR = 13;
  NK_COLOR_SLIDER_CURSOR_HOVER = 14;
  NK_COLOR_SLIDER_CURSOR_ACTIVE = 15;
  NK_COLOR_PROPERTY = 16;
  NK_COLOR_EDIT = 17;
  NK_COLOR_EDIT_CURSOR = 18;
  NK_COLOR_COMBO = 19;
  NK_COLOR_CHART = 20;
  NK_COLOR_CHART_COLOR = 21;
  NK_COLOR_CHART_COLOR_HIGHLIGHT = 22;
  NK_COLOR_SCROLLBAR = 23;
  NK_COLOR_SCROLLBAR_CURSOR = 24;
  NK_COLOR_SCROLLBAR_CURSOR_HOVER = 25;
  NK_COLOR_SCROLLBAR_CURSOR_ACTIVE = 26;
  NK_COLOR_TAB_HEADER = 27;
  NK_COLOR_COUNT = 28;

type
  nk_style_cursor = Integer;
  Pnk_style_cursor = ^nk_style_cursor;

const
  NK_CURSOR_ARROW = 0;
  NK_CURSOR_TEXT = 1;
  NK_CURSOR_MOVE = 2;
  NK_CURSOR_RESIZE_VERTICAL = 3;
  NK_CURSOR_RESIZE_HORIZONTAL = 4;
  NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT = 5;
  NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT = 6;
  NK_CURSOR_COUNT = 7;

type
  nk_font_coord_type = Integer;
  Pnk_font_coord_type = ^nk_font_coord_type;

const
  NK_COORD_UV = 0;
  NK_COORD_PIXEL = 1;

type
  nk_font_atlas_format = Integer;
  Pnk_font_atlas_format = ^nk_font_atlas_format;

const
  NK_FONT_ATLAS_ALPHA8 = 0;
  NK_FONT_ATLAS_RGBA32 = 1;

type
  nk_allocation_type = Integer;
  Pnk_allocation_type = ^nk_allocation_type;

const
  NK_BUFFER_FIXED = 0;
  NK_BUFFER_DYNAMIC = 1;

type
  nk_buffer_allocation_type = Integer;
  Pnk_buffer_allocation_type = ^nk_buffer_allocation_type;

const
  NK_BUFFER_FRONT = 0;
  NK_BUFFER_BACK = 1;
  NK_BUFFER_MAX = 2;

type
  nk_text_edit_type = Integer;
  Pnk_text_edit_type = ^nk_text_edit_type;

const
  NK_TEXT_EDIT_SINGLE_LINE = 0;
  NK_TEXT_EDIT_MULTI_LINE = 1;

type
  nk_text_edit_mode = Integer;
  Pnk_text_edit_mode = ^nk_text_edit_mode;

const
  NK_TEXT_EDIT_MODE_VIEW = 0;
  NK_TEXT_EDIT_MODE_INSERT = 1;
  NK_TEXT_EDIT_MODE_REPLACE = 2;

type
  nk_command_type = Integer;
  Pnk_command_type = ^nk_command_type;

const
  NK_COMMAND_NOP_ = 0;
  NK_COMMAND_SCISSOR_ = 1;
  NK_COMMAND_LINE_ = 2;
  NK_COMMAND_CURVE_ = 3;
  NK_COMMAND_RECT_ = 4;
  NK_COMMAND_RECT_FILLED_ = 5;
  NK_COMMAND_RECT_MULTI_COLOR_ = 6;
  NK_COMMAND_CIRCLE_ = 7;
  NK_COMMAND_CIRCLE_FILLED_ = 8;
  NK_COMMAND_ARC_ = 9;
  NK_COMMAND_ARC_FILLED_ = 10;
  NK_COMMAND_TRIANGLE_ = 11;
  NK_COMMAND_TRIANGLE_FILLED_ = 12;
  NK_COMMAND_POLYGON_ = 13;
  NK_COMMAND_POLYGON_FILLED_ = 14;
  NK_COMMAND_POLYLINE_ = 15;
  NK_COMMAND_TEXT_ = 16;
  NK_COMMAND_IMAGE_ = 17;
  NK_COMMAND_CUSTOM_ = 18;

type
  nk_command_clipping = Integer;
  Pnk_command_clipping = ^nk_command_clipping;

const
  NK_CLIPPING_OFF = 0;
  NK_CLIPPING_ON = 1;

type
  nk_draw_list_stroke = Integer;
  Pnk_draw_list_stroke = ^nk_draw_list_stroke;

const
  NK_STROKE_OPEN = 0;
  NK_STROKE_CLOSED = 1;

type
  nk_draw_vertex_layout_attribute = Integer;
  Pnk_draw_vertex_layout_attribute = ^nk_draw_vertex_layout_attribute;

const
  NK_VERTEX_POSITION = 0;
  NK_VERTEX_COLOR = 1;
  NK_VERTEX_TEXCOORD = 2;
  NK_VERTEX_ATTRIBUTE_COUNT = 3;

type
  nk_draw_vertex_layout_format = Integer;
  Pnk_draw_vertex_layout_format = ^nk_draw_vertex_layout_format;

const
  NK_FORMAT_SCHAR = 0;
  NK_FORMAT_SSHORT = 1;
  NK_FORMAT_SINT = 2;
  NK_FORMAT_UCHAR = 3;
  NK_FORMAT_USHORT = 4;
  NK_FORMAT_UINT = 5;
  NK_FORMAT_FLOAT = 6;
  NK_FORMAT_DOUBLE = 7;
  NK_FORMAT_COLOR_BEGIN = 8;
  NK_FORMAT_R8G8B8 = 8;
  NK_FORMAT_R16G15B16 = 9;
  NK_FORMAT_R32G32B32 = 10;
  NK_FORMAT_R8G8B8A8 = 11;
  NK_FORMAT_B8G8R8A8 = 12;
  NK_FORMAT_R16G15B16A16 = 13;
  NK_FORMAT_R32G32B32A32 = 14;
  NK_FORMAT_R32G32B32A32_FLOAT = 15;
  NK_FORMAT_R32G32B32A32_DOUBLE = 16;
  NK_FORMAT_RGB32 = 17;
  NK_FORMAT_RGBA32 = 18;
  NK_FORMAT_COLOR_END = 18;
  NK_FORMAT_COUNT = 19;

type
  nk_style_item_type = Integer;
  Pnk_style_item_type = ^nk_style_item_type;

const
  NK_STYLE_ITEM_COLOR = 0;
  NK_STYLE_ITEM_IMAGE = 1;
  NK_STYLE_ITEM_NINE_SLICE = 2;

type
  nk_style_header_align = Integer;
  Pnk_style_header_align = ^nk_style_header_align;

const
  NK_HEADER_LEFT = 0;
  NK_HEADER_RIGHT = 1;

type
  nk_panel_type = Integer;
  Pnk_panel_type = ^nk_panel_type;

const
  NK_PANEL_NONE = 0;
  NK_PANEL_WINDOW = 1;
  NK_PANEL_GROUP = 2;
  NK_PANEL_POPUP = 4;
  NK_PANEL_CONTEXTUAL = 16;
  NK_PANEL_COMBO = 32;
  NK_PANEL_MENU = 64;
  NK_PANEL_TOOLTIP = 128;

type
  nk_panel_set = Integer;
  Pnk_panel_set = ^nk_panel_set;

const
  NK_PANEL_SET_NONBLOCK = 240;
  NK_PANEL_SET_POPUP = 244;
  NK_PANEL_SET_SUB = 246;

type
  nk_panel_row_layout_type = Integer;
  Pnk_panel_row_layout_type = ^nk_panel_row_layout_type;

const
  NK_LAYOUT_DYNAMIC_FIXED = 0;
  NK_LAYOUT_DYNAMIC_ROW = 1;
  NK_LAYOUT_DYNAMIC_FREE = 2;
  NK_LAYOUT_DYNAMIC = 3;
  NK_LAYOUT_STATIC_FIXED = 4;
  NK_LAYOUT_STATIC_ROW = 5;
  NK_LAYOUT_STATIC_FREE = 6;
  NK_LAYOUT_STATIC = 7;
  NK_LAYOUT_TEMPLATE = 8;
  NK_LAYOUT_COUNT = 9;

type
  nk_window_flags = Integer;
  Pnk_window_flags = ^nk_window_flags;

const
  NK_WINDOW_PRIVATE = 2048;
  NK_WINDOW_DYNAMIC = 2048;
  NK_WINDOW_ROM = 4096;
  NK_WINDOW_NOT_INTERACTIVE = 5120;
  NK_WINDOW_HIDDEN = 8192;
  NK_WINDOW_CLOSED = 16384;
  NK_WINDOW_MINIMIZED = 32768;
  NK_WINDOW_REMOVE_ROM = 65536;

type
  // Forward declarations
  PPUTF8Char = ^PUTF8Char;
  PWideChar = ^WideChar;
  PPointer = ^Pointer;
  PNativeUInt = ^NativeUInt;
  P_SDL_iconv_t = Pointer;
  PP_SDL_iconv_t = ^P_SDL_iconv_t;
  PSDL_semaphore = Pointer;
  PPSDL_semaphore = ^PSDL_semaphore;
  P_SDL_AudioStream = Pointer;
  PP_SDL_AudioStream = ^P_SDL_AudioStream;
  P_SDL_Joystick = Pointer;
  PP_SDL_Joystick = ^P_SDL_Joystick;
  P_SDL_Sensor = Pointer;
  PP_SDL_Sensor = ^P_SDL_Sensor;
  P_SDL_GameController = Pointer;
  PP_SDL_GameController = ^P_SDL_GameController;
  P_SDL_Haptic = Pointer;
  PP_SDL_Haptic = ^P_SDL_Haptic;
  PSDL_hid_device_ = Pointer;
  PPSDL_hid_device_ = ^PSDL_hid_device_;
  P_Mix_Music = Pointer;
  PP_Mix_Music = ^P_Mix_Music;
  P_TCPsocket = Pointer;
  PP_TCPsocket = ^P_TCPsocket;
  P_UDPsocket = Pointer;
  PP_UDPsocket = ^P_UDPsocket;
  P_SDLNet_SocketSet = Pointer;
  PP_SDLNet_SocketSet = ^P_SDLNet_SocketSet;
  P_TTF_Font = Pointer;
  PP_TTF_Font = ^P_TTF_Font;
  Pnk_style_slide = Pointer;
  PPnk_style_slide = ^Pnk_style_slide;
  PSDL_AssertData = ^SDL_AssertData;
  PSDL_atomic_t = ^SDL_atomic_t;
  PSDL_RWops = ^SDL_RWops;
  PSDL_AudioSpec = ^SDL_AudioSpec;
  PSDL_AudioCVT = ^SDL_AudioCVT;
  PSDL_Color = ^SDL_Color;
  PSDL_Palette = ^SDL_Palette;
  PSDL_PixelFormat = ^SDL_PixelFormat;
  PSDL_Point = ^SDL_Point;
  PSDL_FPoint = ^SDL_FPoint;
  PSDL_Rect = ^SDL_Rect;
  PSDL_FRect = ^SDL_FRect;
  PSDL_Surface = ^SDL_Surface;
  PPSDL_Surface = ^PSDL_Surface;
  PSDL_DisplayMode = ^SDL_DisplayMode;
  PSDL_Keysym = ^SDL_Keysym;
  PSDL_GUID = ^SDL_GUID;
  PSDL_VirtualJoystickDesc = ^SDL_VirtualJoystickDesc;
  PSDL_GameControllerButtonBind = ^SDL_GameControllerButtonBind;
  PSDL_Finger = ^SDL_Finger;
  PSDL_CommonEvent = ^SDL_CommonEvent;
  PSDL_DisplayEvent = ^SDL_DisplayEvent;
  PSDL_WindowEvent = ^SDL_WindowEvent;
  PSDL_KeyboardEvent = ^SDL_KeyboardEvent;
  PSDL_TextEditingEvent = ^SDL_TextEditingEvent;
  PSDL_TextEditingExtEvent = ^SDL_TextEditingExtEvent;
  PSDL_TextInputEvent = ^SDL_TextInputEvent;
  PSDL_MouseMotionEvent = ^SDL_MouseMotionEvent;
  PSDL_MouseButtonEvent = ^SDL_MouseButtonEvent;
  PSDL_MouseWheelEvent = ^SDL_MouseWheelEvent;
  PSDL_JoyAxisEvent = ^SDL_JoyAxisEvent;
  PSDL_JoyBallEvent = ^SDL_JoyBallEvent;
  PSDL_JoyHatEvent = ^SDL_JoyHatEvent;
  PSDL_JoyButtonEvent = ^SDL_JoyButtonEvent;
  PSDL_JoyDeviceEvent = ^SDL_JoyDeviceEvent;
  PSDL_JoyBatteryEvent = ^SDL_JoyBatteryEvent;
  PSDL_ControllerAxisEvent = ^SDL_ControllerAxisEvent;
  PSDL_ControllerButtonEvent = ^SDL_ControllerButtonEvent;
  PSDL_ControllerDeviceEvent = ^SDL_ControllerDeviceEvent;
  PSDL_ControllerTouchpadEvent = ^SDL_ControllerTouchpadEvent;
  PSDL_ControllerSensorEvent = ^SDL_ControllerSensorEvent;
  PSDL_AudioDeviceEvent = ^SDL_AudioDeviceEvent;
  PSDL_TouchFingerEvent = ^SDL_TouchFingerEvent;
  PSDL_MultiGestureEvent = ^SDL_MultiGestureEvent;
  PSDL_DollarGestureEvent = ^SDL_DollarGestureEvent;
  PSDL_DropEvent = ^SDL_DropEvent;
  PSDL_SensorEvent = ^SDL_SensorEvent;
  PSDL_QuitEvent = ^SDL_QuitEvent;
  PSDL_OSEvent = ^SDL_OSEvent;
  PSDL_UserEvent = ^SDL_UserEvent;
  PSDL_SysWMEvent = ^SDL_SysWMEvent;
  PSDL_HapticDirection = ^SDL_HapticDirection;
  PSDL_HapticConstant = ^SDL_HapticConstant;
  PSDL_HapticCondition = ^SDL_HapticCondition;
  PSDL_HapticRamp = ^SDL_HapticRamp;
  PSDL_HapticLeftRight = ^SDL_HapticLeftRight;
  PSDL_HapticCustom = ^SDL_HapticCustom;
  PSDL_hid_device_info = ^SDL_hid_device_info;
  PSDL_MessageBoxButtonData = ^SDL_MessageBoxButtonData;
  PSDL_MessageBoxColor = ^SDL_MessageBoxColor;
  PSDL_MessageBoxColorScheme = ^SDL_MessageBoxColorScheme;
  PSDL_MessageBoxData = ^SDL_MessageBoxData;
  PSDL_RendererInfo = ^SDL_RendererInfo;
  PSDL_Vertex = ^SDL_Vertex;
  PSDL_WindowShapeMode = ^SDL_WindowShapeMode;
  PSDL_version = ^SDL_version;
  PSDL_Locale = ^SDL_Locale;
  PIMG_Animation = ^IMG_Animation;
  PMix_Chunk = ^Mix_Chunk;
  PIPaddress = ^IPaddress;
  PUDPpacket = ^UDPpacket;
  PPUDPpacket = ^PUDPpacket;
  P_SDLNet_GenericSocket = ^_SDLNet_GenericSocket;
  Pnk_color = ^nk_color;
  Pnk_colorf = ^nk_colorf;
  Pnk_vec2 = ^nk_vec2;
  Pnk_vec2i = ^nk_vec2i;
  Pnk_rect = ^nk_rect;
  Pnk_recti = ^nk_recti;
  Pnk_image = ^nk_image;
  Pnk_nine_slice = ^nk_nine_slice;
  Pnk_cursor = ^nk_cursor;
  Pnk_scroll = ^nk_scroll;
  Pnk_allocator = ^nk_allocator;
  Pnk_draw_null_texture = ^nk_draw_null_texture;
  Pnk_convert_config = ^nk_convert_config;
  Pnk_list_view = ^nk_list_view;
  Pnk_user_font_glyph = ^nk_user_font_glyph;
  Pnk_user_font = ^nk_user_font;
  PPnk_user_font = ^Pnk_user_font;
  Pnk_baked_font = ^nk_baked_font;
  Pnk_font_config = ^nk_font_config;
  Pnk_font_glyph = ^nk_font_glyph;
  Pnk_font = ^nk_font;
  Pnk_font_atlas = ^nk_font_atlas;
  PPnk_font_atlas = ^Pnk_font_atlas;
  Pnk_memory_status = ^nk_memory_status;
  Pnk_buffer_marker = ^nk_buffer_marker;
  Pnk_memory = ^nk_memory;
  Pnk_buffer = ^nk_buffer;
  Pnk_str = ^nk_str;
  Pnk_clipboard = ^nk_clipboard;
  Pnk_text_undo_record = ^nk_text_undo_record;
  Pnk_text_undo_state = ^nk_text_undo_state;
  Pnk_text_edit = ^nk_text_edit;
  Pnk_command = ^nk_command;
  Pnk_command_scissor = ^nk_command_scissor;
  Pnk_command_line = ^nk_command_line;
  Pnk_command_curve = ^nk_command_curve;
  Pnk_command_rect = ^nk_command_rect;
  Pnk_command_rect_filled = ^nk_command_rect_filled;
  Pnk_command_rect_multi_color = ^nk_command_rect_multi_color;
  Pnk_command_triangle = ^nk_command_triangle;
  Pnk_command_triangle_filled = ^nk_command_triangle_filled;
  Pnk_command_circle = ^nk_command_circle;
  Pnk_command_circle_filled = ^nk_command_circle_filled;
  Pnk_command_arc = ^nk_command_arc;
  Pnk_command_arc_filled = ^nk_command_arc_filled;
  Pnk_command_polygon = ^nk_command_polygon;
  Pnk_command_polygon_filled = ^nk_command_polygon_filled;
  Pnk_command_polyline = ^nk_command_polyline;
  Pnk_command_image = ^nk_command_image;
  Pnk_command_custom = ^nk_command_custom;
  Pnk_command_text = ^nk_command_text;
  Pnk_command_buffer = ^nk_command_buffer;
  Pnk_mouse_button = ^nk_mouse_button;
  Pnk_mouse = ^nk_mouse;
  Pnk_key = ^nk_key;
  Pnk_keyboard = ^nk_keyboard;
  Pnk_input = ^nk_input;
  Pnk_draw_vertex_layout_element = ^nk_draw_vertex_layout_element;
  Pnk_draw_command = ^nk_draw_command;
  Pnk_draw_list = ^nk_draw_list;
  Pnk_style_item = ^nk_style_item;
  Pnk_style_text = ^nk_style_text;
  Pnk_style_button = ^nk_style_button;
  Pnk_style_toggle = ^nk_style_toggle;
  Pnk_style_selectable = ^nk_style_selectable;
  Pnk_style_slider = ^nk_style_slider;
  Pnk_style_progress = ^nk_style_progress;
  Pnk_style_scrollbar = ^nk_style_scrollbar;
  Pnk_style_edit = ^nk_style_edit;
  Pnk_style_property = ^nk_style_property;
  Pnk_style_chart = ^nk_style_chart;
  Pnk_style_combo = ^nk_style_combo;
  Pnk_style_tab = ^nk_style_tab;
  Pnk_style_window_header = ^nk_style_window_header;
  Pnk_style_window = ^nk_style_window;
  Pnk_style = ^nk_style;
  Pnk_chart_slot = ^nk_chart_slot;
  Pnk_chart = ^nk_chart;
  Pnk_row_layout = ^nk_row_layout;
  Pnk_popup_buffer = ^nk_popup_buffer;
  Pnk_menu_state = ^nk_menu_state;
  Pnk_panel = ^nk_panel;
  Pnk_popup_state = ^nk_popup_state;
  Pnk_edit_state = ^nk_edit_state;
  Pnk_property_state = ^nk_property_state;
  Pnk_window = ^nk_window;
  Pnk_config_stack_style_item_element = ^nk_config_stack_style_item_element;
  Pnk_config_stack_float_element = ^nk_config_stack_float_element;
  Pnk_config_stack_vec2_element = ^nk_config_stack_vec2_element;
  Pnk_config_stack_flags_element = ^nk_config_stack_flags_element;
  Pnk_config_stack_color_element = ^nk_config_stack_color_element;
  Pnk_config_stack_user_font_element = ^nk_config_stack_user_font_element;
  Pnk_config_stack_button_behavior_element = ^nk_config_stack_button_behavior_element;
  Pnk_config_stack_style_item = ^nk_config_stack_style_item;
  Pnk_config_stack_float = ^nk_config_stack_float;
  Pnk_config_stack_vec2 = ^nk_config_stack_vec2;
  Pnk_config_stack_flags = ^nk_config_stack_flags;
  Pnk_config_stack_color = ^nk_config_stack_color;
  Pnk_config_stack_user_font = ^nk_config_stack_user_font;
  Pnk_config_stack_button_behavior = ^nk_config_stack_button_behavior;
  Pnk_configuration_stacks = ^nk_configuration_stacks;
  Pnk_table = ^nk_table;
  Pnk_page_element = ^nk_page_element;
  Pnk_page = ^nk_page;
  Pnk_pool = ^nk_pool;
  Pnk_context = ^nk_context;
  Pplm_packet_t = ^plm_packet_t;
  Pplm_plane_t = ^plm_plane_t;
  Pplm_frame_t = ^plm_frame_t;
  Pplm_samples_t = ^plm_samples_t;
  Ptm_zip_s = ^tm_zip_s;
  Pzip_fileinfo = ^zip_fileinfo;

  Sint8 = Int8;
  PUint8 = ^Uint8;
  PPUint8 = ^PUint8;
  Sint16 = Int16;
  PSint16 = ^Sint16;
  PUint16 = ^Uint16;
  Sint32 = Int32;
  PUint32 = ^Uint32;
  Sint64 = Int64;

  SDL_malloc_func = function(size: NativeUInt): Pointer; cdecl;
  PSDL_malloc_func = ^SDL_malloc_func;

  SDL_calloc_func = function(nmemb: NativeUInt; size: NativeUInt): Pointer; cdecl;
  PSDL_calloc_func = ^SDL_calloc_func;

  SDL_realloc_func = function(mem: Pointer; size: NativeUInt): Pointer; cdecl;
  PSDL_realloc_func = ^SDL_realloc_func;

  SDL_free_func = procedure(mem: Pointer); cdecl;
  PSDL_free_func = ^SDL_free_func;
  SDL_iconv_t = Pointer;
  PSDL_iconv_t = ^SDL_iconv_t;

  (**
   *  The prototype for the application's main() function
   *)
  SDL_main_func = function(argc: Integer; argv: PPUTF8Char): Integer; cdecl;

  SDL_AssertData = record
    always_ignore: Integer;
    trigger_count: Cardinal;
    condition: PUTF8Char;
    filename: PUTF8Char;
    linenum: Integer;
    function_: PUTF8Char;
    next: PSDL_AssertData;
  end;

  (**
   * A callback that fires when an SDL assertion fails.
   *
   * \param data a pointer to the SDL_AssertData structure corresponding to the
   *             current assertion
   * \param userdata what was passed as `userdata` to SDL_SetAssertionHandler()
   * \returns an SDL_AssertState value indicating how to handle the failure.
   *)
  SDL_AssertionHandler = function(const data: PSDL_AssertData; userdata: Pointer): SDL_AssertState; cdecl;
  SDL_SpinLock = Integer;
  PSDL_SpinLock = ^SDL_SpinLock;

  (**
   * \brief A type representing an atomic integer value.  It is a struct
   *        so people don't accidentally use numeric operations on it.
   *)
  SDL_atomic_t = record
    value: Integer;
  end;

  PSDL_mutex = Pointer;
  PPSDL_mutex = ^PSDL_mutex;
  PSDL_sem = Pointer;
  PPSDL_sem = ^PSDL_sem;
  PSDL_cond = Pointer;
  PPSDL_cond = ^PSDL_cond;
  PSDL_Thread = Pointer;
  PPSDL_Thread = ^PSDL_Thread;
  SDL_threadID_ = Cardinal;
  SDL_TLSID = Cardinal;

  (**
   * The function passed to SDL_CreateThread().
   *
   * \param data what was passed as `data` to SDL_CreateThread()
   * \returns a value that can be reported through SDL_WaitThread().
   *)
  SDL_ThreadFunction = function(data: Pointer): Integer; cdecl;
  pfnSDL_CurrentBeginThread_func = Pointer;

  pfnSDL_CurrentBeginThread = function(p1: Pointer; p2: Cardinal; func: pfnSDL_CurrentBeginThread_func; p4: Pointer; p5: Cardinal; p6: PCardinal): UIntPtr; cdecl;

  pfnSDL_CurrentEndThread = procedure(code: Cardinal); cdecl;

  _anonymous_type_2 = record
    data: Pointer;
    size: NativeUInt;
    left: NativeUInt;
  end;
  P_anonymous_type_2 = ^_anonymous_type_2;

  _anonymous_type_3 = record
    append: SDL_bool;
    h: Pointer;
    buffer: _anonymous_type_2;
  end;
  P_anonymous_type_3 = ^_anonymous_type_3;

  _anonymous_type_4 = record
    base: PUint8;
    here: PUint8;
    stop: PUint8;
  end;
  P_anonymous_type_4 = ^_anonymous_type_4;

  _anonymous_type_5 = record
    data1: Pointer;
    data2: Pointer;
  end;
  P_anonymous_type_5 = ^_anonymous_type_5;

  _anonymous_type_6 = record
    case Integer of
      0: (windowsio: _anonymous_type_3);
      1: (mem: _anonymous_type_4);
      2: (unknown: _anonymous_type_5);
  end;
  P_anonymous_type_6 = ^_anonymous_type_6;

  (**
   * This is the read/write operation structure -- very basic.
   *)
  SDL_RWops = record
    (**
     *  Return the size of the file in this rwops, or -1 if unknown
     *)
    size: function(context: PSDL_RWops): Sint64; cdecl;
    (**
     *  Seek to \c offset relative to \c whence, one of stdio's whence values:
     *  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
     *
     *  \return the final offset in the data stream, or -1 on error.
     *)
    seek: function(context: PSDL_RWops; offset: Sint64; whence: Integer): Sint64; cdecl;
    (**
     *  Read up to \c maxnum objects each of size \c size from the data
     *  stream to the area pointed at by \c ptr.
     *
     *  \return the number of objects read, or 0 at error or end of file.
     *)
    read: function(context: PSDL_RWops; ptr: Pointer; size: NativeUInt; maxnum: NativeUInt): NativeUInt; cdecl;
    (**
     *  Write exactly \c num objects each of size \c size from the area
     *  pointed at by \c ptr to data stream.
     *
     *  \return the number of objects written, or 0 at error or end of file.
     *)
    write: function(context: PSDL_RWops; const ptr: Pointer; size: NativeUInt; num: NativeUInt): NativeUInt; cdecl;
    (**
     *  Close and free an allocated SDL_RWops structure.
     *
     *  \return 0 if successful or -1 on write error when flushing data.
     *)
    close: function(context: PSDL_RWops): Integer; cdecl;
    type_: Uint32;
    hidden: _anonymous_type_6;
  end;

  (**
   *  \brief Audio format flags.
   *
   *  These are what the 16 bits in SDL_AudioFormat currently mean...
   *  (Unspecified bits are always zero).
   *
   *  \verbatim
      ++-----------------------sample is signed if set
      ||
      ||       ++-----------sample is bigendian if set
      ||       ||
      ||       ||          ++---sample is float if set
      ||       ||          ||
      ||       ||          || +---sample bit size---+
      ||       ||          || |                     |
      15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
      \endverbatim
   *
   *  There are macros in SDL 2.0 and later to query these bits.
   *)
  SDL_AudioFormat = Uint16;

  (**
   *  This function is called when the audio device needs more data.
   *
   *  \param userdata An application-specific parameter saved in
   *                  the SDL_AudioSpec structure
   *  \param stream A pointer to the audio data buffer.
   *  \param len    The length of that buffer in bytes.
   *
   *  Once the callback returns, the buffer will no longer be valid.
   *  Stereo samples are stored in a LRLRLR ordering.
   *
   *  You can choose to avoid callbacks and use SDL_QueueAudio() instead, if
   *  you like. Just open your audio device with a NULL callback.
   *)
  SDL_AudioCallback = procedure(userdata: Pointer; stream: PUint8; len: Integer); cdecl;

  (**
   *  The calculated values in this structure are calculated by SDL_OpenAudio().
   *
   *  For multi-channel audio, the default SDL channel mapping is:
   *  2:  FL FR                       (stereo)
   *  3:  FL FR LFE                   (2.1 surround)
   *  4:  FL FR BL BR                 (quad)
   *  5:  FL FR LFE BL BR             (4.1 surround)
   *  6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)
   *  7:  FL FR FC LFE BC SL SR       (6.1 surround)
   *  8:  FL FR FC LFE BL BR SL SR    (7.1 surround)
   *)
  SDL_AudioSpec = record
    (** DSP frequency -- samples per second *)
    freq: Integer;
    (** Audio data format *)
    format: SDL_AudioFormat;
    (** Number of channels: 1 mono, 2 stereo *)
    channels: Uint8;
    (** Audio buffer silence value (calculated) *)
    silence: Uint8;
    (** Audio buffer size in sample FRAMES (total samples divided by channel count) *)
    samples: Uint16;
    (** Necessary for some compile environments *)
    padding: Uint16;
    (** Audio buffer size in bytes (calculated) *)
    size: Uint32;
    (** Callback that feeds the audio device (NULL to use SDL_QueueAudio()). *)
    callback: SDL_AudioCallback;
    (** Userdata passed to callback (ignored for NULL callbacks). *)
    userdata: Pointer;
  end;

  SDL_AudioFilter = procedure(cvt: PSDL_AudioCVT; format: SDL_AudioFormat); cdecl;

  SDL_AudioCVT = record
    (** Set to 1 if conversion possible *)
    needed: Integer;
    (** Source audio format *)
    src_format: SDL_AudioFormat;
    (** Target audio format *)
    dst_format: SDL_AudioFormat;
    (** Rate conversion increment *)
    rate_incr: Double;
    (** Buffer to hold entire audio data *)
    buf: PUint8;
    (** Length of original audio buffer *)
    len: Integer;
    (** Length of converted audio buffer *)
    len_cvt: Integer;
    (** buffer must be len*len_mult big *)
    len_mult: Integer;
    (** Given len, final size is len*len_ratio *)
    len_ratio: Double;
    (** NULL-terminated list of filter functions *)
    filters: array [0..9] of SDL_AudioFilter;
    (** Current audio conversion function *)
    filter_index: Integer;
  end;

  (**
   *  SDL Audio Device IDs.
   *
   *  A successful call to SDL_OpenAudio() is always device id 1, and legacy
   *  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
   *  always returns devices >= 2 on success. The legacy calls are good both
   *  for backwards compatibility and when you don't care about multiple,
   *  specific, or capture devices.
   *)
  SDL_AudioDeviceID = Uint32;
  PSDL_AudioStream = Pointer;
  PPSDL_AudioStream = ^PSDL_AudioStream;

  (**
   * The bits of this structure can be directly reinterpreted as an integer-packed
   * color which uses the SDL_PIXELFORMAT_RGBA32 format (SDL_PIXELFORMAT_ABGR8888
   * on little-endian systems and SDL_PIXELFORMAT_RGBA8888 on big-endian systems).
   *)
  SDL_Color = record
    r: Uint8;
    g: Uint8;
    b: Uint8;
    a: Uint8;
  end;

  SDL_Palette = record
    ncolors: Integer;
    colors: PSDL_Color;
    version: Uint32;
    refcount: Integer;
  end;

  (**
   *  \note Everything in the pixel format structure is read-only.
   *)
  SDL_PixelFormat = record
    format: Uint32;
    palette: PSDL_Palette;
    BitsPerPixel: Uint8;
    BytesPerPixel: Uint8;
    padding: array [0..1] of Uint8;
    Rmask: Uint32;
    Gmask: Uint32;
    Bmask: Uint32;
    Amask: Uint32;
    Rloss: Uint8;
    Gloss: Uint8;
    Bloss: Uint8;
    Aloss: Uint8;
    Rshift: Uint8;
    Gshift: Uint8;
    Bshift: Uint8;
    Ashift: Uint8;
    refcount: Integer;
    next: PSDL_PixelFormat;
  end;

  (**
   * The structure that defines a point (integer)
   *
   * \sa SDL_EnclosePoints
   * \sa SDL_PointInRect
   *)
  SDL_Point = record
    x: Integer;
    y: Integer;
  end;

  (**
   * The structure that defines a point (floating point)
   *
   * \sa SDL_EncloseFPoints
   * \sa SDL_PointInFRect
   *)
  SDL_FPoint = record
    x: Single;
    y: Single;
  end;

  (**
   * A rectangle, with the origin at the upper left (integer).
   *
   * \sa SDL_RectEmpty
   * \sa SDL_RectEquals
   * \sa SDL_HasIntersection
   * \sa SDL_IntersectRect
   * \sa SDL_IntersectRectAndLine
   * \sa SDL_UnionRect
   * \sa SDL_EnclosePoints
   *)
  SDL_Rect = record
    x: Integer;
    y: Integer;
    w: Integer;
    h: Integer;
  end;

  (**
   * A rectangle, with the origin at the upper left (floating point).
   *
   * \sa SDL_FRectEmpty
   * \sa SDL_FRectEquals
   * \sa SDL_FRectEqualsEpsilon
   * \sa SDL_HasIntersectionF
   * \sa SDL_IntersectFRect
   * \sa SDL_IntersectFRectAndLine
   * \sa SDL_UnionFRect
   * \sa SDL_EncloseFPoints
   * \sa SDL_PointInFRect
   *)
  SDL_FRect = record
    x: Single;
    y: Single;
    w: Single;
    h: Single;
  end;

  PSDL_BlitMap = Pointer;
  PPSDL_BlitMap = ^PSDL_BlitMap;

  (**
   * \brief A collection of pixels used in software blitting.
   *
   * \note  This structure should be treated as read-only, except for \c pixels,
   *        which, if not NULL, contains the raw pixel data for the surface.
   *)
  SDL_Surface = record
    (** Read-only *)
    flags: Uint32;
    (** Read-only *)
    format: PSDL_PixelFormat;
    (** Read-only *)
    w: Integer;
    (** Read-only *)
    h: Integer;
    (** Read-only *)
    pitch: Integer;
    (** Read-write *)
    pixels: Pointer;
    (** Read-write *)
    userdata: Pointer;
    (** Read-only *)
    locked: Integer;
    (** Private *)
    list_blitmap: Pointer;
    (** Read-only *)
    clip_rect: SDL_Rect;
    (** Private *)
    map: PSDL_BlitMap;
    (** Read-mostly *)
    refcount: Integer;
  end;

  (**
   * \brief The type of function used for surface blitting functions.
   *)
  SDL_blit = function(src: PSDL_Surface; srcrect: PSDL_Rect; dst: PSDL_Surface; dstrect: PSDL_Rect): Integer; cdecl;

  (**
   *  \brief  The structure that defines a display mode
   *
   *  \sa SDL_GetNumDisplayModes()
   *  \sa SDL_GetDisplayMode()
   *  \sa SDL_GetDesktopDisplayMode()
   *  \sa SDL_GetCurrentDisplayMode()
   *  \sa SDL_GetClosestDisplayMode()
   *  \sa SDL_SetWindowDisplayMode()
   *  \sa SDL_GetWindowDisplayMode()
   *)
  SDL_DisplayMode = record
    (** pixel format *)
    format: Uint32;
    (** width, in screen coordinates *)
    w: Integer;
    (** height, in screen coordinates *)
    h: Integer;
    (** refresh rate (or zero for unspecified) *)
    refresh_rate: Integer;
    (** driver-specific data, initialize to 0 *)
    driverdata: Pointer;
  end;

  PSDL_Window = Pointer;
  PPSDL_Window = ^PSDL_Window;
  (**
   *  \brief An opaque handle to an OpenGL context.
   *)
  SDL_GLContext = Pointer;

  (**
   * Callback used for hit-testing.
   *
   * \param win the SDL_Window where hit-testing was set on
   * \param area an SDL_Point which should be hit-tested
   * \param data what was passed as `callback_data` to SDL_SetWindowHitTest()
   * \return an SDL_HitTestResult value.
   *
   * \sa SDL_SetWindowHitTest
   *)
  SDL_HitTest = function(win: PSDL_Window; const area: PSDL_Point; data: Pointer): SDL_HitTestResult; cdecl;
  (**
   *  \brief The SDL virtual key representation.
   *
   *  Values of this type are used to represent keyboard keys using the current
   *  layout of the keyboard.  These values include Unicode values representing
   *  the unmodified character that would be generated by pressing the key, or
   *  an SDLK_* constant for those keys that do not generate characters.
   *
   *  A special exception is the number keys at the top of the keyboard which
   *  always map to SDLK_0...SDLK_9, regardless of layout.
   *)

  (**
   *  \brief The SDL keysym structure, used in key events.
   *
   *  \note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event.
   *)
  SDL_Keysym = record
    (** SDL physical key code - see ::SDL_Scancode for details *)
    scancode: SDL_Scancode;
    (** SDL virtual key code - see ::SDL_Keycode for details *)
    sym: SDL_Keycode;
    (** current key modifiers *)
    mod_: Uint16;
    unused: Uint32;
  end;

  PSDL_Cursor = Pointer;
  PPSDL_Cursor = ^PSDL_Cursor;

  (**
   * An SDL_GUID is a 128-bit identifier for an input device that
   *   identifies that device across runs of SDL programs on the same
   *   platform.  If the device is detached and then re-attached to a
   *   different port, or if the base system is rebooted, the device
   *   should still report the same GUID.
   *
   * GUIDs are as precise as possible but are not guaranteed to
   *   distinguish physically distinct but equivalent devices.  For
   *   example, two game controllers from the same vendor with the same
   *   product ID and revision may have the same GUID.
   *
   * GUIDs may be platform-dependent (i.e., the same device may report
   *   different GUIDs on different operating systems).
   *)
  SDL_GUID = record
    data: array [0..15] of Uint8;
  end;

  PSDL_Joystick = Pointer;
  PPSDL_Joystick = ^PSDL_Joystick;
  SDL_JoystickGUID = SDL_GUID;
  (**
   * This is a unique ID for a joystick for the time it is connected to the system,
   * and is never reused for the lifetime of the application. If the joystick is
   * disconnected and reconnected, it will get a new ID.
   *
   * The ID value starts at 0 and increments from there. The value -1 is an invalid ID.
   *)
  SDL_JoystickID = Sint32;

  (**
   * The structure that defines an extended virtual joystick description
   *
   * The caller must zero the structure and then initialize the version with `SDL_VIRTUAL_JOYSTICK_DESC_VERSION` before passing it to SDL_JoystickAttachVirtualEx()
   *  All other elements of this structure are optional and can be left 0.
   *
   * \sa SDL_JoystickAttachVirtualEx
   *)
  SDL_VirtualJoystickDesc = record
    (** `SDL_VIRTUAL_JOYSTICK_DESC_VERSION` *)
    version: Uint16;
    (** `SDL_JoystickType` *)
    type_: Uint16;
    (** the number of axes on this joystick *)
    naxes: Uint16;
    (** the number of buttons on this joystick *)
    nbuttons: Uint16;
    (** the number of hats on this joystick *)
    nhats: Uint16;
    (** the USB vendor ID of this joystick *)
    vendor_id: Uint16;
    (** the USB product ID of this joystick *)
    product_id: Uint16;
    (** unused *)
    padding: Uint16;
    (** A mask of which buttons are valid for this controller
                                 e.g. (1 << SDL_CONTROLLER_BUTTON_A) *)
    button_mask: Uint32;
    (** A mask of which axes are valid for this controller
                                 e.g. (1 << SDL_CONTROLLER_AXIS_LEFTX) *)
    axis_mask: Uint32;
    (** the name of the joystick *)
    name: PUTF8Char;
    (** User data pointer passed to callbacks *)
    userdata: Pointer;
    (** Called when the joystick state should be updated *)
    Update: procedure(userdata: Pointer); cdecl;
    (** Called when the player index is set *)
    SetPlayerIndex: procedure(userdata: Pointer; player_index: Integer); cdecl;
    (** Implements SDL_JoystickRumble() *)
    Rumble: function(userdata: Pointer; low_frequency_rumble: Uint16; high_frequency_rumble: Uint16): Integer; cdecl;
    (** Implements SDL_JoystickRumbleTriggers() *)
    RumbleTriggers: function(userdata: Pointer; left_rumble: Uint16; right_rumble: Uint16): Integer; cdecl;
    (** Implements SDL_JoystickSetLED() *)
    SetLED: function(userdata: Pointer; red: Uint8; green: Uint8; blue: Uint8): Integer; cdecl;
    (** Implements SDL_JoystickSendEffect() *)
    SendEffect: function(userdata: Pointer; const data: Pointer; size: Integer): Integer; cdecl;
  end;

  PSDL_Sensor = Pointer;
  PPSDL_Sensor = ^PSDL_Sensor;
  (**
   * This is a unique ID for a sensor for the time it is connected to the system,
   * and is never reused for the lifetime of the application.
   *
   * The ID value starts at 0 and increments from there. The value -1 is an invalid ID.
   *)
  SDL_SensorID = Sint32;
  PSDL_GameController = Pointer;
  PPSDL_GameController = ^PSDL_GameController;

  _anonymous_type_7 = record
    hat: Integer;
    hat_mask: Integer;
  end;
  P_anonymous_type_7 = ^_anonymous_type_7;

  _anonymous_type_8 = record
    case Integer of
      0: (button: Integer);
      1: (axis: Integer);
      2: (hat: _anonymous_type_7);
  end;
  P_anonymous_type_8 = ^_anonymous_type_8;

  (**
   *  Get the SDL joystick layer binding for this controller button/axis mapping
   *)
  SDL_GameControllerButtonBind = record
    bindType: SDL_GameControllerBindType;
    value: _anonymous_type_8;
  end;

  SDL_TouchID = Sint64;
  SDL_FingerID = Sint64;

  SDL_Finger = record
    id: SDL_FingerID;
    x: Single;
    y: Single;
    pressure: Single;
  end;

  SDL_GestureID = Sint64;

  (**
   *  \brief Fields shared by every event
   *)
  SDL_CommonEvent = record
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
  end;

  (**
   *  \brief Display state change event data (event.display.* )
   *)
  SDL_DisplayEvent = record
    (** ::SDL_DISPLAYEVENT *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The associated display index *)
    display: Uint32;
    (** ::SDL_DisplayEventID *)
    event: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** event dependent data *)
    data1: Sint32;
  end;

  (**
   *  \brief Window state change event data (event.window.* )
   *)
  SDL_WindowEvent = record
    (** ::SDL_WINDOWEVENT *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The associated window *)
    windowID: Uint32;
    (** ::SDL_WindowEventID *)
    event: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** event dependent data *)
    data1: Sint32;
    (** event dependent data *)
    data2: Sint32;
  end;

  (**
   *  \brief Keyboard button event structure (event.key.* )
   *)
  SDL_KeyboardEvent = record
    (** ::SDL_KEYDOWN or ::SDL_KEYUP *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The window with keyboard focus, if any *)
    windowID: Uint32;
    (** ::SDL_PRESSED or ::SDL_RELEASED *)
    state: Uint8;
    (** Non-zero if this is a key repeat *)
    repeat_: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** The key that was pressed or released *)
    keysym: SDL_Keysym;
  end;

  (**
   *  \brief Keyboard text editing event structure (event.edit.* )
   *)
  SDL_TextEditingEvent = record
    (** ::SDL_TEXTEDITING *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The window with keyboard focus, if any *)
    windowID: Uint32;
    (** The editing text *)
    text: array [0..31] of UTF8Char;
    (** The start cursor of selected editing text *)
    start: Sint32;
    (** The length of selected editing text *)
    length: Sint32;
  end;

  (**
   *  \brief Extended keyboard text editing event structure (event.editExt.* ) when text would be
   *  truncated if stored in the text buffer SDL_TextEditingEvent
   *)
  SDL_TextEditingExtEvent = record
    (** ::SDL_TEXTEDITING_EXT *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The window with keyboard focus, if any *)
    windowID: Uint32;
    (** The editing text, which should be freed with SDL_free(), and will not be NULL *)
    text: PUTF8Char;
    (** The start cursor of selected editing text *)
    start: Sint32;
    (** The length of selected editing text *)
    length: Sint32;
  end;

  (**
   *  \brief Keyboard text input event structure (event.text.* )
   *)
  SDL_TextInputEvent = record
    (** ::SDL_TEXTINPUT *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The window with keyboard focus, if any *)
    windowID: Uint32;
    (** The input text *)
    text: array [0..31] of UTF8Char;
  end;

  (**
   *  \brief Mouse motion event structure (event.motion.* )
   *)
  SDL_MouseMotionEvent = record
    (** ::SDL_MOUSEMOTION *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The window with mouse focus, if any *)
    windowID: Uint32;
    (** The mouse instance id, or SDL_TOUCH_MOUSEID *)
    which: Uint32;
    (** The current button state *)
    state: Uint32;
    (** X coordinate, relative to window *)
    x: Sint32;
    (** Y coordinate, relative to window *)
    y: Sint32;
    (** The relative motion in the X direction *)
    xrel: Sint32;
    (** The relative motion in the Y direction *)
    yrel: Sint32;
  end;

  (**
   *  \brief Mouse button event structure (event.button.* )
   *)
  SDL_MouseButtonEvent = record
    (** ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The window with mouse focus, if any *)
    windowID: Uint32;
    (** The mouse instance id, or SDL_TOUCH_MOUSEID *)
    which: Uint32;
    (** The mouse button index *)
    button: Uint8;
    (** ::SDL_PRESSED or ::SDL_RELEASED *)
    state: Uint8;
    (** 1 for single-click, 2 for double-click, etc. *)
    clicks: Uint8;
    padding1: Uint8;
    (** X coordinate, relative to window *)
    x: Sint32;
    (** Y coordinate, relative to window *)
    y: Sint32;
  end;

  (**
   *  \brief Mouse wheel event structure (event.wheel.* )
   *)
  SDL_MouseWheelEvent = record
    (** ::SDL_MOUSEWHEEL *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The window with mouse focus, if any *)
    windowID: Uint32;
    (** The mouse instance id, or SDL_TOUCH_MOUSEID *)
    which: Uint32;
    (** The amount scrolled horizontally, positive to the right and negative to the left *)
    x: Sint32;
    (** The amount scrolled vertically, positive away from the user and negative toward the user *)
    y: Sint32;
    (** Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back *)
    direction: Uint32;
    (** The amount scrolled horizontally, positive to the right and negative to the left, with float precision (added in 2.0.18) *)
    preciseX: Single;
    (** The amount scrolled vertically, positive away from the user and negative toward the user, with float precision (added in 2.0.18) *)
    preciseY: Single;
  end;

  (**
   *  \brief Joystick axis motion event structure (event.jaxis.* )
   *)
  SDL_JoyAxisEvent = record
    (** ::SDL_JOYAXISMOTION *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick axis index *)
    axis: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** The axis value (range: -32768 to 32767) *)
    value: Sint16;
    padding4: Uint16;
  end;

  (**
   *  \brief Joystick trackball motion event structure (event.jball.* )
   *)
  SDL_JoyBallEvent = record
    (** ::SDL_JOYBALLMOTION *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick trackball index *)
    ball: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** The relative motion in the X direction *)
    xrel: Sint16;
    (** The relative motion in the Y direction *)
    yrel: Sint16;
  end;

  (**
   *  \brief Joystick hat position change event structure (event.jhat.* )
   *)
  SDL_JoyHatEvent = record
    (** ::SDL_JOYHATMOTION *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick hat index *)
    hat: Uint8;
    (** The hat position value.
     *   \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
     *   \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
     *   \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
     *
     *   Note that zero means the POV is centered.
     *)
    value: Uint8;
    padding1: Uint8;
    padding2: Uint8;
  end;

  (**
   *  \brief Joystick button event structure (event.jbutton.* )
   *)
  SDL_JoyButtonEvent = record
    (** ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick button index *)
    button: Uint8;
    (** ::SDL_PRESSED or ::SDL_RELEASED *)
    state: Uint8;
    padding1: Uint8;
    padding2: Uint8;
  end;

  (**
   *  \brief Joystick device event structure (event.jdevice.* )
   *)
  SDL_JoyDeviceEvent = record
    (** ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick device index for the ADDED event, instance id for the REMOVED event *)
    which: Sint32;
  end;

  (**
   *  \brief Joysick battery level change event structure (event.jbattery.* )
   *)
  SDL_JoyBatteryEvent = record
    (** ::SDL_JOYBATTERYUPDATED *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The joystick battery level *)
    level: SDL_JoystickPowerLevel;
  end;

  (**
   *  \brief Game controller axis motion event structure (event.caxis.* )
   *)
  SDL_ControllerAxisEvent = record
    (** ::SDL_CONTROLLERAXISMOTION *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The controller axis (SDL_GameControllerAxis) *)
    axis: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
    (** The axis value (range: -32768 to 32767) *)
    value: Sint16;
    padding4: Uint16;
  end;

  (**
   *  \brief Game controller button event structure (event.cbutton.* )
   *)
  SDL_ControllerButtonEvent = record
    (** ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The controller button (SDL_GameControllerButton) *)
    button: Uint8;
    (** ::SDL_PRESSED or ::SDL_RELEASED *)
    state: Uint8;
    padding1: Uint8;
    padding2: Uint8;
  end;

  (**
   *  \brief Controller device event structure (event.cdevice.* )
   *)
  SDL_ControllerDeviceEvent = record
    (** ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event *)
    which: Sint32;
  end;

  (**
   *  \brief Game controller touchpad event structure (event.ctouchpad.* )
   *)
  SDL_ControllerTouchpadEvent = record
    (** ::SDL_CONTROLLERTOUCHPADDOWN or ::SDL_CONTROLLERTOUCHPADMOTION or ::SDL_CONTROLLERTOUCHPADUP *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The index of the touchpad *)
    touchpad: Sint32;
    (** The index of the finger on the touchpad *)
    finger: Sint32;
    (** Normalized in the range 0...1 with 0 being on the left *)
    x: Single;
    (** Normalized in the range 0...1 with 0 being at the top *)
    y: Single;
    (** Normalized in the range 0...1 *)
    pressure: Single;
  end;

  (**
   *  \brief Game controller sensor event structure (event.csensor.* )
   *)
  SDL_ControllerSensorEvent = record
    (** ::SDL_CONTROLLERSENSORUPDATE *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The joystick instance id *)
    which: SDL_JoystickID;
    (** The type of the sensor, one of the values of ::SDL_SensorType *)
    sensor: Sint32;
    (** Up to 3 values from the sensor, as defined in SDL_sensor.h *)
    data: array [0..2] of Single;
  end;

  (**
   *  \brief Audio device event structure (event.adevice.* )
   *)
  SDL_AudioDeviceEvent = record
    (** ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event *)
    which: Uint32;
    (** zero if an output device, non-zero if a capture device. *)
    iscapture: Uint8;
    padding1: Uint8;
    padding2: Uint8;
    padding3: Uint8;
  end;

  (**
   *  \brief Touch finger event structure (event.tfinger.* )
   *)
  SDL_TouchFingerEvent = record
    (** ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The touch device id *)
    touchId: SDL_TouchID;
    fingerId: SDL_FingerID;
    (** Normalized in the range 0...1 *)
    x: Single;
    (** Normalized in the range 0...1 *)
    y: Single;
    (** Normalized in the range -1...1 *)
    dx: Single;
    (** Normalized in the range -1...1 *)
    dy: Single;
    (** Normalized in the range 0...1 *)
    pressure: Single;
    (** The window underneath the finger, if any *)
    windowID: Uint32;
  end;

  (**
   *  \brief Multiple Finger Gesture Event (event.mgesture.* )
   *)
  SDL_MultiGestureEvent = record
    (** ::SDL_MULTIGESTURE *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The touch device id *)
    touchId: SDL_TouchID;
    dTheta: Single;
    dDist: Single;
    x: Single;
    y: Single;
    numFingers: Uint16;
    padding: Uint16;
  end;

  (**
   * \brief Dollar Gesture Event (event.dgesture.* )
   *)
  SDL_DollarGestureEvent = record
    (** ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The touch device id *)
    touchId: SDL_TouchID;
    gestureId: SDL_GestureID;
    numFingers: Uint32;
    error: Single;
    (** Normalized center of gesture *)
    x: Single;
    (** Normalized center of gesture *)
    y: Single;
  end;

  (**
   *  \brief An event used to request a file open by the system (event.drop.* )
   *         This event is enabled by default, you can disable it with SDL_EventState().
   *  \note If this event is enabled, you must free the filename in the event.
   *)
  SDL_DropEvent = record
    (** ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The file name, which should be freed with SDL_free(), is NULL on begin/complete *)
    file_: PUTF8Char;
    (** The window that was dropped on, if any *)
    windowID: Uint32;
  end;

  (**
   *  \brief Sensor event structure (event.sensor.* )
   *)
  SDL_SensorEvent = record
    (** ::SDL_SENSORUPDATE *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The instance ID of the sensor *)
    which: Sint32;
    (** Up to 6 values from the sensor - additional values can be queried using SDL_SensorGetData() *)
    data: array [0..5] of Single;
  end;

  (**
   *  \brief The "quit requested" event
   *)
  SDL_QuitEvent = record
    (** ::SDL_QUIT *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
  end;

  (**
   *  \brief OS Specific event
   *)
  SDL_OSEvent = record
    (** ::SDL_QUIT *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
  end;

  (**
   *  \brief A user-defined event type (event.user.* )
   *)
  SDL_UserEvent = record
    (** ::SDL_USEREVENT through ::SDL_LASTEVENT-1 *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** The associated window if any *)
    windowID: Uint32;
    (** User defined event code *)
    code: Sint32;
    (** User defined data pointer *)
    data1: Pointer;
    (** User defined data pointer *)
    data2: Pointer;
  end;

  PSDL_SysWMmsg = Pointer;
  PPSDL_SysWMmsg = ^PSDL_SysWMmsg;

  (**
   *  \brief A video driver dependent system event (event.syswm.* )
   *         This event is disabled by default, you can enable it with SDL_EventState()
   *
   *  \note If you want to use this event, you should include SDL_syswm.h.
   *)
  SDL_SysWMEvent = record
    (** ::SDL_SYSWMEVENT *)
    type_: Uint32;
    (** In milliseconds, populated using SDL_GetTicks() *)
    timestamp: Uint32;
    (** driver dependent data, defined in SDL_syswm.h *)
    msg: PSDL_SysWMmsg;
  end;

  (**
   *  \brief General event structure
   *)
  PSDL_Event = ^SDL_Event;
  SDL_Event = record
    case Integer of
    (** Event type, shared with all events *)
      0: (type_: Uint32);
    (** Common event data *)
      1: (common: SDL_CommonEvent);
    (** Display event data *)
      2: (display: SDL_DisplayEvent);
    (** Window event data *)
      3: (window: SDL_WindowEvent);
    (** Keyboard event data *)
      4: (key: SDL_KeyboardEvent);
    (** Text editing event data *)
      5: (edit: SDL_TextEditingEvent);
    (** Extended text editing event data *)
      6: (editExt: SDL_TextEditingExtEvent);
    (** Text input event data *)
      7: (text: SDL_TextInputEvent);
    (** Mouse motion event data *)
      8: (motion: SDL_MouseMotionEvent);
    (** Mouse button event data *)
      9: (button: SDL_MouseButtonEvent);
    (** Mouse wheel event data *)
      10: (wheel: SDL_MouseWheelEvent);
    (** Joystick axis event data *)
      11: (jaxis: SDL_JoyAxisEvent);
    (** Joystick ball event data *)
      12: (jball: SDL_JoyBallEvent);
    (** Joystick hat event data *)
      13: (jhat: SDL_JoyHatEvent);
    (** Joystick button event data *)
      14: (jbutton: SDL_JoyButtonEvent);
    (** Joystick device change event data *)
      15: (jdevice: SDL_JoyDeviceEvent);
    (** Joystick battery event data *)
      16: (jbattery: SDL_JoyBatteryEvent);
    (** Game Controller axis event data *)
      17: (caxis: SDL_ControllerAxisEvent);
    (** Game Controller button event data *)
      18: (cbutton: SDL_ControllerButtonEvent);
    (** Game Controller device event data *)
      19: (cdevice: SDL_ControllerDeviceEvent);
    (** Game Controller touchpad event data *)
      20: (ctouchpad: SDL_ControllerTouchpadEvent);
    (** Game Controller sensor event data *)
      21: (csensor: SDL_ControllerSensorEvent);
    (** Audio device event data *)
      22: (adevice: SDL_AudioDeviceEvent);
    (** Sensor event data *)
      23: (sensor: SDL_SensorEvent);
    (** Quit request event data *)
      24: (quit: SDL_QuitEvent);
    (** Custom event data *)
      25: (user: SDL_UserEvent);
    (** System dependent window event data *)
      26: (syswm: SDL_SysWMEvent);
    (** Touch finger event data *)
      27: (tfinger: SDL_TouchFingerEvent);
    (** Gesture event data *)
      28: (mgesture: SDL_MultiGestureEvent);
    (** Gesture event data *)
      29: (dgesture: SDL_DollarGestureEvent);
    (** Drag and drop event data *)
      30: (drop: SDL_DropEvent);
      31: (padding: array [0..55] of Uint8);
  end;

  (**
   * A function pointer used for callbacks that watch the event queue.
   *
   * \param userdata what was passed as `userdata` to SDL_SetEventFilter()
   *        or SDL_AddEventWatch, etc
   * \param event the event that triggered the callback
   * \returns 1 to permit event to be added to the queue, and 0 to disallow
   *          it. When used with SDL_AddEventWatch, the return value is ignored.
   *
   * \sa SDL_SetEventFilter
   * \sa SDL_AddEventWatch
   *)
  SDL_EventFilter = function(userdata: Pointer; event: PSDL_Event): Integer; cdecl;
  PSDL_EventFilter = ^SDL_EventFilter;
  PSDL_Haptic = Pointer;
  PPSDL_Haptic = ^PSDL_Haptic;

  (**
   *  \brief Structure that represents a haptic direction.
   *
   *  This is the direction where the force comes from,
   *  instead of the direction in which the force is exerted.
   *
   *  Directions can be specified by:
   *   - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.
   *   - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
   *   - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
   *
   *  Cardinal directions of the haptic device are relative to the positioning
   *  of the device.  North is considered to be away from the user.
   *
   *  The following diagram represents the cardinal directions:
   *  \verbatim
                   .--.
                   |__| .-------.
                   |=.| |.-----.|
                   |--| ||     ||
                   |  | |'-----'|
                   |__|~')_____('
                     [ COMPUTER ]


                       North (0,-1)
                           ^
                           |
                           |
     (-1,0)  West <----[ HAPTIC ]----> East (1,0)
                           |
                           |
                           v
                        South (0,1)


                        [ USER ]
                          \|||/
                          (o o)
                    ---ooO-(_)-Ooo---
      \endverbatim
   *
   *  If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a
   *  degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses
   *  the first \c dir parameter.  The cardinal directions would be:
   *   - North: 0 (0 degrees)
   *   - East: 9000 (90 degrees)
   *   - South: 18000 (180 degrees)
   *   - West: 27000 (270 degrees)
   *
   *  If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
   *  (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses
   *  the first three \c dir parameters.  The cardinal directions would be:
   *   - North:  0,-1, 0
   *   - East:   1, 0, 0
   *   - South:  0, 1, 0
   *   - West:  -1, 0, 0
   *
   *  The Z axis represents the height of the effect if supported, otherwise
   *  it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you
   *  can use any multiple you want, only the direction matters.
   *
   *  If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
   *  The first two \c dir parameters are used.  The \c dir parameters are as
   *  follows (all values are in hundredths of degrees):
   *   - Degrees from (1, 0) rotated towards (0, 1).
   *   - Degrees towards (0, 0, 1) (device needs at least 3 axes).
   *
   *
   *  Example of force coming from the south with all encodings (force coming
   *  from the south means the user will have to pull the stick to counteract):
   *  \code
   *  SDL_HapticDirection direction;
   *
   *  // Cartesian directions
   *  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
   *  direction.dir[0] = 0; // X position
   *  direction.dir[1] = 1; // Y position
   *  // Assuming the device has 2 axes, we don't need to specify third parameter.
   *
   *  // Polar directions
   *  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
   *  direction.dir[0] = 18000; // Polar only uses first parameter
   *
   *  // Spherical coordinates
   *  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
   *  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
   *  \endcode
   *
   *  \sa SDL_HAPTIC_POLAR
   *  \sa SDL_HAPTIC_CARTESIAN
   *  \sa SDL_HAPTIC_SPHERICAL
   *  \sa SDL_HAPTIC_STEERING_AXIS
   *  \sa SDL_HapticEffect
   *  \sa SDL_HapticNumAxes
   *)
  SDL_HapticDirection = record
    (** The type of encoding. *)
    type_: Uint8;
    (** The encoded direction. *)
    dir: array [0..2] of Sint32;
  end;

  (**
   *  \brief A structure containing a template for a Constant effect.
   *
   *  This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.
   *
   *  A constant effect applies a constant force in the specified direction
   *  to the joystick.
   *
   *  \sa SDL_HAPTIC_CONSTANT
   *  \sa SDL_HapticEffect
   *)
  SDL_HapticConstant = record
    (** ::SDL_HAPTIC_CONSTANT *)
    type_: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Strength of the constant effect. *)
    level: Sint16;
    (** Duration of the attack. *)
    attack_length: Uint16;
    (** Level at the start of the attack. *)
    attack_level: Uint16;
    (** Duration of the fade. *)
    fade_length: Uint16;
    (** Level at the end of the fade. *)
    fade_level: Uint16;
  end;

  (**
   *  \brief A structure containing a template for a Periodic effect.
   *
   *  The struct handles the following effects:
   *   - ::SDL_HAPTIC_SINE
   *   - ::SDL_HAPTIC_LEFTRIGHT
   *   - ::SDL_HAPTIC_TRIANGLE
   *   - ::SDL_HAPTIC_SAWTOOTHUP
   *   - ::SDL_HAPTIC_SAWTOOTHDOWN
   *
   *  A periodic effect consists in a wave-shaped effect that repeats itself
   *  over time.  The type determines the shape of the wave and the parameters
   *  determine the dimensions of the wave.
   *
   *  Phase is given by hundredth of a degree meaning that giving the phase a value
   *  of 9000 will displace it 25% of its period.  Here are sample values:
   *   -     0: No phase displacement.
   *   -  9000: Displaced 25% of its period.
   *   - 18000: Displaced 50% of its period.
   *   - 27000: Displaced 75% of its period.
   *   - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.
   *
   *  Examples:
   *  \verbatim
      SDL_HAPTIC_SINE
        __      __      __      __
       /  \    /  \    /  \    /
      /    \__/    \__/    \__/

      SDL_HAPTIC_SQUARE
       __    __    __    __    __
      |  |  |  |  |  |  |  |  |  |
      |  |__|  |__|  |__|  |__|  |

      SDL_HAPTIC_TRIANGLE
        /\    /\    /\    /\    /\
       /  \  /  \  /  \  /  \  /
      /    \/    \/    \/    \/

      SDL_HAPTIC_SAWTOOTHUP
        /|  /|  /|  /|  /|  /|  /|
       / | / | / | / | / | / | / |
      /  |/  |/  |/  |/  |/  |/  |

      SDL_HAPTIC_SAWTOOTHDOWN
      \  |\  |\  |\  |\  |\  |\  |
       \ | \ | \ | \ | \ | \ | \ |
        \|  \|  \|  \|  \|  \|  \|
      \endverbatim
   *
   *  \sa SDL_HAPTIC_SINE
   *  \sa SDL_HAPTIC_LEFTRIGHT
   *  \sa SDL_HAPTIC_TRIANGLE
   *  \sa SDL_HAPTIC_SAWTOOTHUP
   *  \sa SDL_HAPTIC_SAWTOOTHDOWN
   *  \sa SDL_HapticEffect
   *)
  PSDL_HapticPeriodic = ^SDL_HapticPeriodic;
  SDL_HapticPeriodic = record
    (** ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,
                                 ::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or
                                 ::SDL_HAPTIC_SAWTOOTHDOWN *)
    type_: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Period of the wave. *)
    period: Uint16;
    (** Peak value; if negative, equivalent to 180 degrees extra phase shift. *)
    magnitude: Sint16;
    (** Mean value of the wave. *)
    offset: Sint16;
    (** Positive phase shift given by hundredth of a degree. *)
    phase: Uint16;
    (** Duration of the attack. *)
    attack_length: Uint16;
    (** Level at the start of the attack. *)
    attack_level: Uint16;
    (** Duration of the fade. *)
    fade_length: Uint16;
    (** Level at the end of the fade. *)
    fade_level: Uint16;
  end;

  (**
   *  \brief A structure containing a template for a Condition effect.
   *
   *  The struct handles the following effects:
   *   - ::SDL_HAPTIC_SPRING: Effect based on axes position.
   *   - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.
   *   - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
   *   - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.
   *
   *  Direction is handled by condition internals instead of a direction member.
   *  The condition effect specific members have three parameters.  The first
   *  refers to the X axis, the second refers to the Y axis and the third
   *  refers to the Z axis.  The right terms refer to the positive side of the
   *  axis and the left terms refer to the negative side of the axis.  Please
   *  refer to the ::SDL_HapticDirection diagram for which side is positive and
   *  which is negative.
   *
   *  \sa SDL_HapticDirection
   *  \sa SDL_HAPTIC_SPRING
   *  \sa SDL_HAPTIC_DAMPER
   *  \sa SDL_HAPTIC_INERTIA
   *  \sa SDL_HAPTIC_FRICTION
   *  \sa SDL_HapticEffect
   *)
  SDL_HapticCondition = record
    (** ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,
                                     ::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION *)
    type_: Uint16;
    (** Direction of the effect - Not used ATM. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Level when joystick is to the positive side; max 0xFFFF. *)
    right_sat: array [0..2] of Uint16;
    (** Level when joystick is to the negative side; max 0xFFFF. *)
    left_sat: array [0..2] of Uint16;
    (** How fast to increase the force towards the positive side. *)
    right_coeff: array [0..2] of Sint16;
    (** How fast to increase the force towards the negative side. *)
    left_coeff: array [0..2] of Sint16;
    (** Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered. *)
    deadband: array [0..2] of Uint16;
    (** Position of the dead zone. *)
    center: array [0..2] of Sint16;
  end;

  (**
   *  \brief A structure containing a template for a Ramp effect.
   *
   *  This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.
   *
   *  The ramp effect starts at start strength and ends at end strength.
   *  It augments in linear fashion.  If you use attack and fade with a ramp
   *  the effects get added to the ramp effect making the effect become
   *  quadratic instead of linear.
   *
   *  \sa SDL_HAPTIC_RAMP
   *  \sa SDL_HapticEffect
   *)
  SDL_HapticRamp = record
    (** ::SDL_HAPTIC_RAMP *)
    type_: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Beginning strength level. *)
    start: Sint16;
    (** Ending strength level. *)
    end_: Sint16;
    (** Duration of the attack. *)
    attack_length: Uint16;
    (** Level at the start of the attack. *)
    attack_level: Uint16;
    (** Duration of the fade. *)
    fade_length: Uint16;
    (** Level at the end of the fade. *)
    fade_level: Uint16;
  end;

  (**
   * \brief A structure containing a template for a Left/Right effect.
   *
   * This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.
   *
   * The Left/Right effect is used to explicitly control the large and small
   * motors, commonly found in modern game controllers. The small (right) motor
   * is high frequency, and the large (left) motor is low frequency.
   *
   * \sa SDL_HAPTIC_LEFTRIGHT
   * \sa SDL_HapticEffect
   *)
  SDL_HapticLeftRight = record
    (** ::SDL_HAPTIC_LEFTRIGHT *)
    type_: Uint16;
    (** Duration of the effect in milliseconds. *)
    length: Uint32;
    (** Control of the large controller motor. *)
    large_magnitude: Uint16;
    (** Control of the small controller motor. *)
    small_magnitude: Uint16;
  end;

  (**
   *  \brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.
   *
   *  This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.
   *
   *  A custom force feedback effect is much like a periodic effect, where the
   *  application can define its exact shape.  You will have to allocate the
   *  data yourself.  Data should consist of channels * samples Uint16 samples.
   *
   *  If channels is one, the effect is rotated using the defined direction.
   *  Otherwise it uses the samples in data for the different axes.
   *
   *  \sa SDL_HAPTIC_CUSTOM
   *  \sa SDL_HapticEffect
   *)
  SDL_HapticCustom = record
    (** ::SDL_HAPTIC_CUSTOM *)
    type_: Uint16;
    (** Direction of the effect. *)
    direction: SDL_HapticDirection;
    (** Duration of the effect. *)
    length: Uint32;
    (** Delay before starting the effect. *)
    delay: Uint16;
    (** Button that triggers the effect. *)
    button: Uint16;
    (** How soon it can be triggered again after button. *)
    interval: Uint16;
    (** Axes to use, minimum of one. *)
    channels: Uint8;
    (** Sample periods. *)
    period: Uint16;
    (** Amount of samples. *)
    samples: Uint16;
    (** Should contain channels*samples items. *)
    data: PUint16;
    (** Duration of the attack. *)
    attack_length: Uint16;
    (** Level at the start of the attack. *)
    attack_level: Uint16;
    (** Duration of the fade. *)
    fade_length: Uint16;
    (** Level at the end of the fade. *)
    fade_level: Uint16;
  end;

  (**
   *  \brief The generic template for any haptic effect.
   *
   *  All values max at 32767 (0x7FFF).  Signed values also can be negative.
   *  Time values unless specified otherwise are in milliseconds.
   *
   *  You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767
   *  value.  Neither delay, interval, attack_length nor fade_length support
   *  ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.
   *
   *  Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of
   *  ::SDL_HAPTIC_INFINITY.
   *
   *  Button triggers may not be supported on all devices, it is advised to not
   *  use them if possible.  Buttons start at index 1 instead of index 0 like
   *  the joystick.
   *
   *  If both attack_length and fade_level are 0, the envelope is not used,
   *  otherwise both values are used.
   *
   *  Common parts:
   *  \code
   *  // Replay - All effects have this
   *  Uint32 length;        // Duration of effect (ms).
   *  Uint16 delay;         // Delay before starting effect.
   *
   *  // Trigger - All effects have this
   *  Uint16 button;        // Button that triggers effect.
   *  Uint16 interval;      // How soon before effect can be triggered again.
   *
   *  // Envelope - All effects except condition effects have this
   *  Uint16 attack_length; // Duration of the attack (ms).
   *  Uint16 attack_level;  // Level at the start of the attack.
   *  Uint16 fade_length;   // Duration of the fade out (ms).
   *  Uint16 fade_level;    // Level at the end of the fade.
   *  \endcode
   *
   *
   *  Here we have an example of a constant effect evolution in time:
   *  \verbatim
      Strength
      ^
      |
      |    effect level -->  _________________
      |                     /                 \
      |                    /                   \
      |                   /                     \
      |                  /                       \
      | attack_level --> |                        \
      |                  |                        |  <---  fade_level
      |
      +--------------------------------------------------> Time
                         [--]                 [---]
                         attack_length        fade_length

      [------------------][-----------------------]
      delay               length
      \endverbatim
   *
   *  Note either the attack_level or the fade_level may be above the actual
   *  effect level.
   *
   *  \sa SDL_HapticConstant
   *  \sa SDL_HapticPeriodic
   *  \sa SDL_HapticCondition
   *  \sa SDL_HapticRamp
   *  \sa SDL_HapticLeftRight
   *  \sa SDL_HapticCustom
   *)
  PSDL_HapticEffect = ^SDL_HapticEffect;
  SDL_HapticEffect = record
    case Integer of
    (** Effect type. *)
      0: (type_: Uint16);
    (** Constant effect. *)
      1: (constant: SDL_HapticConstant);
    (** Periodic effect. *)
      2: (periodic: SDL_HapticPeriodic);
    (** Condition effect. *)
      3: (condition: SDL_HapticCondition);
    (** Ramp effect. *)
      4: (ramp: SDL_HapticRamp);
    (** Left/Right effect. *)
      5: (leftright: SDL_HapticLeftRight);
    (** Custom effect. *)
      6: (custom: SDL_HapticCustom);
  end;

  PSDL_hid_device = Pointer;
  PPSDL_hid_device = ^PSDL_hid_device;

  (** hidapi info structure */
  (**
   *  \brief  Information about a connected HID device
   *)
  SDL_hid_device_info = record
    (** Platform-specific device path *)
    path: PUTF8Char;
    (** Device Vendor ID *)
    vendor_id: Word;
    (** Device Product ID *)
    product_id: Word;
    (** Serial Number *)
    serial_number: PWideChar;
    (** Device Release Number in binary-coded decimal,
            also known as Device Version Number *)
    release_number: Word;
    (** Manufacturer String *)
    manufacturer_string: PWideChar;
    (** Product string *)
    product_string: PWideChar;
    (** Usage Page for this Device/Interface
            (Windows/Mac only). *)
    usage_page: Word;
    (** Usage for this Device/Interface
            (Windows/Mac only).*)
    usage: Word;
    (** The USB interface which this logical device
            represents.

     * Valid on both Linux implementations in all cases.
     * Valid on the Windows implementation only if the device
              contains more than one interface. *)
    interface_number: Integer;
    (** Additional information about the USB interface.
            Valid on libusb and Android implementations. *)
    interface_class: Integer;
    interface_subclass: Integer;
    interface_protocol: Integer;
    (** Pointer to the next device *)
    next: PSDL_hid_device_info;
  end;

  (**
   * Type definition of the hint callback function.
   *
   * \param userdata what was passed as `userdata` to SDL_AddHintCallback()
   * \param name what was passed as `name` to SDL_AddHintCallback()
   * \param oldValue the previous hint value
   * \param newValue the new value hint is to be set to
   *)
  SDL_HintCallback = procedure(userdata: Pointer; const name: PUTF8Char; const oldValue: PUTF8Char; const newValue: PUTF8Char); cdecl;

  (**
   * The prototype for the log output callback function.
   *
   * This function is called by SDL when there is new text to be logged.
   *
   * \param userdata what was passed as `userdata` to SDL_LogSetOutputFunction()
   * \param category the category of the message
   * \param priority the priority of the message
   * \param message the message being output
   *)
  SDL_LogOutputFunction = procedure(userdata: Pointer; category: Integer; priority: SDL_LogPriority; const message_: PUTF8Char); cdecl;
  PSDL_LogOutputFunction = ^SDL_LogOutputFunction;

  (**
   * Individual button data.
   *)
  SDL_MessageBoxButtonData = record
    (** ::SDL_MessageBoxButtonFlags *)
    flags: Uint32;
    (** User defined button id (value returned via SDL_ShowMessageBox) *)
    buttonid: Integer;
    (** The UTF-8 button text *)
    text: PUTF8Char;
  end;

  (**
   * RGB value used in a message box color scheme
   *)
  SDL_MessageBoxColor = record
    r: Uint8;
    g: Uint8;
    b: Uint8;
  end;

  (**
   * A set of colors to use for message box dialogs
   *)
  SDL_MessageBoxColorScheme = record
    colors: array [0..4] of SDL_MessageBoxColor;
  end;

  (**
   * MessageBox structure containing title, text, window, etc.
   *)
  SDL_MessageBoxData = record
    (** ::SDL_MessageBoxFlags *)
    flags: Uint32;
    (** Parent window, can be NULL *)
    window: PSDL_Window;
    (** UTF-8 title *)
    title: PUTF8Char;
    (** UTF-8 message text *)
    message_: PUTF8Char;
    numbuttons: Integer;
    buttons: PSDL_MessageBoxButtonData;
    (** ::SDL_MessageBoxColorScheme, can be NULL to use system settings *)
    colorScheme: PSDL_MessageBoxColorScheme;
  end;

  (**
   *  \brief A handle to a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS).
   *
   *  \note This can be cast directly to an NSView or UIView.
   *)
  SDL_MetalView = Pointer;

  (**
   * Information on the capabilities of a render driver or context.
   *)
  SDL_RendererInfo = record
    (** The name of the renderer *)
    name: PUTF8Char;
    (** Supported ::SDL_RendererFlags *)
    flags: Uint32;
    (** The number of available texture formats *)
    num_texture_formats: Uint32;
    (** The available texture formats *)
    texture_formats: array [0..15] of Uint32;
    (** The maximum texture width *)
    max_texture_width: Integer;
    (** The maximum texture height *)
    max_texture_height: Integer;
  end;

  (**
   *  Vertex structure
   *)
  SDL_Vertex = record
    (** Vertex position, in SDL_Renderer coordinates  *)
    position: SDL_FPoint;
    (** Vertex color *)
    color: SDL_Color;
    (** Normalized texture coordinates, if needed *)
    tex_coord: SDL_FPoint;
  end;

  PSDL_Renderer = Pointer;
  PPSDL_Renderer = ^PSDL_Renderer;
  PSDL_Texture = Pointer;
  PPSDL_Texture = ^PSDL_Texture;

  (** \brief A union containing parameters for shaped windows. *)
  SDL_WindowShapeParams = record
    case Integer of
    (** \brief A cutoff alpha value for binarization of the window shape's alpha channel. *)
      0: (binarizationCutoff: Uint8);
      1: (colorKey: SDL_Color);
  end;

  (** \brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents. *)
  SDL_WindowShapeMode = record
    (** \brief The mode of these window-shape parameters. *)
    mode: WindowShapeMode;
    (** \brief Window-shape parameters. *)
    parameters: SDL_WindowShapeParams;
  end;

  SDL_WindowsMessageHook = procedure(userdata: Pointer; hWnd: Pointer; message_: Cardinal; wParam: Uint64; lParam: Sint64); cdecl;
  PIDirect3DDevice9 = Pointer;
  PPIDirect3DDevice9 = ^PIDirect3DDevice9;
  PID3D11Device = Pointer;
  PPID3D11Device = ^PID3D11Device;
  PID3D12Device = Pointer;
  PPID3D12Device = ^PID3D12Device;

  (**
   * Function prototype for the timer callback function.
   *
   * The callback function is passed the current timer interval and returns
   * the next timer interval. If the returned value is the same as the one
   * passed in, the periodic alarm continues, otherwise a new alarm is
   * scheduled. If the callback returns 0, the periodic alarm is cancelled.
   *)
  SDL_TimerCallback = function(interval: Uint32; param: Pointer): Uint32; cdecl;
  (**
   * Definition of the timer ID type.
   *)
  SDL_TimerID = Integer;

  (**
   * Information about the version of SDL in use.
   *
   * Represents the library's version as three levels: major revision
   * (increments with massive changes, additions, and enhancements),
   * minor revision (increments with backwards-compatible changes to the
   * major revision), and patchlevel (increments with fixes to the minor
   * revision).
   *
   * \sa SDL_VERSION
   * \sa SDL_GetVersion
   *)
  SDL_version = record
    (** major version *)
    major: Uint8;
    (** minor version *)
    minor: Uint8;
    (** update version *)
    patch: Uint8;
  end;

  SDL_Locale = record
    (** A language name, like "en" for English. *)
    language: PUTF8Char;
    (** A country, like "US" for America. Can be NULL. *)
    country: PUTF8Char;
  end;

  (**
   * Animated image support
   * Currently only animated GIFs are supported.
   *)
  IMG_Animation = record
    w: Integer;
    h: Integer;
    count: Integer;
    frames: PPSDL_Surface;
    delays: PInteger;
  end;

  (**
   * The internal format for an audio chunk
   *)
  Mix_Chunk = record
    allocated: Integer;
    abuf: PUint8;
    alen: Uint32;
    volume: Uint8;
  end;

  PMix_Music = Pointer;
  PPMix_Music = ^PMix_Music;

  (**
   * This is the format of a special effect callback:
   *
   *   myeffect(int chan, void *stream, int len, void *udata);
   *
   * (chan) is the channel number that your effect is affecting. (stream) is
   *  the buffer of data to work upon. (len) is the size of (stream), and
   *  (udata) is a user-defined bit of data, which you pass as the last arg of
   *  Mix_RegisterEffect(), and is passed back unmolested to your callback.
   *  Your effect changes the contents of (stream) based on whatever parameters
   *  are significant, or just leaves it be, if you prefer. You can do whatever
   *  you like to the buffer, though, and it will continue in its changed state
   *  down the mixing pipeline, through any other effect functions, then finally
   *  to be mixed with the rest of the channels and music for the final output
   *  stream.
   *
   * DO NOT EVER call SDL_LockAudio() from your callback function!
   *)
  Mix_EffectFunc_t = procedure(chan: Integer; stream: Pointer; len: Integer; udata: Pointer); cdecl;

  (**
   * This is a callback that signifies that a channel has finished all its
   *  loops and has completed playback. This gets called if the buffer
   *  plays out normally, or if you call Mix_HaltChannel(), implicitly stop
   *  a channel via Mix_AllocateChannels(), or unregister a callback while
   *  it's still playing.
   *
   * DO NOT EVER call SDL_LockAudio() from your callback function!
   *)
  Mix_EffectDone_t = procedure(chan: Integer; udata: Pointer); cdecl;
  SDLNet_version = SDL_version;
  PSDLNet_version = ^SDLNet_version;

  IPaddress = record
    host: Uint32;
    port: Uint16;
  end;

  TCPsocket = Pointer;
  PTCPsocket = ^TCPsocket;
  UDPsocket = Pointer;
  PUDPsocket = ^UDPsocket;

  UDPpacket = record
    channel: Integer;
    data: PUint8;
    len: Integer;
    maxlen: Integer;
    status: Integer;
    address: IPaddress;
  end;

  SDLNet_SocketSet = Pointer;
  PSDLNet_SocketSet = ^SDLNet_SocketSet;

  _SDLNet_GenericSocket = record
    ready: Integer;
  end;

  SDLNet_GenericSocket = P_SDLNet_GenericSocket;
  PTTF_Font = Pointer;
  PPTTF_Font = ^PTTF_Font;
  nk_char = Int8;
  nk_uchar = UInt8;
  nk_byte = UInt8;
  Pnk_byte = ^nk_byte;
  nk_short = Int16;
  nk_ushort = UInt16;
  nk_int = Int32;
  nk_uint = UInt32;
  Pnk_uint = ^nk_uint;
  nk_size = UIntPtr;
  Pnk_size = ^nk_size;
  nk_ptr = UIntPtr;
  nk_bool = Integer;
  Pnk_bool = ^nk_bool;
  nk_hash = nk_uint;
  nk_flags = nk_uint;
  Pnk_flags = ^nk_flags;
  nk_rune = nk_uint;
  Pnk_rune = ^nk_rune;
  _dummy_array0 = array [0..0] of UTF8Char;
  _dummy_array1 = array [0..0] of UTF8Char;
  _dummy_array2 = array [0..0] of UTF8Char;
  _dummy_array3 = array [0..0] of UTF8Char;
  _dummy_array4 = array [0..0] of UTF8Char;
  _dummy_array5 = array [0..0] of UTF8Char;
  _dummy_array6 = array [0..0] of UTF8Char;
  _dummy_array7 = array [0..0] of UTF8Char;
  _dummy_array8 = array [0..0] of UTF8Char;
  _dummy_array9 = array [0..0] of UTF8Char;

  nk_color = record
    r: nk_byte;
    g: nk_byte;
    b: nk_byte;
    a: nk_byte;
  end;

  nk_colorf = record
    r: Single;
    g: Single;
    b: Single;
    a: Single;
  end;

  nk_vec2 = record
    x: Single;
    y: Single;
  end;

  nk_vec2i = record
    x: Smallint;
    y: Smallint;
  end;

  nk_rect = record
    x: Single;
    y: Single;
    w: Single;
    h: Single;
  end;

  nk_recti = record
    x: Smallint;
    y: Smallint;
    w: Smallint;
    h: Smallint;
  end;

  nk_glyph = array [0..3] of UTF8Char;

  nk_handle = record
    case Integer of
      0: (ptr: Pointer);
      1: (id: Integer);
  end;

  nk_image = record
    handle: nk_handle;
    w: nk_ushort;
    h: nk_ushort;
    region: array [0..3] of nk_ushort;
  end;

  nk_nine_slice = record
    img: nk_image;
    l: nk_ushort;
    t: nk_ushort;
    r: nk_ushort;
    b: nk_ushort;
  end;

  nk_cursor = record
    img: nk_image;
    size: nk_vec2;
    offset: nk_vec2;
  end;

  nk_scroll = record
    x: nk_uint;
    y: nk_uint;
  end;

  nk_plugin_alloc = function(p1: nk_handle; old: Pointer; p3: nk_size): Pointer; cdecl;

  nk_plugin_free = procedure(p1: nk_handle; old: Pointer); cdecl;

  nk_plugin_filter = function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  nk_plugin_paste = procedure(p1: nk_handle; p2: Pnk_text_edit); cdecl;

  nk_plugin_copy = procedure(p1: nk_handle; const p2: PUTF8Char; len: Integer); cdecl;

  nk_allocator = record
    userdata: nk_handle;
    alloc: nk_plugin_alloc;
    free: nk_plugin_free;
  end;

  nk_draw_null_texture = record
    texture: nk_handle;
    uv: nk_vec2;
  end;

  nk_convert_config = record
    global_alpha: Single;
    line_AA: nk_anti_aliasing;
    shape_AA: nk_anti_aliasing;
    circle_segment_count: Cardinal;
    arc_segment_count: Cardinal;
    curve_segment_count: Cardinal;
    null: nk_draw_null_texture;
    vertex_layout: Pnk_draw_vertex_layout_element;
    vertex_size: nk_size;
    vertex_alignment: nk_size;
  end;

  nk_list_view = record
    begin_: Integer;
    end_: Integer;
    count: Integer;
    total_height: Integer;
    ctx: Pnk_context;
    scroll_pointer: Pnk_uint;
    scroll_value: nk_uint;
  end;

  nk_text_width_f = function(p1: nk_handle; h: Single; const p3: PUTF8Char; len: Integer): Single; cdecl;

  nk_query_font_glyph_f = procedure(handle: nk_handle; font_height: Single; glyph: Pnk_user_font_glyph; codepoint: nk_rune; next_codepoint: nk_rune); cdecl;

  nk_user_font_glyph = record
    uv: array [0..1] of nk_vec2;
    offset: nk_vec2;
    width: Single;
    height: Single;
    xadvance: Single;
  end;

  nk_user_font = record
    userdata: nk_handle;
    height: Single;
    width: nk_text_width_f;
    query: nk_query_font_glyph_f;
    texture: nk_handle;
  end;

  nk_baked_font = record
    height: Single;
    ascent: Single;
    descent: Single;
    glyph_offset: nk_rune;
    glyph_count: nk_rune;
    ranges: Pnk_rune;
  end;

  nk_font_config = record
    next: Pnk_font_config;
    ttf_blob: Pointer;
    ttf_size: nk_size;
    ttf_data_owned_by_atlas: Byte;
    merge_mode: Byte;
    pixel_snap: Byte;
    oversample_v: Byte;
    oversample_h: Byte;
    padding: array [0..2] of Byte;
    size: Single;
    coord_type: nk_font_coord_type;
    spacing: nk_vec2;
    range: Pnk_rune;
    font: Pnk_baked_font;
    fallback_glyph: nk_rune;
    n: Pnk_font_config;
    p: Pnk_font_config;
  end;

  nk_font_glyph = record
    codepoint: nk_rune;
    xadvance: Single;
    x0: Single;
    y0: Single;
    x1: Single;
    y1: Single;
    w: Single;
    h: Single;
    u0: Single;
    v0: Single;
    u1: Single;
    v1: Single;
  end;

  nk_font = record
    next: Pnk_font;
    handle: nk_user_font;
    info: nk_baked_font;
    scale: Single;
    glyphs: Pnk_font_glyph;
    fallback: Pnk_font_glyph;
    fallback_codepoint: nk_rune;
    texture: nk_handle;
    config: Pnk_font_config;
  end;

  nk_font_atlas = record
    pixel: Pointer;
    tex_width: Integer;
    tex_height: Integer;
    permanent: nk_allocator;
    temporary: nk_allocator;
    custom: nk_recti;
    cursors: array [0..6] of nk_cursor;
    glyph_count: Integer;
    glyphs: Pnk_font_glyph;
    default_font: Pnk_font;
    fonts: Pnk_font;
    config: Pnk_font_config;
    font_num: Integer;
  end;

  nk_memory_status = record
    memory: Pointer;
    type_: Cardinal;
    size: nk_size;
    allocated: nk_size;
    needed: nk_size;
    calls: nk_size;
  end;

  nk_buffer_marker = record
    active: nk_bool;
    offset: nk_size;
  end;

  nk_memory = record
    ptr: Pointer;
    size: nk_size;
  end;

  nk_buffer = record
    marker: array [0..1] of nk_buffer_marker;
    pool: nk_allocator;
    type_: nk_allocation_type;
    memory: nk_memory;
    grow_factor: Single;
    allocated: nk_size;
    needed: nk_size;
    calls: nk_size;
    size: nk_size;
  end;

  nk_str = record
    buffer: nk_buffer;
    len: Integer;
  end;

  nk_clipboard = record
    userdata: nk_handle;
    paste: nk_plugin_paste;
    copy: nk_plugin_copy;
  end;

  nk_text_undo_record = record
    where: Integer;
    insert_length: Smallint;
    delete_length: Smallint;
    char_storage: Smallint;
  end;

  nk_text_undo_state = record
    undo_rec: array [0..98] of nk_text_undo_record;
    undo_char: array [0..998] of nk_rune;
    undo_point: Smallint;
    redo_point: Smallint;
    undo_char_point: Smallint;
    redo_char_point: Smallint;
  end;

  nk_text_edit = record
    clip: nk_clipboard;
    string_: nk_str;
    filter: nk_plugin_filter;
    scrollbar: nk_vec2;
    cursor: Integer;
    select_start: Integer;
    select_end: Integer;
    mode: Byte;
    cursor_at_end_of_line: Byte;
    initialized: Byte;
    has_preferred_x: Byte;
    single_line: Byte;
    active: Byte;
    padding1: Byte;
    preferred_x: Single;
    undo: nk_text_undo_state;
  end;

  nk_command = record
    type_: nk_command_type;
    next: nk_size;
  end;

  nk_command_scissor = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
  end;

  nk_command_line = record
    header: nk_command;
    line_thickness: Word;
    begin_: nk_vec2i;
    end_: nk_vec2i;
    color: nk_color;
  end;

  nk_command_curve = record
    header: nk_command;
    line_thickness: Word;
    begin_: nk_vec2i;
    end_: nk_vec2i;
    ctrl: array [0..1] of nk_vec2i;
    color: nk_color;
  end;

  nk_command_rect = record
    header: nk_command;
    rounding: Word;
    line_thickness: Word;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    color: nk_color;
  end;

  nk_command_rect_filled = record
    header: nk_command;
    rounding: Word;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    color: nk_color;
  end;

  nk_command_rect_multi_color = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    left: nk_color;
    top: nk_color;
    bottom: nk_color;
    right: nk_color;
  end;

  nk_command_triangle = record
    header: nk_command;
    line_thickness: Word;
    a: nk_vec2i;
    b: nk_vec2i;
    c: nk_vec2i;
    color: nk_color;
  end;

  nk_command_triangle_filled = record
    header: nk_command;
    a: nk_vec2i;
    b: nk_vec2i;
    c: nk_vec2i;
    color: nk_color;
  end;

  nk_command_circle = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    line_thickness: Word;
    w: Word;
    h: Word;
    color: nk_color;
  end;

  nk_command_circle_filled = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    color: nk_color;
  end;

  nk_command_arc = record
    header: nk_command;
    cx: Smallint;
    cy: Smallint;
    r: Word;
    line_thickness: Word;
    a: array [0..1] of Single;
    color: nk_color;
  end;

  nk_command_arc_filled = record
    header: nk_command;
    cx: Smallint;
    cy: Smallint;
    r: Word;
    a: array [0..1] of Single;
    color: nk_color;
  end;

  nk_command_polygon = record
    header: nk_command;
    color: nk_color;
    line_thickness: Word;
    point_count: Word;
    points: array [0..0] of nk_vec2i;
  end;

  nk_command_polygon_filled = record
    header: nk_command;
    color: nk_color;
    point_count: Word;
    points: array [0..0] of nk_vec2i;
  end;

  nk_command_polyline = record
    header: nk_command;
    color: nk_color;
    line_thickness: Word;
    point_count: Word;
    points: array [0..0] of nk_vec2i;
  end;

  nk_command_image = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    img: nk_image;
    col: nk_color;
  end;

  nk_command_custom_callback = procedure(canvas: Pointer; x: Smallint; y: Smallint; w: Word; h: Word; callback_data: nk_handle); cdecl;

  nk_command_custom = record
    header: nk_command;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    callback_data: nk_handle;
    callback: nk_command_custom_callback;
  end;

  nk_command_text = record
    header: nk_command;
    font: Pnk_user_font;
    background: nk_color;
    foreground: nk_color;
    x: Smallint;
    y: Smallint;
    w: Word;
    h: Word;
    height: Single;
    length: Integer;
    string_: array [0..0] of UTF8Char;
  end;

  nk_command_buffer = record
    base: Pnk_buffer;
    clip: nk_rect;
    use_clipping: Integer;
    userdata: nk_handle;
    begin_: nk_size;
    end_: nk_size;
    last: nk_size;
  end;

  nk_mouse_button = record
    down: nk_bool;
    clicked: Cardinal;
    clicked_pos: nk_vec2;
  end;

  nk_mouse = record
    buttons: array [0..3] of nk_mouse_button;
    pos: nk_vec2;
    prev: nk_vec2;
    delta: nk_vec2;
    scroll_delta: nk_vec2;
    grab: Byte;
    grabbed: Byte;
    ungrab: Byte;
  end;

  nk_key = record
    down: nk_bool;
    clicked: Cardinal;
  end;

  nk_keyboard = record
    keys: array [0..29] of nk_key;
    text: array [0..15] of UTF8Char;
    text_len: Integer;
  end;

  nk_input = record
    keyboard: nk_keyboard;
    mouse: nk_mouse;
  end;

  nk_draw_index = nk_ushort;

  nk_draw_vertex_layout_element = record
    attribute: nk_draw_vertex_layout_attribute;
    format: nk_draw_vertex_layout_format;
    offset: nk_size;
  end;

  nk_draw_command = record
    elem_count: Cardinal;
    clip_rect: nk_rect;
    texture: nk_handle;
  end;

  nk_draw_list = record
    clip_rect: nk_rect;
    circle_vtx: array [0..11] of nk_vec2;
    config: nk_convert_config;
    buffer: Pnk_buffer;
    vertices: Pnk_buffer;
    elements: Pnk_buffer;
    element_count: Cardinal;
    vertex_count: Cardinal;
    cmd_count: Cardinal;
    cmd_offset: nk_size;
    path_count: Cardinal;
    path_offset: Cardinal;
    line_AA: nk_anti_aliasing;
    shape_AA: nk_anti_aliasing;
  end;

  nk_style_item_data = record
    case Integer of
      0: (color: nk_color);
      1: (image: nk_image);
      2: (slice: nk_nine_slice);
  end;

  nk_style_item = record
    type_: nk_style_item_type;
    data: nk_style_item_data;
  end;

  nk_style_text = record
    color: nk_color;
    padding: nk_vec2;
  end;

  nk_style_button = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    text_background: nk_color;
    text_normal: nk_color;
    text_hover: nk_color;
    text_active: nk_color;
    text_alignment: nk_flags;
    border: Single;
    rounding: Single;
    padding: nk_vec2;
    image_padding: nk_vec2;
    touch_padding: nk_vec2;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; userdata: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; userdata: nk_handle); cdecl;
  end;

  nk_style_toggle = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    cursor_normal: nk_style_item;
    cursor_hover: nk_style_item;
    text_normal: nk_color;
    text_hover: nk_color;
    text_active: nk_color;
    text_background: nk_color;
    text_alignment: nk_flags;
    padding: nk_vec2;
    touch_padding: nk_vec2;
    spacing: Single;
    border: Single;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  nk_style_selectable = record
    normal: nk_style_item;
    hover: nk_style_item;
    pressed: nk_style_item;
    normal_active: nk_style_item;
    hover_active: nk_style_item;
    pressed_active: nk_style_item;
    text_normal: nk_color;
    text_hover: nk_color;
    text_pressed: nk_color;
    text_normal_active: nk_color;
    text_hover_active: nk_color;
    text_pressed_active: nk_color;
    text_background: nk_color;
    text_alignment: nk_flags;
    rounding: Single;
    padding: nk_vec2;
    touch_padding: nk_vec2;
    image_padding: nk_vec2;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  nk_style_slider = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    bar_normal: nk_color;
    bar_hover: nk_color;
    bar_active: nk_color;
    bar_filled: nk_color;
    cursor_normal: nk_style_item;
    cursor_hover: nk_style_item;
    cursor_active: nk_style_item;
    border: Single;
    rounding: Single;
    bar_height: Single;
    padding: nk_vec2;
    spacing: nk_vec2;
    cursor_size: nk_vec2;
    show_buttons: Integer;
    inc_button: nk_style_button;
    dec_button: nk_style_button;
    inc_symbol: nk_symbol_type;
    dec_symbol: nk_symbol_type;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  nk_style_progress = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    cursor_normal: nk_style_item;
    cursor_hover: nk_style_item;
    cursor_active: nk_style_item;
    cursor_border_color: nk_color;
    rounding: Single;
    border: Single;
    cursor_border: Single;
    cursor_rounding: Single;
    padding: nk_vec2;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  nk_style_scrollbar = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    cursor_normal: nk_style_item;
    cursor_hover: nk_style_item;
    cursor_active: nk_style_item;
    cursor_border_color: nk_color;
    border: Single;
    rounding: Single;
    border_cursor: Single;
    rounding_cursor: Single;
    padding: nk_vec2;
    show_buttons: Integer;
    inc_button: nk_style_button;
    dec_button: nk_style_button;
    inc_symbol: nk_symbol_type;
    dec_symbol: nk_symbol_type;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  nk_style_edit = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    scrollbar: nk_style_scrollbar;
    cursor_normal: nk_color;
    cursor_hover: nk_color;
    cursor_text_normal: nk_color;
    cursor_text_hover: nk_color;
    text_normal: nk_color;
    text_hover: nk_color;
    text_active: nk_color;
    selected_normal: nk_color;
    selected_hover: nk_color;
    selected_text_normal: nk_color;
    selected_text_hover: nk_color;
    border: Single;
    rounding: Single;
    cursor_size: Single;
    scrollbar_size: nk_vec2;
    padding: nk_vec2;
    row_padding: Single;
  end;

  nk_style_property = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    label_normal: nk_color;
    label_hover: nk_color;
    label_active: nk_color;
    sym_left: nk_symbol_type;
    sym_right: nk_symbol_type;
    border: Single;
    rounding: Single;
    padding: nk_vec2;
    edit: nk_style_edit;
    inc_button: nk_style_button;
    dec_button: nk_style_button;
    userdata: nk_handle;
    draw_begin: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
    draw_end: procedure(p1: Pnk_command_buffer; p2: nk_handle); cdecl;
  end;

  nk_style_chart = record
    background: nk_style_item;
    border_color: nk_color;
    selected_color: nk_color;
    color: nk_color;
    border: Single;
    rounding: Single;
    padding: nk_vec2;
  end;

  nk_style_combo = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    border_color: nk_color;
    label_normal: nk_color;
    label_hover: nk_color;
    label_active: nk_color;
    symbol_normal: nk_color;
    symbol_hover: nk_color;
    symbol_active: nk_color;
    button: nk_style_button;
    sym_normal: nk_symbol_type;
    sym_hover: nk_symbol_type;
    sym_active: nk_symbol_type;
    border: Single;
    rounding: Single;
    content_padding: nk_vec2;
    button_padding: nk_vec2;
    spacing: nk_vec2;
  end;

  nk_style_tab = record
    background: nk_style_item;
    border_color: nk_color;
    text: nk_color;
    tab_maximize_button: nk_style_button;
    tab_minimize_button: nk_style_button;
    node_maximize_button: nk_style_button;
    node_minimize_button: nk_style_button;
    sym_minimize: nk_symbol_type;
    sym_maximize: nk_symbol_type;
    border: Single;
    rounding: Single;
    indent: Single;
    padding: nk_vec2;
    spacing: nk_vec2;
  end;

  nk_style_window_header = record
    normal: nk_style_item;
    hover: nk_style_item;
    active: nk_style_item;
    close_button: nk_style_button;
    minimize_button: nk_style_button;
    close_symbol: nk_symbol_type;
    minimize_symbol: nk_symbol_type;
    maximize_symbol: nk_symbol_type;
    label_normal: nk_color;
    label_hover: nk_color;
    label_active: nk_color;
    align: nk_style_header_align;
    padding: nk_vec2;
    label_padding: nk_vec2;
    spacing: nk_vec2;
  end;

  nk_style_window = record
    header: nk_style_window_header;
    fixed_background: nk_style_item;
    background: nk_color;
    border_color: nk_color;
    popup_border_color: nk_color;
    combo_border_color: nk_color;
    contextual_border_color: nk_color;
    menu_border_color: nk_color;
    group_border_color: nk_color;
    tooltip_border_color: nk_color;
    scaler: nk_style_item;
    border: Single;
    combo_border: Single;
    contextual_border: Single;
    menu_border: Single;
    group_border: Single;
    tooltip_border: Single;
    popup_border: Single;
    min_row_height_padding: Single;
    rounding: Single;
    spacing: nk_vec2;
    scrollbar_size: nk_vec2;
    min_size: nk_vec2;
    padding: nk_vec2;
    group_padding: nk_vec2;
    popup_padding: nk_vec2;
    combo_padding: nk_vec2;
    contextual_padding: nk_vec2;
    menu_padding: nk_vec2;
    tooltip_padding: nk_vec2;
  end;

  nk_style = record
    font: Pnk_user_font;
    cursors: array [0..6] of Pnk_cursor;
    cursor_active: Pnk_cursor;
    cursor_last: Pnk_cursor;
    cursor_visible: Integer;
    text: nk_style_text;
    button: nk_style_button;
    contextual_button: nk_style_button;
    menu_button: nk_style_button;
    option: nk_style_toggle;
    checkbox: nk_style_toggle;
    selectable: nk_style_selectable;
    slider: nk_style_slider;
    progress: nk_style_progress;
    property_: nk_style_property;
    edit: nk_style_edit;
    chart: nk_style_chart;
    scrollh: nk_style_scrollbar;
    scrollv: nk_style_scrollbar;
    tab: nk_style_tab;
    combo: nk_style_combo;
    window: nk_style_window;
  end;

  nk_chart_slot = record
    type_: nk_chart_type;
    color: nk_color;
    highlight: nk_color;
    min: Single;
    max: Single;
    range: Single;
    count: Integer;
    last: nk_vec2;
    index: Integer;
  end;

  nk_chart = record
    slot: Integer;
    x: Single;
    y: Single;
    w: Single;
    h: Single;
    slots: array [0..3] of nk_chart_slot;
  end;

  nk_row_layout = record
    type_: nk_panel_row_layout_type;
    index: Integer;
    height: Single;
    min_height: Single;
    columns: Integer;
    ratio: PSingle;
    item_width: Single;
    item_height: Single;
    item_offset: Single;
    filled: Single;
    item: nk_rect;
    tree_depth: Integer;
    templates: array [0..15] of Single;
  end;

  nk_popup_buffer = record
    begin_: nk_size;
    parent: nk_size;
    last: nk_size;
    end_: nk_size;
    active: nk_bool;
  end;

  nk_menu_state = record
    x: Single;
    y: Single;
    w: Single;
    h: Single;
    offset: nk_scroll;
  end;

  nk_panel = record
    type_: nk_panel_type;
    flags: nk_flags;
    bounds: nk_rect;
    offset_x: Pnk_uint;
    offset_y: Pnk_uint;
    at_x: Single;
    at_y: Single;
    max_x: Single;
    footer_height: Single;
    header_height: Single;
    border: Single;
    has_scrolling: Cardinal;
    clip: nk_rect;
    menu: nk_menu_state;
    row: nk_row_layout;
    chart: nk_chart;
    buffer: Pnk_command_buffer;
    parent: Pnk_panel;
  end;

  nk_popup_state = record
    win: Pnk_window;
    type_: nk_panel_type;
    buf: nk_popup_buffer;
    name: nk_hash;
    active: nk_bool;
    combo_count: Cardinal;
    con_count: Cardinal;
    con_old: Cardinal;
    active_con: Cardinal;
    header: nk_rect;
  end;

  nk_edit_state = record
    name: nk_hash;
    seq: Cardinal;
    old: Cardinal;
    active: Integer;
    prev: Integer;
    cursor: Integer;
    sel_start: Integer;
    sel_end: Integer;
    scrollbar: nk_scroll;
    mode: Byte;
    single_line: Byte;
  end;

  nk_property_state = record
    active: Integer;
    prev: Integer;
    buffer: array [0..63] of UTF8Char;
    length: Integer;
    cursor: Integer;
    select_start: Integer;
    select_end: Integer;
    name: nk_hash;
    seq: Cardinal;
    old: Cardinal;
    state: Integer;
  end;

  nk_window = record
    seq: Cardinal;
    name: nk_hash;
    name_string: array [0..63] of UTF8Char;
    flags: nk_flags;
    bounds: nk_rect;
    scrollbar: nk_scroll;
    buffer: nk_command_buffer;
    layout: Pnk_panel;
    scrollbar_hiding_timer: Single;
    property_: nk_property_state;
    popup: nk_popup_state;
    edit: nk_edit_state;
    scrolled: Cardinal;
    tables: Pnk_table;
    table_count: Cardinal;
    next: Pnk_window;
    prev: Pnk_window;
    parent: Pnk_window;
  end;

  nk_config_stack_style_item_element = record
    address: Pnk_style_item;
    old_value: nk_style_item;
  end;

  nk_config_stack_float_element = record
    address: PSingle;
    old_value: Single;
  end;

  nk_config_stack_vec2_element = record
    address: Pnk_vec2;
    old_value: nk_vec2;
  end;

  nk_config_stack_flags_element = record
    address: Pnk_flags;
    old_value: nk_flags;
  end;

  nk_config_stack_color_element = record
    address: Pnk_color;
    old_value: nk_color;
  end;

  nk_config_stack_user_font_element = record
    address: PPnk_user_font;
    old_value: Pnk_user_font;
  end;

  nk_config_stack_button_behavior_element = record
    address: Pnk_button_behavior;
    old_value: nk_button_behavior;
  end;

  nk_config_stack_style_item = record
    head: Integer;
    elements: array [0..15] of nk_config_stack_style_item_element;
  end;

  nk_config_stack_float = record
    head: Integer;
    elements: array [0..31] of nk_config_stack_float_element;
  end;

  nk_config_stack_vec2 = record
    head: Integer;
    elements: array [0..15] of nk_config_stack_vec2_element;
  end;

  nk_config_stack_flags = record
    head: Integer;
    elements: array [0..31] of nk_config_stack_flags_element;
  end;

  nk_config_stack_color = record
    head: Integer;
    elements: array [0..31] of nk_config_stack_color_element;
  end;

  nk_config_stack_user_font = record
    head: Integer;
    elements: array [0..7] of nk_config_stack_user_font_element;
  end;

  nk_config_stack_button_behavior = record
    head: Integer;
    elements: array [0..7] of nk_config_stack_button_behavior_element;
  end;

  nk_configuration_stacks = record
    style_items: nk_config_stack_style_item;
    floats: nk_config_stack_float;
    vectors: nk_config_stack_vec2;
    flags: nk_config_stack_flags;
    colors: nk_config_stack_color;
    fonts: nk_config_stack_user_font;
    button_behaviors: nk_config_stack_button_behavior;
  end;

  nk_table = record
    seq: Cardinal;
    size: Cardinal;
    keys: array [0..58] of nk_hash;
    values: array [0..58] of nk_uint;
    next: Pnk_table;
    prev: Pnk_table;
  end;

  nk_page_data = record
    case Integer of
      0: (tbl: nk_table);
      1: (pan: nk_panel);
      2: (win: nk_window);
  end;

  nk_page_element = record
    data: nk_page_data;
    next: Pnk_page_element;
    prev: Pnk_page_element;
  end;

  nk_page = record
    size: Cardinal;
    next: Pnk_page;
    win: array [0..0] of nk_page_element;
  end;

  nk_pool = record
    alloc: nk_allocator;
    type_: nk_allocation_type;
    page_count: Cardinal;
    pages: Pnk_page;
    freelist: Pnk_page_element;
    capacity: Cardinal;
    size: nk_size;
    cap: nk_size;
  end;

  nk_context = record
    input: nk_input;
    style: nk_style;
    memory: nk_buffer;
    clip: nk_clipboard;
    last_widget_state: nk_flags;
    button_behavior: nk_button_behavior;
    stacks: nk_configuration_stacks;
    delta_time_seconds: Single;
    draw_list: nk_draw_list;
    text_edit: nk_text_edit;
    overlay: nk_command_buffer;
    build: Integer;
    use_pool: Integer;
    pool: nk_pool;
    begin_: Pnk_window;
    end_: Pnk_window;
    active: Pnk_window;
    current: Pnk_window;
    freelist: Pnk_page_element;
    count: Cardinal;
    seq: Cardinal;
  end;

  Pplm_t = Pointer;
  PPplm_t = ^Pplm_t;
  Pplm_buffer_t = Pointer;
  PPplm_buffer_t = ^Pplm_buffer_t;
  Pplm_demux_t = Pointer;
  PPplm_demux_t = ^Pplm_demux_t;
  Pplm_video_t = Pointer;
  PPplm_video_t = ^Pplm_video_t;
  Pplm_audio_t = Pointer;
  PPplm_audio_t = ^Pplm_audio_t;

  plm_packet_t = record
    type_: Integer;
    pts: Double;
    length: NativeUInt;
    data: PUInt8;
  end;

  plm_plane_t = record
    width: Cardinal;
    height: Cardinal;
    data: PUInt8;
  end;

  plm_frame_t = record
    time: Double;
    width: Cardinal;
    height: Cardinal;
    y: plm_plane_t;
    cr: plm_plane_t;
    cb: plm_plane_t;
  end;

  plm_video_decode_callback = procedure(self: Pplm_t; frame: Pplm_frame_t; user: Pointer); cdecl;

  plm_samples_t = record
    time: Double;
    count: Cardinal;
    interleaved: array [0..2303] of Single;
  end;

  plm_audio_decode_callback = procedure(self: Pplm_t; samples: Pplm_samples_t; user: Pointer); cdecl;

  plm_buffer_load_callback = procedure(self: Pplm_buffer_t; user: Pointer); cdecl;
  uInt = Cardinal;
  uLong = Cardinal;
  zipFile = Pointer;

  tm_zip_s = record
    tm_sec: uInt;
    tm_min: uInt;
    tm_hour: uInt;
    tm_mday: uInt;
    tm_mon: uInt;
    tm_year: uInt;
  end;

  tm_zip = tm_zip_s;

  zip_fileinfo = record
    tmz_date: tm_zip;
    dosDate: uLong;
    internal_fa: uLong;
  end;

const
  PLM_DEMUX_PACKET_PRIVATE : Integer = $BD;
  PLM_DEMUX_PACKET_AUDIO_1 : Integer = $C0;
  PLM_DEMUX_PACKET_AUDIO_2 : Integer = $C1;
  PLM_DEMUX_PACKET_AUDIO_3 : Integer = $C2;
  PLM_DEMUX_PACKET_AUDIO_4 : Integer = $C2;
  PLM_DEMUX_PACKET_VIDEO_1 : Integer = $E0;

var
(**
 * Get the name of the platform.
 *
 * Here are the names returned for some (but not all) supported platforms:
 *
 * - "Windows"
 * - "Mac OS X"
 * - "Linux"
 * - "iOS"
 * - "Android"
 *
 * \returns the name of the platform. If the correct platform name is not
 *          available, returns a string beginning with the text "Unknown".
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GetPlatform: function(): PUTF8Char; cdecl;

  SDL_malloc: function(size: NativeUInt): Pointer; cdecl;

  SDL_calloc: function(nmemb: NativeUInt; size: NativeUInt): Pointer; cdecl;

  SDL_realloc: function(mem: Pointer; size: NativeUInt): Pointer; cdecl;

  SDL_free: procedure(mem: Pointer); cdecl;

(**
 * Get the original set of SDL memory functions
 *
 * \since This function is available since SDL 2.24.0.
 *)
  SDL_GetOriginalMemoryFunctions: procedure(malloc_func: PSDL_malloc_func; calloc_func: PSDL_calloc_func; realloc_func: PSDL_realloc_func; free_func: PSDL_free_func); cdecl;

(**
 * Get the current set of SDL memory functions
 *
 * \since This function is available since SDL 2.0.7.
 *)
  SDL_GetMemoryFunctions: procedure(malloc_func: PSDL_malloc_func; calloc_func: PSDL_calloc_func; realloc_func: PSDL_realloc_func; free_func: PSDL_free_func); cdecl;

(**
 * Replace SDL's memory allocation functions with a custom set
 *
 * \since This function is available since SDL 2.0.7.
 *)
  SDL_SetMemoryFunctions: function(malloc_func: SDL_malloc_func; calloc_func: SDL_calloc_func; realloc_func: SDL_realloc_func; free_func: SDL_free_func): Integer; cdecl;

(**
 * Get the number of outstanding (unfreed) allocations
 *
 * \since This function is available since SDL 2.0.7.
 *)
  SDL_GetNumAllocations: function(): Integer; cdecl;

  SDL_getenv: function(const name: PUTF8Char): PUTF8Char; cdecl;

  SDL_setenv: function(const name: PUTF8Char; const value: PUTF8Char; overwrite: Integer): Integer; cdecl;

type
  SDL_qsort_compare = function(const p1: Pointer; const p2: Pointer): Integer; cdecl;

var
  SDL_qsort: procedure(base: Pointer; nmemb: NativeUInt; size: NativeUInt; compare: SDL_qsort_compare); cdecl;

type
  SDL_bsearch_compare = function(const p1: Pointer; const p2: Pointer): Integer; cdecl;

var
  SDL_bsearch: function(const key: Pointer; const base: Pointer; nmemb: NativeUInt; size: NativeUInt; compare: SDL_bsearch_compare): Pointer; cdecl;

  SDL_abs: function(x: Integer): Integer; cdecl;

  SDL_isalpha: function(x: Integer): Integer; cdecl;

  SDL_isalnum: function(x: Integer): Integer; cdecl;

  SDL_isblank: function(x: Integer): Integer; cdecl;

  SDL_iscntrl: function(x: Integer): Integer; cdecl;

  SDL_isdigit: function(x: Integer): Integer; cdecl;

  SDL_isxdigit: function(x: Integer): Integer; cdecl;

  SDL_ispunct: function(x: Integer): Integer; cdecl;

  SDL_isspace: function(x: Integer): Integer; cdecl;

  SDL_isupper: function(x: Integer): Integer; cdecl;

  SDL_islower: function(x: Integer): Integer; cdecl;

  SDL_isprint: function(x: Integer): Integer; cdecl;

  SDL_isgraph: function(x: Integer): Integer; cdecl;

  SDL_toupper: function(x: Integer): Integer; cdecl;

  SDL_tolower: function(x: Integer): Integer; cdecl;

  SDL_crc16: function(crc: Uint16; const data: Pointer; len: NativeUInt): Uint16; cdecl;

  SDL_crc32: function(crc: Uint32; const data: Pointer; len: NativeUInt): Uint32; cdecl;

  SDL_memset: function(dst: Pointer; c: Integer; len: NativeUInt): Pointer; cdecl;

  SDL_memcpy: function(dst: Pointer; const src: Pointer; len: NativeUInt): Pointer; cdecl;

  SDL_memmove: function(dst: Pointer; const src: Pointer; len: NativeUInt): Pointer; cdecl;

  SDL_memcmp: function(const s1: Pointer; const s2: Pointer; len: NativeUInt): Integer; cdecl;

  SDL_wcslen: function(const wstr: PWideChar): NativeUInt; cdecl;

  SDL_wcslcpy: function(dst: PWideChar; const src: PWideChar; maxlen: NativeUInt): NativeUInt; cdecl;

  SDL_wcslcat: function(dst: PWideChar; const src: PWideChar; maxlen: NativeUInt): NativeUInt; cdecl;

  SDL_wcsdup: function(const wstr: PWideChar): PWideChar; cdecl;

  SDL_wcsstr: function(const haystack: PWideChar; const needle: PWideChar): PWideChar; cdecl;

  SDL_wcscmp: function(const str1: PWideChar; const str2: PWideChar): Integer; cdecl;

  SDL_wcsncmp: function(const str1: PWideChar; const str2: PWideChar; maxlen: NativeUInt): Integer; cdecl;

  SDL_wcscasecmp: function(const str1: PWideChar; const str2: PWideChar): Integer; cdecl;

  SDL_wcsncasecmp: function(const str1: PWideChar; const str2: PWideChar; len: NativeUInt): Integer; cdecl;

  SDL_strlen: function(const str: PUTF8Char): NativeUInt; cdecl;

  SDL_strlcpy: function(dst: PUTF8Char; const src: PUTF8Char; maxlen: NativeUInt): NativeUInt; cdecl;

  SDL_utf8strlcpy: function(dst: PUTF8Char; const src: PUTF8Char; dst_bytes: NativeUInt): NativeUInt; cdecl;

  SDL_strlcat: function(dst: PUTF8Char; const src: PUTF8Char; maxlen: NativeUInt): NativeUInt; cdecl;

  SDL_strdup: function(const str: PUTF8Char): PUTF8Char; cdecl;

  SDL_strrev: function(str: PUTF8Char): PUTF8Char; cdecl;

  SDL_strupr: function(str: PUTF8Char): PUTF8Char; cdecl;

  SDL_strlwr: function(str: PUTF8Char): PUTF8Char; cdecl;

  SDL_strchr: function(const str: PUTF8Char; c: Integer): PUTF8Char; cdecl;

  SDL_strrchr: function(const str: PUTF8Char; c: Integer): PUTF8Char; cdecl;

  SDL_strstr: function(const haystack: PUTF8Char; const needle: PUTF8Char): PUTF8Char; cdecl;

  SDL_strtokr: function(s1: PUTF8Char; const s2: PUTF8Char; saveptr: PPUTF8Char): PUTF8Char; cdecl;

  SDL_utf8strlen: function(const str: PUTF8Char): NativeUInt; cdecl;

  SDL_utf8strnlen: function(const str: PUTF8Char; bytes: NativeUInt): NativeUInt; cdecl;

  SDL_itoa: function(value: Integer; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;

  SDL_uitoa: function(value: Cardinal; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;

  SDL_ltoa: function(value: Integer; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;

  SDL_ultoa: function(value: Cardinal; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;

  SDL_lltoa: function(value: Sint64; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;

  SDL_ulltoa: function(value: Uint64; str: PUTF8Char; radix: Integer): PUTF8Char; cdecl;

  SDL_atoi: function(const str: PUTF8Char): Integer; cdecl;

  SDL_atof: function(const str: PUTF8Char): Double; cdecl;

  SDL_strtol: function(const str: PUTF8Char; endp: PPUTF8Char; base: Integer): Integer; cdecl;

  SDL_strtoul: function(const str: PUTF8Char; endp: PPUTF8Char; base: Integer): Cardinal; cdecl;

  SDL_strtoll: function(const str: PUTF8Char; endp: PPUTF8Char; base: Integer): Sint64; cdecl;

  SDL_strtoull: function(const str: PUTF8Char; endp: PPUTF8Char; base: Integer): Uint64; cdecl;

  SDL_strtod: function(const str: PUTF8Char; endp: PPUTF8Char): Double; cdecl;

  SDL_strcmp: function(const str1: PUTF8Char; const str2: PUTF8Char): Integer; cdecl;

  SDL_strncmp: function(const str1: PUTF8Char; const str2: PUTF8Char; maxlen: NativeUInt): Integer; cdecl;

  SDL_strcasecmp: function(const str1: PUTF8Char; const str2: PUTF8Char): Integer; cdecl;

  SDL_strncasecmp: function(const str1: PUTF8Char; const str2: PUTF8Char; len: NativeUInt): Integer; cdecl;

  SDL_sscanf: function(const text: PUTF8Char; const fmt: PUTF8Char): Integer varargs; cdecl;

  SDL_vsscanf: function(const text: PUTF8Char; const fmt: PUTF8Char; ap: Pointer): Integer; cdecl;

  SDL_snprintf: function(text: PUTF8Char; maxlen: NativeUInt; const fmt: PUTF8Char): Integer varargs; cdecl;

  SDL_vsnprintf: function(text: PUTF8Char; maxlen: NativeUInt; const fmt: PUTF8Char; ap: Pointer): Integer; cdecl;

  SDL_asprintf: function(strp: PPUTF8Char; const fmt: PUTF8Char): Integer varargs; cdecl;

  SDL_vasprintf: function(strp: PPUTF8Char; const fmt: PUTF8Char; ap: Pointer): Integer; cdecl;

(**
 * Use this function to compute arc cosine of `x`.
 *
 * The definition of `y = acos(x)` is `x = cos(y)`.
 *
 * Domain: `-1 <= x <= 1`
 *
 * Range: `0 <= y <= Pi`
 *
 * \param x floating point value, in radians.
 * \returns arc cosine of `x`.
 *
 * \since This function is available since SDL 2.0.2.
 *)
  SDL_acos: function(x: Double): Double; cdecl;

  SDL_acosf: function(x: Single): Single; cdecl;

  SDL_asin: function(x: Double): Double; cdecl;

  SDL_asinf: function(x: Single): Single; cdecl;

  SDL_atan: function(x: Double): Double; cdecl;

  SDL_atanf: function(x: Single): Single; cdecl;

  SDL_atan2: function(y: Double; x: Double): Double; cdecl;

  SDL_atan2f: function(y: Single; x: Single): Single; cdecl;

  SDL_ceil: function(x: Double): Double; cdecl;

  SDL_ceilf: function(x: Single): Single; cdecl;

  SDL_copysign: function(x: Double; y: Double): Double; cdecl;

  SDL_copysignf: function(x: Single; y: Single): Single; cdecl;

  SDL_cos: function(x: Double): Double; cdecl;

  SDL_cosf: function(x: Single): Single; cdecl;

  SDL_exp: function(x: Double): Double; cdecl;

  SDL_expf: function(x: Single): Single; cdecl;

  SDL_fabs: function(x: Double): Double; cdecl;

  SDL_fabsf: function(x: Single): Single; cdecl;

  SDL_floor: function(x: Double): Double; cdecl;

  SDL_floorf: function(x: Single): Single; cdecl;

  SDL_trunc: function(x: Double): Double; cdecl;

  SDL_truncf: function(x: Single): Single; cdecl;

  SDL_fmod: function(x: Double; y: Double): Double; cdecl;

  SDL_fmodf: function(x: Single; y: Single): Single; cdecl;

  SDL_log: function(x: Double): Double; cdecl;

  SDL_logf: function(x: Single): Single; cdecl;

  SDL_log10: function(x: Double): Double; cdecl;

  SDL_log10f: function(x: Single): Single; cdecl;

  SDL_pow: function(x: Double; y: Double): Double; cdecl;

  SDL_powf: function(x: Single; y: Single): Single; cdecl;

  SDL_round: function(x: Double): Double; cdecl;

  SDL_roundf: function(x: Single): Single; cdecl;

  SDL_lround: function(x: Double): Integer; cdecl;

  SDL_lroundf: function(x: Single): Integer; cdecl;

  SDL_scalbn: function(x: Double; n: Integer): Double; cdecl;

  SDL_scalbnf: function(x: Single; n: Integer): Single; cdecl;

  SDL_sin: function(x: Double): Double; cdecl;

  SDL_sinf: function(x: Single): Single; cdecl;

  SDL_sqrt: function(x: Double): Double; cdecl;

  SDL_sqrtf: function(x: Single): Single; cdecl;

  SDL_tan: function(x: Double): Double; cdecl;

  SDL_tanf: function(x: Single): Single; cdecl;

  SDL_iconv_open: function(const tocode: PUTF8Char; const fromcode: PUTF8Char): SDL_iconv_t; cdecl;

  SDL_iconv_close: function(cd: SDL_iconv_t): Integer; cdecl;

  SDL_iconv: function(cd: SDL_iconv_t; inbuf: PPUTF8Char; inbytesleft: PNativeUInt; outbuf: PPUTF8Char; outbytesleft: PNativeUInt): NativeUInt; cdecl;

(**
 * This function converts a string between encodings in one pass, returning a
 * string that must be freed with SDL_free() or NULL on error.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_iconv_string: function(const tocode: PUTF8Char; const fromcode: PUTF8Char; const inbuf: PUTF8Char; inbytesleft: NativeUInt): PUTF8Char; cdecl;

  SDL_main: function(argc: Integer; argv: PPUTF8Char): Integer; cdecl;

(**
 * Circumvent failure of SDL_Init() when not using SDL_main() as an entry
 * point.
 *
 * This function is defined in SDL_main.h, along with the preprocessor rule to
 * redefine main() as SDL_main(). Thus to ensure that your main() function
 * will not be changed it is necessary to define SDL_MAIN_HANDLED before
 * including SDL.h.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Init
 *)
  SDL_SetMainReady: procedure(); cdecl;

(**
 * Register a win32 window class for SDL's use.
 *
 * This can be called to set the application window class at startup. It is
 * safe to call this multiple times, as long as every call is eventually
 * paired with a call to SDL_UnregisterApp, but a second registration attempt
 * while a previous registration is still active will be ignored, other than
 * to increment a counter.
 *
 * Most applications do not need to, and should not, call this directly; SDL
 * will call it when initializing the video subsystem.
 *
 * \param name the window class name, in UTF-8 encoding. If NULL, SDL
 *             currently uses "SDL_app" but this isn't guaranteed.
 * \param style the value to use in WNDCLASSEX::style. If `name` is NULL, SDL
 *              currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` regardless of
 *              what is specified here.
 * \param hInst the HINSTANCE to use in WNDCLASSEX::hInstance. If zero, SDL
 *              will use `GetModuleHandle(NULL)` instead.
 * \returns 0 on success, -1 on error. SDL_GetError() may have details.
 *
 * \since This function is available since SDL 2.0.2.
 *)
  SDL_RegisterApp: function(const name: PUTF8Char; style: Uint32; hInst: Pointer): Integer; cdecl;

(**
 * Deregister the win32 window class from an SDL_RegisterApp call.
 *
 * This can be called to undo the effects of SDL_RegisterApp.
 *
 * Most applications do not need to, and should not, call this directly; SDL
 * will call it when deinitializing the video subsystem.
 *
 * It is safe to call this multiple times, as long as every call is eventually
 * paired with a prior call to SDL_RegisterApp. The window class will only be
 * deregistered when the registration counter in SDL_RegisterApp decrements to
 * zero through calls to this function.
 *
 * \since This function is available since SDL 2.0.2.
 *)
  SDL_UnregisterApp: procedure(); cdecl;

  __debugbreak: procedure(); cdecl;

  SDL_ReportAssertion: function(p1: PSDL_AssertData; const p2: PUTF8Char; const p3: PUTF8Char; p4: Integer): SDL_AssertState; cdecl;

(**
 * Set an application-defined assertion handler.
 *
 * This function allows an application to show its own assertion UI and/or
 * force the response to an assertion failure. If the application doesn't
 * provide this, SDL will try to do the right thing, popping up a
 * system-specific GUI dialog, and probably minimizing any fullscreen windows.
 *
 * This callback may fire from any thread, but it runs wrapped in a mutex, so
 * it will only fire from one thread at a time.
 *
 * This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
 *
 * \param handler the SDL_AssertionHandler function to call when an assertion
 *                fails or NULL for the default handler
 * \param userdata a pointer that is passed to `handler`
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetAssertionHandler
 *)
  SDL_SetAssertionHandler: procedure(handler: SDL_AssertionHandler; userdata: Pointer); cdecl;

(**
 * Get the default assertion handler.
 *
 * This returns the function pointer that is called by default when an
 * assertion is triggered. This is an internal function provided by SDL, that
 * is used for assertions when SDL_SetAssertionHandler() hasn't been used to
 * provide a different function.
 *
 * \returns the default SDL_AssertionHandler that is called when an assert
 *          triggers.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_GetAssertionHandler
 *)
  SDL_GetDefaultAssertionHandler: function(): SDL_AssertionHandler; cdecl;

(**
 * Get the current assertion handler.
 *
 * This returns the function pointer that is called when an assertion is
 * triggered. This is either the value last passed to
 * SDL_SetAssertionHandler(), or if no application-specified function is set,
 * is equivalent to calling SDL_GetDefaultAssertionHandler().
 *
 * The parameter `puserdata` is a pointer to a void*, which will store the
 * "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value
 * will always be NULL for the default handler. If you don't care about this
 * data, it is safe to pass a NULL pointer to this function to ignore it.
 *
 * \param puserdata pointer which is filled with the "userdata" pointer that
 *                  was passed to SDL_SetAssertionHandler()
 * \returns the SDL_AssertionHandler that is called when an assert triggers.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_SetAssertionHandler
 *)
  SDL_GetAssertionHandler: function(puserdata: PPointer): SDL_AssertionHandler; cdecl;

(**
 * Get a list of all assertion failures.
 *
 * This function gets all assertions triggered since the last call to
 * SDL_ResetAssertionReport(), or the start of the program.
 *
 * The proper way to examine this data looks something like this:
 *
 * ```c
 * const SDL_AssertData *item = SDL_GetAssertionReport();
 * while (item) {
 *    printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
 *           item->condition, item->function, item->filename,
 *           item->linenum, item->trigger_count,
 *           item->always_ignore ? "yes" : "no");
 *    item = item->next;
 * }
 * ```
 *
 * \returns a list of all failed assertions or NULL if the list is empty. This
 *          memory should not be modified or freed by the application.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ResetAssertionReport
 *)
  SDL_GetAssertionReport: function(): PSDL_AssertData; cdecl;

(**
 * Clear the list of all assertion failures.
 *
 * This function will clear the list of all assertions triggered up to that
 * point. Immediately following this call, SDL_GetAssertionReport will return
 * no items. In addition, any previously-triggered assertions will be reset to
 * a trigger_count of zero, and their always_ignore state will be false.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetAssertionReport
 *)
  SDL_ResetAssertionReport: procedure(); cdecl;

(**
 * Try to lock a spin lock by setting it to a non-zero value.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * \param lock a pointer to a lock variable
 * \returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already
 *          held.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AtomicLock
 * \sa SDL_AtomicUnlock
 *)
  SDL_AtomicTryLock: function(lock: PSDL_SpinLock): SDL_bool; cdecl;

(**
 * Lock a spin lock by setting it to a non-zero value.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * \param lock a pointer to a lock variable
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AtomicTryLock
 * \sa SDL_AtomicUnlock
 *)
  SDL_AtomicLock: procedure(lock: PSDL_SpinLock); cdecl;

(**
 * Unlock a spin lock by setting it to 0.
 *
 * Always returns immediately.
 *
 * ***Please note that spinlocks are dangerous if you don't know what you're
 * doing. Please be careful using any sort of spinlock!***
 *
 * \param lock a pointer to a lock variable
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AtomicLock
 * \sa SDL_AtomicTryLock
 *)
  SDL_AtomicUnlock: procedure(lock: PSDL_SpinLock); cdecl;

(**
 * Memory barriers are designed to prevent reads and writes from being
 * reordered by the compiler and being seen out of order on multi-core CPUs.
 *
 * A typical pattern would be for thread A to write some data and a flag, and
 * for thread B to read the flag and get the data. In this case you would
 * insert a release barrier between writing the data and the flag,
 * guaranteeing that the data write completes no later than the flag is
 * written, and you would insert an acquire barrier between reading the flag
 * and reading the data, to ensure that all the reads associated with the flag
 * have completed.
 *
 * In this pattern you should always see a release barrier paired with an
 * acquire barrier and you should gate the data reads/writes with a single
 * flag variable.
 *
 * For more information on these semantics, take a look at the blog post:
 * http://preshing.com/20120913/acquire-and-release-semantics
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_MemoryBarrierReleaseFunction: procedure(); cdecl;

  SDL_MemoryBarrierAcquireFunction: procedure(); cdecl;

(**
 * Set an atomic variable to a new value if it is currently an old value.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_atomic_t variable to be modified
 * \param oldval the old value
 * \param newval the new value
 * \returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AtomicCASPtr
 * \sa SDL_AtomicGet
 * \sa SDL_AtomicSet
 *)
  SDL_AtomicCAS: function(a: PSDL_atomic_t; oldval: Integer; newval: Integer): SDL_bool; cdecl;

(**
 * Set an atomic variable to a value.
 *
 * This function also acts as a full memory barrier.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_atomic_t variable to be modified
 * \param v the desired value
 * \returns the previous value of the atomic variable.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_AtomicGet
 *)
  SDL_AtomicSet: function(a: PSDL_atomic_t; v: Integer): Integer; cdecl;

(**
 * Get the value of an atomic variable.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_atomic_t variable
 * \returns the current value of an atomic variable.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_AtomicSet
 *)
  SDL_AtomicGet: function(a: PSDL_atomic_t): Integer; cdecl;

(**
 * Add to an atomic variable.
 *
 * This function also acts as a full memory barrier.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to an SDL_atomic_t variable to be modified
 * \param v the desired value to add
 * \returns the previous value of the atomic variable.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_AtomicDecRef
 * \sa SDL_AtomicIncRef
 *)
  SDL_AtomicAdd: function(a: PSDL_atomic_t; v: Integer): Integer; cdecl;

(**
 * Set a pointer to a new value if it is currently an old value.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to a pointer
 * \param oldval the old pointer value
 * \param newval the new pointer value
 * \returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AtomicCAS
 * \sa SDL_AtomicGetPtr
 * \sa SDL_AtomicSetPtr
 *)
  SDL_AtomicCASPtr: function(a: PPointer; oldval: Pointer; newval: Pointer): SDL_bool; cdecl;

(**
 * Set a pointer to a value atomically.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to a pointer
 * \param v the desired pointer value
 * \returns the previous value of the pointer.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_AtomicCASPtr
 * \sa SDL_AtomicGetPtr
 *)
  SDL_AtomicSetPtr: function(a: PPointer; v: Pointer): Pointer; cdecl;

(**
 * Get the value of a pointer atomically.
 *
 * ***Note: If you don't know what this function is for, you shouldn't use
 * it!***
 *
 * \param a a pointer to a pointer
 * \returns the current value of a pointer.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_AtomicCASPtr
 * \sa SDL_AtomicSetPtr
 *)
  SDL_AtomicGetPtr: function(a: PPointer): Pointer; cdecl;

(**
 * Set the SDL error message for the current thread.
 *
 * Calling this function will replace any previous error message that was set.
 *
 * This function always returns -1, since SDL frequently uses -1 to signify an
 * failing result, leading to this idiom:
 *
 * ```c
 * if (error_code) {
 *     return SDL_SetError("This operation has failed: %d", error_code);
 * }
 * ```
 *
 * \param fmt a printf()-style message format string
 * \param ... additional parameters matching % tokens in the `fmt` string, if
 *            any
 * \returns always -1.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ClearError
 * \sa SDL_GetError
 *)
  SDL_SetError: function(const fmt: PUTF8Char): Integer varargs; cdecl;

(**
 * Retrieve a message about the last error that occurred on the current
 * thread.
 *
 * It is possible for multiple errors to occur before calling SDL_GetError().
 * Only the last error is returned.
 *
 * The message is only applicable when an SDL function has signaled an error.
 * You must check the return values of SDL function calls to determine when to
 * appropriately call SDL_GetError(). You should *not* use the results of
 * SDL_GetError() to decide if an error has occurred! Sometimes SDL will set
 * an error string even when reporting success.
 *
 * SDL will *not* clear the error string for successful API calls. You *must*
 * check return values for failure cases before you can assume the error
 * string applies.
 *
 * Error strings are set per-thread, so an error set in a different thread
 * will not interfere with the current thread's operation.
 *
 * The returned string is internally allocated and must not be freed by the
 * application.
 *
 * \returns a message with information about the specific error that occurred,
 *          or an empty string if there hasn't been an error message set since
 *          the last call to SDL_ClearError(). The message is only applicable
 *          when an SDL function has signaled an error. You must check the
 *          return values of SDL function calls to determine when to
 *          appropriately call SDL_GetError().
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ClearError
 * \sa SDL_SetError
 *)
  SDL_GetError: function(): PUTF8Char; cdecl;

(**
 * Get the last error message that was set for the current thread.
 *
 * This allows the caller to copy the error string into a provided buffer, but
 * otherwise operates exactly the same as SDL_GetError().
 *
 * \param errstr A buffer to fill with the last error message that was set for
 *               the current thread
 * \param maxlen The size of the buffer pointed to by the errstr parameter
 * \returns the pointer passed in as the `errstr` parameter.
 *
 * \since This function is available since SDL 2.0.14.
 *
 * \sa SDL_GetError
 *)
  SDL_GetErrorMsg: function(errstr: PUTF8Char; maxlen: Integer): PUTF8Char; cdecl;

(**
 * Clear any previous error message for this thread.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetError
 * \sa SDL_SetError
 *)
  SDL_ClearError: procedure(); cdecl;

  SDL_Error: function(code: SDL_errorcode): Integer; cdecl;

(**
 * Create a new mutex.
 *
 * All newly-created mutexes begin in the _unlocked_ state.
 *
 * Calls to SDL_LockMutex() will not return while the mutex is locked by
 * another thread. See SDL_TryLockMutex() to attempt to lock without blocking.
 *
 * SDL mutexes are reentrant.
 *
 * \returns the initialized and unlocked mutex or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_DestroyMutex
 * \sa SDL_LockMutex
 * \sa SDL_TryLockMutex
 * \sa SDL_UnlockMutex
 *)
  SDL_CreateMutex: function(): PSDL_mutex; cdecl;

(**
 * Lock the mutex.
 *
 * This will block until the mutex is available, which is to say it is in the
 * unlocked state and the OS has chosen the caller as the next thread to lock
 * it. Of all threads waiting to lock the mutex, only one may do so at a time.
 *
 * It is legal for the owning thread to lock an already-locked mutex. It must
 * unlock it the same number of times before it is actually made available for
 * other threads in the system (this is known as a "recursive mutex").
 *
 * \param mutex the mutex to lock
 * \return 0, or -1 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_LockMutex: function(mutex: PSDL_mutex): Integer; cdecl;

(**
 * Try to lock a mutex without blocking.
 *
 * This works just like SDL_LockMutex(), but if the mutex is not available,
 * this function returns `SDL_MUTEX_TIMEOUT` immediately.
 *
 * This technique is useful if you need exclusive access to a resource but
 * don't want to wait for it, and will return to it to try again later.
 *
 * \param mutex the mutex to try to lock
 * \returns 0, `SDL_MUTEX_TIMEDOUT`, or -1 on error; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateMutex
 * \sa SDL_DestroyMutex
 * \sa SDL_LockMutex
 * \sa SDL_UnlockMutex
 *)
  SDL_TryLockMutex: function(mutex: PSDL_mutex): Integer; cdecl;

(**
 * Unlock the mutex.
 *
 * It is legal for the owning thread to lock an already-locked mutex. It must
 * unlock it the same number of times before it is actually made available for
 * other threads in the system (this is known as a "recursive mutex").
 *
 * It is an error to unlock a mutex that has not been locked by the current
 * thread, and doing so results in undefined behavior.
 *
 * It is also an error to unlock a mutex that isn't locked at all.
 *
 * \param mutex the mutex to unlock.
 * \returns 0, or -1 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_UnlockMutex: function(mutex: PSDL_mutex): Integer; cdecl;

(**
 * Destroy a mutex created with SDL_CreateMutex().
 *
 * This function must be called on any mutex that is no longer needed. Failure
 * to destroy a mutex will result in a system memory or resource leak. While
 * it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt
 * to destroy a locked mutex, and may result in undefined behavior depending
 * on the platform.
 *
 * \param mutex the mutex to destroy
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateMutex
 * \sa SDL_LockMutex
 * \sa SDL_TryLockMutex
 * \sa SDL_UnlockMutex
 *)
  SDL_DestroyMutex: procedure(mutex: PSDL_mutex); cdecl;

(**
 * Create a semaphore.
 *
 * This function creates a new semaphore and initializes it with the value
 * `initial_value`. Each wait operation on the semaphore will atomically
 * decrement the semaphore value and potentially block if the semaphore value
 * is 0. Each post operation will atomically increment the semaphore value and
 * wake waiting threads and allow them to retry the wait operation.
 *
 * \param initial_value the starting value of the semaphore
 * \returns a new semaphore or NULL on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_DestroySemaphore
 * \sa SDL_SemPost
 * \sa SDL_SemTryWait
 * \sa SDL_SemValue
 * \sa SDL_SemWait
 * \sa SDL_SemWaitTimeout
 *)
  SDL_CreateSemaphore: function(initial_value: Uint32): PSDL_sem; cdecl;

(**
 * Destroy a semaphore.
 *
 * It is not safe to destroy a semaphore if there are threads currently
 * waiting on it.
 *
 * \param sem the semaphore to destroy
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateSemaphore
 * \sa SDL_SemPost
 * \sa SDL_SemTryWait
 * \sa SDL_SemValue
 * \sa SDL_SemWait
 * \sa SDL_SemWaitTimeout
 *)
  SDL_DestroySemaphore: procedure(sem: PSDL_sem); cdecl;

(**
 * Wait until a semaphore has a positive value and then decrements it.
 *
 * This function suspends the calling thread until either the semaphore
 * pointed to by `sem` has a positive value or the call is interrupted by a
 * signal or error. If the call is successful it will atomically decrement the
 * semaphore value.
 *
 * This function is the equivalent of calling SDL_SemWaitTimeout() with a time
 * length of `SDL_MUTEX_MAXWAIT`.
 *
 * \param sem the semaphore wait on
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateSemaphore
 * \sa SDL_DestroySemaphore
 * \sa SDL_SemPost
 * \sa SDL_SemTryWait
 * \sa SDL_SemValue
 * \sa SDL_SemWait
 * \sa SDL_SemWaitTimeout
 *)
  SDL_SemWait: function(sem: PSDL_sem): Integer; cdecl;

(**
 * See if a semaphore has a positive value and decrement it if it does.
 *
 * This function checks to see if the semaphore pointed to by `sem` has a
 * positive value and atomically decrements the semaphore value if it does. If
 * the semaphore doesn't have a positive value, the function immediately
 * returns SDL_MUTEX_TIMEDOUT.
 *
 * \param sem the semaphore to wait on
 * \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would
 *          block, or a negative error code on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateSemaphore
 * \sa SDL_DestroySemaphore
 * \sa SDL_SemPost
 * \sa SDL_SemValue
 * \sa SDL_SemWait
 * \sa SDL_SemWaitTimeout
 *)
  SDL_SemTryWait: function(sem: PSDL_sem): Integer; cdecl;

(**
 * Wait until a semaphore has a positive value and then decrements it.
 *
 * This function suspends the calling thread until either the semaphore
 * pointed to by `sem` has a positive value, the call is interrupted by a
 * signal or error, or the specified time has elapsed. If the call is
 * successful it will atomically decrement the semaphore value.
 *
 * \param sem the semaphore to wait on
 * \param ms the length of the timeout, in milliseconds
 * \returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not
 *          succeed in the allotted time, or a negative error code on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateSemaphore
 * \sa SDL_DestroySemaphore
 * \sa SDL_SemPost
 * \sa SDL_SemTryWait
 * \sa SDL_SemValue
 * \sa SDL_SemWait
 *)
  SDL_SemWaitTimeout: function(sem: PSDL_sem; ms: Uint32): Integer; cdecl;

(**
 * Atomically increment a semaphore's value and wake waiting threads.
 *
 * \param sem the semaphore to increment
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateSemaphore
 * \sa SDL_DestroySemaphore
 * \sa SDL_SemTryWait
 * \sa SDL_SemValue
 * \sa SDL_SemWait
 * \sa SDL_SemWaitTimeout
 *)
  SDL_SemPost: function(sem: PSDL_sem): Integer; cdecl;

(**
 * Get the current value of a semaphore.
 *
 * \param sem the semaphore to query
 * \returns the current value of the semaphore.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateSemaphore
 *)
  SDL_SemValue: function(sem: PSDL_sem): Uint32; cdecl;

(**
 * Create a condition variable.
 *
 * \returns a new condition variable or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CondBroadcast
 * \sa SDL_CondSignal
 * \sa SDL_CondWait
 * \sa SDL_CondWaitTimeout
 * \sa SDL_DestroyCond
 *)
  SDL_CreateCond: function(): PSDL_cond; cdecl;

(**
 * Destroy a condition variable.
 *
 * \param cond the condition variable to destroy
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CondBroadcast
 * \sa SDL_CondSignal
 * \sa SDL_CondWait
 * \sa SDL_CondWaitTimeout
 * \sa SDL_CreateCond
 *)
  SDL_DestroyCond: procedure(cond: PSDL_cond); cdecl;

(**
 * Restart one of the threads that are waiting on the condition variable.
 *
 * \param cond the condition variable to signal
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CondBroadcast
 * \sa SDL_CondWait
 * \sa SDL_CondWaitTimeout
 * \sa SDL_CreateCond
 * \sa SDL_DestroyCond
 *)
  SDL_CondSignal: function(cond: PSDL_cond): Integer; cdecl;

(**
 * Restart all threads that are waiting on the condition variable.
 *
 * \param cond the condition variable to signal
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CondSignal
 * \sa SDL_CondWait
 * \sa SDL_CondWaitTimeout
 * \sa SDL_CreateCond
 * \sa SDL_DestroyCond
 *)
  SDL_CondBroadcast: function(cond: PSDL_cond): Integer; cdecl;

(**
 * Wait until a condition variable is signaled.
 *
 * This function unlocks the specified `mutex` and waits for another thread to
 * call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
 * `cond`. Once the condition variable is signaled, the mutex is re-locked and
 * the function returns.
 *
 * The mutex must be locked before calling this function.
 *
 * This function is the equivalent of calling SDL_CondWaitTimeout() with a
 * time length of `SDL_MUTEX_MAXWAIT`.
 *
 * \param cond the condition variable to wait on
 * \param mutex the mutex used to coordinate thread access
 * \returns 0 when it is signaled or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CondBroadcast
 * \sa SDL_CondSignal
 * \sa SDL_CondWaitTimeout
 * \sa SDL_CreateCond
 * \sa SDL_DestroyCond
 *)
  SDL_CondWait: function(cond: PSDL_cond; mutex: PSDL_mutex): Integer; cdecl;

(**
 * Wait until a condition variable is signaled or a certain time has passed.
 *
 * This function unlocks the specified `mutex` and waits for another thread to
 * call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable
 * `cond`, or for the specified time to elapse. Once the condition variable is
 * signaled or the time elapsed, the mutex is re-locked and the function
 * returns.
 *
 * The mutex must be locked before calling this function.
 *
 * \param cond the condition variable to wait on
 * \param mutex the mutex used to coordinate thread access
 * \param ms the maximum time to wait, in milliseconds, or `SDL_MUTEX_MAXWAIT`
 *           to wait indefinitely
 * \returns 0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if
 *          the condition is not signaled in the allotted time, or a negative
 *          error code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CondBroadcast
 * \sa SDL_CondSignal
 * \sa SDL_CondWait
 * \sa SDL_CreateCond
 * \sa SDL_DestroyCond
 *)
  SDL_CondWaitTimeout: function(cond: PSDL_cond; mutex: PSDL_mutex; ms: Uint32): Integer; cdecl;

  SDL_CreateThread: function(fn: SDL_ThreadFunction; const name: PUTF8Char; data: Pointer; pfnBeginThread: pfnSDL_CurrentBeginThread; pfnEndThread: pfnSDL_CurrentEndThread): PSDL_Thread; cdecl;

  SDL_CreateThreadWithStackSize: function(fn: SDL_ThreadFunction; const name: PUTF8Char; const stacksize: NativeUInt; data: Pointer; pfnBeginThread: pfnSDL_CurrentBeginThread; pfnEndThread: pfnSDL_CurrentEndThread): PSDL_Thread; cdecl;

(**
 * Get the thread name as it was specified in SDL_CreateThread().
 *
 * This is internal memory, not to be freed by the caller, and remains valid
 * until the specified thread is cleaned up by SDL_WaitThread().
 *
 * \param thread the thread to query
 * \returns a pointer to a UTF-8 string that names the specified thread, or
 *          NULL if it doesn't have a name.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateThread
 *)
  SDL_GetThreadName: function(thread: PSDL_Thread): PUTF8Char; cdecl;

(**
 * Get the thread identifier for the current thread.
 *
 * This thread identifier is as reported by the underlying operating system.
 * If SDL is running on a platform that does not support threads the return
 * value will always be zero.
 *
 * This function also returns a valid thread ID when called from the main
 * thread.
 *
 * \returns the ID of the current thread.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetThreadID
 *)
  SDL_ThreadID: function(): SDL_threadID_; cdecl;

(**
 * Get the thread identifier for the specified thread.
 *
 * This thread identifier is as reported by the underlying operating system.
 * If SDL is running on a platform that does not support threads the return
 * value will always be zero.
 *
 * \param thread the thread to query
 * \returns the ID of the specified thread, or the ID of the current thread if
 *          `thread` is NULL.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ThreadID
 *)
  SDL_GetThreadID: function(thread: PSDL_Thread): SDL_threadID_; cdecl;

(**
 * Set the priority for the current thread.
 *
 * Note that some platforms will not let you alter the priority (or at least,
 * promote the thread to a higher priority) at all, and some require you to be
 * an administrator account. Be prepared for this to fail.
 *
 * \param priority the SDL_ThreadPriority to set
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_SetThreadPriority: function(priority: SDL_ThreadPriority): Integer; cdecl;

(**
 * Wait for a thread to finish.
 *
 * Threads that haven't been detached will remain (as a "zombie") until this
 * function cleans them up. Not doing so is a resource leak.
 *
 * Once a thread has been cleaned up through this function, the SDL_Thread
 * that references it becomes invalid and should not be referenced again. As
 * such, only one thread may call SDL_WaitThread() on another.
 *
 * The return code for the thread function is placed in the area pointed to by
 * `status`, if `status` is not NULL.
 *
 * You may not wait on a thread that has been used in a call to
 * SDL_DetachThread(). Use either that function or this one, but not both, or
 * behavior is undefined.
 *
 * It is safe to pass a NULL thread to this function; it is a no-op.
 *
 * Note that the thread pointer is freed by this function and is not valid
 * afterward.
 *
 * \param thread the SDL_Thread pointer that was returned from the
 *               SDL_CreateThread() call that started this thread
 * \param status pointer to an integer that will receive the value returned
 *               from the thread function by its 'return', or NULL to not
 *               receive such value back.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateThread
 * \sa SDL_DetachThread
 *)
  SDL_WaitThread: procedure(thread: PSDL_Thread; status: PInteger); cdecl;

(**
 * Let a thread clean up on exit without intervention.
 *
 * A thread may be "detached" to signify that it should not remain until
 * another thread has called SDL_WaitThread() on it. Detaching a thread is
 * useful for long-running threads that nothing needs to synchronize with or
 * further manage. When a detached thread is done, it simply goes away.
 *
 * There is no way to recover the return code of a detached thread. If you
 * need this, don't detach the thread and instead use SDL_WaitThread().
 *
 * Once a thread is detached, you should usually assume the SDL_Thread isn't
 * safe to reference again, as it will become invalid immediately upon the
 * detached thread's exit, instead of remaining until someone has called
 * SDL_WaitThread() to finally clean it up. As such, don't detach the same
 * thread more than once.
 *
 * If a thread has already exited when passed to SDL_DetachThread(), it will
 * stop waiting for a call to SDL_WaitThread() and clean up immediately. It is
 * not safe to detach a thread that might be used with SDL_WaitThread().
 *
 * You may not call SDL_WaitThread() on a thread that has been detached. Use
 * either that function or this one, but not both, or behavior is undefined.
 *
 * It is safe to pass NULL to this function; it is a no-op.
 *
 * \param thread the SDL_Thread pointer that was returned from the
 *               SDL_CreateThread() call that started this thread
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_CreateThread
 * \sa SDL_WaitThread
 *)
  SDL_DetachThread: procedure(thread: PSDL_Thread); cdecl;

(**
 * Create a piece of thread-local storage.
 *
 * This creates an identifier that is globally visible to all threads but
 * refers to data that is thread-specific.
 *
 * \returns the newly created thread local storage identifier or 0 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_TLSGet
 * \sa SDL_TLSSet
 *)
  SDL_TLSCreate: function(): SDL_TLSID; cdecl;

(**
 * Get the current thread's value associated with a thread local storage ID.
 *
 * \param id the thread local storage ID
 * \returns the value associated with the ID for the current thread or NULL if
 *          no value has been set; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_TLSCreate
 * \sa SDL_TLSSet
 *)
  SDL_TLSGet: function(id: SDL_TLSID): Pointer; cdecl;

type
  SDL_TLSSet_destructor = procedure(p1: Pointer); cdecl;

var
(**
 * Set the current thread's value associated with a thread local storage ID.
 *
 * The function prototype for `destructor` is:
 *
 * ```c
 * void destructor(void *value)
 * ```
 *
 * where its parameter `value` is what was passed as `value` to SDL_TLSSet().
 *
 * \param id the thread local storage ID
 * \param value the value to associate with the ID for the current thread
 * \param destructor a function called when the thread exits, to free the
 *                   value
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_TLSCreate
 * \sa SDL_TLSGet
 *)
  SDL_TLSSet: function(id: SDL_TLSID; const value: Pointer; destructor_: SDL_TLSSet_destructor): Integer; cdecl;

(**
 * Cleanup all TLS data for this thread.
 *
 * \since This function is available since SDL 2.0.16.
 *)
  SDL_TLSCleanup: procedure(); cdecl;

(**
 * Use this function to create a new SDL_RWops structure for reading from
 * and/or writing to a named file.
 *
 * The `mode` string is treated roughly the same as in a call to the C
 * library's fopen(), even if SDL doesn't happen to use fopen() behind the
 * scenes.
 *
 * Available `mode` strings:
 *
 * - "r": Open a file for reading. The file must exist.
 * - "w": Create an empty file for writing. If a file with the same name
 *   already exists its content is erased and the file is treated as a new
 *   empty file.
 * - "a": Append to a file. Writing operations append data at the end of the
 *   file. The file is created if it does not exist.
 * - "r+": Open a file for update both reading and writing. The file must
 *   exist.
 * - "w+": Create an empty file for both reading and writing. If a file with
 *   the same name already exists its content is erased and the file is
 *   treated as a new empty file.
 * - "a+": Open a file for reading and appending. All writing operations are
 *   performed at the end of the file, protecting the previous content to be
 *   overwritten. You can reposition (fseek, rewind) the internal pointer to
 *   anywhere in the file for reading, but writing operations will move it
 *   back to the end of file. The file is created if it does not exist.
 *
 * **NOTE**: In order to open a file as a binary file, a "b" character has to
 * be included in the `mode` string. This additional "b" character can either
 * be appended at the end of the string (thus making the following compound
 * modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the
 * letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").
 * Additional characters may follow the sequence, although they should have no
 * effect. For example, "t" is sometimes appended to make explicit the file is
 * a text file.
 *
 * This function supports Unicode filenames, but they must be encoded in UTF-8
 * format, regardless of the underlying operating system.
 *
 * As a fallback, SDL_RWFromFile() will transparently open a matching filename
 * in an Android app's `assets`.
 *
 * Closing the SDL_RWops will close the file handle SDL is holding internally.
 *
 * \param file a UTF-8 string representing the filename to open
 * \param mode an ASCII string representing the mode to be used for opening
 *             the file.
 * \returns a pointer to the SDL_RWops structure that is created, or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RWclose
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFP
 * \sa SDL_RWFromMem
 * \sa SDL_RWread
 * \sa SDL_RWseek
 * \sa SDL_RWtell
 * \sa SDL_RWwrite
 *)
  SDL_RWFromFile: function(const file_: PUTF8Char; const mode: PUTF8Char): PSDL_RWops; cdecl;

(**
 * Use this function to create an SDL_RWops structure from a standard I/O file
 * pointer (stdio.h's `FILE*`).
 *
 * This function is not available on Windows, since files opened in an
 * application on that platform cannot be used by a dynamically linked
 * library.
 *
 * On some platforms, the first parameter is a `void*`, on others, it's a
 * `FILE*`, depending on what system headers are available to SDL. It is
 * always intended to be the `FILE*` type from the C runtime's stdio.h.
 *
 * \param fp the `FILE*` that feeds the SDL_RWops stream
 * \param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,
 *                  SDL_FALSE to leave the `FILE*` open when the RWops is
 *                  closed
 * \returns a pointer to the SDL_RWops structure that is created, or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RWclose
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFile
 * \sa SDL_RWFromMem
 * \sa SDL_RWread
 * \sa SDL_RWseek
 * \sa SDL_RWtell
 * \sa SDL_RWwrite
 *)
  SDL_RWFromFP: function(fp: Pointer; autoclose: SDL_bool): PSDL_RWops; cdecl;

(**
 * Use this function to prepare a read-write memory buffer for use with
 * SDL_RWops.
 *
 * This function sets up an SDL_RWops struct based on a memory area of a
 * certain size, for both read and write access.
 *
 * This memory buffer is not copied by the RWops; the pointer you provide must
 * remain valid until you close the stream. Closing the stream will not free
 * the original buffer.
 *
 * If you need to make sure the RWops never writes to the memory buffer, you
 * should use SDL_RWFromConstMem() with a read-only buffer of memory instead.
 *
 * \param mem a pointer to a buffer to feed an SDL_RWops stream
 * \param size the buffer size, in bytes
 * \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RWclose
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFile
 * \sa SDL_RWFromFP
 * \sa SDL_RWFromMem
 * \sa SDL_RWread
 * \sa SDL_RWseek
 * \sa SDL_RWtell
 * \sa SDL_RWwrite
 *)
  SDL_RWFromMem: function(mem: Pointer; size: Integer): PSDL_RWops; cdecl;

(**
 * Use this function to prepare a read-only memory buffer for use with RWops.
 *
 * This function sets up an SDL_RWops struct based on a memory area of a
 * certain size. It assumes the memory area is not writable.
 *
 * Attempting to write to this RWops stream will report an error without
 * writing to the memory buffer.
 *
 * This memory buffer is not copied by the RWops; the pointer you provide must
 * remain valid until you close the stream. Closing the stream will not free
 * the original buffer.
 *
 * If you need to write to a memory buffer, you should use SDL_RWFromMem()
 * with a writable buffer of memory instead.
 *
 * \param mem a pointer to a read-only buffer to feed an SDL_RWops stream
 * \param size the buffer size, in bytes
 * \returns a pointer to a new SDL_RWops structure, or NULL if it fails; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RWclose
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFile
 * \sa SDL_RWFromFP
 * \sa SDL_RWFromMem
 * \sa SDL_RWread
 * \sa SDL_RWseek
 * \sa SDL_RWtell
 *)
  SDL_RWFromConstMem: function(const mem: Pointer; size: Integer): PSDL_RWops; cdecl;

(**
 * Use this function to allocate an empty, unpopulated SDL_RWops structure.
 *
 * Applications do not need to use this function unless they are providing
 * their own SDL_RWops implementation. If you just need a SDL_RWops to
 * read/write a common data source, you should use the built-in
 * implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.
 *
 * You must free the returned pointer with SDL_FreeRW(). Depending on your
 * operating system and compiler, there may be a difference between the
 * malloc() and free() your program uses and the versions SDL calls
 * internally. Trying to mix the two can cause crashing such as segmentation
 * faults. Since all SDL_RWops must free themselves when their **close**
 * method is called, all SDL_RWops must be allocated through this function, so
 * they can all be freed correctly with SDL_FreeRW().
 *
 * \returns a pointer to the allocated memory on success, or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FreeRW
 *)
  SDL_AllocRW: function(): PSDL_RWops; cdecl;

(**
 * Use this function to free an SDL_RWops structure allocated by
 * SDL_AllocRW().
 *
 * Applications do not need to use this function unless they are providing
 * their own SDL_RWops implementation. If you just need a SDL_RWops to
 * read/write a common data source, you should use the built-in
 * implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and
 * call the **close** method on those SDL_RWops pointers when you are done
 * with them.
 *
 * Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is
 * invalid as soon as this function returns. Any extra memory allocated during
 * creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must
 * be responsible for managing that memory in their **close** method.
 *
 * \param area the SDL_RWops structure to be freed
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AllocRW
 *)
  SDL_FreeRW: procedure(area: PSDL_RWops); cdecl;

(**
 * Use this function to get the size of the data stream in an SDL_RWops.
 *
 * Prior to SDL 2.0.10, this function was a macro.
 *
 * \param context the SDL_RWops to get the size of the data stream from
 * \returns the size of the data stream in the SDL_RWops on success, -1 if
 *          unknown or a negative error code on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RWsize: function(context: PSDL_RWops): Sint64; cdecl;

(**
 * Seek within an SDL_RWops data stream.
 *
 * This function seeks to byte `offset`, relative to `whence`.
 *
 * `whence` may be any of the following values:
 *
 * - `RW_SEEK_SET`: seek from the beginning of data
 * - `RW_SEEK_CUR`: seek relative to current read point
 * - `RW_SEEK_END`: seek relative to the end of data
 *
 * If this stream can not seek, it will return -1.
 *
 * SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's
 * `seek` method appropriately, to simplify application development.
 *
 * Prior to SDL 2.0.10, this function was a macro.
 *
 * \param context a pointer to an SDL_RWops structure
 * \param offset an offset in bytes, relative to **whence** location; can be
 *               negative
 * \param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`
 * \returns the final offset in the data stream after the seek or -1 on error.
 *
 * \since This function is available since SDL 2.0.10.
 *
 * \sa SDL_RWclose
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFile
 * \sa SDL_RWFromFP
 * \sa SDL_RWFromMem
 * \sa SDL_RWread
 * \sa SDL_RWtell
 * \sa SDL_RWwrite
 *)
  SDL_RWseek: function(context: PSDL_RWops; offset: Sint64; whence: Integer): Sint64; cdecl;

(**
 * Determine the current read/write offset in an SDL_RWops data stream.
 *
 * SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`
 * method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify
 * application development.
 *
 * Prior to SDL 2.0.10, this function was a macro.
 *
 * \param context a SDL_RWops data stream object from which to get the current
 *                offset
 * \returns the current offset in the stream, or -1 if the information can not
 *          be determined.
 *
 * \since This function is available since SDL 2.0.10.
 *
 * \sa SDL_RWclose
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFile
 * \sa SDL_RWFromFP
 * \sa SDL_RWFromMem
 * \sa SDL_RWread
 * \sa SDL_RWseek
 * \sa SDL_RWwrite
 *)
  SDL_RWtell: function(context: PSDL_RWops): Sint64; cdecl;

(**
 * Read from a data source.
 *
 * This function reads up to `maxnum` objects each of size `size` from the
 * data source to the area pointed at by `ptr`. This function may read less
 * objects than requested. It will return zero when there has been an error or
 * the data stream is completely read.
 *
 * SDL_RWread() is actually a function wrapper that calls the SDL_RWops's
 * `read` method appropriately, to simplify application development.
 *
 * Prior to SDL 2.0.10, this function was a macro.
 *
 * \param context a pointer to an SDL_RWops structure
 * \param ptr a pointer to a buffer to read data into
 * \param size the size of each object to read, in bytes
 * \param maxnum the maximum number of objects to be read
 * \returns the number of objects read, or 0 at error or end of file; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.10.
 *
 * \sa SDL_RWclose
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFile
 * \sa SDL_RWFromFP
 * \sa SDL_RWFromMem
 * \sa SDL_RWseek
 * \sa SDL_RWwrite
 *)
  SDL_RWread: function(context: PSDL_RWops; ptr: Pointer; size: NativeUInt; maxnum: NativeUInt): NativeUInt; cdecl;

(**
 * Write to an SDL_RWops data stream.
 *
 * This function writes exactly `num` objects each of size `size` from the
 * area pointed at by `ptr` to the stream. If this fails for any reason, it'll
 * return less than `num` to demonstrate how far the write progressed. On
 * success, it returns `num`.
 *
 * SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's
 * `write` method appropriately, to simplify application development.
 *
 * Prior to SDL 2.0.10, this function was a macro.
 *
 * \param context a pointer to an SDL_RWops structure
 * \param ptr a pointer to a buffer containing data to write
 * \param size the size of an object to write, in bytes
 * \param num the number of objects to write
 * \returns the number of objects written, which will be less than **num** on
 *          error; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.10.
 *
 * \sa SDL_RWclose
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFile
 * \sa SDL_RWFromFP
 * \sa SDL_RWFromMem
 * \sa SDL_RWread
 * \sa SDL_RWseek
 *)
  SDL_RWwrite: function(context: PSDL_RWops; const ptr: Pointer; size: NativeUInt; num: NativeUInt): NativeUInt; cdecl;

(**
 * Close and free an allocated SDL_RWops structure.
 *
 * SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any
 * resources used by the stream and frees the SDL_RWops itself with
 * SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to
 * flush to its output (e.g. to disk).
 *
 * Note that if this fails to flush the stream to disk, this function reports
 * an error, but the SDL_RWops is still invalid once this function returns.
 *
 * Prior to SDL 2.0.10, this function was a macro.
 *
 * \param context SDL_RWops structure to close
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.10.
 *
 * \sa SDL_RWFromConstMem
 * \sa SDL_RWFromFile
 * \sa SDL_RWFromFP
 * \sa SDL_RWFromMem
 * \sa SDL_RWread
 * \sa SDL_RWseek
 * \sa SDL_RWwrite
 *)
  SDL_RWclose: function(context: PSDL_RWops): Integer; cdecl;

(**
 * Load all the data from an SDL data stream.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported via
 * `datasize`.
 *
 * The data should be freed with SDL_free().
 *
 * \param src the SDL_RWops to read all available data from
 * \param datasize if not NULL, will store the number of bytes read
 * \param freesrc if non-zero, calls SDL_RWclose() on `src` before returning
 * \returns the data, or NULL if there was an error.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_LoadFile_RW: function(src: PSDL_RWops; datasize: PNativeUInt; freesrc: Integer): Pointer; cdecl;

(**
 * Load all the data from a file path.
 *
 * The data is allocated with a zero byte at the end (null terminated) for
 * convenience. This extra byte is not included in the value reported via
 * `datasize`.
 *
 * The data should be freed with SDL_free().
 *
 * Prior to SDL 2.0.10, this function was a macro wrapping around
 * SDL_LoadFile_RW.
 *
 * \param file the path to read all available data from
 * \param datasize if not NULL, will store the number of bytes read
 * \returns the data, or NULL if there was an error.
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_LoadFile: function(const file_: PUTF8Char; datasize: PNativeUInt): Pointer; cdecl;

(**
 * Use this function to read a byte from an SDL_RWops.
 *
 * \param src the SDL_RWops to read from
 * \returns the read byte on success or 0 on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WriteU8
 *)
  SDL_ReadU8: function(src: PSDL_RWops): Uint8; cdecl;

(**
 * Use this function to read 16 bits of little-endian data from an SDL_RWops
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * \param src the stream from which to read data
 * \returns 16 bits of data in the native byte order of the platform.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ReadBE16
 *)
  SDL_ReadLE16: function(src: PSDL_RWops): Uint16; cdecl;

(**
 * Use this function to read 16 bits of big-endian data from an SDL_RWops and
 * return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * \param src the stream from which to read data
 * \returns 16 bits of data in the native byte order of the platform.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ReadLE16
 *)
  SDL_ReadBE16: function(src: PSDL_RWops): Uint16; cdecl;

(**
 * Use this function to read 32 bits of little-endian data from an SDL_RWops
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * \param src the stream from which to read data
 * \returns 32 bits of data in the native byte order of the platform.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ReadBE32
 *)
  SDL_ReadLE32: function(src: PSDL_RWops): Uint32; cdecl;

(**
 * Use this function to read 32 bits of big-endian data from an SDL_RWops and
 * return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * \param src the stream from which to read data
 * \returns 32 bits of data in the native byte order of the platform.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ReadLE32
 *)
  SDL_ReadBE32: function(src: PSDL_RWops): Uint32; cdecl;

(**
 * Use this function to read 64 bits of little-endian data from an SDL_RWops
 * and return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * \param src the stream from which to read data
 * \returns 64 bits of data in the native byte order of the platform.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ReadBE64
 *)
  SDL_ReadLE64: function(src: PSDL_RWops): Uint64; cdecl;

(**
 * Use this function to read 64 bits of big-endian data from an SDL_RWops and
 * return in native format.
 *
 * SDL byteswaps the data only if necessary, so the data returned will be in
 * the native byte order.
 *
 * \param src the stream from which to read data
 * \returns 64 bits of data in the native byte order of the platform.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ReadLE64
 *)
  SDL_ReadBE64: function(src: PSDL_RWops): Uint64; cdecl;

(**
 * Use this function to write a byte to an SDL_RWops.
 *
 * \param dst the SDL_RWops to write to
 * \param value the byte value to write
 * \returns 1 on success or 0 on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ReadU8
 *)
  SDL_WriteU8: function(dst: PSDL_RWops; value: Uint8): NativeUInt; cdecl;

(**
 * Use this function to write 16 bits in native format to a SDL_RWops as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written
 * \param value the data to be written, in native format
 * \returns 1 on successful write, 0 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WriteBE16
 *)
  SDL_WriteLE16: function(dst: PSDL_RWops; value: Uint16): NativeUInt; cdecl;

(**
 * Use this function to write 16 bits in native format to a SDL_RWops as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written
 * \param value the data to be written, in native format
 * \returns 1 on successful write, 0 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WriteLE16
 *)
  SDL_WriteBE16: function(dst: PSDL_RWops; value: Uint16): NativeUInt; cdecl;

(**
 * Use this function to write 32 bits in native format to a SDL_RWops as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written
 * \param value the data to be written, in native format
 * \returns 1 on successful write, 0 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WriteBE32
 *)
  SDL_WriteLE32: function(dst: PSDL_RWops; value: Uint32): NativeUInt; cdecl;

(**
 * Use this function to write 32 bits in native format to a SDL_RWops as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written
 * \param value the data to be written, in native format
 * \returns 1 on successful write, 0 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WriteLE32
 *)
  SDL_WriteBE32: function(dst: PSDL_RWops; value: Uint32): NativeUInt; cdecl;

(**
 * Use this function to write 64 bits in native format to a SDL_RWops as
 * little-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in little-endian
 * format.
 *
 * \param dst the stream to which data will be written
 * \param value the data to be written, in native format
 * \returns 1 on successful write, 0 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WriteBE64
 *)
  SDL_WriteLE64: function(dst: PSDL_RWops; value: Uint64): NativeUInt; cdecl;

(**
 * Use this function to write 64 bits in native format to a SDL_RWops as
 * big-endian data.
 *
 * SDL byteswaps the data only if necessary, so the application always
 * specifies native format, and the data written will be in big-endian format.
 *
 * \param dst the stream to which data will be written
 * \param value the data to be written, in native format
 * \returns 1 on successful write, 0 on error.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WriteLE64
 *)
  SDL_WriteBE64: function(dst: PSDL_RWops; value: Uint64): NativeUInt; cdecl;

(**
 * Use this function to get the number of built-in audio drivers.
 *
 * This function returns a hardcoded number. This never returns a negative
 * value; if there are no drivers compiled into this build of SDL, this
 * function returns zero. The presence of a driver in this list does not mean
 * it will function, it just means SDL is capable of interacting with that
 * interface. For example, a build of SDL might have esound support, but if
 * there's no esound server available, SDL's esound driver would fail if used.
 *
 * By default, SDL tries all drivers, in its preferred order, until one is
 * found to be usable.
 *
 * \returns the number of built-in audio drivers.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetAudioDriver
 *)
  SDL_GetNumAudioDrivers: function(): Integer; cdecl;

(**
 * Use this function to get the name of a built in audio driver.
 *
 * The list of audio drivers is given in the order that they are normally
 * initialized by default; the drivers that seem more reasonable to choose
 * first (as far as the SDL developers believe) are earlier in the list.
 *
 * The names of drivers are all simple, low-ASCII identifiers, like "alsa",
 * "coreaudio" or "xaudio2". These never have Unicode characters, and are not
 * meant to be proper names.
 *
 * \param index the index of the audio driver; the value ranges from 0 to
 *              SDL_GetNumAudioDrivers() - 1
 * \returns the name of the audio driver at the requested index, or NULL if an
 *          invalid index was specified.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumAudioDrivers
 *)
  SDL_GetAudioDriver: function(index: Integer): PUTF8Char; cdecl;

(**
 * Use this function to initialize a particular audio driver.
 *
 * This function is used internally, and should not be used unless you have a
 * specific need to designate the audio driver you want to use. You should
 * normally use SDL_Init() or SDL_InitSubSystem().
 *
 * \param driver_name the name of the desired audio driver
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AudioQuit
 *)
  SDL_AudioInit: function(const driver_name: PUTF8Char): Integer; cdecl;

(**
 * Use this function to shut down audio if you initialized it with
 * SDL_AudioInit().
 *
 * This function is used internally, and should not be used unless you have a
 * specific need to specify the audio driver you want to use. You should
 * normally use SDL_Quit() or SDL_QuitSubSystem().
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AudioInit
 *)
  SDL_AudioQuit: procedure(); cdecl;

(**
 * Get the name of the current audio driver.
 *
 * The returned string points to internal static memory and thus never becomes
 * invalid, even if you quit the audio subsystem and initialize a new driver
 * (although such a case would return a different static string from another
 * call to this function, of course). As such, you should not modify or free
 * the returned string.
 *
 * \returns the name of the current audio driver or NULL if no driver has been
 *          initialized.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AudioInit
 *)
  SDL_GetCurrentAudioDriver: function(): PUTF8Char; cdecl;

(**
 * This function is a legacy means of opening the audio device.
 *
 * This function remains for compatibility with SDL 1.2, but also because it's
 * slightly easier to use than the new functions in SDL 2.0. The new, more
 * powerful, and preferred way to do this is SDL_OpenAudioDevice().
 *
 * This function is roughly equivalent to:
 *
 * ```c
 * SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);
 * ```
 *
 * With two notable exceptions:
 *
 * - If `obtained` is NULL, we use `desired` (and allow no changes), which
 *   means desired will be modified to have the correct values for silence,
 *   etc, and SDL will convert any differences between your app's specific
 *   request and the hardware behind the scenes.
 * - The return value is always success or failure, and not a device ID, which
 *   means you can only have one device open at a time with this function.
 *
 * \param desired an SDL_AudioSpec structure representing the desired output
 *                format. Please refer to the SDL_OpenAudioDevice
 *                documentation for details on how to prepare this structure.
 * \param obtained an SDL_AudioSpec structure filled in with the actual
 *                 parameters, or NULL.
 * \returns 0 if successful, placing the actual hardware parameters in the
 *          structure pointed to by `obtained`.
 *
 *          If `obtained` is NULL, the audio data passed to the callback
 *          function will be guaranteed to be in the requested format, and
 *          will be automatically converted to the actual hardware audio
 *          format if necessary. If `obtained` is NULL, `desired` will have
 *          fields modified.
 *
 *          This function returns a negative error code on failure to open the
 *          audio device or failure to set up the audio thread; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CloseAudio
 * \sa SDL_LockAudio
 * \sa SDL_PauseAudio
 * \sa SDL_UnlockAudio
 *)
  SDL_OpenAudio: function(desired: PSDL_AudioSpec; obtained: PSDL_AudioSpec): Integer; cdecl;

(**
 * Get the number of built-in audio devices.
 *
 * This function is only valid after successfully initializing the audio
 * subsystem.
 *
 * Note that audio capture support is not implemented as of SDL 2.0.4, so the
 * `iscapture` parameter is for future expansion and should always be zero for
 * now.
 *
 * This function will return -1 if an explicit list of devices can't be
 * determined. Returning -1 is not an error. For example, if SDL is set up to
 * talk to a remote audio server, it can't list every one available on the
 * Internet, but it will still allow a specific host to be specified in
 * SDL_OpenAudioDevice().
 *
 * In many common cases, when this function returns a value <= 0, it can still
 * successfully open the default device (NULL for first argument of
 * SDL_OpenAudioDevice()).
 *
 * This function may trigger a complete redetect of available hardware. It
 * should not be called for each iteration of a loop, but rather once at the
 * start of a loop:
 *
 * ```c
 * // Don't do this:
 * for (int i = 0; i < SDL_GetNumAudioDevices(0); i++)
 *
 * // do this instead:
 * const int count = SDL_GetNumAudioDevices(0);
 * for (int i = 0; i < count; ++i) { do_something_here(); }
 * ```
 *
 * \param iscapture zero to request playback devices, non-zero to request
 *                  recording devices
 * \returns the number of available devices exposed by the current driver or
 *          -1 if an explicit list of devices can't be determined. A return
 *          value of -1 does not necessarily mean an error condition.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetAudioDeviceName
 * \sa SDL_OpenAudioDevice
 *)
  SDL_GetNumAudioDevices: function(iscapture: Integer): Integer; cdecl;

(**
 * Get the human-readable name of a specific audio device.
 *
 * This function is only valid after successfully initializing the audio
 * subsystem. The values returned by this function reflect the latest call to
 * SDL_GetNumAudioDevices(); re-call that function to redetect available
 * hardware.
 *
 * The string returned by this function is UTF-8 encoded, read-only, and
 * managed internally. You are not to free it. If you need to keep the string
 * for any length of time, you should make your own copy of it, as it will be
 * invalid next time any of several other SDL functions are called.
 *
 * \param index the index of the audio device; valid values range from 0 to
 *              SDL_GetNumAudioDevices() - 1
 * \param iscapture non-zero to query the list of recording devices, zero to
 *                  query the list of output devices.
 * \returns the name of the audio device at the requested index, or NULL on
 *          error.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumAudioDevices
 * \sa SDL_GetDefaultAudioInfo
 *)
  SDL_GetAudioDeviceName: function(index: Integer; iscapture: Integer): PUTF8Char; cdecl;

(**
 * Get the preferred audio format of a specific audio device.
 *
 * This function is only valid after a successfully initializing the audio
 * subsystem. The values returned by this function reflect the latest call to
 * SDL_GetNumAudioDevices(); re-call that function to redetect available
 * hardware.
 *
 * `spec` will be filled with the sample rate, sample format, and channel
 * count.
 *
 * \param index the index of the audio device; valid values range from 0 to
 *              SDL_GetNumAudioDevices() - 1
 * \param iscapture non-zero to query the list of recording devices, zero to
 *                  query the list of output devices.
 * \param spec The SDL_AudioSpec to be initialized by this function.
 * \returns 0 on success, nonzero on error
 *
 * \since This function is available since SDL 2.0.16.
 *
 * \sa SDL_GetNumAudioDevices
 * \sa SDL_GetDefaultAudioInfo
 *)
  SDL_GetAudioDeviceSpec: function(index: Integer; iscapture: Integer; spec: PSDL_AudioSpec): Integer; cdecl;

(**
 * Get the name and preferred format of the default audio device.
 *
 * Some (but not all!) platforms have an isolated mechanism to get information
 * about the "default" device. This can actually be a completely different
 * device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can
 * even be a network address! (This is discussed in SDL_OpenAudioDevice().)
 *
 * As a result, this call is not guaranteed to be performant, as it can query
 * the sound server directly every time, unlike the other query functions. You
 * should call this function sparingly!
 *
 * `spec` will be filled with the sample rate, sample format, and channel
 * count, if a default device exists on the system. If `name` is provided,
 * will be filled with either a dynamically-allocated UTF-8 string or NULL.
 *
 * \param name A pointer to be filled with the name of the default device (can
 *             be NULL). Please call SDL_free() when you are done with this
 *             pointer!
 * \param spec The SDL_AudioSpec to be initialized by this function.
 * \param iscapture non-zero to query the default recording device, zero to
 *                  query the default output device.
 * \returns 0 on success, nonzero on error
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GetAudioDeviceName
 * \sa SDL_GetAudioDeviceSpec
 * \sa SDL_OpenAudioDevice
 *)
  SDL_GetDefaultAudioInfo: function(name: PPUTF8Char; spec: PSDL_AudioSpec; iscapture: Integer): Integer; cdecl;

(**
 * Open a specific audio device.
 *
 * SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,
 * this function will never return a 1 so as not to conflict with the legacy
 * function.
 *
 * Please note that SDL 2.0 before 2.0.5 did not support recording; as such,
 * this function would fail if `iscapture` was not zero. Starting with SDL
 * 2.0.5, recording is implemented and this value can be non-zero.
 *
 * Passing in a `device` name of NULL requests the most reasonable default
 * (and is equivalent to what SDL_OpenAudio() does to choose a device). The
 * `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
 * some drivers allow arbitrary and driver-specific strings, such as a
 * hostname/IP address for a remote audio server, or a filename in the
 * diskaudio driver.
 *
 * An opened audio device starts out paused, and should be enabled for playing
 * by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio
 * callback function to be called. Since the audio driver may modify the
 * requested size of the audio buffer, you should allocate any local mixing
 * buffers after you open the audio device.
 *
 * The audio callback runs in a separate thread in most cases; you can prevent
 * race conditions between your callback and other threads without fully
 * pausing playback with SDL_LockAudioDevice(). For more information about the
 * callback, see SDL_AudioSpec.
 *
 * Managing the audio spec via 'desired' and 'obtained':
 *
 * When filling in the desired audio spec structure:
 *
 * - `desired->freq` should be the frequency in sample-frames-per-second (Hz).
 * - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).
 * - `desired->samples` is the desired size of the audio buffer, in _sample
 *   frames_ (with stereo output, two samples--left and right--would make a
 *   single sample frame). This number should be a power of two, and may be
 *   adjusted by the audio driver to a value more suitable for the hardware.
 *   Good values seem to range between 512 and 8096 inclusive, depending on
 *   the application and CPU speed. Smaller values reduce latency, but can
 *   lead to underflow if the application is doing heavy processing and cannot
 *   fill the audio buffer in time. Note that the number of sample frames is
 *   directly related to time by the following formula: `ms =
 *   (sampleframes*1000)/freq`
 * - `desired->size` is the size in _bytes_ of the audio buffer, and is
 *   calculated by SDL_OpenAudioDevice(). You don't initialize this.
 * - `desired->silence` is the value used to set the buffer to silence, and is
 *   calculated by SDL_OpenAudioDevice(). You don't initialize this.
 * - `desired->callback` should be set to a function that will be called when
 *   the audio device is ready for more data. It is passed a pointer to the
 *   audio buffer, and the length in bytes of the audio buffer. This function
 *   usually runs in a separate thread, and so you should protect data
 *   structures that it accesses by calling SDL_LockAudioDevice() and
 *   SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL
 *   pointer here, and call SDL_QueueAudio() with some frequency, to queue
 *   more audio samples to be played (or for capture devices, call
 *   SDL_DequeueAudio() with some frequency, to obtain audio samples).
 * - `desired->userdata` is passed as the first parameter to your callback
 *   function. If you passed a NULL callback, this value is ignored.
 *
 * `allowed_changes` can have the following flags OR'd together:
 *
 * - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`
 * - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`
 * - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`
 * - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`
 * - `SDL_AUDIO_ALLOW_ANY_CHANGE`
 *
 * These flags specify how SDL should behave when a device cannot offer a
 * specific feature. If the application requests a feature that the hardware
 * doesn't offer, SDL will always try to get the closest equivalent.
 *
 * For example, if you ask for float32 audio format, but the sound card only
 * supports int16, SDL will set the hardware to int16. If you had set
 * SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`
 * structure. If that flag was *not* set, SDL will prepare to convert your
 * callback's float32 audio to int16 before feeding it to the hardware and
 * will keep the originally requested format in the `obtained` structure.
 *
 * The resulting audio specs, varying depending on hardware and on what
 * changes were allowed, will then be written back to `obtained`.
 *
 * If your application can only handle one specific data format, pass a zero
 * for `allowed_changes` and let SDL transparently handle any differences.
 *
 * \param device a UTF-8 string reported by SDL_GetAudioDeviceName() or a
 *               driver-specific name as appropriate. NULL requests the most
 *               reasonable default device.
 * \param iscapture non-zero to specify a device should be opened for
 *                  recording, not playback
 * \param desired an SDL_AudioSpec structure representing the desired output
 *                format; see SDL_OpenAudio() for more information
 * \param obtained an SDL_AudioSpec structure filled in with the actual output
 *                 format; see SDL_OpenAudio() for more information
 * \param allowed_changes 0, or one or more flags OR'd together
 * \returns a valid device ID that is > 0 on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 *          For compatibility with SDL 1.2, this will never return 1, since
 *          SDL reserves that ID for the legacy SDL_OpenAudio() function.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CloseAudioDevice
 * \sa SDL_GetAudioDeviceName
 * \sa SDL_LockAudioDevice
 * \sa SDL_OpenAudio
 * \sa SDL_PauseAudioDevice
 * \sa SDL_UnlockAudioDevice
 *)
  SDL_OpenAudioDevice: function(const device: PUTF8Char; iscapture: Integer; const desired: PSDL_AudioSpec; obtained: PSDL_AudioSpec; allowed_changes: Integer): SDL_AudioDeviceID; cdecl;

(**
 * This function is a legacy means of querying the audio device.
 *
 * New programs might want to use SDL_GetAudioDeviceStatus() instead. This
 * function is equivalent to calling...
 *
 * ```c
 * SDL_GetAudioDeviceStatus(1);
 * ```
 *
 * ...and is only useful if you used the legacy SDL_OpenAudio() function.
 *
 * \returns the SDL_AudioStatus of the audio device opened by SDL_OpenAudio().
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetAudioDeviceStatus
 *)
  SDL_GetAudioStatus: function(): SDL_AudioStatus; cdecl;

(**
 * Use this function to get the current audio state of an audio device.
 *
 * \param dev the ID of an audio device previously opened with
 *            SDL_OpenAudioDevice()
 * \returns the SDL_AudioStatus of the specified audio device.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PauseAudioDevice
 *)
  SDL_GetAudioDeviceStatus: function(dev: SDL_AudioDeviceID): SDL_AudioStatus; cdecl;

(**
 * This function is a legacy means of pausing the audio device.
 *
 * New programs might want to use SDL_PauseAudioDevice() instead. This
 * function is equivalent to calling...
 *
 * ```c
 * SDL_PauseAudioDevice(1, pause_on);
 * ```
 *
 * ...and is only useful if you used the legacy SDL_OpenAudio() function.
 *
 * \param pause_on non-zero to pause, 0 to unpause
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetAudioStatus
 * \sa SDL_PauseAudioDevice
 *)
  SDL_PauseAudio: procedure(pause_on: Integer); cdecl;

(**
 * Use this function to pause and unpause audio playback on a specified
 * device.
 *
 * This function pauses and unpauses the audio callback processing for a given
 * device. Newly-opened audio devices start in the paused state, so you must
 * call this function with **pause_on**=0 after opening the specified audio
 * device to start playing sound. This allows you to safely initialize data
 * for your callback function after opening the audio device. Silence will be
 * written to the audio device while paused, and the audio callback is
 * guaranteed to not be called. Pausing one device does not prevent other
 * unpaused devices from running their callbacks.
 *
 * Pausing state does not stack; even if you pause a device several times, a
 * single unpause will start the device playing again, and vice versa. This is
 * different from how SDL_LockAudioDevice() works.
 *
 * If you just need to protect a few variables from race conditions vs your
 * callback, you shouldn't pause the audio device, as it will lead to dropouts
 * in the audio playback. Instead, you should use SDL_LockAudioDevice().
 *
 * \param dev a device opened by SDL_OpenAudioDevice()
 * \param pause_on non-zero to pause, 0 to unpause
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LockAudioDevice
 *)
  SDL_PauseAudioDevice: procedure(dev: SDL_AudioDeviceID; pause_on: Integer); cdecl;

(**
 * Load the audio data of a WAVE file into memory.
 *
 * Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to
 * be valid pointers. The entire data portion of the file is then loaded into
 * memory and decoded if necessary.
 *
 * If `freesrc` is non-zero, the data source gets automatically closed and
 * freed before the function returns.
 *
 * Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and
 * 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and
 * A-law and mu-law (8 bits). Other formats are currently unsupported and
 * cause an error.
 *
 * If this function succeeds, the pointer returned by it is equal to `spec`
 * and the pointer to the audio data allocated by the function is written to
 * `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec
 * members `freq`, `channels`, and `format` are set to the values of the audio
 * data in the buffer. The `samples` member is set to a sane default and all
 * others are set to zero.
 *
 * It's necessary to use SDL_FreeWAV() to free the audio data returned in
 * `audio_buf` when it is no longer used.
 *
 * Because of the underspecification of the .WAV format, there are many
 * problematic files in the wild that cause issues with strict decoders. To
 * provide compatibility with these files, this decoder is lenient in regards
 * to the truncation of the file, the fact chunk, and the size of the RIFF
 * chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,
 * `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to
 * tune the behavior of the loading process.
 *
 * Any file that is invalid (due to truncation, corruption, or wrong values in
 * the headers), too big, or unsupported causes an error. Additionally, any
 * critical I/O error from the data source will terminate the loading process
 * with an error. The function returns NULL on error and in all cases (with
 * the exception of `src` being NULL), an appropriate error message will be
 * set.
 *
 * It is required that the data source supports seeking.
 *
 * Example:
 *
 * ```c
 * SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, &spec, &buf, &len);
 * ```
 *
 * Note that the SDL_LoadWAV macro does this same thing for you, but in a less
 * messy way:
 *
 * ```c
 * SDL_LoadWAV("sample.wav", &spec, &buf, &len);
 * ```
 *
 * \param src The data source for the WAVE data
 * \param freesrc If non-zero, SDL will _always_ free the data source
 * \param spec An SDL_AudioSpec that will be filled in with the wave file's
 *             format details
 * \param audio_buf A pointer filled with the audio data, allocated by the
 *                  function.
 * \param audio_len A pointer filled with the length of the audio data buffer
 *                  in bytes
 * \returns This function, if successfully called, returns `spec`, which will
 *          be filled with the audio data format of the wave source data.
 *          `audio_buf` will be filled with a pointer to an allocated buffer
 *          containing the audio data, and `audio_len` is filled with the
 *          length of that audio buffer in bytes.
 *
 *          This function returns NULL if the .WAV file cannot be opened, uses
 *          an unknown data format, or is corrupt; call SDL_GetError() for
 *          more information.
 *
 *          When the application is done with the data returned in
 *          `audio_buf`, it should call SDL_FreeWAV() to dispose of it.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FreeWAV
 * \sa SDL_LoadWAV
 *)
  SDL_LoadWAV_RW: function(src: PSDL_RWops; freesrc: Integer; spec: PSDL_AudioSpec; audio_buf: PPUint8; audio_len: PUint32): PSDL_AudioSpec; cdecl;

(**
 * Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().
 *
 * After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()
 * its data can eventually be freed with SDL_FreeWAV(). It is safe to call
 * this function with a NULL pointer.
 *
 * \param audio_buf a pointer to the buffer created by SDL_LoadWAV() or
 *                  SDL_LoadWAV_RW()
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LoadWAV
 * \sa SDL_LoadWAV_RW
 *)
  SDL_FreeWAV: procedure(audio_buf: PUint8); cdecl;

(**
 * Initialize an SDL_AudioCVT structure for conversion.
 *
 * Before an SDL_AudioCVT structure can be used to convert audio data it must
 * be initialized with source and destination information.
 *
 * This function will zero out every field of the SDL_AudioCVT, so it must be
 * called before the application fills in the final buffer information.
 *
 * Once this function has returned successfully, and reported that a
 * conversion is necessary, the application fills in the rest of the fields in
 * SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,
 * and then can call SDL_ConvertAudio() to complete the conversion.
 *
 * \param cvt an SDL_AudioCVT structure filled in with audio conversion
 *            information
 * \param src_format the source format of the audio data; for more info see
 *                   SDL_AudioFormat
 * \param src_channels the number of channels in the source
 * \param src_rate the frequency (sample-frames-per-second) of the source
 * \param dst_format the destination format of the audio data; for more info
 *                   see SDL_AudioFormat
 * \param dst_channels the number of channels in the destination
 * \param dst_rate the frequency (sample-frames-per-second) of the destination
 * \returns 1 if the audio filter is prepared, 0 if no conversion is needed,
 *          or a negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ConvertAudio
 *)
  SDL_BuildAudioCVT: function(cvt: PSDL_AudioCVT; src_format: SDL_AudioFormat; src_channels: Uint8; src_rate: Integer; dst_format: SDL_AudioFormat; dst_channels: Uint8; dst_rate: Integer): Integer; cdecl;

(**
 * Convert audio data to a desired audio format.
 *
 * This function does the actual audio data conversion, after the application
 * has called SDL_BuildAudioCVT() to prepare the conversion information and
 * then filled in the buffer details.
 *
 * Once the application has initialized the `cvt` structure using
 * SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio
 * data in the source format, this function will convert the buffer, in-place,
 * to the desired format.
 *
 * The data conversion may go through several passes; any given pass may
 * possibly temporarily increase the size of the data. For example, SDL might
 * expand 16-bit data to 32 bits before resampling to a lower frequency,
 * shrinking the data size after having grown it briefly. Since the supplied
 * buffer will be both the source and destination, converting as necessary
 * in-place, the application must allocate a buffer that will fully contain
 * the data during its largest conversion pass. After SDL_BuildAudioCVT()
 * returns, the application should set the `cvt->len` field to the size, in
 * bytes, of the source data, and allocate a buffer that is `cvt->len *
 * cvt->len_mult` bytes long for the `buf` field.
 *
 * The source data should be copied into this buffer before the call to
 * SDL_ConvertAudio(). Upon successful return, this buffer will contain the
 * converted audio, and `cvt->len_cvt` will be the size of the converted data,
 * in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once
 * this function returns.
 *
 * \param cvt an SDL_AudioCVT structure that was previously set up by
 *            SDL_BuildAudioCVT().
 * \returns 0 if the conversion was completed successfully or a negative error
 *          code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BuildAudioCVT
 *)
  SDL_ConvertAudio: function(cvt: PSDL_AudioCVT): Integer; cdecl;

(**
 * Create a new audio stream.
 *
 * \param src_format The format of the source audio
 * \param src_channels The number of channels of the source audio
 * \param src_rate The sampling rate of the source audio
 * \param dst_format The format of the desired audio output
 * \param dst_channels The number of channels of the desired audio output
 * \param dst_rate The sampling rate of the desired audio output
 * \returns 0 on success, or -1 on error.
 *
 * \since This function is available since SDL 2.0.7.
 *
 * \sa SDL_AudioStreamPut
 * \sa SDL_AudioStreamGet
 * \sa SDL_AudioStreamAvailable
 * \sa SDL_AudioStreamFlush
 * \sa SDL_AudioStreamClear
 * \sa SDL_FreeAudioStream
 *)
  SDL_NewAudioStream: function(const src_format: SDL_AudioFormat; const src_channels: Uint8; const src_rate: Integer; const dst_format: SDL_AudioFormat; const dst_channels: Uint8; const dst_rate: Integer): PSDL_AudioStream; cdecl;

(**
 * Add data to be converted/resampled to the stream.
 *
 * \param stream The stream the audio data is being added to
 * \param buf A pointer to the audio data to add
 * \param len The number of bytes to write to the stream
 * \returns 0 on success, or -1 on error.
 *
 * \since This function is available since SDL 2.0.7.
 *
 * \sa SDL_NewAudioStream
 * \sa SDL_AudioStreamGet
 * \sa SDL_AudioStreamAvailable
 * \sa SDL_AudioStreamFlush
 * \sa SDL_AudioStreamClear
 * \sa SDL_FreeAudioStream
 *)
  SDL_AudioStreamPut: function(stream: PSDL_AudioStream; const buf: Pointer; len: Integer): Integer; cdecl;

(**
 * Get converted/resampled data from the stream
 *
 * \param stream The stream the audio is being requested from
 * \param buf A buffer to fill with audio data
 * \param len The maximum number of bytes to fill
 * \returns the number of bytes read from the stream, or -1 on error
 *
 * \since This function is available since SDL 2.0.7.
 *
 * \sa SDL_NewAudioStream
 * \sa SDL_AudioStreamPut
 * \sa SDL_AudioStreamAvailable
 * \sa SDL_AudioStreamFlush
 * \sa SDL_AudioStreamClear
 * \sa SDL_FreeAudioStream
 *)
  SDL_AudioStreamGet: function(stream: PSDL_AudioStream; buf: Pointer; len: Integer): Integer; cdecl;

(**
 * Get the number of converted/resampled bytes available.
 *
 * The stream may be buffering data behind the scenes until it has enough to
 * resample correctly, so this number might be lower than what you expect, or
 * even be zero. Add more data or flush the stream if you need the data now.
 *
 * \since This function is available since SDL 2.0.7.
 *
 * \sa SDL_NewAudioStream
 * \sa SDL_AudioStreamPut
 * \sa SDL_AudioStreamGet
 * \sa SDL_AudioStreamFlush
 * \sa SDL_AudioStreamClear
 * \sa SDL_FreeAudioStream
 *)
  SDL_AudioStreamAvailable: function(stream: PSDL_AudioStream): Integer; cdecl;

(**
 * Tell the stream that you're done sending data, and anything being buffered
 * should be converted/resampled and made available immediately.
 *
 * It is legal to add more data to a stream after flushing, but there will be
 * audio gaps in the output. Generally this is intended to signal the end of
 * input, so the complete output becomes available.
 *
 * \since This function is available since SDL 2.0.7.
 *
 * \sa SDL_NewAudioStream
 * \sa SDL_AudioStreamPut
 * \sa SDL_AudioStreamGet
 * \sa SDL_AudioStreamAvailable
 * \sa SDL_AudioStreamClear
 * \sa SDL_FreeAudioStream
 *)
  SDL_AudioStreamFlush: function(stream: PSDL_AudioStream): Integer; cdecl;

(**
 * Clear any pending data in the stream without converting it
 *
 * \since This function is available since SDL 2.0.7.
 *
 * \sa SDL_NewAudioStream
 * \sa SDL_AudioStreamPut
 * \sa SDL_AudioStreamGet
 * \sa SDL_AudioStreamAvailable
 * \sa SDL_AudioStreamFlush
 * \sa SDL_FreeAudioStream
 *)
  SDL_AudioStreamClear: procedure(stream: PSDL_AudioStream); cdecl;

(**
 * Free an audio stream
 *
 * \since This function is available since SDL 2.0.7.
 *
 * \sa SDL_NewAudioStream
 * \sa SDL_AudioStreamPut
 * \sa SDL_AudioStreamGet
 * \sa SDL_AudioStreamAvailable
 * \sa SDL_AudioStreamFlush
 * \sa SDL_AudioStreamClear
 *)
  SDL_FreeAudioStream: procedure(stream: PSDL_AudioStream); cdecl;

(**
 * This function is a legacy means of mixing audio.
 *
 * This function is equivalent to calling...
 *
 * ```c
 * SDL_MixAudioFormat(dst, src, format, len, volume);
 * ```
 *
 * ...where `format` is the obtained format of the audio device from the
 * legacy SDL_OpenAudio() function.
 *
 * \param dst the destination for the mixed audio
 * \param src the source audio buffer to be mixed
 * \param len the length of the audio buffer in bytes
 * \param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME
 *               for full audio volume
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_MixAudioFormat
 *)
  SDL_MixAudio: procedure(dst: PUint8; const src: PUint8; len: Uint32; volume: Integer); cdecl;

(**
 * Mix audio data in a specified format.
 *
 * This takes an audio buffer `src` of `len` bytes of `format` data and mixes
 * it into `dst`, performing addition, volume adjustment, and overflow
 * clipping. The buffer pointed to by `dst` must also be `len` bytes of
 * `format` data.
 *
 * This is provided for convenience -- you can mix your own audio data.
 *
 * Do not use this function for mixing together more than two streams of
 * sample data. The output from repeated application of this function may be
 * distorted by clipping, because there is no accumulator with greater range
 * than the input (not to mention this being an inefficient way of doing it).
 *
 * It is a common misconception that this function is required to write audio
 * data to an output stream in an audio callback. While you can do that,
 * SDL_MixAudioFormat() is really only needed when you're mixing a single
 * audio stream with a volume adjustment.
 *
 * \param dst the destination for the mixed audio
 * \param src the source audio buffer to be mixed
 * \param format the SDL_AudioFormat structure representing the desired audio
 *               format
 * \param len the length of the audio buffer in bytes
 * \param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME
 *               for full audio volume
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_MixAudioFormat: procedure(dst: PUint8; const src: PUint8; format: SDL_AudioFormat; len: Uint32; volume: Integer); cdecl;

(**
 * Queue more audio on non-callback devices.
 *
 * If you are looking to retrieve queued audio from a non-callback capture
 * device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return
 * -1 to signify an error if you use it with capture devices.
 *
 * SDL offers two ways to feed audio to the device: you can either supply a
 * callback that SDL triggers with some frequency to obtain more audio (pull
 * method), or you can supply no callback, and then SDL will expect you to
 * supply data at regular intervals (push method) with this function.
 *
 * There are no limits on the amount of data you can queue, short of
 * exhaustion of address space. Queued data will drain to the device as
 * necessary without further intervention from you. If the device needs audio
 * but there is not enough queued, it will play silence to make up the
 * difference. This means you will have skips in your audio playback if you
 * aren't routinely queueing sufficient data.
 *
 * This function copies the supplied data, so you are safe to free it when the
 * function returns. This function is thread-safe, but queueing to the same
 * device from two threads at once does not promise which buffer will be
 * queued first.
 *
 * You may not queue audio on a device that is using an application-supplied
 * callback; doing so returns an error. You have to use the audio callback or
 * queue audio with this function, but not both.
 *
 * You should not call SDL_LockAudio() on the device before queueing; SDL
 * handles locking internally for this function.
 *
 * Note that SDL2 does not support planar audio. You will need to resample
 * from planar audio formats into a non-planar one (see SDL_AudioFormat)
 * before queuing audio.
 *
 * \param dev the device ID to which we will queue audio
 * \param data the data to queue to the device for later playback
 * \param len the number of bytes (not samples!) to which `data` points
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_ClearQueuedAudio
 * \sa SDL_GetQueuedAudioSize
 *)
  SDL_QueueAudio: function(dev: SDL_AudioDeviceID; const data: Pointer; len: Uint32): Integer; cdecl;

(**
 * Dequeue more audio on non-callback devices.
 *
 * If you are looking to queue audio for output on a non-callback playback
 * device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always
 * return 0 if you use it with playback devices.
 *
 * SDL offers two ways to retrieve audio from a capture device: you can either
 * supply a callback that SDL triggers with some frequency as the device
 * records more audio data, (push method), or you can supply no callback, and
 * then SDL will expect you to retrieve data at regular intervals (pull
 * method) with this function.
 *
 * There are no limits on the amount of data you can queue, short of
 * exhaustion of address space. Data from the device will keep queuing as
 * necessary without further intervention from you. This means you will
 * eventually run out of memory if you aren't routinely dequeueing data.
 *
 * Capture devices will not queue data when paused; if you are expecting to
 * not need captured audio for some length of time, use SDL_PauseAudioDevice()
 * to stop the capture device from queueing more data. This can be useful
 * during, say, level loading times. When unpaused, capture devices will start
 * queueing data from that point, having flushed any capturable data available
 * while paused.
 *
 * This function is thread-safe, but dequeueing from the same device from two
 * threads at once does not promise which thread will dequeue data first.
 *
 * You may not dequeue audio from a device that is using an
 * application-supplied callback; doing so returns an error. You have to use
 * the audio callback, or dequeue audio with this function, but not both.
 *
 * You should not call SDL_LockAudio() on the device before dequeueing; SDL
 * handles locking internally for this function.
 *
 * \param dev the device ID from which we will dequeue audio
 * \param data a pointer into where audio data should be copied
 * \param len the number of bytes (not samples!) to which (data) points
 * \returns the number of bytes dequeued, which could be less than requested;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_ClearQueuedAudio
 * \sa SDL_GetQueuedAudioSize
 *)
  SDL_DequeueAudio: function(dev: SDL_AudioDeviceID; data: Pointer; len: Uint32): Uint32; cdecl;

(**
 * Get the number of bytes of still-queued audio.
 *
 * For playback devices: this is the number of bytes that have been queued for
 * playback with SDL_QueueAudio(), but have not yet been sent to the hardware.
 *
 * Once we've sent it to the hardware, this function can not decide the exact
 * byte boundary of what has been played. It's possible that we just gave the
 * hardware several kilobytes right before you called this function, but it
 * hasn't played any of it yet, or maybe half of it, etc.
 *
 * For capture devices, this is the number of bytes that have been captured by
 * the device and are waiting for you to dequeue. This number may grow at any
 * time, so this only informs of the lower-bound of available data.
 *
 * You may not queue or dequeue audio on a device that is using an
 * application-supplied callback; calling this function on such a device
 * always returns 0. You have to use the audio callback or queue audio, but
 * not both.
 *
 * You should not call SDL_LockAudio() on the device before querying; SDL
 * handles locking internally for this function.
 *
 * \param dev the device ID of which we will query queued audio size
 * \returns the number of bytes (not samples!) of queued audio.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_ClearQueuedAudio
 * \sa SDL_QueueAudio
 * \sa SDL_DequeueAudio
 *)
  SDL_GetQueuedAudioSize: function(dev: SDL_AudioDeviceID): Uint32; cdecl;

(**
 * Drop any queued audio data waiting to be sent to the hardware.
 *
 * Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For
 * output devices, the hardware will start playing silence if more audio isn't
 * queued. For capture devices, the hardware will start filling the empty
 * queue with new data if the capture device isn't paused.
 *
 * This will not prevent playback of queued audio that's already been sent to
 * the hardware, as we can not undo that, so expect there to be some fraction
 * of a second of audio that might still be heard. This can be useful if you
 * want to, say, drop any pending music or any unprocessed microphone input
 * during a level change in your game.
 *
 * You may not queue or dequeue audio on a device that is using an
 * application-supplied callback; calling this function on such a device
 * always returns 0. You have to use the audio callback or queue audio, but
 * not both.
 *
 * You should not call SDL_LockAudio() on the device before clearing the
 * queue; SDL handles locking internally for this function.
 *
 * This function always succeeds and thus returns void.
 *
 * \param dev the device ID of which to clear the audio queue
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_GetQueuedAudioSize
 * \sa SDL_QueueAudio
 * \sa SDL_DequeueAudio
 *)
  SDL_ClearQueuedAudio: procedure(dev: SDL_AudioDeviceID); cdecl;

(**
 * This function is a legacy means of locking the audio device.
 *
 * New programs might want to use SDL_LockAudioDevice() instead. This function
 * is equivalent to calling...
 *
 * ```c
 * SDL_LockAudioDevice(1);
 * ```
 *
 * ...and is only useful if you used the legacy SDL_OpenAudio() function.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LockAudioDevice
 * \sa SDL_UnlockAudio
 * \sa SDL_UnlockAudioDevice
 *)
  SDL_LockAudio: procedure(); cdecl;

(**
 * Use this function to lock out the audio callback function for a specified
 * device.
 *
 * The lock manipulated by these functions protects the audio callback
 * function specified in SDL_OpenAudioDevice(). During a
 * SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed
 * that the callback function for that device is not running, even if the
 * device is not paused. While a device is locked, any other unpaused,
 * unlocked devices may still run their callbacks.
 *
 * Calling this function from inside your audio callback is unnecessary. SDL
 * obtains this lock before calling your function, and releases it when the
 * function returns.
 *
 * You should not hold the lock longer than absolutely necessary. If you hold
 * it too long, you'll experience dropouts in your audio playback. Ideally,
 * your application locks the device, sets a few variables and unlocks again.
 * Do not do heavy work while holding the lock for a device.
 *
 * It is safe to lock the audio device multiple times, as long as you unlock
 * it an equivalent number of times. The callback will not run until the
 * device has been unlocked completely in this way. If your application fails
 * to unlock the device appropriately, your callback will never run, you might
 * hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably
 * deadlock.
 *
 * Internally, the audio device lock is a mutex; if you lock from two threads
 * at once, not only will you block the audio callback, you'll block the other
 * thread.
 *
 * \param dev the ID of the device to be locked
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_UnlockAudioDevice
 *)
  SDL_LockAudioDevice: procedure(dev: SDL_AudioDeviceID); cdecl;

(**
 * This function is a legacy means of unlocking the audio device.
 *
 * New programs might want to use SDL_UnlockAudioDevice() instead. This
 * function is equivalent to calling...
 *
 * ```c
 * SDL_UnlockAudioDevice(1);
 * ```
 *
 * ...and is only useful if you used the legacy SDL_OpenAudio() function.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LockAudio
 * \sa SDL_UnlockAudioDevice
 *)
  SDL_UnlockAudio: procedure(); cdecl;

(**
 * Use this function to unlock the audio callback function for a specified
 * device.
 *
 * This function should be paired with a previous SDL_LockAudioDevice() call.
 *
 * \param dev the ID of the device to be unlocked
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LockAudioDevice
 *)
  SDL_UnlockAudioDevice: procedure(dev: SDL_AudioDeviceID); cdecl;

(**
 * This function is a legacy means of closing the audio device.
 *
 * This function is equivalent to calling...
 *
 * ```c
 * SDL_CloseAudioDevice(1);
 * ```
 *
 * ...and is only useful if you used the legacy SDL_OpenAudio() function.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_OpenAudio
 *)
  SDL_CloseAudio: procedure(); cdecl;

(**
 * Use this function to shut down audio processing and close the audio device.
 *
 * The application should close open audio devices once they are no longer
 * needed. Calling this function will wait until the device's audio callback
 * is not running, release the audio hardware and then clean up internal
 * state. No further audio will play from this device once this function
 * returns.
 *
 * This function may block briefly while pending audio data is played by the
 * hardware, so that applications don't drop the last buffer of data they
 * supplied.
 *
 * The device ID is invalid as soon as the device is closed, and is eligible
 * for reuse in a new SDL_OpenAudioDevice() call immediately.
 *
 * \param dev an audio device previously opened with SDL_OpenAudioDevice()
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_OpenAudioDevice
 *)
  SDL_CloseAudioDevice: procedure(dev: SDL_AudioDeviceID); cdecl;

(**
 * Put UTF-8 text into the clipboard.
 *
 * \param text the text to store in the clipboard
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetClipboardText
 * \sa SDL_HasClipboardText
 *)
  SDL_SetClipboardText: function(const text: PUTF8Char): Integer; cdecl;

(**
 * Get UTF-8 text from the clipboard, which must be freed with SDL_free().
 *
 * This functions returns empty string if there was not enough memory left for
 * a copy of the clipboard's content.
 *
 * \returns the clipboard text on success or an empty string on failure; call
 *          SDL_GetError() for more information. Caller must call SDL_free()
 *          on the returned pointer when done with it (even if there was an
 *          error).
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HasClipboardText
 * \sa SDL_SetClipboardText
 *)
  SDL_GetClipboardText: function(): PUTF8Char; cdecl;

(**
 * Query whether the clipboard exists and contains a non-empty text string.
 *
 * \returns SDL_TRUE if the clipboard has text, or SDL_FALSE if it does not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetClipboardText
 * \sa SDL_SetClipboardText
 *)
  SDL_HasClipboardText: function(): SDL_bool; cdecl;

(**
 * Put UTF-8 text into the primary selection.
 *
 * \param text the text to store in the primary selection
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.26.0.
 *
 * \sa SDL_GetPrimarySelectionText
 * \sa SDL_HasPrimarySelectionText
 *)
  SDL_SetPrimarySelectionText: function(const text: PUTF8Char): Integer; cdecl;

(**
 * Get UTF-8 text from the primary selection, which must be freed with
 * SDL_free().
 *
 * This functions returns empty string if there was not enough memory left for
 * a copy of the primary selection's content.
 *
 * \returns the primary selection text on success or an empty string on
 *          failure; call SDL_GetError() for more information. Caller must
 *          call SDL_free() on the returned pointer when done with it (even if
 *          there was an error).
 *
 * \since This function is available since SDL 2.26.0.
 *
 * \sa SDL_HasPrimarySelectionText
 * \sa SDL_SetPrimarySelectionText
 *)
  SDL_GetPrimarySelectionText: function(): PUTF8Char; cdecl;

(**
 * Query whether the primary selection exists and contains a non-empty text
 * string.
 *
 * \returns SDL_TRUE if the primary selection has text, or SDL_FALSE if it
 *          does not.
 *
 * \since This function is available since SDL 2.26.0.
 *
 * \sa SDL_GetPrimarySelectionText
 * \sa SDL_SetPrimarySelectionText
 *)
  SDL_HasPrimarySelectionText: function(): SDL_bool; cdecl;

(**
 * Get the number of CPU cores available.
 *
 * \returns the total number of logical CPU cores. On CPUs that include
 *          technologies such as hyperthreading, the number of logical cores
 *          may be more than the number of physical cores.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GetCPUCount: function(): Integer; cdecl;

(**
 * Determine the L1 cache line size of the CPU.
 *
 * This is useful for determining multi-threaded structure padding or SIMD
 * prefetch sizes.
 *
 * \returns the L1 cache line size of the CPU, in bytes.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GetCPUCacheLineSize: function(): Integer; cdecl;

(**
 * Determine whether the CPU has the RDTSC instruction.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has the RDTSC instruction or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_HasRDTSC: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has AltiVec features.
 *
 * This always returns false on CPUs that aren't using PowerPC instruction
 * sets.
 *
 * \returns SDL_TRUE if the CPU has AltiVec features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_HasAltiVec: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has MMX features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has MMX features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_HasMMX: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has 3DNow! features.
 *
 * This always returns false on CPUs that aren't using AMD instruction sets.
 *
 * \returns SDL_TRUE if the CPU has 3DNow! features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_Has3DNow: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has SSE features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has SSE features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_HasSSE: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has SSE2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has SSE2 features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_HasSSE2: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has SSE3 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has SSE3 features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_HasSSE3: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has SSE4.1 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has SSE4.1 features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE42
 *)
  SDL_HasSSE41: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has SSE4.2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has SSE4.2 features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 *)
  SDL_HasSSE42: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has AVX features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has AVX features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX2
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_HasAVX: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has AVX2 features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has AVX2 features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_Has3DNow
 * \sa SDL_HasAltiVec
 * \sa SDL_HasAVX
 * \sa SDL_HasMMX
 * \sa SDL_HasRDTSC
 * \sa SDL_HasSSE
 * \sa SDL_HasSSE2
 * \sa SDL_HasSSE3
 * \sa SDL_HasSSE41
 * \sa SDL_HasSSE42
 *)
  SDL_HasAVX2: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has AVX-512F (foundation) features.
 *
 * This always returns false on CPUs that aren't using Intel instruction sets.
 *
 * \returns SDL_TRUE if the CPU has AVX-512F features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.9.
 *
 * \sa SDL_HasAVX
 *)
  SDL_HasAVX512F: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has ARM SIMD (ARMv6) features.
 *
 * This is different from ARM NEON, which is a different instruction set.
 *
 * This always returns false on CPUs that aren't using ARM instruction sets.
 *
 * \returns SDL_TRUE if the CPU has ARM SIMD features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.12.
 *
 * \sa SDL_HasNEON
 *)
  SDL_HasARMSIMD: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has NEON (ARM SIMD) features.
 *
 * This always returns false on CPUs that aren't using ARM instruction sets.
 *
 * \returns SDL_TRUE if the CPU has ARM NEON features or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_HasNEON: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has LSX (LOONGARCH SIMD) features.
 *
 * This always returns false on CPUs that aren't using LOONGARCH instruction
 * sets.
 *
 * \returns SDL_TRUE if the CPU has LOONGARCH LSX features or SDL_FALSE if
 *          not.
 *
 * \since This function is available since SDL 2.24.0.
 *)
  SDL_HasLSX: function(): SDL_bool; cdecl;

(**
 * Determine whether the CPU has LASX (LOONGARCH SIMD) features.
 *
 * This always returns false on CPUs that aren't using LOONGARCH instruction
 * sets.
 *
 * \returns SDL_TRUE if the CPU has LOONGARCH LASX features or SDL_FALSE if
 *          not.
 *
 * \since This function is available since SDL 2.24.0.
 *)
  SDL_HasLASX: function(): SDL_bool; cdecl;

(**
 * Get the amount of RAM configured in the system.
 *
 * \returns the amount of RAM configured in the system in MiB.
 *
 * \since This function is available since SDL 2.0.1.
 *)
  SDL_GetSystemRAM: function(): Integer; cdecl;

(**
 * Report the alignment this system needs for SIMD allocations.
 *
 * This will return the minimum number of bytes to which a pointer must be
 * aligned to be compatible with SIMD instructions on the current machine. For
 * example, if the machine supports SSE only, it will return 16, but if it
 * supports AVX-512F, it'll return 64 (etc). This only reports values for
 * instruction sets SDL knows about, so if your SDL build doesn't have
 * SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and
 * not 64 for the AVX-512 instructions that exist but SDL doesn't know about.
 * Plan accordingly.
 *
 * \returns the alignment in bytes needed for available, known SIMD
 *          instructions.
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_SIMDGetAlignment: function(): NativeUInt; cdecl;

(**
 * Allocate memory in a SIMD-friendly way.
 *
 * This will allocate a block of memory that is suitable for use with SIMD
 * instructions. Specifically, it will be properly aligned and padded for the
 * system's supported vector instructions.
 *
 * The memory returned will be padded such that it is safe to read or write an
 * incomplete vector at the end of the memory block. This can be useful so you
 * don't have to drop back to a scalar fallback at the end of your SIMD
 * processing loop to deal with the final elements without overflowing the
 * allocated buffer.
 *
 * You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or
 * delete[], etc.
 *
 * Note that SDL will only deal with SIMD instruction sets it is aware of; for
 * example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and
 * AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants
 * 64. To be clear: if you can't decide to use an instruction set with an
 * SDL_Has*() function, don't use that instruction set with memory allocated
 * through here.
 *
 * SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't
 * out of memory, but you are not allowed to dereference it (because you only
 * own zero bytes of that buffer).
 *
 * \param len The length, in bytes, of the block to allocate. The actual
 *            allocated block might be larger due to padding, etc.
 * \returns a pointer to the newly-allocated block, NULL if out of memory.
 *
 * \since This function is available since SDL 2.0.10.
 *
 * \sa SDL_SIMDGetAlignment
 * \sa SDL_SIMDRealloc
 * \sa SDL_SIMDFree
 *)
  SDL_SIMDAlloc: function(const len: NativeUInt): Pointer; cdecl;

(**
 * Reallocate memory obtained from SDL_SIMDAlloc
 *
 * It is not valid to use this function on a pointer from anything but
 * SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,
 * SDL_malloc, memalign, new[], etc.
 *
 * \param mem The pointer obtained from SDL_SIMDAlloc. This function also
 *            accepts NULL, at which point this function is the same as
 *            calling SDL_SIMDAlloc with a NULL pointer.
 * \param len The length, in bytes, of the block to allocated. The actual
 *            allocated block might be larger due to padding, etc. Passing 0
 *            will return a non-NULL pointer, assuming the system isn't out of
 *            memory.
 * \returns a pointer to the newly-reallocated block, NULL if out of memory.
 *
 * \since This function is available since SDL 2.0.14.
 *
 * \sa SDL_SIMDGetAlignment
 * \sa SDL_SIMDAlloc
 * \sa SDL_SIMDFree
 *)
  SDL_SIMDRealloc: function(mem: Pointer; const len: NativeUInt): Pointer; cdecl;

(**
 * Deallocate memory obtained from SDL_SIMDAlloc
 *
 * It is not valid to use this function on a pointer from anything but
 * SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from
 * malloc, realloc, SDL_malloc, memalign, new[], etc.
 *
 * However, SDL_SIMDFree(NULL) is a legal no-op.
 *
 * The memory pointed to by `ptr` is no longer valid for access upon return,
 * and may be returned to the system or reused by a future allocation. The
 * pointer passed to this function is no longer safe to dereference once this
 * function returns, and should be discarded.
 *
 * \param ptr The pointer, returned from SDL_SIMDAlloc or SDL_SIMDRealloc, to
 *            deallocate. NULL is a legal no-op.
 *
 * \since This function is available since SDL 2.0.10.
 *
 * \sa SDL_SIMDAlloc
 * \sa SDL_SIMDRealloc
 *)
  SDL_SIMDFree: procedure(ptr: Pointer); cdecl;

(**
 * Get the human readable name of a pixel format.
 *
 * \param format the pixel format to query
 * \returns the human readable name of the specified pixel format or
 *          `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GetPixelFormatName: function(format: Uint32): PUTF8Char; cdecl;

(**
 * Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
 *
 * \param format one of the SDL_PixelFormatEnum values
 * \param bpp a bits per pixel value; usually 15, 16, or 32
 * \param Rmask a pointer filled in with the red mask for the format
 * \param Gmask a pointer filled in with the green mask for the format
 * \param Bmask a pointer filled in with the blue mask for the format
 * \param Amask a pointer filled in with the alpha mask for the format
 * \returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't
 *          possible; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_MasksToPixelFormatEnum
 *)
  SDL_PixelFormatEnumToMasks: function(format: Uint32; bpp: PInteger; Rmask: PUint32; Gmask: PUint32; Bmask: PUint32; Amask: PUint32): SDL_bool; cdecl;

(**
 * Convert a bpp value and RGBA masks to an enumerated pixel format.
 *
 * This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
 * possible.
 *
 * \param bpp a bits per pixel value; usually 15, 16, or 32
 * \param Rmask the red mask for the format
 * \param Gmask the green mask for the format
 * \param Bmask the blue mask for the format
 * \param Amask the alpha mask for the format
 * \returns one of the SDL_PixelFormatEnum values
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PixelFormatEnumToMasks
 *)
  SDL_MasksToPixelFormatEnum: function(bpp: Integer; Rmask: Uint32; Gmask: Uint32; Bmask: Uint32; Amask: Uint32): Uint32; cdecl;

(**
 * Create an SDL_PixelFormat structure corresponding to a pixel format.
 *
 * Returned structure may come from a shared global cache (i.e. not newly
 * allocated), and hence should not be modified, especially the palette. Weird
 * errors such as `Blit combination not supported` may occur.
 *
 * \param pixel_format one of the SDL_PixelFormatEnum values
 * \returns the new SDL_PixelFormat structure or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FreeFormat
 *)
  SDL_AllocFormat: function(pixel_format: Uint32): PSDL_PixelFormat; cdecl;

(**
 * Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().
 *
 * \param format the SDL_PixelFormat structure to free
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AllocFormat
 *)
  SDL_FreeFormat: procedure(format: PSDL_PixelFormat); cdecl;

(**
 * Create a palette structure with the specified number of color entries.
 *
 * The palette entries are initialized to white.
 *
 * \param ncolors represents the number of color entries in the color palette
 * \returns a new SDL_Palette structure on success or NULL on failure (e.g. if
 *          there wasn't enough memory); call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FreePalette
 *)
  SDL_AllocPalette: function(ncolors: Integer): PSDL_Palette; cdecl;

(**
 * Set the palette for a pixel format structure.
 *
 * \param format the SDL_PixelFormat structure that will use the palette
 * \param palette the SDL_Palette structure that will be used
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AllocPalette
 * \sa SDL_FreePalette
 *)
  SDL_SetPixelFormatPalette: function(format: PSDL_PixelFormat; palette: PSDL_Palette): Integer; cdecl;

(**
 * Set a range of colors in a palette.
 *
 * \param palette the SDL_Palette structure to modify
 * \param colors an array of SDL_Color structures to copy into the palette
 * \param firstcolor the index of the first palette entry to modify
 * \param ncolors the number of entries to modify
 * \returns 0 on success or a negative error code if not all of the colors
 *          could be set; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AllocPalette
 * \sa SDL_CreateRGBSurface
 *)
  SDL_SetPaletteColors: function(palette: PSDL_Palette; const colors: PSDL_Color; firstcolor: Integer; ncolors: Integer): Integer; cdecl;

(**
 * Free a palette created with SDL_AllocPalette().
 *
 * \param palette the SDL_Palette structure to be freed
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AllocPalette
 *)
  SDL_FreePalette: procedure(palette: PSDL_Palette); cdecl;

(**
 * Map an RGB triple to an opaque pixel value for a given pixel format.
 *
 * This function maps the RGB color value to the specified pixel format and
 * returns the pixel value best approximating the given RGB color value for
 * the given pixel format.
 *
 * If the format has a palette (8-bit) the index of the closest matching color
 * in the palette will be returned.
 *
 * If the specified pixel format has an alpha component it will be returned as
 * all 1 bits (fully opaque).
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * \param format an SDL_PixelFormat structure describing the pixel format
 * \param r the red component of the pixel in the range 0-255
 * \param g the green component of the pixel in the range 0-255
 * \param b the blue component of the pixel in the range 0-255
 * \returns a pixel value
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRGB
 * \sa SDL_GetRGBA
 * \sa SDL_MapRGBA
 *)
  SDL_MapRGB: function(const format: PSDL_PixelFormat; r: Uint8; g: Uint8; b: Uint8): Uint32; cdecl;

(**
 * Map an RGBA quadruple to a pixel value for a given pixel format.
 *
 * This function maps the RGBA color value to the specified pixel format and
 * returns the pixel value best approximating the given RGBA color value for
 * the given pixel format.
 *
 * If the specified pixel format has no alpha component the alpha value will
 * be ignored (as it will be in formats with a palette).
 *
 * If the format has a palette (8-bit) the index of the closest matching color
 * in the palette will be returned.
 *
 * If the pixel format bpp (color depth) is less than 32-bpp then the unused
 * upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 * format the return value can be assigned to a Uint16, and similarly a Uint8
 * for an 8-bpp format).
 *
 * \param format an SDL_PixelFormat structure describing the format of the
 *               pixel
 * \param r the red component of the pixel in the range 0-255
 * \param g the green component of the pixel in the range 0-255
 * \param b the blue component of the pixel in the range 0-255
 * \param a the alpha component of the pixel in the range 0-255
 * \returns a pixel value
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRGB
 * \sa SDL_GetRGBA
 * \sa SDL_MapRGB
 *)
  SDL_MapRGBA: function(const format: PSDL_PixelFormat; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Uint32; cdecl;

(**
 * Get RGB values from a pixel in the specified format.
 *
 * This function uses the entire 8-bit [0..255] range when converting color
 * components from pixel formats with less than 8-bits per RGB component
 * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
 *
 * \param pixel a pixel value
 * \param format an SDL_PixelFormat structure describing the format of the
 *               pixel
 * \param r a pointer filled in with the red component
 * \param g a pointer filled in with the green component
 * \param b a pointer filled in with the blue component
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRGBA
 * \sa SDL_MapRGB
 * \sa SDL_MapRGBA
 *)
  SDL_GetRGB: procedure(pixel: Uint32; const format: PSDL_PixelFormat; r: PUint8; g: PUint8; b: PUint8); cdecl;

(**
 * Get RGBA values from a pixel in the specified format.
 *
 * This function uses the entire 8-bit [0..255] range when converting color
 * components from pixel formats with less than 8-bits per RGB component
 * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).
 *
 * If the surface has no alpha component, the alpha will be returned as 0xff
 * (100% opaque).
 *
 * \param pixel a pixel value
 * \param format an SDL_PixelFormat structure describing the format of the
 *               pixel
 * \param r a pointer filled in with the red component
 * \param g a pointer filled in with the green component
 * \param b a pointer filled in with the blue component
 * \param a a pointer filled in with the alpha component
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRGB
 * \sa SDL_MapRGB
 * \sa SDL_MapRGBA
 *)
  SDL_GetRGBA: procedure(pixel: Uint32; const format: PSDL_PixelFormat; r: PUint8; g: PUint8; b: PUint8; a: PUint8); cdecl;

(**
 * Calculate a 256 entry gamma ramp for a gamma value.
 *
 * \param gamma a gamma value where 0.0 is black and 1.0 is identity
 * \param ramp an array of 256 values filled in with the gamma ramp
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetWindowGammaRamp
 *)
  SDL_CalculateGammaRamp: procedure(gamma: Single; ramp: PUint16); cdecl;

(**
 * Determine whether two rectangles intersect.
 *
 * If either pointer is NULL the function will return SDL_FALSE.
 *
 * \param A an SDL_Rect structure representing the first rectangle
 * \param B an SDL_Rect structure representing the second rectangle
 * \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_IntersectRect
 *)
  SDL_HasIntersection: function(const A: PSDL_Rect; const B: PSDL_Rect): SDL_bool; cdecl;

(**
 * Calculate the intersection of two rectangles.
 *
 * If `result` is NULL then this function will return SDL_FALSE.
 *
 * \param A an SDL_Rect structure representing the first rectangle
 * \param B an SDL_Rect structure representing the second rectangle
 * \param result an SDL_Rect structure filled in with the intersection of
 *               rectangles `A` and `B`
 * \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HasIntersection
 *)
  SDL_IntersectRect: function(const A: PSDL_Rect; const B: PSDL_Rect; result: PSDL_Rect): SDL_bool; cdecl;

(**
 * Calculate the union of two rectangles.
 *
 * \param A an SDL_Rect structure representing the first rectangle
 * \param B an SDL_Rect structure representing the second rectangle
 * \param result an SDL_Rect structure filled in with the union of rectangles
 *               `A` and `B`
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_UnionRect: procedure(const A: PSDL_Rect; const B: PSDL_Rect; result: PSDL_Rect); cdecl;

(**
 * Calculate a minimal rectangle enclosing a set of points.
 *
 * If `clip` is not NULL then only points inside of the clipping rectangle are
 * considered.
 *
 * \param points an array of SDL_Point structures representing points to be
 *               enclosed
 * \param count the number of structures in the `points` array
 * \param clip an SDL_Rect used for clipping or NULL to enclose all points
 * \param result an SDL_Rect structure filled in with the minimal enclosing
 *               rectangle
 * \returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the
 *          points were outside of the clipping rectangle.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_EnclosePoints: function(const points: PSDL_Point; count: Integer; const clip: PSDL_Rect; result: PSDL_Rect): SDL_bool; cdecl;

(**
 * Calculate the intersection of a rectangle and line segment.
 *
 * This function is used to clip a line segment to a rectangle. A line segment
 * contained entirely within the rectangle or that does not intersect will
 * remain unchanged. A line segment that crosses the rectangle at either or
 * both ends will be clipped to the boundary of the rectangle and the new
 * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
 *
 * \param rect an SDL_Rect structure representing the rectangle to intersect
 * \param X1 a pointer to the starting X-coordinate of the line
 * \param Y1 a pointer to the starting Y-coordinate of the line
 * \param X2 a pointer to the ending X-coordinate of the line
 * \param Y2 a pointer to the ending Y-coordinate of the line
 * \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_IntersectRectAndLine: function(const rect: PSDL_Rect; X1: PInteger; Y1: PInteger; X2: PInteger; Y2: PInteger): SDL_bool; cdecl;

(**
 * Determine whether two rectangles intersect with float precision.
 *
 * If either pointer is NULL the function will return SDL_FALSE.
 *
 * \param A an SDL_FRect structure representing the first rectangle
 * \param B an SDL_FRect structure representing the second rectangle
 * \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.22.
 *
 * \sa SDL_IntersectRect
 *)
  SDL_HasIntersectionF: function(const A: PSDL_FRect; const B: PSDL_FRect): SDL_bool; cdecl;

(**
 * Calculate the intersection of two rectangles with float precision.
 *
 * If `result` is NULL then this function will return SDL_FALSE.
 *
 * \param A an SDL_FRect structure representing the first rectangle
 * \param B an SDL_FRect structure representing the second rectangle
 * \param result an SDL_FRect structure filled in with the intersection of
 *               rectangles `A` and `B`
 * \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.22.
 *
 * \sa SDL_HasIntersectionF
 *)
  SDL_IntersectFRect: function(const A: PSDL_FRect; const B: PSDL_FRect; result: PSDL_FRect): SDL_bool; cdecl;

(**
 * Calculate the union of two rectangles with float precision.
 *
 * \param A an SDL_FRect structure representing the first rectangle
 * \param B an SDL_FRect structure representing the second rectangle
 * \param result an SDL_FRect structure filled in with the union of rectangles
 *               `A` and `B`
 *
 * \since This function is available since SDL 2.0.22.
 *)
  SDL_UnionFRect: procedure(const A: PSDL_FRect; const B: PSDL_FRect; result: PSDL_FRect); cdecl;

(**
 * Calculate a minimal rectangle enclosing a set of points with float
 * precision.
 *
 * If `clip` is not NULL then only points inside of the clipping rectangle are
 * considered.
 *
 * \param points an array of SDL_FPoint structures representing points to be
 *               enclosed
 * \param count the number of structures in the `points` array
 * \param clip an SDL_FRect used for clipping or NULL to enclose all points
 * \param result an SDL_FRect structure filled in with the minimal enclosing
 *               rectangle
 * \returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the
 *          points were outside of the clipping rectangle.
 *
 * \since This function is available since SDL 2.0.22.
 *)
  SDL_EncloseFPoints: function(const points: PSDL_FPoint; count: Integer; const clip: PSDL_FRect; result: PSDL_FRect): SDL_bool; cdecl;

(**
 * Calculate the intersection of a rectangle and line segment with float
 * precision.
 *
 * This function is used to clip a line segment to a rectangle. A line segment
 * contained entirely within the rectangle or that does not intersect will
 * remain unchanged. A line segment that crosses the rectangle at either or
 * both ends will be clipped to the boundary of the rectangle and the new
 * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.
 *
 * \param rect an SDL_FRect structure representing the rectangle to intersect
 * \param X1 a pointer to the starting X-coordinate of the line
 * \param Y1 a pointer to the starting Y-coordinate of the line
 * \param X2 a pointer to the ending X-coordinate of the line
 * \param Y2 a pointer to the ending Y-coordinate of the line
 * \returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.22.
 *)
  SDL_IntersectFRectAndLine: function(const rect: PSDL_FRect; X1: PSingle; Y1: PSingle; X2: PSingle; Y2: PSingle): SDL_bool; cdecl;

(**
 * Compose a custom blend mode for renderers.
 *
 * The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept
 * the SDL_BlendMode returned by this function if the renderer supports it.
 *
 * A blend mode controls how the pixels from a drawing operation (source) get
 * combined with the pixels from the render target (destination). First, the
 * components of the source and destination pixels get multiplied with their
 * blend factors. Then, the blend operation takes the two products and
 * calculates the result that will get stored in the render target.
 *
 * Expressed in pseudocode, it would look like this:
 *
 * ```c
 * dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);
 * dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);
 * ```
 *
 * Where the functions `colorOperation(src, dst)` and `alphaOperation(src,
 * dst)` can return one of the following:
 *
 * - `src + dst`
 * - `src - dst`
 * - `dst - src`
 * - `min(src, dst)`
 * - `max(src, dst)`
 *
 * The red, green, and blue components are always multiplied with the first,
 * second, and third components of the SDL_BlendFactor, respectively. The
 * fourth component is not used.
 *
 * The alpha component is always multiplied with the fourth component of the
 * SDL_BlendFactor. The other components are not used in the alpha
 * calculation.
 *
 * Support for these blend modes varies for each renderer. To check if a
 * specific SDL_BlendMode is supported, create a renderer and pass it to
 * either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will
 * return with an error if the blend mode is not supported.
 *
 * This list describes the support of custom blend modes for each renderer in
 * SDL 2.0.6. All renderers support the four blend modes listed in the
 * SDL_BlendMode enumeration.
 *
 * - **direct3d**: Supports all operations with all factors. However, some
 *   factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and
 *   `SDL_BLENDOPERATION_MAXIMUM`.
 * - **direct3d11**: Same as Direct3D 9.
 * - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
 *   factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL
 *   2.0.6.
 * - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all
 *   factors. Color and alpha factors need to be the same. OpenGL ES 1
 *   implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`
 *   and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha
 *   operations being different from each other. May support color and alpha
 *   factors being different from each other.
 * - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,
 *   `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`
 *   operations with all factors.
 * - **psp**: No custom blend mode support.
 * - **software**: No custom blend mode support.
 *
 * Some renderers do not provide an alpha component for the default render
 * target. The `SDL_BLENDFACTOR_DST_ALPHA` and
 * `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this
 * case.
 *
 * \param srcColorFactor the SDL_BlendFactor applied to the red, green, and
 *                       blue components of the source pixels
 * \param dstColorFactor the SDL_BlendFactor applied to the red, green, and
 *                       blue components of the destination pixels
 * \param colorOperation the SDL_BlendOperation used to combine the red,
 *                       green, and blue components of the source and
 *                       destination pixels
 * \param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of
 *                       the source pixels
 * \param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of
 *                       the destination pixels
 * \param alphaOperation the SDL_BlendOperation used to combine the alpha
 *                       component of the source and destination pixels
 * \returns an SDL_BlendMode that represents the chosen factors and
 *          operations.
 *
 * \since This function is available since SDL 2.0.6.
 *
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_GetRenderDrawBlendMode
 * \sa SDL_SetTextureBlendMode
 * \sa SDL_GetTextureBlendMode
 *)
  SDL_ComposeCustomBlendMode: function(srcColorFactor: SDL_BlendFactor; dstColorFactor: SDL_BlendFactor; colorOperation: SDL_BlendOperation; srcAlphaFactor: SDL_BlendFactor; dstAlphaFactor: SDL_BlendFactor; alphaOperation: SDL_BlendOperation): SDL_BlendMode; cdecl;

(**
 * Allocate a new RGB surface.
 *
 * If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.
 * If `depth` is greater than 8 bits, the pixel format is set using the
 * [RGBA]mask parameters.
 *
 * The [RGBA]mask parameters are the bitmasks used to extract that color from
 * a pixel. For instance, `Rmask` being 0xFF000000 means the red data is
 * stored in the most significant byte. Using zeros for the RGB masks sets a
 * default value, based on the depth. For example:
 *
 * ```c++
 * SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);
 * ```
 *
 * However, using zero for the Amask results in an Amask of 0.
 *
 * By default surfaces with an alpha mask are set up for blending as with:
 *
 * ```c++
 * SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)
 * ```
 *
 * You can change this by calling SDL_SetSurfaceBlendMode() and selecting a
 * different `blendMode`.
 *
 * \param flags the flags are unused and should be set to 0
 * \param width the width of the surface
 * \param height the height of the surface
 * \param depth the depth of the surface in bits
 * \param Rmask the red mask for the pixels
 * \param Gmask the green mask for the pixels
 * \param Bmask the blue mask for the pixels
 * \param Amask the alpha mask for the pixels
 * \returns the new SDL_Surface structure that is created or NULL if it fails;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRGBSurfaceFrom
 * \sa SDL_CreateRGBSurfaceWithFormat
 * \sa SDL_FreeSurface
 *)
  SDL_CreateRGBSurface: function(flags: Uint32; width: Integer; height: Integer; depth: Integer; Rmask: Uint32; Gmask: Uint32; Bmask: Uint32; Amask: Uint32): PSDL_Surface; cdecl;

(**
 * Allocate a new RGB surface with a specific pixel format.
 *
 * This function operates mostly like SDL_CreateRGBSurface(), except instead
 * of providing pixel color masks, you provide it with a predefined format
 * from SDL_PixelFormatEnum.
 *
 * \param flags the flags are unused and should be set to 0
 * \param width the width of the surface
 * \param height the height of the surface
 * \param depth the depth of the surface in bits
 * \param format the SDL_PixelFormatEnum for the new surface's pixel format.
 * \returns the new SDL_Surface structure that is created or NULL if it fails;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_CreateRGBSurface
 * \sa SDL_CreateRGBSurfaceFrom
 * \sa SDL_FreeSurface
 *)
  SDL_CreateRGBSurfaceWithFormat: function(flags: Uint32; width: Integer; height: Integer; depth: Integer; format: Uint32): PSDL_Surface; cdecl;

(**
 * Allocate a new RGB surface with existing pixel data.
 *
 * This function operates mostly like SDL_CreateRGBSurface(), except it does
 * not allocate memory for the pixel data, instead the caller provides an
 * existing buffer of data for the surface to use.
 *
 * No copy is made of the pixel data. Pixel data is not managed automatically;
 * you must free the surface before you free the pixel data.
 *
 * \param pixels a pointer to existing pixel data
 * \param width the width of the surface
 * \param height the height of the surface
 * \param depth the depth of the surface in bits
 * \param pitch the pitch of the surface in bytes
 * \param Rmask the red mask for the pixels
 * \param Gmask the green mask for the pixels
 * \param Bmask the blue mask for the pixels
 * \param Amask the alpha mask for the pixels
 * \returns the new SDL_Surface structure that is created or NULL if it fails;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRGBSurface
 * \sa SDL_CreateRGBSurfaceWithFormat
 * \sa SDL_FreeSurface
 *)
  SDL_CreateRGBSurfaceFrom: function(pixels: Pointer; width: Integer; height: Integer; depth: Integer; pitch: Integer; Rmask: Uint32; Gmask: Uint32; Bmask: Uint32; Amask: Uint32): PSDL_Surface; cdecl;

(**
 * Allocate a new RGB surface with with a specific pixel format and existing
 * pixel data.
 *
 * This function operates mostly like SDL_CreateRGBSurfaceFrom(), except
 * instead of providing pixel color masks, you provide it with a predefined
 * format from SDL_PixelFormatEnum.
 *
 * No copy is made of the pixel data. Pixel data is not managed automatically;
 * you must free the surface before you free the pixel data.
 *
 * \param pixels a pointer to existing pixel data
 * \param width the width of the surface
 * \param height the height of the surface
 * \param depth the depth of the surface in bits
 * \param pitch the pitch of the surface in bytes
 * \param format the SDL_PixelFormatEnum for the new surface's pixel format.
 * \returns the new SDL_Surface structure that is created or NULL if it fails;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_CreateRGBSurfaceFrom
 * \sa SDL_CreateRGBSurfaceWithFormat
 * \sa SDL_FreeSurface
 *)
  SDL_CreateRGBSurfaceWithFormatFrom: function(pixels: Pointer; width: Integer; height: Integer; depth: Integer; pitch: Integer; format: Uint32): PSDL_Surface; cdecl;

(**
 * Free an RGB surface.
 *
 * It is safe to pass NULL to this function.
 *
 * \param surface the SDL_Surface to free.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRGBSurface
 * \sa SDL_CreateRGBSurfaceFrom
 * \sa SDL_LoadBMP
 * \sa SDL_LoadBMP_RW
 *)
  SDL_FreeSurface: procedure(surface: PSDL_Surface); cdecl;

(**
 * Set the palette used by a surface.
 *
 * A single palette can be shared with many surfaces.
 *
 * \param surface the SDL_Surface structure to update
 * \param palette the SDL_Palette structure to use
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_SetSurfacePalette: function(surface: PSDL_Surface; palette: PSDL_Palette): Integer; cdecl;

(**
 * Set up a surface for directly accessing the pixels.
 *
 * Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
 * and read from `surface->pixels`, using the pixel format stored in
 * `surface->format`. Once you are done accessing the surface, you should use
 * SDL_UnlockSurface() to release it.
 *
 * Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
 * 0, then you can read and write to the surface at any time, and the pixel
 * format of the surface will not change.
 *
 * \param surface the SDL_Surface structure to be locked
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_MUSTLOCK
 * \sa SDL_UnlockSurface
 *)
  SDL_LockSurface: function(surface: PSDL_Surface): Integer; cdecl;

(**
 * Release a surface after directly accessing the pixels.
 *
 * \param surface the SDL_Surface structure to be unlocked
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LockSurface
 *)
  SDL_UnlockSurface: procedure(surface: PSDL_Surface); cdecl;

(**
 * Load a BMP image from a seekable SDL data stream.
 *
 * The new surface should be freed with SDL_FreeSurface(). Not doing so will
 * result in a memory leak.
 *
 * src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.
 * Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap
 * from a file, convert it to an SDL_Surface and then close the file.
 *
 * \param src the data stream for the surface
 * \param freesrc non-zero to close the stream after being read
 * \returns a pointer to a new SDL_Surface structure or NULL if there was an
 *          error; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FreeSurface
 * \sa SDL_RWFromFile
 * \sa SDL_LoadBMP
 * \sa SDL_SaveBMP_RW
 *)
  SDL_LoadBMP_RW: function(src: PSDL_RWops; freesrc: Integer): PSDL_Surface; cdecl;

(**
 * Save a surface to a seekable SDL data stream in BMP format.
 *
 * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 * BMP directly. Other RGB formats with 8-bit or higher get converted to a
 * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 * not supported.
 *
 * \param surface the SDL_Surface structure containing the image to be saved
 * \param dst a data stream to save to
 * \param freedst non-zero to close the stream after being written
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LoadBMP_RW
 * \sa SDL_SaveBMP
 *)
  SDL_SaveBMP_RW: function(surface: PSDL_Surface; dst: PSDL_RWops; freedst: Integer): Integer; cdecl;

(**
 * Set the RLE acceleration hint for a surface.
 *
 * If RLE is enabled, color key and alpha blending blits are much faster, but
 * the surface must be locked before directly accessing the pixels.
 *
 * \param surface the SDL_Surface structure to optimize
 * \param flag 0 to disable, non-zero to enable RLE acceleration
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitSurface
 * \sa SDL_LockSurface
 * \sa SDL_UnlockSurface
 *)
  SDL_SetSurfaceRLE: function(surface: PSDL_Surface; flag: Integer): Integer; cdecl;

(**
 * Returns whether the surface is RLE enabled
 *
 * It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
 *
 * \param surface the SDL_Surface structure to query
 * \returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.14.
 *
 * \sa SDL_SetSurfaceRLE
 *)
  SDL_HasSurfaceRLE: function(surface: PSDL_Surface): SDL_bool; cdecl;

(**
 * Set the color key (transparent pixel) in a surface.
 *
 * The color key defines a pixel value that will be treated as transparent in
 * a blit. For example, one can use this to specify that cyan pixels should be
 * considered transparent, and therefore not rendered.
 *
 * It is a pixel of the format used by the surface, as generated by
 * SDL_MapRGB().
 *
 * RLE acceleration can substantially speed up blitting of images with large
 * horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.
 *
 * \param surface the SDL_Surface structure to update
 * \param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key
 * \param key the transparent pixel
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitSurface
 * \sa SDL_GetColorKey
 *)
  SDL_SetColorKey: function(surface: PSDL_Surface; flag: Integer; key: Uint32): Integer; cdecl;

(**
 * Returns whether the surface has a color key
 *
 * It is safe to pass a NULL `surface` here; it will return SDL_FALSE.
 *
 * \param surface the SDL_Surface structure to query
 * \return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.9.
 *
 * \sa SDL_SetColorKey
 * \sa SDL_GetColorKey
 *)
  SDL_HasColorKey: function(surface: PSDL_Surface): SDL_bool; cdecl;

(**
 * Get the color key (transparent pixel) for a surface.
 *
 * The color key is a pixel of the format used by the surface, as generated by
 * SDL_MapRGB().
 *
 * If the surface doesn't have color key enabled this function returns -1.
 *
 * \param surface the SDL_Surface structure to query
 * \param key a pointer filled in with the transparent pixel
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitSurface
 * \sa SDL_SetColorKey
 *)
  SDL_GetColorKey: function(surface: PSDL_Surface; key: PUint32): Integer; cdecl;

(**
 * Set an additional color value multiplied into blit operations.
 *
 * When this surface is blitted, during the blit operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * (color / 255)`
 *
 * \param surface the SDL_Surface structure to update
 * \param r the red color value multiplied into blit operations
 * \param g the green color value multiplied into blit operations
 * \param b the blue color value multiplied into blit operations
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetSurfaceColorMod
 * \sa SDL_SetSurfaceAlphaMod
 *)
  SDL_SetSurfaceColorMod: function(surface: PSDL_Surface; r: Uint8; g: Uint8; b: Uint8): Integer; cdecl;

(**
 * Get the additional color value multiplied into blit operations.
 *
 * \param surface the SDL_Surface structure to query
 * \param r a pointer filled in with the current red color value
 * \param g a pointer filled in with the current green color value
 * \param b a pointer filled in with the current blue color value
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetSurfaceAlphaMod
 * \sa SDL_SetSurfaceColorMod
 *)
  SDL_GetSurfaceColorMod: function(surface: PSDL_Surface; r: PUint8; g: PUint8; b: PUint8): Integer; cdecl;

(**
 * Set an additional alpha value used in blit operations.
 *
 * When this surface is blitted, during the blit operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * (alpha / 255)`
 *
 * \param surface the SDL_Surface structure to update
 * \param alpha the alpha value multiplied into blit operations
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetSurfaceAlphaMod
 * \sa SDL_SetSurfaceColorMod
 *)
  SDL_SetSurfaceAlphaMod: function(surface: PSDL_Surface; alpha: Uint8): Integer; cdecl;

(**
 * Get the additional alpha value used in blit operations.
 *
 * \param surface the SDL_Surface structure to query
 * \param alpha a pointer filled in with the current alpha value
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetSurfaceColorMod
 * \sa SDL_SetSurfaceAlphaMod
 *)
  SDL_GetSurfaceAlphaMod: function(surface: PSDL_Surface; alpha: PUint8): Integer; cdecl;

(**
 * Set the blend mode used for blit operations.
 *
 * To copy a surface to another surface (or texture) without blending with the
 * existing data, the blendmode of the SOURCE surface should be set to
 * `SDL_BLENDMODE_NONE`.
 *
 * \param surface the SDL_Surface structure to update
 * \param blendMode the SDL_BlendMode to use for blit blending
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetSurfaceBlendMode
 *)
  SDL_SetSurfaceBlendMode: function(surface: PSDL_Surface; blendMode: SDL_BlendMode): Integer; cdecl;

(**
 * Get the blend mode used for blit operations.
 *
 * \param surface the SDL_Surface structure to query
 * \param blendMode a pointer filled in with the current SDL_BlendMode
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetSurfaceBlendMode
 *)
  SDL_GetSurfaceBlendMode: function(surface: PSDL_Surface; blendMode: PSDL_BlendMode): Integer; cdecl;

(**
 * Set the clipping rectangle for a surface.
 *
 * When `surface` is the destination of a blit, only the area within the clip
 * rectangle is drawn into.
 *
 * Note that blits are automatically clipped to the edges of the source and
 * destination surfaces.
 *
 * \param surface the SDL_Surface structure to be clipped
 * \param rect the SDL_Rect structure representing the clipping rectangle, or
 *             NULL to disable clipping
 * \returns SDL_TRUE if the rectangle intersects the surface, otherwise
 *          SDL_FALSE and blits will be completely clipped.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitSurface
 * \sa SDL_GetClipRect
 *)
  SDL_SetClipRect: function(surface: PSDL_Surface; const rect: PSDL_Rect): SDL_bool; cdecl;

(**
 * Get the clipping rectangle for a surface.
 *
 * When `surface` is the destination of a blit, only the area within the clip
 * rectangle is drawn into.
 *
 * \param surface the SDL_Surface structure representing the surface to be
 *                clipped
 * \param rect an SDL_Rect structure filled in with the clipping rectangle for
 *             the surface
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitSurface
 * \sa SDL_SetClipRect
 *)
  SDL_GetClipRect: procedure(surface: PSDL_Surface; rect: PSDL_Rect); cdecl;

  SDL_DuplicateSurface: function(surface: PSDL_Surface): PSDL_Surface; cdecl;

(**
 * Copy an existing surface to a new surface of the specified format.
 *
 * This function is used to optimize images for faster *repeat* blitting. This
 * is accomplished by converting the original and storing the result as a new
 * surface. The new, optimized surface can then be used as the source for
 * future blits, making them faster.
 *
 * \param src the existing SDL_Surface structure to convert
 * \param fmt the SDL_PixelFormat structure that the new surface is optimized
 *            for
 * \param flags the flags are unused and should be set to 0; this is a
 *              leftover from SDL 1.2's API
 * \returns the new SDL_Surface structure that is created or NULL if it fails;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AllocFormat
 * \sa SDL_ConvertSurfaceFormat
 * \sa SDL_CreateRGBSurface
 *)
  SDL_ConvertSurface: function(src: PSDL_Surface; const fmt: PSDL_PixelFormat; flags: Uint32): PSDL_Surface; cdecl;

(**
 * Copy an existing surface to a new surface of the specified format enum.
 *
 * This function operates just like SDL_ConvertSurface(), but accepts an
 * SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,
 * it might be easier to call but it doesn't have access to palette
 * information for the destination surface, in case that would be important.
 *
 * \param src the existing SDL_Surface structure to convert
 * \param pixel_format the SDL_PixelFormatEnum that the new surface is
 *                     optimized for
 * \param flags the flags are unused and should be set to 0; this is a
 *              leftover from SDL 1.2's API
 * \returns the new SDL_Surface structure that is created or NULL if it fails;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AllocFormat
 * \sa SDL_ConvertSurface
 * \sa SDL_CreateRGBSurface
 *)
  SDL_ConvertSurfaceFormat: function(src: PSDL_Surface; pixel_format: Uint32; flags: Uint32): PSDL_Surface; cdecl;

(**
 * Copy a block of pixels of one format to another format.
 *
 * \param width the width of the block to copy, in pixels
 * \param height the height of the block to copy, in pixels
 * \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
 * \param src a pointer to the source pixels
 * \param src_pitch the pitch of the source pixels, in bytes
 * \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
 * \param dst a pointer to be filled in with new pixel data
 * \param dst_pitch the pitch of the destination pixels, in bytes
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_ConvertPixels: function(width: Integer; height: Integer; src_format: Uint32; const src: Pointer; src_pitch: Integer; dst_format: Uint32; dst: Pointer; dst_pitch: Integer): Integer; cdecl;

(**
 * Premultiply the alpha on a block of pixels.
 *
 * This is safe to use with src == dst, but not for other overlapping areas.
 *
 * This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.
 *
 * \param width the width of the block to convert, in pixels
 * \param height the height of the block to convert, in pixels
 * \param src_format an SDL_PixelFormatEnum value of the `src` pixels format
 * \param src a pointer to the source pixels
 * \param src_pitch the pitch of the source pixels, in bytes
 * \param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format
 * \param dst a pointer to be filled in with premultiplied pixel data
 * \param dst_pitch the pitch of the destination pixels, in bytes
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_PremultiplyAlpha: function(width: Integer; height: Integer; src_format: Uint32; const src: Pointer; src_pitch: Integer; dst_format: Uint32; dst: Pointer; dst_pitch: Integer): Integer; cdecl;

(**
 * Perform a fast fill of a rectangle with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * SDL_SetClipRect()), then this function will fill based on the intersection
 * of the clip rectangle and `rect`.
 *
 * \param dst the SDL_Surface structure that is the drawing target
 * \param rect the SDL_Rect structure representing the rectangle to fill, or
 *             NULL to fill the entire surface
 * \param color the color to fill with
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FillRects
 *)
  SDL_FillRect: function(dst: PSDL_Surface; const rect: PSDL_Rect; color: Uint32): Integer; cdecl;

(**
 * Perform a fast fill of a set of rectangles with a specific color.
 *
 * `color` should be a pixel of the format used by the surface, and can be
 * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 * alpha component then the destination is simply filled with that alpha
 * information, no blending takes place.
 *
 * If there is a clip rectangle set on the destination (set via
 * SDL_SetClipRect()), then this function will fill based on the intersection
 * of the clip rectangle and `rect`.
 *
 * \param dst the SDL_Surface structure that is the drawing target
 * \param rects an array of SDL_Rects representing the rectangles to fill.
 * \param count the number of rectangles in the array
 * \param color the color to fill with
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FillRect
 *)
  SDL_FillRects: function(dst: PSDL_Surface; const rects: PSDL_Rect; count: Integer; color: Uint32): Integer; cdecl;

(**
 * Perform a fast blit from the source surface to the destination surface.
 *
 * SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a
 * macro for this function with a less confusing name.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitSurface
 *)
  SDL_UpperBlit: function(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; dstrect: PSDL_Rect): Integer; cdecl;

(**
 * Perform low-level surface blitting only.
 *
 * This is a semi-private blit function and it performs low-level surface
 * blitting, assuming the input rectangles have already been clipped.
 *
 * Unless you know what you're doing, you should be using SDL_BlitSurface()
 * instead.
 *
 * \param src the SDL_Surface structure to be copied from
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied, or NULL to copy the entire surface
 * \param dst the SDL_Surface structure that is the blit target
 * \param dstrect the SDL_Rect structure representing the rectangle that is
 *                copied into
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitSurface
 *)
  SDL_LowerBlit: function(src: PSDL_Surface; srcrect: PSDL_Rect; dst: PSDL_Surface; dstrect: PSDL_Rect): Integer; cdecl;

(**
 * Perform a fast, low quality, stretch blit between two surfaces of the same
 * format.
 *
 * Please use SDL_BlitScaled() instead.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_SoftStretch: function(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; const dstrect: PSDL_Rect): Integer; cdecl;

(**
 * Perform bilinear scaling between two surfaces of the same format, 32BPP.
 *
 * \since This function is available since SDL 2.0.16.
 *)
  SDL_SoftStretchLinear: function(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; const dstrect: PSDL_Rect): Integer; cdecl;

(**
 * Perform a scaled surface copy to a destination surface.
 *
 * SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is
 * merely a macro for this function with a less confusing name.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitScaled
 *)
  SDL_UpperBlitScaled: function(src: PSDL_Surface; const srcrect: PSDL_Rect; dst: PSDL_Surface; dstrect: PSDL_Rect): Integer; cdecl;

(**
 * Perform low-level surface scaled blitting only.
 *
 * This is a semi-private function and it performs low-level surface blitting,
 * assuming the input rectangles have already been clipped.
 *
 * \param src the SDL_Surface structure to be copied from
 * \param srcrect the SDL_Rect structure representing the rectangle to be
 *                copied
 * \param dst the SDL_Surface structure that is the blit target
 * \param dstrect the SDL_Rect structure representing the rectangle that is
 *                copied into
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_BlitScaled
 *)
  SDL_LowerBlitScaled: function(src: PSDL_Surface; srcrect: PSDL_Rect; dst: PSDL_Surface; dstrect: PSDL_Rect): Integer; cdecl;

(**
 * Set the YUV conversion mode
 *
 * \since This function is available since SDL 2.0.8.
 *)
  SDL_SetYUVConversionMode: procedure(mode: SDL_YUV_CONVERSION_MODE); cdecl;

(**
 * Get the YUV conversion mode
 *
 * \since This function is available since SDL 2.0.8.
 *)
  SDL_GetYUVConversionMode: function(): SDL_YUV_CONVERSION_MODE; cdecl;

(**
 * Get the YUV conversion mode, returning the correct mode for the resolution
 * when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC
 *
 * \since This function is available since SDL 2.0.8.
 *)
  SDL_GetYUVConversionModeForResolution: function(width: Integer; height: Integer): SDL_YUV_CONVERSION_MODE; cdecl;

(**
 * Get the number of video drivers compiled into SDL.
 *
 * \returns a number >= 1 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetVideoDriver
 *)
  SDL_GetNumVideoDrivers: function(): Integer; cdecl;

(**
 * Get the name of a built in video driver.
 *
 * The video drivers are presented in the order in which they are normally
 * checked during initialization.
 *
 * \param index the index of a video driver
 * \returns the name of the video driver with the given **index**.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumVideoDrivers
 *)
  SDL_GetVideoDriver: function(index: Integer): PUTF8Char; cdecl;

(**
 * Initialize the video subsystem, optionally specifying a video driver.
 *
 * This function initializes the video subsystem, setting up a connection to
 * the window manager, etc, and determines the available display modes and
 * pixel formats, but does not initialize a window or graphics mode.
 *
 * If you use this function and you haven't used the SDL_INIT_VIDEO flag with
 * either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()
 * before calling SDL_Quit().
 *
 * It is safe to call this function multiple times. SDL_VideoInit() will call
 * SDL_VideoQuit() itself if the video subsystem has already been initialized.
 *
 * You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a
 * specific `driver_name`.
 *
 * \param driver_name the name of a video driver to initialize, or NULL for
 *                    the default driver
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumVideoDrivers
 * \sa SDL_GetVideoDriver
 * \sa SDL_InitSubSystem
 * \sa SDL_VideoQuit
 *)
  SDL_VideoInit: function(const driver_name: PUTF8Char): Integer; cdecl;

(**
 * Shut down the video subsystem, if initialized with SDL_VideoInit().
 *
 * This function closes all windows, and restores the original video mode.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_VideoInit
 *)
  SDL_VideoQuit: procedure(); cdecl;

(**
 * Get the name of the currently initialized video driver.
 *
 * \returns the name of the current video driver or NULL if no driver has been
 *          initialized.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumVideoDrivers
 * \sa SDL_GetVideoDriver
 *)
  SDL_GetCurrentVideoDriver: function(): PUTF8Char; cdecl;

(**
 * Get the number of available video displays.
 *
 * \returns a number >= 1 or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetDisplayBounds
 *)
  SDL_GetNumVideoDisplays: function(): Integer; cdecl;

(**
 * Get the name of a display in UTF-8 encoding.
 *
 * \param displayIndex the index of display from which the name should be
 *                     queried
 * \returns the name of a display or NULL for an invalid display index or
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetDisplayName: function(displayIndex: Integer): PUTF8Char; cdecl;

(**
 * Get the desktop area represented by a display.
 *
 * The primary display (`displayIndex` zero) is always located at 0,0.
 *
 * \param displayIndex the index of the display to query
 * \param rect the SDL_Rect structure filled in with the display bounds
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetDisplayBounds: function(displayIndex: Integer; rect: PSDL_Rect): Integer; cdecl;

(**
 * Get the usable desktop area represented by a display.
 *
 * The primary display (`displayIndex` zero) is always located at 0,0.
 *
 * This is the same area as SDL_GetDisplayBounds() reports, but with portions
 * reserved by the system removed. For example, on Apple's macOS, this
 * subtracts the area occupied by the menu bar and dock.
 *
 * Setting a window to be fullscreen generally bypasses these unusable areas,
 * so these are good guidelines for the maximum space available to a
 * non-fullscreen window.
 *
 * The parameter `rect` is ignored if it is NULL.
 *
 * This function also returns -1 if the parameter `displayIndex` is out of
 * range.
 *
 * \param displayIndex the index of the display to query the usable bounds
 *                     from
 * \param rect the SDL_Rect structure filled in with the display bounds
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_GetDisplayBounds
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetDisplayUsableBounds: function(displayIndex: Integer; rect: PSDL_Rect): Integer; cdecl;

(**
 * Get the dots/pixels-per-inch for a display.
 *
 * Diagonal, horizontal and vertical DPI can all be optionally returned if the
 * appropriate parameter is non-NULL.
 *
 * A failure of this function usually means that either no DPI information is
 * available or the `displayIndex` is out of range.
 *
 * **WARNING**: This reports the DPI that the hardware reports, and it is not
 * always reliable! It is almost always better to use SDL_GetWindowSize() to
 * find the window size, which might be in logical points instead of pixels,
 * and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),
 * SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare
 * the two values to get an actual scaling value between the two. We will be
 * rethinking how high-dpi details should be managed in SDL3 to make things
 * more consistent, reliable, and clear.
 *
 * \param displayIndex the index of the display from which DPI information
 *                     should be queried
 * \param ddpi a pointer filled in with the diagonal DPI of the display; may
 *             be NULL
 * \param hdpi a pointer filled in with the horizontal DPI of the display; may
 *             be NULL
 * \param vdpi a pointer filled in with the vertical DPI of the display; may
 *             be NULL
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetDisplayDPI: function(displayIndex: Integer; ddpi: PSingle; hdpi: PSingle; vdpi: PSingle): Integer; cdecl;

(**
 * Get the orientation of a display.
 *
 * \param displayIndex the index of the display to query
 * \returns The SDL_DisplayOrientation enum value of the display, or
 *          `SDL_ORIENTATION_UNKNOWN` if it isn't available.
 *
 * \since This function is available since SDL 2.0.9.
 *
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetDisplayOrientation: function(displayIndex: Integer): SDL_DisplayOrientation; cdecl;

(**
 * Get the number of available display modes.
 *
 * The `displayIndex` needs to be in the range from 0 to
 * SDL_GetNumVideoDisplays() - 1.
 *
 * \param displayIndex the index of the display to query
 * \returns a number >= 1 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetDisplayMode
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetNumDisplayModes: function(displayIndex: Integer): Integer; cdecl;

(**
 * Get information about a specific display mode.
 *
 * The display modes are sorted in this priority:
 *
 * - width -> largest to smallest
 * - height -> largest to smallest
 * - bits per pixel -> more colors to fewer colors
 * - packed pixel layout -> largest to smallest
 * - refresh rate -> highest to lowest
 *
 * \param displayIndex the index of the display to query
 * \param modeIndex the index of the display mode to query
 * \param mode an SDL_DisplayMode structure filled in with the mode at
 *             `modeIndex`
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumDisplayModes
 *)
  SDL_GetDisplayMode: function(displayIndex: Integer; modeIndex: Integer; mode: PSDL_DisplayMode): Integer; cdecl;

(**
 * Get information about the desktop's display mode.
 *
 * There's a difference between this function and SDL_GetCurrentDisplayMode()
 * when SDL runs fullscreen and has changed the resolution. In that case this
 * function will return the previous native display mode, and not the current
 * display mode.
 *
 * \param displayIndex the index of the display to query
 * \param mode an SDL_DisplayMode structure filled in with the current display
 *             mode
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetCurrentDisplayMode
 * \sa SDL_GetDisplayMode
 * \sa SDL_SetWindowDisplayMode
 *)
  SDL_GetDesktopDisplayMode: function(displayIndex: Integer; mode: PSDL_DisplayMode): Integer; cdecl;

(**
 * Get information about the current display mode.
 *
 * There's a difference between this function and SDL_GetDesktopDisplayMode()
 * when SDL runs fullscreen and has changed the resolution. In that case this
 * function will return the current display mode, and not the previous native
 * display mode.
 *
 * \param displayIndex the index of the display to query
 * \param mode an SDL_DisplayMode structure filled in with the current display
 *             mode
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetDesktopDisplayMode
 * \sa SDL_GetDisplayMode
 * \sa SDL_GetNumVideoDisplays
 * \sa SDL_SetWindowDisplayMode
 *)
  SDL_GetCurrentDisplayMode: function(displayIndex: Integer; mode: PSDL_DisplayMode): Integer; cdecl;

(**
 * Get the closest match to the requested display mode.
 *
 * The available display modes are scanned and `closest` is filled in with the
 * closest mode matching the requested mode and returned. The mode format and
 * refresh rate default to the desktop mode if they are set to 0. The modes
 * are scanned with size being first priority, format being second priority,
 * and finally checking the refresh rate. If all the available modes are too
 * small, then NULL is returned.
 *
 * \param displayIndex the index of the display to query
 * \param mode an SDL_DisplayMode structure containing the desired display
 *             mode
 * \param closest an SDL_DisplayMode structure filled in with the closest
 *                match of the available display modes
 * \returns the passed in value `closest` or NULL if no matching video mode
 *          was available; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetDisplayMode
 * \sa SDL_GetNumDisplayModes
 *)
  SDL_GetClosestDisplayMode: function(displayIndex: Integer; const mode: PSDL_DisplayMode; closest: PSDL_DisplayMode): PSDL_DisplayMode; cdecl;

(**
 * Get the index of the display containing a point
 *
 * \param point the point to query
 * \returns the index of the display containing the point or a negative error
 *          code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GetDisplayBounds
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetPointDisplayIndex: function(const point: PSDL_Point): Integer; cdecl;

(**
 * Get the index of the display primarily containing a rect
 *
 * \param rect the rect to query
 * \returns the index of the display entirely containing the rect or closest
 *          to the center of the rect on success or a negative error code on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GetDisplayBounds
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetRectDisplayIndex: function(const rect: PSDL_Rect): Integer; cdecl;

(**
 * Get the index of the display associated with a window.
 *
 * \param window the window to query
 * \returns the index of the display containing the center of the window on
 *          success or a negative error code on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetDisplayBounds
 * \sa SDL_GetNumVideoDisplays
 *)
  SDL_GetWindowDisplayIndex: function(window: PSDL_Window): Integer; cdecl;

(**
 * Set the display mode to use when a window is visible at fullscreen.
 *
 * This only affects the display mode used when the window is fullscreen. To
 * change the window size when the window is not fullscreen, use
 * SDL_SetWindowSize().
 *
 * \param window the window to affect
 * \param mode the SDL_DisplayMode structure representing the mode to use, or
 *             NULL to use the window's dimensions and the desktop's format
 *             and refresh rate
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowDisplayMode
 * \sa SDL_SetWindowFullscreen
 *)
  SDL_SetWindowDisplayMode: function(window: PSDL_Window; const mode: PSDL_DisplayMode): Integer; cdecl;

(**
 * Query the display mode to use when a window is visible at fullscreen.
 *
 * \param window the window to query
 * \param mode an SDL_DisplayMode structure filled in with the fullscreen
 *             display mode
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetWindowDisplayMode
 * \sa SDL_SetWindowFullscreen
 *)
  SDL_GetWindowDisplayMode: function(window: PSDL_Window; mode: PSDL_DisplayMode): Integer; cdecl;

(**
 * Get the raw ICC profile data for the screen the window is currently on.
 *
 * Data returned should be freed with SDL_free.
 *
 * \param window the window to query
 * \param size the size of the ICC profile
 * \returns the raw ICC profile data on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_GetWindowICCProfile: function(window: PSDL_Window; size: PNativeUInt): Pointer; cdecl;

(**
 * Get the pixel format associated with the window.
 *
 * \param window the window to query
 * \returns the pixel format of the window on success or
 *          SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GetWindowPixelFormat: function(window: PSDL_Window): Uint32; cdecl;

(**
 * Create a window with the specified position, dimensions, and flags.
 *
 * `flags` may be any of the following OR'd together:
 *
 * - `SDL_WINDOW_FULLSCREEN`: fullscreen window
 * - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution
 * - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
 * - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
 * - `SDL_WINDOW_METAL`: window usable with a Metal instance
 * - `SDL_WINDOW_HIDDEN`: window is not visible
 * - `SDL_WINDOW_BORDERLESS`: no window decoration
 * - `SDL_WINDOW_RESIZABLE`: window can be resized
 * - `SDL_WINDOW_MINIMIZED`: window is minimized
 * - `SDL_WINDOW_MAXIMIZED`: window is maximized
 * - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus
 * - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if
 *   supported (>= SDL 2.0.1)
 *
 * `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is
 * implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be
 * queried later using SDL_GetWindowFlags().
 *
 * On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
 * property to YES, otherwise you will not receive a High-DPI OpenGL canvas.
 *
 * If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size
 * in pixels may differ from its size in screen coordinates on platforms with
 * high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the
 * client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or
 * SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that
 * when this flag is set, the drawable size can vary after the window is
 * created and should be queried after major window events such as when the
 * window is resized or moved between displays.
 *
 * If the window is set fullscreen, the width and height parameters `w` and
 * `h` will not be used. However, invalid size parameters (e.g. too large) may
 * still fail. Window size is actually limited to 16384 x 16384 for all
 * platforms at window creation.
 *
 * If the window is created with any of the SDL_WINDOW_OPENGL or
 * SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
 * (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
 * corresponding UnloadLibrary function is called by SDL_DestroyWindow().
 *
 * If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
 * SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
 *
 * If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
 * SDL_CreateWindow() will fail.
 *
 * On non-Apple devices, SDL requires you to either not link to the Vulkan
 * loader or link to a dynamic library version. This limitation may be removed
 * in a future version of SDL.
 *
 * \param title the title of the window, in UTF-8 encoding
 * \param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or
 *          `SDL_WINDOWPOS_UNDEFINED`
 * \param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or
 *          `SDL_WINDOWPOS_UNDEFINED`
 * \param w the width of the window, in screen coordinates
 * \param h the height of the window, in screen coordinates
 * \param flags 0, or one or more SDL_WindowFlags OR'd together
 * \returns the window that was created or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateWindowFrom
 * \sa SDL_DestroyWindow
 *)
  SDL_CreateWindow: function(const title: PUTF8Char; x: Integer; y: Integer; w: Integer; h: Integer; flags: Uint32): PSDL_Window; cdecl;

(**
 * Create an SDL window from an existing native window.
 *
 * In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)
 * the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured
 * before using SDL_CreateWindowFrom().
 *
 * \param data a pointer to driver-dependent window creation data, typically
 *             your native window cast to a void*
 * \returns the window that was created or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateWindow
 * \sa SDL_DestroyWindow
 *)
  SDL_CreateWindowFrom: function(const data: Pointer): PSDL_Window; cdecl;

(**
 * Get the numeric ID of a window.
 *
 * The numeric ID is what SDL_WindowEvent references, and is necessary to map
 * these events to specific SDL_Window objects.
 *
 * \param window the window to query
 * \returns the ID of the window on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowFromID
 *)
  SDL_GetWindowID: function(window: PSDL_Window): Uint32; cdecl;

(**
 * Get a window from a stored ID.
 *
 * The numeric ID is what SDL_WindowEvent references, and is necessary to map
 * these events to specific SDL_Window objects.
 *
 * \param id the ID of the window
 * \returns the window associated with `id` or NULL if it doesn't exist; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowID
 *)
  SDL_GetWindowFromID: function(id: Uint32): PSDL_Window; cdecl;

(**
 * Get the window flags.
 *
 * \param window the window to query
 * \returns a mask of the SDL_WindowFlags associated with `window`
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateWindow
 * \sa SDL_HideWindow
 * \sa SDL_MaximizeWindow
 * \sa SDL_MinimizeWindow
 * \sa SDL_SetWindowFullscreen
 * \sa SDL_SetWindowGrab
 * \sa SDL_ShowWindow
 *)
  SDL_GetWindowFlags: function(window: PSDL_Window): Uint32; cdecl;

(**
 * Set the title of a window.
 *
 * This string is expected to be in UTF-8 encoding.
 *
 * \param window the window to change
 * \param title the desired window title in UTF-8 format
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowTitle
 *)
  SDL_SetWindowTitle: procedure(window: PSDL_Window; const title: PUTF8Char); cdecl;

(**
 * Get the title of a window.
 *
 * \param window the window to query
 * \returns the title of the window in UTF-8 format or "" if there is no
 *          title.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetWindowTitle
 *)
  SDL_GetWindowTitle: function(window: PSDL_Window): PUTF8Char; cdecl;

(**
 * Set the icon for a window.
 *
 * \param window the window to change
 * \param icon an SDL_Surface structure containing the icon for the window
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_SetWindowIcon: procedure(window: PSDL_Window; icon: PSDL_Surface); cdecl;

(**
 * Associate an arbitrary named pointer with a window.
 *
 * `name` is case-sensitive.
 *
 * \param window the window to associate with the pointer
 * \param name the name of the pointer
 * \param userdata the associated pointer
 * \returns the previous value associated with `name`.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowData
 *)
  SDL_SetWindowData: function(window: PSDL_Window; const name: PUTF8Char; userdata: Pointer): Pointer; cdecl;

(**
 * Retrieve the data pointer associated with a window.
 *
 * \param window the window to query
 * \param name the name of the pointer
 * \returns the value associated with `name`.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetWindowData
 *)
  SDL_GetWindowData: function(window: PSDL_Window; const name: PUTF8Char): Pointer; cdecl;

(**
 * Set the position of a window.
 *
 * The window coordinate origin is the upper left of the display.
 *
 * \param window the window to reposition
 * \param x the x coordinate of the window in screen coordinates, or
 *          `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
 * \param y the y coordinate of the window in screen coordinates, or
 *          `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowPosition
 *)
  SDL_SetWindowPosition: procedure(window: PSDL_Window; x: Integer; y: Integer); cdecl;

(**
 * Get the position of a window.
 *
 * If you do not need the value for one of the positions a NULL may be passed
 * in the `x` or `y` parameter.
 *
 * \param window the window to query
 * \param x a pointer filled in with the x position of the window, in screen
 *          coordinates, may be NULL
 * \param y a pointer filled in with the y position of the window, in screen
 *          coordinates, may be NULL
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetWindowPosition
 *)
  SDL_GetWindowPosition: procedure(window: PSDL_Window; x: PInteger; y: PInteger); cdecl;

(**
 * Set the size of a window's client area.
 *
 * The window size in screen coordinates may differ from the size in pixels,
 * if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
 * with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or
 * SDL_GetRendererOutputSize() to get the real client area size in pixels.
 *
 * Fullscreen windows automatically match the size of the display mode, and
 * you should use SDL_SetWindowDisplayMode() to change their size.
 *
 * \param window the window to change
 * \param w the width of the window in pixels, in screen coordinates, must be
 *          > 0
 * \param h the height of the window in pixels, in screen coordinates, must be
 *          > 0
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowSize
 * \sa SDL_SetWindowDisplayMode
 *)
  SDL_SetWindowSize: procedure(window: PSDL_Window; w: Integer; h: Integer); cdecl;

(**
 * Get the size of a window's client area.
 *
 * NULL can safely be passed as the `w` or `h` parameter if the width or
 * height value is not desired.
 *
 * The window size in screen coordinates may differ from the size in pixels,
 * if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform
 * with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),
 * SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the
 * real client area size in pixels.
 *
 * \param window the window to query the width and height from
 * \param w a pointer filled in with the width of the window, in screen
 *          coordinates, may be NULL
 * \param h a pointer filled in with the height of the window, in screen
 *          coordinates, may be NULL
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_GetDrawableSize
 * \sa SDL_Vulkan_GetDrawableSize
 * \sa SDL_SetWindowSize
 *)
  SDL_GetWindowSize: procedure(window: PSDL_Window; w: PInteger; h: PInteger); cdecl;

(**
 * Get the size of a window's borders (decorations) around the client area.
 *
 * Note: If this function fails (returns -1), the size values will be
 * initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
 * window in question was borderless.
 *
 * Note: This function may fail on systems where the window has not yet been
 * decorated by the display server (for example, immediately after calling
 * SDL_CreateWindow). It is recommended that you wait at least until the
 * window has been presented and composited, so that the window system has a
 * chance to decorate the window and provide the border dimensions to SDL.
 *
 * This function also returns -1 if getting the information is not supported.
 *
 * \param window the window to query the size values of the border
 *               (decorations) from
 * \param top pointer to variable for storing the size of the top border; NULL
 *            is permitted
 * \param left pointer to variable for storing the size of the left border;
 *             NULL is permitted
 * \param bottom pointer to variable for storing the size of the bottom
 *               border; NULL is permitted
 * \param right pointer to variable for storing the size of the right border;
 *              NULL is permitted
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_GetWindowSize
 *)
  SDL_GetWindowBordersSize: function(window: PSDL_Window; top: PInteger; left: PInteger; bottom: PInteger; right: PInteger): Integer; cdecl;

(**
 * Get the size of a window in pixels.
 *
 * This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
 * drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
 * platform with high-DPI support (Apple calls this "Retina"), and not
 * disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
 *
 * \param window the window from which the drawable size should be queried
 * \param w a pointer to variable for storing the width in pixels, may be NULL
 * \param h a pointer to variable for storing the height in pixels, may be
 *          NULL
 *
 * \since This function is available since SDL 2.26.0.
 *
 * \sa SDL_CreateWindow
 * \sa SDL_GetWindowSize
 *)
  SDL_GetWindowSizeInPixels: procedure(window: PSDL_Window; w: PInteger; h: PInteger); cdecl;

(**
 * Set the minimum size of a window's client area.
 *
 * \param window the window to change
 * \param min_w the minimum width of the window in pixels
 * \param min_h the minimum height of the window in pixels
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowMinimumSize
 * \sa SDL_SetWindowMaximumSize
 *)
  SDL_SetWindowMinimumSize: procedure(window: PSDL_Window; min_w: Integer; min_h: Integer); cdecl;

(**
 * Get the minimum size of a window's client area.
 *
 * \param window the window to query
 * \param w a pointer filled in with the minimum width of the window, may be
 *          NULL
 * \param h a pointer filled in with the minimum height of the window, may be
 *          NULL
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowMaximumSize
 * \sa SDL_SetWindowMinimumSize
 *)
  SDL_GetWindowMinimumSize: procedure(window: PSDL_Window; w: PInteger; h: PInteger); cdecl;

(**
 * Set the maximum size of a window's client area.
 *
 * \param window the window to change
 * \param max_w the maximum width of the window in pixels
 * \param max_h the maximum height of the window in pixels
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowMaximumSize
 * \sa SDL_SetWindowMinimumSize
 *)
  SDL_SetWindowMaximumSize: procedure(window: PSDL_Window; max_w: Integer; max_h: Integer); cdecl;

(**
 * Get the maximum size of a window's client area.
 *
 * \param window the window to query
 * \param w a pointer filled in with the maximum width of the window, may be
 *          NULL
 * \param h a pointer filled in with the maximum height of the window, may be
 *          NULL
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowMinimumSize
 * \sa SDL_SetWindowMaximumSize
 *)
  SDL_GetWindowMaximumSize: procedure(window: PSDL_Window; w: PInteger; h: PInteger); cdecl;

(**
 * Set the border state of a window.
 *
 * This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
 * or remove the border from the actual window. This is a no-op if the
 * window's border already matches the requested state.
 *
 * You can't change the border state of a fullscreen window.
 *
 * \param window the window of which to change the border state
 * \param bordered SDL_FALSE to remove border, SDL_TRUE to add border
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowFlags
 *)
  SDL_SetWindowBordered: procedure(window: PSDL_Window; bordered: SDL_bool); cdecl;

(**
 * Set the user-resizable state of a window.
 *
 * This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
 * allow/disallow user resizing of the window. This is a no-op if the window's
 * resizable state already matches the requested state.
 *
 * You can't change the resizable state of a fullscreen window.
 *
 * \param window the window of which to change the resizable state
 * \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_GetWindowFlags
 *)
  SDL_SetWindowResizable: procedure(window: PSDL_Window; resizable: SDL_bool); cdecl;

(**
 * Set the window to always be above the others.
 *
 * This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
 * will bring the window to the front and keep the window above the rest.
 *
 * \param window The window of which to change the always on top state
 * \param on_top SDL_TRUE to set the window always on top, SDL_FALSE to
 *               disable
 *
 * \since This function is available since SDL 2.0.16.
 *
 * \sa SDL_GetWindowFlags
 *)
  SDL_SetWindowAlwaysOnTop: procedure(window: PSDL_Window; on_top: SDL_bool); cdecl;

(**
 * Show a window.
 *
 * \param window the window to show
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HideWindow
 * \sa SDL_RaiseWindow
 *)
  SDL_ShowWindow: procedure(window: PSDL_Window); cdecl;

(**
 * Hide a window.
 *
 * \param window the window to hide
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ShowWindow
 *)
  SDL_HideWindow: procedure(window: PSDL_Window); cdecl;

(**
 * Raise a window above other windows and set the input focus.
 *
 * \param window the window to raise
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_RaiseWindow: procedure(window: PSDL_Window); cdecl;

(**
 * Make a window as large as possible.
 *
 * \param window the window to maximize
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_MinimizeWindow
 * \sa SDL_RestoreWindow
 *)
  SDL_MaximizeWindow: procedure(window: PSDL_Window); cdecl;

(**
 * Minimize a window to an iconic representation.
 *
 * \param window the window to minimize
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_MaximizeWindow
 * \sa SDL_RestoreWindow
 *)
  SDL_MinimizeWindow: procedure(window: PSDL_Window); cdecl;

(**
 * Restore the size and position of a minimized or maximized window.
 *
 * \param window the window to restore
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_MaximizeWindow
 * \sa SDL_MinimizeWindow
 *)
  SDL_RestoreWindow: procedure(window: PSDL_Window); cdecl;

(**
 * Set a window's fullscreen state.
 *
 * `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a
 * videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen
 * that takes the size of the desktop; and 0 for windowed mode.
 *
 * \param window the window to change
 * \param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowDisplayMode
 * \sa SDL_SetWindowDisplayMode
 *)
  SDL_SetWindowFullscreen: function(window: PSDL_Window; flags: Uint32): Integer; cdecl;

(**
 * Get the SDL surface associated with the window.
 *
 * A new surface will be created with the optimal format for the window, if
 * necessary. This surface will be freed when the window is destroyed. Do not
 * free this surface.
 *
 * This surface will be invalidated if the window is resized. After resizing a
 * window this function must be called again to return a valid surface.
 *
 * You may not combine this with 3D or the rendering API on this window.
 *
 * This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.
 *
 * \param window the window to query
 * \returns the surface associated with the window, or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_UpdateWindowSurface
 * \sa SDL_UpdateWindowSurfaceRects
 *)
  SDL_GetWindowSurface: function(window: PSDL_Window): PSDL_Surface; cdecl;

(**
 * Copy the window surface to the screen.
 *
 * This is the function you use to reflect any changes to the surface on the
 * screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_Flip().
 *
 * \param window the window to update
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowSurface
 * \sa SDL_UpdateWindowSurfaceRects
 *)
  SDL_UpdateWindowSurface: function(window: PSDL_Window): Integer; cdecl;

(**
 * Copy areas of the window surface to the screen.
 *
 * This is the function you use to reflect changes to portions of the surface
 * on the screen.
 *
 * This function is equivalent to the SDL 1.2 API SDL_UpdateRects().
 *
 * \param window the window to update
 * \param rects an array of SDL_Rect structures representing areas of the
 *              surface to copy
 * \param numrects the number of rectangles
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowSurface
 * \sa SDL_UpdateWindowSurface
 *)
  SDL_UpdateWindowSurfaceRects: function(window: PSDL_Window; const rects: PSDL_Rect; numrects: Integer): Integer; cdecl;

(**
 * Set a window's input grab mode.
 *
 * When input is grabbed, the mouse is confined to the window. This function
 * will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the
 * keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().
 *
 * If the caller enables a grab while another window is currently grabbed, the
 * other window loses its grab in favor of the caller's window.
 *
 * \param window the window for which the input grab mode should be set
 * \param grabbed SDL_TRUE to grab input or SDL_FALSE to release input
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetGrabbedWindow
 * \sa SDL_GetWindowGrab
 *)
  SDL_SetWindowGrab: procedure(window: PSDL_Window; grabbed: SDL_bool); cdecl;

(**
 * Set a window's keyboard grab mode.
 *
 * Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
 * the Meta/Super key. Note that not all system keyboard shortcuts can be
 * captured by applications (one example is Ctrl+Alt+Del on Windows).
 *
 * This is primarily intended for specialized applications such as VNC clients
 * or VM frontends. Normal games should not use keyboard grab.
 *
 * When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
 * window is full-screen to ensure the user is not trapped in your
 * application. If you have a custom keyboard shortcut to exit fullscreen
 * mode, you may suppress this behavior with
 * `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.
 *
 * If the caller enables a grab while another window is currently grabbed, the
 * other window loses its grab in favor of the caller's window.
 *
 * \param window The window for which the keyboard grab mode should be set.
 * \param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.
 *
 * \since This function is available since SDL 2.0.16.
 *
 * \sa SDL_GetWindowKeyboardGrab
 * \sa SDL_SetWindowMouseGrab
 * \sa SDL_SetWindowGrab
 *)
  SDL_SetWindowKeyboardGrab: procedure(window: PSDL_Window; grabbed: SDL_bool); cdecl;

(**
 * Set a window's mouse grab mode.
 *
 * Mouse grab confines the mouse cursor to the window.
 *
 * \param window The window for which the mouse grab mode should be set.
 * \param grabbed This is SDL_TRUE to grab mouse, and SDL_FALSE to release.
 *
 * \since This function is available since SDL 2.0.16.
 *
 * \sa SDL_GetWindowMouseGrab
 * \sa SDL_SetWindowKeyboardGrab
 * \sa SDL_SetWindowGrab
 *)
  SDL_SetWindowMouseGrab: procedure(window: PSDL_Window; grabbed: SDL_bool); cdecl;

(**
 * Get a window's input grab mode.
 *
 * \param window the window to query
 * \returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetWindowGrab
 *)
  SDL_GetWindowGrab: function(window: PSDL_Window): SDL_bool; cdecl;

(**
 * Get a window's keyboard grab mode.
 *
 * \param window the window to query
 * \returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.16.
 *
 * \sa SDL_SetWindowKeyboardGrab
 * \sa SDL_GetWindowGrab
 *)
  SDL_GetWindowKeyboardGrab: function(window: PSDL_Window): SDL_bool; cdecl;

(**
 * Get a window's mouse grab mode.
 *
 * \param window the window to query
 * \returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.16.
 *
 * \sa SDL_SetWindowKeyboardGrab
 * \sa SDL_GetWindowGrab
 *)
  SDL_GetWindowMouseGrab: function(window: PSDL_Window): SDL_bool; cdecl;

(**
 * Get the window that currently has an input grab enabled.
 *
 * \returns the window if input is grabbed or NULL otherwise.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_GetWindowGrab
 * \sa SDL_SetWindowGrab
 *)
  SDL_GetGrabbedWindow: function(): PSDL_Window; cdecl;

(**
 * Confines the cursor to the specified area of a window.
 *
 * Note that this does NOT grab the cursor, it only defines the area a cursor
 * is restricted to when the window has mouse focus.
 *
 * \param window The window that will be associated with the barrier.
 * \param rect A rectangle area in window-relative coordinates. If NULL the
 *             barrier for the specified window will be destroyed.
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_GetWindowMouseRect
 * \sa SDL_SetWindowMouseGrab
 *)
  SDL_SetWindowMouseRect: function(window: PSDL_Window; const rect: PSDL_Rect): Integer; cdecl;

(**
 * Get the mouse confinement rectangle of a window.
 *
 * \param window The window to query
 * \returns A pointer to the mouse confinement rectangle of a window, or NULL
 *          if there isn't one.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_SetWindowMouseRect
 *)
  SDL_GetWindowMouseRect: function(window: PSDL_Window): PSDL_Rect; cdecl;

(**
 * Set the brightness (gamma multiplier) for a given window's display.
 *
 * Despite the name and signature, this method sets the brightness of the
 * entire display, not an individual window. A window is considered to be
 * owned by the display that contains the window's center pixel. (The index of
 * this display can be retrieved using SDL_GetWindowDisplayIndex().) The
 * brightness set will not follow the window if it is moved to another
 * display.
 *
 * Many platforms will refuse to set the display brightness in modern times.
 * You are better off using a shader to adjust gamma during rendering, or
 * something similar.
 *
 * \param window the window used to select the display whose brightness will
 *               be changed
 * \param brightness the brightness (gamma multiplier) value to set where 0.0
 *                   is completely dark and 1.0 is normal brightness
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowBrightness
 * \sa SDL_SetWindowGammaRamp
 *)
  SDL_SetWindowBrightness: function(window: PSDL_Window; brightness: Single): Integer; cdecl;

(**
 * Get the brightness (gamma multiplier) for a given window's display.
 *
 * Despite the name and signature, this method retrieves the brightness of the
 * entire display, not an individual window. A window is considered to be
 * owned by the display that contains the window's center pixel. (The index of
 * this display can be retrieved using SDL_GetWindowDisplayIndex().)
 *
 * \param window the window used to select the display whose brightness will
 *               be queried
 * \returns the brightness for the display where 0.0 is completely dark and
 *          1.0 is normal brightness.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetWindowBrightness
 *)
  SDL_GetWindowBrightness: function(window: PSDL_Window): Single; cdecl;

(**
 * Set the opacity for a window.
 *
 * The parameter `opacity` will be clamped internally between 0.0f
 * (transparent) and 1.0f (opaque).
 *
 * This function also returns -1 if setting the opacity isn't supported.
 *
 * \param window the window which will be made transparent or opaque
 * \param opacity the opacity value (0.0f - transparent, 1.0f - opaque)
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_GetWindowOpacity
 *)
  SDL_SetWindowOpacity: function(window: PSDL_Window; opacity: Single): Integer; cdecl;

(**
 * Get the opacity of a window.
 *
 * If transparency isn't supported on this platform, opacity will be reported
 * as 1.0f without error.
 *
 * The parameter `opacity` is ignored if it is NULL.
 *
 * This function also returns -1 if an invalid window was provided.
 *
 * \param window the window to get the current opacity value from
 * \param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_SetWindowOpacity
 *)
  SDL_GetWindowOpacity: function(window: PSDL_Window; out_opacity: PSingle): Integer; cdecl;

(**
 * Set the window as a modal for another window.
 *
 * \param modal_window the window that should be set modal
 * \param parent_window the parent window for the modal window
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *)
  SDL_SetWindowModalFor: function(modal_window: PSDL_Window; parent_window: PSDL_Window): Integer; cdecl;

(**
 * Explicitly set input focus to the window.
 *
 * You almost certainly want SDL_RaiseWindow() instead of this function. Use
 * this with caution, as you might give focus to a window that is completely
 * obscured by other windows.
 *
 * \param window the window that should get the input focus
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_RaiseWindow
 *)
  SDL_SetWindowInputFocus: function(window: PSDL_Window): Integer; cdecl;

(**
 * Set the gamma ramp for the display that owns a given window.
 *
 * Set the gamma translation table for the red, green, and blue channels of
 * the video hardware. Each table is an array of 256 16-bit quantities,
 * representing a mapping between the input and output for that channel. The
 * input is the index into the array, and the output is the 16-bit gamma value
 * at that index, scaled to the output color precision.
 *
 * Despite the name and signature, this method sets the gamma ramp of the
 * entire display, not an individual window. A window is considered to be
 * owned by the display that contains the window's center pixel. (The index of
 * this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma
 * ramp set will not follow the window if it is moved to another display.
 *
 * \param window the window used to select the display whose gamma ramp will
 *               be changed
 * \param red a 256 element array of 16-bit quantities representing the
 *            translation table for the red channel, or NULL
 * \param green a 256 element array of 16-bit quantities representing the
 *              translation table for the green channel, or NULL
 * \param blue a 256 element array of 16-bit quantities representing the
 *             translation table for the blue channel, or NULL
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetWindowGammaRamp
 *)
  SDL_SetWindowGammaRamp: function(window: PSDL_Window; const red: PUint16; const green: PUint16; const blue: PUint16): Integer; cdecl;

(**
 * Get the gamma ramp for a given window's display.
 *
 * Despite the name and signature, this method retrieves the gamma ramp of the
 * entire display, not an individual window. A window is considered to be
 * owned by the display that contains the window's center pixel. (The index of
 * this display can be retrieved using SDL_GetWindowDisplayIndex().)
 *
 * \param window the window used to select the display whose gamma ramp will
 *               be queried
 * \param red a 256 element array of 16-bit quantities filled in with the
 *            translation table for the red channel, or NULL
 * \param green a 256 element array of 16-bit quantities filled in with the
 *              translation table for the green channel, or NULL
 * \param blue a 256 element array of 16-bit quantities filled in with the
 *             translation table for the blue channel, or NULL
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetWindowGammaRamp
 *)
  SDL_GetWindowGammaRamp: function(window: PSDL_Window; red: PUint16; green: PUint16; blue: PUint16): Integer; cdecl;

(**
 * Provide a callback that decides if a window region has special properties.
 *
 * Normally windows are dragged and resized by decorations provided by the
 * system window manager (a title bar, borders, etc), but for some apps, it
 * makes sense to drag them from somewhere else inside the window itself; for
 * example, one might have a borderless window that wants to be draggable from
 * any part, or simulate its own title bar, etc.
 *
 * This function lets the app provide a callback that designates pieces of a
 * given window as special. This callback is run during event processing if we
 * need to tell the OS to treat a region of the window specially; the use of
 * this callback is known as "hit testing."
 *
 * Mouse input may not be delivered to your application if it is within a
 * special area; the OS will often apply that input to moving the window or
 * resizing the window and not deliver it to the application.
 *
 * Specifying NULL for a callback disables hit-testing. Hit-testing is
 * disabled by default.
 *
 * Platforms that don't support this functionality will return -1
 * unconditionally, even if you're attempting to disable hit-testing.
 *
 * Your callback may fire at any time, and its firing does not indicate any
 * specific behavior (for example, on Windows, this certainly might fire when
 * the OS is deciding whether to drag your window, but it fires for lots of
 * other reasons, too, some unrelated to anything you probably care about _and
 * when the mouse isn't actually at the location it is testing_). Since this
 * can fire at any time, you should try to keep your callback efficient,
 * devoid of allocations, etc.
 *
 * \param window the window to set hit-testing on
 * \param callback the function to call when doing a hit-test
 * \param callback_data an app-defined void pointer passed to **callback**
 * \returns 0 on success or -1 on error (including unsupported); call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.4.
 *)
  SDL_SetWindowHitTest: function(window: PSDL_Window; callback: SDL_HitTest; callback_data: Pointer): Integer; cdecl;

(**
 * Request a window to demand attention from the user.
 *
 * \param window the window to be flashed
 * \param operation the flash operation
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.16.
 *)
  SDL_FlashWindow: function(window: PSDL_Window; operation: SDL_FlashOperation): Integer; cdecl;

(**
 * Destroy a window.
 *
 * If `window` is NULL, this function will return immediately after setting
 * the SDL error message to "Invalid window". See SDL_GetError().
 *
 * \param window the window to destroy
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateWindow
 * \sa SDL_CreateWindowFrom
 *)
  SDL_DestroyWindow: procedure(window: PSDL_Window); cdecl;

(**
 * Check whether the screensaver is currently enabled.
 *
 * The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2
 * the screensaver was enabled by default.
 *
 * The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.
 *
 * \returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is
 *          disabled.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_DisableScreenSaver
 * \sa SDL_EnableScreenSaver
 *)
  SDL_IsScreenSaverEnabled: function(): SDL_bool; cdecl;

(**
 * Allow the screen to be blanked by a screen saver.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_DisableScreenSaver
 * \sa SDL_IsScreenSaverEnabled
 *)
  SDL_EnableScreenSaver: procedure(); cdecl;

(**
 * Prevent the screen from being blanked by a screen saver.
 *
 * If you disable the screensaver, it is automatically re-enabled when SDL
 * quits.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_EnableScreenSaver
 * \sa SDL_IsScreenSaverEnabled
 *)
  SDL_DisableScreenSaver: procedure(); cdecl;

(**
 * Dynamically load an OpenGL library.
 *
 * This should be done after initializing the video driver, but before
 * creating any OpenGL windows. If no OpenGL library is loaded, the default
 * library will be loaded upon creation of the first OpenGL window.
 *
 * If you do this, you need to retrieve all of the GL functions used in your
 * program from the dynamic library using SDL_GL_GetProcAddress().
 *
 * \param path the platform dependent OpenGL library name, or NULL to open the
 *             default OpenGL library
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_GetProcAddress
 * \sa SDL_GL_UnloadLibrary
 *)
  SDL_GL_LoadLibrary: function(const path: PUTF8Char): Integer; cdecl;

(**
 * Get an OpenGL function by name.
 *
 * If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
 * GL functions must be retrieved this way. Usually this is used to retrieve
 * function pointers to OpenGL extensions.
 *
 * There are some quirks to looking up OpenGL functions that require some
 * extra care from the application. If you code carefully, you can handle
 * these quirks without any platform-specific code, though:
 *
 * - On Windows, function pointers are specific to the current GL context;
 *   this means you need to have created a GL context and made it current
 *   before calling SDL_GL_GetProcAddress(). If you recreate your context or
 *   create a second context, you should assume that any existing function
 *   pointers aren't valid to use with it. This is (currently) a
 *   Windows-specific limitation, and in practice lots of drivers don't suffer
 *   this limitation, but it is still the way the wgl API is documented to
 *   work and you should expect crashes if you don't respect it. Store a copy
 *   of the function pointers that comes and goes with context lifespan.
 * - On X11, function pointers returned by this function are valid for any
 *   context, and can even be looked up before a context is created at all.
 *   This means that, for at least some common OpenGL implementations, if you
 *   look up a function that doesn't exist, you'll get a non-NULL result that
 *   is _NOT_ safe to call. You must always make sure the function is actually
 *   available for a given GL context before calling it, by checking for the
 *   existence of the appropriate extension with SDL_GL_ExtensionSupported(),
 *   or verifying that the version of OpenGL you're using offers the function
 *   as core functionality.
 * - Some OpenGL drivers, on all platforms, *will* return NULL if a function
 *   isn't supported, but you can't count on this behavior. Check for
 *   extensions you use, and if you get a NULL anyway, act as if that
 *   extension wasn't available. This is probably a bug in the driver, but you
 *   can code defensively for this scenario anyhow.
 * - Just because you're on Linux/Unix, don't assume you'll be using X11.
 *   Next-gen display servers are waiting to replace it, and may or may not
 *   make the same promises about function pointers.
 * - OpenGL function pointers must be declared `APIENTRY` as in the example
 *   code. This will ensure the proper calling convention is followed on
 *   platforms where this matters (Win32) thereby avoiding stack corruption.
 *
 * \param proc the name of an OpenGL function
 * \returns a pointer to the named OpenGL function. The returned pointer
 *          should be cast to the appropriate function signature.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_ExtensionSupported
 * \sa SDL_GL_LoadLibrary
 * \sa SDL_GL_UnloadLibrary
 *)
  SDL_GL_GetProcAddress: function(const proc: PUTF8Char): Pointer; cdecl;

(**
 * Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_LoadLibrary
 *)
  SDL_GL_UnloadLibrary: procedure(); cdecl;

(**
 * Check if an OpenGL extension is supported for the current context.
 *
 * This function operates on the current GL context; you must have created a
 * context and it must be current before calling this function. Do not assume
 * that all contexts you create will have the same set of extensions
 * available, or that recreating an existing context will offer the same
 * extensions again.
 *
 * While it's probably not a massive overhead, this function is not an O(1)
 * operation. Check the extensions you care about after creating the GL
 * context and save that information somewhere instead of calling the function
 * every time you need to know.
 *
 * \param extension the name of the extension to check
 * \returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GL_ExtensionSupported: function(const extension: PUTF8Char): SDL_bool; cdecl;

(**
 * Reset all previously set OpenGL context attributes to their default values.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_GL_GetAttribute
 * \sa SDL_GL_SetAttribute
 *)
  SDL_GL_ResetAttributes: procedure(); cdecl;

(**
 * Set an OpenGL window attribute before window creation.
 *
 * This function sets the OpenGL attribute `attr` to `value`. The requested
 * attributes should be set before creating an OpenGL window. You should use
 * SDL_GL_GetAttribute() to check the values after creating the OpenGL
 * context, since the values obtained can differ from the requested ones.
 *
 * \param attr an SDL_GLattr enum value specifying the OpenGL attribute to set
 * \param value the desired value for the attribute
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_GetAttribute
 * \sa SDL_GL_ResetAttributes
 *)
  SDL_GL_SetAttribute: function(attr: SDL_GLattr; value: Integer): Integer; cdecl;

(**
 * Get the actual value for an attribute from the current context.
 *
 * \param attr an SDL_GLattr enum value specifying the OpenGL attribute to get
 * \param value a pointer filled in with the current value of `attr`
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_ResetAttributes
 * \sa SDL_GL_SetAttribute
 *)
  SDL_GL_GetAttribute: function(attr: SDL_GLattr; value: PInteger): Integer; cdecl;

(**
 * Create an OpenGL context for an OpenGL window, and make it current.
 *
 * Windows users new to OpenGL should note that, for historical reasons, GL
 * functions added after OpenGL version 1.1 are not available by default.
 * Those functions must be loaded at run-time, either with an OpenGL
 * extension-handling library or with SDL_GL_GetProcAddress() and its related
 * functions.
 *
 * SDL_GLContext is an alias for `void *`. It's opaque to the application.
 *
 * \param window the window to associate with the context
 * \returns the OpenGL context associated with `window` or NULL on error; call
 *          SDL_GetError() for more details.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_DeleteContext
 * \sa SDL_GL_MakeCurrent
 *)
  SDL_GL_CreateContext: function(window: PSDL_Window): SDL_GLContext; cdecl;

(**
 * Set up an OpenGL context for rendering into an OpenGL window.
 *
 * The context must have been created with a compatible window.
 *
 * \param window the window to associate with the context
 * \param context the OpenGL context to associate with the window
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_CreateContext
 *)
  SDL_GL_MakeCurrent: function(window: PSDL_Window; context: SDL_GLContext): Integer; cdecl;

(**
 * Get the currently active OpenGL window.
 *
 * \returns the currently active OpenGL window on success or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GL_GetCurrentWindow: function(): PSDL_Window; cdecl;

(**
 * Get the currently active OpenGL context.
 *
 * \returns the currently active OpenGL context or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_MakeCurrent
 *)
  SDL_GL_GetCurrentContext: function(): SDL_GLContext; cdecl;

(**
 * Get the size of a window's underlying drawable in pixels.
 *
 * This returns info useful for calling glViewport().
 *
 * This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
 * drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a
 * platform with high-DPI support (Apple calls this "Retina"), and not
 * disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.
 *
 * \param window the window from which the drawable size should be queried
 * \param w a pointer to variable for storing the width in pixels, may be NULL
 * \param h a pointer to variable for storing the height in pixels, may be
 *          NULL
 *
 * \since This function is available since SDL 2.0.1.
 *
 * \sa SDL_CreateWindow
 * \sa SDL_GetWindowSize
 *)
  SDL_GL_GetDrawableSize: procedure(window: PSDL_Window; w: PInteger; h: PInteger); cdecl;

(**
 * Set the swap interval for the current OpenGL context.
 *
 * Some systems allow specifying -1 for the interval, to enable adaptive
 * vsync. Adaptive vsync works the same as vsync, but if you've already missed
 * the vertical retrace for a given frame, it swaps buffers immediately, which
 * might be less jarring for the user during occasional framerate drops. If an
 * application requests adaptive vsync and the system does not support it,
 * this function will fail and return -1. In such a case, you should probably
 * retry the call with 1 for the interval.
 *
 * Adaptive vsync is implemented for some glX drivers with
 * GLX_EXT_swap_control_tear, and for some Windows drivers with
 * WGL_EXT_swap_control_tear.
 *
 * Read more on the Khronos wiki:
 * https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync
 *
 * \param interval 0 for immediate updates, 1 for updates synchronized with
 *                 the vertical retrace, -1 for adaptive vsync
 * \returns 0 on success or -1 if setting the swap interval is not supported;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_GetSwapInterval
 *)
  SDL_GL_SetSwapInterval: function(interval: Integer): Integer; cdecl;

(**
 * Get the swap interval for the current OpenGL context.
 *
 * If the system can't determine the swap interval, or there isn't a valid
 * current context, this function will return 0 as a safe default.
 *
 * \returns 0 if there is no vertical retrace synchronization, 1 if the buffer
 *          swap is synchronized with the vertical retrace, and -1 if late
 *          swaps happen immediately instead of waiting for the next retrace;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_SetSwapInterval
 *)
  SDL_GL_GetSwapInterval: function(): Integer; cdecl;

(**
 * Update a window with OpenGL rendering.
 *
 * This is used with double-buffered OpenGL contexts, which are the default.
 *
 * On macOS, make sure you bind 0 to the draw framebuffer before swapping the
 * window, otherwise nothing will happen. If you aren't using
 * glBindFramebuffer(), this is the default and you won't have to do anything
 * extra.
 *
 * \param window the window to change
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GL_SwapWindow: procedure(window: PSDL_Window); cdecl;

(**
 * Delete an OpenGL context.
 *
 * \param context the OpenGL context to be deleted
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_CreateContext
 *)
  SDL_GL_DeleteContext: procedure(context: SDL_GLContext); cdecl;

(**
 * Query the window which currently has keyboard focus.
 *
 * \returns the window with keyboard focus.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GetKeyboardFocus: function(): PSDL_Window; cdecl;

(**
 * Get a snapshot of the current state of the keyboard.
 *
 * The pointer returned is a pointer to an internal SDL array. It will be
 * valid for the whole lifetime of the application and should not be freed by
 * the caller.
 *
 * A array element with a value of 1 means that the key is pressed and a value
 * of 0 means that it is not. Indexes into this array are obtained by using
 * SDL_Scancode values.
 *
 * Use SDL_PumpEvents() to update the state array.
 *
 * This function gives you the current state after all events have been
 * processed, so if a key or button has been pressed and released before you
 * process events, then the pressed state will never show up in the
 * SDL_GetKeyboardState() calls.
 *
 * Note: This function doesn't take into account whether shift has been
 * pressed or not.
 *
 * \param numkeys if non-NULL, receives the length of the returned array
 * \returns a pointer to an array of key states.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PumpEvents
 * \sa SDL_ResetKeyboard
 *)
  SDL_GetKeyboardState: function(numkeys: PInteger): PUint8; cdecl;

(**
 * Clear the state of the keyboard
 *
 * This function will generate key up events for all pressed keys.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GetKeyboardState
 *)
  SDL_ResetKeyboard: procedure(); cdecl;

(**
 * Get the current key modifier state for the keyboard.
 *
 * \returns an OR'd combination of the modifier keys for the keyboard. See
 *          SDL_Keymod for details.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetKeyboardState
 * \sa SDL_SetModState
 *)
  SDL_GetModState: function(): SDL_Keymod; cdecl;

(**
 * Set the current key modifier state for the keyboard.
 *
 * The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose
 * modifier key states on your application. Simply pass your desired modifier
 * states into `modstate`. This value may be a bitwise, OR'd combination of
 * SDL_Keymod values.
 *
 * This does not change the keyboard state, only the key modifier flags that
 * SDL reports.
 *
 * \param modstate the desired SDL_Keymod for the keyboard
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetModState
 *)
  SDL_SetModState: procedure(modstate: SDL_Keymod); cdecl;

(**
 * Get the key code corresponding to the given scancode according to the
 * current keyboard layout.
 *
 * See SDL_Keycode for details.
 *
 * \param scancode the desired SDL_Scancode to query
 * \returns the SDL_Keycode that corresponds to the given SDL_Scancode.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetKeyName
 * \sa SDL_GetScancodeFromKey
 *)
  SDL_GetKeyFromScancode: function(scancode: SDL_Scancode): SDL_Keycode; cdecl;

(**
 * Get the scancode corresponding to the given key code according to the
 * current keyboard layout.
 *
 * See SDL_Scancode for details.
 *
 * \param key the desired SDL_Keycode to query
 * \returns the SDL_Scancode that corresponds to the given SDL_Keycode.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetKeyFromScancode
 * \sa SDL_GetScancodeName
 *)
  SDL_GetScancodeFromKey: function(key: SDL_Keycode): SDL_Scancode; cdecl;

(**
 * Get a human-readable name for a scancode.
 *
 * See SDL_Scancode for details.
 *
 * **Warning**: The returned name is by design not stable across platforms,
 * e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left
 * Windows" under Microsoft Windows, and some scancodes like
 * `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even
 * scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and
 * `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore
 * unsuitable for creating a stable cross-platform two-way mapping between
 * strings and scancodes.
 *
 * \param scancode the desired SDL_Scancode to query
 * \returns a pointer to the name for the scancode. If the scancode doesn't
 *          have a name this function returns an empty string ("").
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetScancodeFromKey
 * \sa SDL_GetScancodeFromName
 *)
  SDL_GetScancodeName: function(scancode: SDL_Scancode): PUTF8Char; cdecl;

(**
 * Get a scancode from a human-readable name.
 *
 * \param name the human-readable scancode name
 * \returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't
 *          recognized; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetKeyFromName
 * \sa SDL_GetScancodeFromKey
 * \sa SDL_GetScancodeName
 *)
  SDL_GetScancodeFromName: function(const name: PUTF8Char): SDL_Scancode; cdecl;

(**
 * Get a human-readable name for a key.
 *
 * See SDL_Scancode and SDL_Keycode for details.
 *
 * \param key the desired SDL_Keycode to query
 * \returns a pointer to a UTF-8 string that stays valid at least until the
 *          next call to this function. If you need it around any longer, you
 *          must copy it. If the key doesn't have a name, this function
 *          returns an empty string ("").
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetKeyFromName
 * \sa SDL_GetKeyFromScancode
 * \sa SDL_GetScancodeFromKey
 *)
  SDL_GetKeyName: function(key: SDL_Keycode): PUTF8Char; cdecl;

(**
 * Get a key code from a human-readable name.
 *
 * \param name the human-readable key name
 * \returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetKeyFromScancode
 * \sa SDL_GetKeyName
 * \sa SDL_GetScancodeFromName
 *)
  SDL_GetKeyFromName: function(const name: PUTF8Char): SDL_Keycode; cdecl;

(**
 * Start accepting Unicode text input events.
 *
 * This function will start accepting Unicode text input events in the focused
 * SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and
 * SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in
 * pair with SDL_StopTextInput().
 *
 * On some platforms using this function activates the screen keyboard.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetTextInputRect
 * \sa SDL_StopTextInput
 *)
  SDL_StartTextInput: procedure(); cdecl;

(**
 * Check whether or not Unicode text input events are enabled.
 *
 * \returns SDL_TRUE if text input events are enabled else SDL_FALSE.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_StartTextInput
 *)
  SDL_IsTextInputActive: function(): SDL_bool; cdecl;

(**
 * Stop receiving any text input events.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_StartTextInput
 *)
  SDL_StopTextInput: procedure(); cdecl;

(**
 * Dismiss the composition window/IME without disabling the subsystem.
 *
 * \since This function is available since SDL 2.0.22.
 *
 * \sa SDL_StartTextInput
 * \sa SDL_StopTextInput
 *)
  SDL_ClearComposition: procedure(); cdecl;

(**
 * Returns if an IME Composite or Candidate window is currently shown.
 *
 * \since This function is available since SDL 2.0.22.
 *)
  SDL_IsTextInputShown: function(): SDL_bool; cdecl;

(**
 * Set the rectangle used to type Unicode text inputs.
 *
 * To start text input in a given location, this function is intended to be
 * called before SDL_StartTextInput, although some platforms support moving
 * the rectangle even while text input (and a composition) is active.
 *
 * Note: If you want to use the system native IME window, try setting hint
 * **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you
 * any feedback.
 *
 * \param rect the SDL_Rect structure representing the rectangle to receive
 *             text (ignored if NULL)
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_StartTextInput
 *)
  SDL_SetTextInputRect: procedure(const rect: PSDL_Rect); cdecl;

(**
 * Check whether the platform has screen keyboard support.
 *
 * \returns SDL_TRUE if the platform has some screen keyboard support or
 *          SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_StartTextInput
 * \sa SDL_IsScreenKeyboardShown
 *)
  SDL_HasScreenKeyboardSupport: function(): SDL_bool; cdecl;

(**
 * Check whether the screen keyboard is shown for given window.
 *
 * \param window the window for which screen keyboard should be queried
 * \returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HasScreenKeyboardSupport
 *)
  SDL_IsScreenKeyboardShown: function(window: PSDL_Window): SDL_bool; cdecl;

(**
 * Get the window which currently has mouse focus.
 *
 * \returns the window with mouse focus.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GetMouseFocus: function(): PSDL_Window; cdecl;

(**
 * Retrieve the current state of the mouse.
 *
 * The current button state is returned as a button bitmask, which can be
 * tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the
 * left, 2 for middle, 3 for the right button), and `x` and `y` are set to the
 * mouse cursor position relative to the focus window. You can pass NULL for
 * either `x` or `y`.
 *
 * \param x the x coordinate of the mouse cursor position relative to the
 *          focus window
 * \param y the y coordinate of the mouse cursor position relative to the
 *          focus window
 * \returns a 32-bit button bitmask of the current button state.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetGlobalMouseState
 * \sa SDL_GetRelativeMouseState
 * \sa SDL_PumpEvents
 *)
  SDL_GetMouseState: function(x: PInteger; y: PInteger): Uint32; cdecl;

(**
 * Get the current state of the mouse in relation to the desktop.
 *
 * This works similarly to SDL_GetMouseState(), but the coordinates will be
 * reported relative to the top-left of the desktop. This can be useful if you
 * need to track the mouse outside of a specific window and SDL_CaptureMouse()
 * doesn't fit your needs. For example, it could be useful if you need to
 * track the mouse while dragging a window, where coordinates relative to a
 * window might not be in sync at all times.
 *
 * Note: SDL_GetMouseState() returns the mouse position as SDL understands it
 * from the last pump of the event queue. This function, however, queries the
 * OS for the current mouse position, and as such, might be a slightly less
 * efficient function. Unless you know what you're doing and have a good
 * reason to use this function, you probably want SDL_GetMouseState() instead.
 *
 * \param x filled in with the current X coord relative to the desktop; can be
 *          NULL
 * \param y filled in with the current Y coord relative to the desktop; can be
 *          NULL
 * \returns the current button state as a bitmask which can be tested using
 *          the SDL_BUTTON(X) macros.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_CaptureMouse
 *)
  SDL_GetGlobalMouseState: function(x: PInteger; y: PInteger): Uint32; cdecl;

(**
 * Retrieve the relative state of the mouse.
 *
 * The current button state is returned as a button bitmask, which can be
 * tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the
 * left, 2 for middle, 3 for the right button), and `x` and `y` are set to the
 * mouse deltas since the last call to SDL_GetRelativeMouseState() or since
 * event initialization. You can pass NULL for either `x` or `y`.
 *
 * \param x a pointer filled with the last recorded x coordinate of the mouse
 * \param y a pointer filled with the last recorded y coordinate of the mouse
 * \returns a 32-bit button bitmask of the relative button state.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetMouseState
 *)
  SDL_GetRelativeMouseState: function(x: PInteger; y: PInteger): Uint32; cdecl;

(**
 * Move the mouse cursor to the given position within the window.
 *
 * This function generates a mouse motion event if relative mode is not
 * enabled. If relative mode is enabled, you can force mouse events for the
 * warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.
 *
 * Note that this function will appear to succeed, but not actually move the
 * mouse when used over Microsoft Remote Desktop.
 *
 * \param window the window to move the mouse into, or NULL for the current
 *               mouse focus
 * \param x the x coordinate within the window
 * \param y the y coordinate within the window
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WarpMouseGlobal
 *)
  SDL_WarpMouseInWindow: procedure(window: PSDL_Window; x: Integer; y: Integer); cdecl;

(**
 * Move the mouse to the given position in global screen space.
 *
 * This function generates a mouse motion event.
 *
 * A failure of this function usually means that it is unsupported by a
 * platform.
 *
 * Note that this function will appear to succeed, but not actually move the
 * mouse when used over Microsoft Remote Desktop.
 *
 * \param x the x coordinate
 * \param y the y coordinate
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_WarpMouseInWindow
 *)
  SDL_WarpMouseGlobal: function(x: Integer; y: Integer): Integer; cdecl;

(**
 * Set relative mouse mode.
 *
 * While the mouse is in relative mode, the cursor is hidden, and the driver
 * will try to report continuous motion in the current window. Only relative
 * motion events will be delivered, the mouse position will not change.
 *
 * Note that this function will not be able to provide continuous relative
 * motion when used over Microsoft Remote Desktop, instead motion is limited
 * to the bounds of the screen.
 *
 * This function will flush any pending mouse motion.
 *
 * \param enabled SDL_TRUE to enable relative mode, SDL_FALSE to disable.
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 *          If relative mode is not supported, this returns -1.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRelativeMouseMode
 *)
  SDL_SetRelativeMouseMode: function(enabled: SDL_bool): Integer; cdecl;

(**
 * Capture the mouse and to track input outside an SDL window.
 *
 * Capturing enables your app to obtain mouse events globally, instead of just
 * within your window. Not all video targets support this function. When
 * capturing is enabled, the current window will get all mouse events, but
 * unlike relative mode, no change is made to the cursor and it is not
 * restrained to your window.
 *
 * This function may also deny mouse input to other windows--both those in
 * your application and others on the system--so you should use this function
 * sparingly, and in small bursts. For example, you might want to track the
 * mouse while the user is dragging something, until the user releases a mouse
 * button. It is not recommended that you capture the mouse for long periods
 * of time, such as the entire time your app is running. For that, you should
 * probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending
 * on your goals.
 *
 * While captured, mouse events still report coordinates relative to the
 * current (foreground) window, but those coordinates may be outside the
 * bounds of the window (including negative values). Capturing is only allowed
 * for the foreground window. If the window loses focus while capturing, the
 * capture will be disabled automatically.
 *
 * While capturing is enabled, the current window will have the
 * `SDL_WINDOW_MOUSE_CAPTURE` flag set.
 *
 * Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the
 * mouse while the user is pressing a button; this is to try and make mouse
 * behavior more consistent between platforms, and deal with the common case
 * of a user dragging the mouse outside of the window. This means that if you
 * are calling SDL_CaptureMouse() only to deal with this situation, you no
 * longer have to (although it is safe to do so). If this causes problems for
 * your app, you can disable auto capture by setting the
 * `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.
 *
 * \param enabled SDL_TRUE to enable capturing, SDL_FALSE to disable.
 * \returns 0 on success or -1 if not supported; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_GetGlobalMouseState
 *)
  SDL_CaptureMouse: function(enabled: SDL_bool): Integer; cdecl;

(**
 * Query whether relative mouse mode is enabled.
 *
 * \returns SDL_TRUE if relative mode is enabled or SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetRelativeMouseMode
 *)
  SDL_GetRelativeMouseMode: function(): SDL_bool; cdecl;

(**
 * Create a cursor using the specified bitmap data and mask (in MSB format).
 *
 * `mask` has to be in MSB (Most Significant Bit) format.
 *
 * The cursor width (`w`) must be a multiple of 8 bits.
 *
 * The cursor is created in black and white according to the following:
 *
 * - data=0, mask=1: white
 * - data=1, mask=1: black
 * - data=0, mask=0: transparent
 * - data=1, mask=0: inverted color if possible, black if not.
 *
 * Cursors created with this function must be freed with SDL_FreeCursor().
 *
 * If you want to have a color cursor, or create your cursor from an
 * SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can
 * hide the cursor and draw your own as part of your game's rendering, but it
 * will be bound to the framerate.
 *
 * Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which
 * provides twelve readily available system cursors to pick from.
 *
 * \param data the color value for each pixel of the cursor
 * \param mask the mask value for each pixel of the cursor
 * \param w the width of the cursor
 * \param h the height of the cursor
 * \param hot_x the X-axis location of the upper left corner of the cursor
 *              relative to the actual mouse position
 * \param hot_y the Y-axis location of the upper left corner of the cursor
 *              relative to the actual mouse position
 * \returns a new cursor with the specified parameters on success or NULL on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FreeCursor
 * \sa SDL_SetCursor
 * \sa SDL_ShowCursor
 *)
  SDL_CreateCursor: function(const data: PUint8; const mask: PUint8; w: Integer; h: Integer; hot_x: Integer; hot_y: Integer): PSDL_Cursor; cdecl;

(**
 * Create a color cursor.
 *
 * \param surface an SDL_Surface structure representing the cursor image
 * \param hot_x the x position of the cursor hot spot
 * \param hot_y the y position of the cursor hot spot
 * \returns the new cursor on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateCursor
 * \sa SDL_FreeCursor
 *)
  SDL_CreateColorCursor: function(surface: PSDL_Surface; hot_x: Integer; hot_y: Integer): PSDL_Cursor; cdecl;

(**
 * Create a system cursor.
 *
 * \param id an SDL_SystemCursor enum value
 * \returns a cursor on success or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FreeCursor
 *)
  SDL_CreateSystemCursor: function(id: SDL_SystemCursor): PSDL_Cursor; cdecl;

(**
 * Set the active cursor.
 *
 * This function sets the currently active cursor to the specified one. If the
 * cursor is currently visible, the change will be immediately represented on
 * the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if
 * this is desired for any reason.
 *
 * \param cursor a cursor to make active
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateCursor
 * \sa SDL_GetCursor
 * \sa SDL_ShowCursor
 *)
  SDL_SetCursor: procedure(cursor: PSDL_Cursor); cdecl;

(**
 * Get the active cursor.
 *
 * This function returns a pointer to the current cursor which is owned by the
 * library. It is not necessary to free the cursor with SDL_FreeCursor().
 *
 * \returns the active cursor or NULL if there is no mouse.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetCursor
 *)
  SDL_GetCursor: function(): PSDL_Cursor; cdecl;

(**
 * Get the default cursor.
 *
 * \returns the default cursor on success or NULL on failure.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateSystemCursor
 *)
  SDL_GetDefaultCursor: function(): PSDL_Cursor; cdecl;

(**
 * Free a previously-created cursor.
 *
 * Use this function to free cursor resources created with SDL_CreateCursor(),
 * SDL_CreateColorCursor() or SDL_CreateSystemCursor().
 *
 * \param cursor the cursor to free
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateColorCursor
 * \sa SDL_CreateCursor
 * \sa SDL_CreateSystemCursor
 *)
  SDL_FreeCursor: procedure(cursor: PSDL_Cursor); cdecl;

(**
 * Toggle whether or not the cursor is shown.
 *
 * The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`
 * displays the cursor and passing `SDL_DISABLE` hides it.
 *
 * The current state of the mouse cursor can be queried by passing
 * `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.
 *
 * \param toggle `SDL_ENABLE` to show the cursor, `SDL_DISABLE` to hide it,
 *               `SDL_QUERY` to query the current state without changing it.
 * \returns `SDL_ENABLE` if the cursor is shown, or `SDL_DISABLE` if the
 *          cursor is hidden, or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateCursor
 * \sa SDL_SetCursor
 *)
  SDL_ShowCursor: function(toggle: Integer): Integer; cdecl;

(**
 * Get an ASCII string representation for a given ::SDL_GUID.
 *
 * You should supply at least 33 bytes for pszGUID.
 *
 * \param guid the ::SDL_GUID you wish to convert to string
 * \param pszGUID buffer in which to write the ASCII string
 * \param cbGUID the size of pszGUID
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GUIDFromString
 *)
  SDL_GUIDToString: procedure(guid: SDL_GUID; pszGUID: PUTF8Char; cbGUID: Integer); cdecl;

(**
 * Convert a GUID string into a ::SDL_GUID structure.
 *
 * Performs no error checking. If this function is given a string containing
 * an invalid GUID, the function will silently succeed, but the GUID generated
 * will not be useful.
 *
 * \param pchGUID string containing an ASCII representation of a GUID
 * \returns a ::SDL_GUID structure.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GUIDToString
 *)
  SDL_GUIDFromString: function(const pchGUID: PUTF8Char): SDL_GUID; cdecl;

(**
 * Locking for multi-threaded access to the joystick API
 *
 * If you are using the joystick API or handling events from multiple threads
 * you should use these locking functions to protect access to the joysticks.
 *
 * In particular, you are guaranteed that the joystick list won't change, so
 * the API functions that take a joystick index will be valid, and joystick
 * and game controller events will not be delivered.
 *
 * As of SDL 2.26.0, you can take the joystick lock around reinitializing the
 * joystick subsystem, to prevent other threads from seeing joysticks in an
 * uninitialized state. However, all open joysticks will be closed and SDL
 * functions called with them will fail.
 *
 * \since This function is available since SDL 2.0.7.
 *)
  SDL_LockJoysticks: procedure(); cdecl;

(**
 * Unlocking for multi-threaded access to the joystick API
 *
 * If you are using the joystick API or handling events from multiple threads
 * you should use these locking functions to protect access to the joysticks.
 *
 * In particular, you are guaranteed that the joystick list won't change, so
 * the API functions that take a joystick index will be valid, and joystick
 * and game controller events will not be delivered.
 *
 * \since This function is available since SDL 2.0.7.
 *)
  SDL_UnlockJoysticks: procedure(); cdecl;

(**
 * Count the number of joysticks attached to the system.
 *
 * \returns the number of attached joysticks on success or a negative error
 *          code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickName
 * \sa SDL_JoystickPath
 * \sa SDL_JoystickOpen
 *)
  SDL_NumJoysticks: function(): Integer; cdecl;

(**
 * Get the implementation dependent name of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * \param device_index the index of the joystick to query (the N'th joystick
 *                     on the system)
 * \returns the name of the selected joystick. If no name can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickName
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickNameForIndex: function(device_index: Integer): PUTF8Char; cdecl;

(**
 * Get the implementation dependent path of a joystick.
 *
 * This can be called before any joysticks are opened.
 *
 * \param device_index the index of the joystick to query (the N'th joystick
 *                     on the system)
 * \returns the path of the selected joystick. If no path can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_JoystickPath
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickPathForIndex: function(device_index: Integer): PUTF8Char; cdecl;

(**
 * Get the player index of a joystick, or -1 if it's not available This can be
 * called before any joysticks are opened.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_JoystickGetDevicePlayerIndex: function(device_index: Integer): Integer; cdecl;

(**
 * Get the implementation-dependent GUID for the joystick at a given device
 * index.
 *
 * This function can be called before any joysticks are opened.
 *
 * \param device_index the index of the joystick to query (the N'th joystick
 *                     on the system
 * \returns the GUID of the selected joystick. If called on an invalid index,
 *          this function returns a zero GUID
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetGUID
 * \sa SDL_JoystickGetGUIDString
 *)
  SDL_JoystickGetDeviceGUID: function(device_index: Integer): SDL_JoystickGUID; cdecl;

(**
 * Get the USB vendor ID of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the vendor ID isn't
 * available this function returns 0.
 *
 * \param device_index the index of the joystick to query (the N'th joystick
 *                     on the system
 * \returns the USB vendor ID of the selected joystick. If called on an
 *          invalid index, this function returns zero
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetDeviceVendor: function(device_index: Integer): Uint16; cdecl;

(**
 * Get the USB product ID of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the product ID isn't
 * available this function returns 0.
 *
 * \param device_index the index of the joystick to query (the N'th joystick
 *                     on the system
 * \returns the USB product ID of the selected joystick. If called on an
 *          invalid index, this function returns zero
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetDeviceProduct: function(device_index: Integer): Uint16; cdecl;

(**
 * Get the product version of a joystick, if available.
 *
 * This can be called before any joysticks are opened. If the product version
 * isn't available this function returns 0.
 *
 * \param device_index the index of the joystick to query (the N'th joystick
 *                     on the system
 * \returns the product version of the selected joystick. If called on an
 *          invalid index, this function returns zero
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetDeviceProductVersion: function(device_index: Integer): Uint16; cdecl;

(**
 * Get the type of a joystick, if available.
 *
 * This can be called before any joysticks are opened.
 *
 * \param device_index the index of the joystick to query (the N'th joystick
 *                     on the system
 * \returns the SDL_JoystickType of the selected joystick. If called on an
 *          invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetDeviceType: function(device_index: Integer): SDL_JoystickType; cdecl;

(**
 * Get the instance ID of a joystick.
 *
 * This can be called before any joysticks are opened. If the index is out of
 * range, this function will return -1.
 *
 * \param device_index the index of the joystick to query (the N'th joystick
 *                     on the system
 * \returns the instance id of the selected joystick. If called on an invalid
 *          index, this function returns zero
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetDeviceInstanceID: function(device_index: Integer): SDL_JoystickID; cdecl;

(**
 * Open a joystick for use.
 *
 * The `device_index` argument refers to the N'th joystick presently
 * recognized by SDL on the system. It is **NOT** the same as the instance ID
 * used to identify the joystick in future events. See
 * SDL_JoystickInstanceID() for more details about instance IDs.
 *
 * The joystick subsystem must be initialized before a joystick can be opened
 * for use.
 *
 * \param device_index the index of the joystick to query
 * \returns a joystick identifier or NULL if an error occurred; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickClose
 * \sa SDL_JoystickInstanceID
 *)
  SDL_JoystickOpen: function(device_index: Integer): PSDL_Joystick; cdecl;

(**
 * Get the SDL_Joystick associated with an instance id.
 *
 * \param instance_id the instance id to get the SDL_Joystick for
 * \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.4.
 *)
  SDL_JoystickFromInstanceID: function(instance_id: SDL_JoystickID): PSDL_Joystick; cdecl;

(**
 * Get the SDL_Joystick associated with a player index.
 *
 * \param player_index the player index to get the SDL_Joystick for
 * \returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.12.
 *)
  SDL_JoystickFromPlayerIndex: function(player_index: Integer): PSDL_Joystick; cdecl;

(**
 * Attach a new virtual joystick.
 *
 * \returns the joystick's device index, or -1 if an error occurred.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickAttachVirtual: function(type_: SDL_JoystickType; naxes: Integer; nbuttons: Integer; nhats: Integer): Integer; cdecl;

(**
 * Attach a new virtual joystick with extended properties.
 *
 * \returns the joystick's device index, or -1 if an error occurred.
 *
 * \since This function is available since SDL 2.24.0.
 *)
  SDL_JoystickAttachVirtualEx: function(const desc: PSDL_VirtualJoystickDesc): Integer; cdecl;

(**
 * Detach a virtual joystick.
 *
 * \param device_index a value previously returned from
 *                     SDL_JoystickAttachVirtual()
 * \returns 0 on success, or -1 if an error occurred.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickDetachVirtual: function(device_index: Integer): Integer; cdecl;

(**
 * Query whether or not the joystick at a given device index is virtual.
 *
 * \param device_index a joystick device index.
 * \returns SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickIsVirtual: function(device_index: Integer): SDL_bool; cdecl;

(**
 * Set values on an opened, virtual-joystick's axis.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_JoystickUpdate, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * Note that when sending trigger axes, you should scale the value to the full
 * range of Sint16. For example, a trigger at rest would have the value of
 * `SDL_JOYSTICK_AXIS_MIN`.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param axis the specific axis on the virtual joystick to set.
 * \param value the new value for the specified axis.
 * \returns 0 on success, -1 on error.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickSetVirtualAxis: function(joystick: PSDL_Joystick; axis: Integer; value: Sint16): Integer; cdecl;

(**
 * Set values on an opened, virtual-joystick's button.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_JoystickUpdate, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param button the specific button on the virtual joystick to set.
 * \param value the new value for the specified button.
 * \returns 0 on success, -1 on error.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickSetVirtualButton: function(joystick: PSDL_Joystick; button: Integer; value: Uint8): Integer; cdecl;

(**
 * Set values on an opened, virtual-joystick's hat.
 *
 * Please note that values set here will not be applied until the next call to
 * SDL_JoystickUpdate, which can either be called directly, or can be called
 * indirectly through various other SDL APIs, including, but not limited to
 * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,
 * SDL_WaitEvent.
 *
 * \param joystick the virtual joystick on which to set state.
 * \param hat the specific hat on the virtual joystick to set.
 * \param value the new value for the specified hat.
 * \returns 0 on success, -1 on error.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickSetVirtualHat: function(joystick: PSDL_Joystick; hat: Integer; value: Uint8): Integer; cdecl;

(**
 * Get the implementation dependent name of a joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the name of the selected joystick. If no name can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickNameForIndex
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickName: function(joystick: PSDL_Joystick): PUTF8Char; cdecl;

(**
 * Get the implementation dependent path of a joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the path of the selected joystick. If no path can be found, this
 *          function returns NULL; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_JoystickPathForIndex
 *)
  SDL_JoystickPath: function(joystick: PSDL_Joystick): PUTF8Char; cdecl;

(**
 * Get the player index of an opened joystick.
 *
 * For XInput controllers this returns the XInput user index. Many joysticks
 * will not be able to supply this information.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the player index, or -1 if it's not available.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_JoystickGetPlayerIndex: function(joystick: PSDL_Joystick): Integer; cdecl;

(**
 * Set the player index of an opened joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \param player_index Player index to assign to this joystick, or -1 to clear
 *                     the player index and turn off player LEDs.
 *
 * \since This function is available since SDL 2.0.12.
 *)
  SDL_JoystickSetPlayerIndex: procedure(joystick: PSDL_Joystick; player_index: Integer); cdecl;

(**
 * Get the implementation-dependent GUID for the joystick.
 *
 * This function requires an open joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the GUID of the given joystick. If called on an invalid index,
 *          this function returns a zero GUID; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetDeviceGUID
 * \sa SDL_JoystickGetGUIDString
 *)
  SDL_JoystickGetGUID: function(joystick: PSDL_Joystick): SDL_JoystickGUID; cdecl;

(**
 * Get the USB vendor ID of an opened joystick, if available.
 *
 * If the vendor ID isn't available this function returns 0.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the USB vendor ID of the selected joystick, or 0 if unavailable.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetVendor: function(joystick: PSDL_Joystick): Uint16; cdecl;

(**
 * Get the USB product ID of an opened joystick, if available.
 *
 * If the product ID isn't available this function returns 0.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the USB product ID of the selected joystick, or 0 if unavailable.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetProduct: function(joystick: PSDL_Joystick): Uint16; cdecl;

(**
 * Get the product version of an opened joystick, if available.
 *
 * If the product version isn't available this function returns 0.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the product version of the selected joystick, or 0 if unavailable.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetProductVersion: function(joystick: PSDL_Joystick): Uint16; cdecl;

(**
 * Get the firmware version of an opened joystick, if available.
 *
 * If the firmware version isn't available this function returns 0.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the firmware version of the selected joystick, or 0 if
 *          unavailable.
 *
 * \since This function is available since SDL 2.24.0.
 *)
  SDL_JoystickGetFirmwareVersion: function(joystick: PSDL_Joystick): Uint16; cdecl;

(**
 * Get the serial number of an opened joystick, if available.
 *
 * Returns the serial number of the joystick, or NULL if it is not available.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the serial number of the selected joystick, or NULL if
 *          unavailable.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickGetSerial: function(joystick: PSDL_Joystick): PUTF8Char; cdecl;

(**
 * Get the type of an opened joystick.
 *
 * \param joystick the SDL_Joystick obtained from SDL_JoystickOpen()
 * \returns the SDL_JoystickType of the selected joystick.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetType: function(joystick: PSDL_Joystick): SDL_JoystickType; cdecl;

(**
 * Get an ASCII string representation for a given SDL_JoystickGUID.
 *
 * You should supply at least 33 bytes for pszGUID.
 *
 * \param guid the SDL_JoystickGUID you wish to convert to string
 * \param pszGUID buffer in which to write the ASCII string
 * \param cbGUID the size of pszGUID
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetDeviceGUID
 * \sa SDL_JoystickGetGUID
 * \sa SDL_JoystickGetGUIDFromString
 *)
  SDL_JoystickGetGUIDString: procedure(guid: SDL_JoystickGUID; pszGUID: PUTF8Char; cbGUID: Integer); cdecl;

(**
 * Convert a GUID string into a SDL_JoystickGUID structure.
 *
 * Performs no error checking. If this function is given a string containing
 * an invalid GUID, the function will silently succeed, but the GUID generated
 * will not be useful.
 *
 * \param pchGUID string containing an ASCII representation of a GUID
 * \returns a SDL_JoystickGUID structure.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetGUIDString
 *)
  SDL_JoystickGetGUIDFromString: function(const pchGUID: PUTF8Char): SDL_JoystickGUID; cdecl;

(**
 * Get the device information encoded in a SDL_JoystickGUID structure
 *
 * \param guid the SDL_JoystickGUID you wish to get info about
 * \param vendor A pointer filled in with the device VID, or 0 if not
 *               available
 * \param product A pointer filled in with the device PID, or 0 if not
 *                available
 * \param version A pointer filled in with the device version, or 0 if not
 *                available
 * \param crc16 A pointer filled in with a CRC used to distinguish different
 *              products with the same VID/PID, or 0 if not available
 *
 * \since This function is available since SDL 2.26.0.
 *
 * \sa SDL_JoystickGetDeviceGUID
 *)
  SDL_GetJoystickGUIDInfo: procedure(guid: SDL_JoystickGUID; vendor: PUint16; product: PUint16; version: PUint16; crc16: PUint16); cdecl;

(**
 * Get the status of a specified joystick.
 *
 * \param joystick the joystick to query
 * \returns SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickClose
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickGetAttached: function(joystick: PSDL_Joystick): SDL_bool; cdecl;

(**
 * Get the instance ID of an opened joystick.
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \returns the instance ID of the specified joystick on success or a negative
 *          error code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickInstanceID: function(joystick: PSDL_Joystick): SDL_JoystickID; cdecl;

(**
 * Get the number of general axis controls on a joystick.
 *
 * Often, the directional pad on a game controller will either look like 4
 * separate buttons or a POV hat, and not axes, but all of this is up to the
 * device and platform.
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \returns the number of axis controls/number of axes on success or a
 *          negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetAxis
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickNumAxes: function(joystick: PSDL_Joystick): Integer; cdecl;

(**
 * Get the number of trackballs on a joystick.
 *
 * Joystick trackballs have only relative motion events associated with them
 * and their state cannot be polled.
 *
 * Most joysticks do not have trackballs.
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \returns the number of trackballs on success or a negative error code on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetBall
 *)
  SDL_JoystickNumBalls: function(joystick: PSDL_Joystick): Integer; cdecl;

(**
 * Get the number of POV hats on a joystick.
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \returns the number of POV hats on success or a negative error code on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetHat
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickNumHats: function(joystick: PSDL_Joystick): Integer; cdecl;

(**
 * Get the number of buttons on a joystick.
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \returns the number of buttons on success or a negative error code on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetButton
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickNumButtons: function(joystick: PSDL_Joystick): Integer; cdecl;

(**
 * Update the current state of the open joysticks.
 *
 * This is called automatically by the event loop if any joystick events are
 * enabled.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickEventState
 *)
  SDL_JoystickUpdate: procedure(); cdecl;

(**
 * Enable/disable joystick event polling.
 *
 * If joystick events are disabled, you must call SDL_JoystickUpdate()
 * yourself and manually check the state of the joystick when you want
 * joystick information.
 *
 * It is recommended that you leave joystick event handling enabled.
 *
 * **WARNING**: Calling this function may delete all events currently in SDL's
 * event queue.
 *
 * \param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`
 * \returns 1 if enabled, 0 if disabled, or a negative error code on failure;
 *          call SDL_GetError() for more information.
 *
 *          If `state` is `SDL_QUERY` then the current state is returned,
 *          otherwise the new processing state is returned.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerEventState
 *)
  SDL_JoystickEventState: function(state: Integer): Integer; cdecl;

(**
 * Get the current state of an axis control on a joystick.
 *
 * SDL makes no promises about what part of the joystick any given axis refers
 * to. Your game should have some sort of configuration UI to let users
 * specify what each axis should be bound to. Alternately, SDL's higher-level
 * Game Controller API makes a great effort to apply order to this lower-level
 * interface, so you know that a specific axis is the "left thumb stick," etc.
 *
 * The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to
 * 32767) representing the current position of the axis. It may be necessary
 * to impose certain tolerances on these values to account for jitter.
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \param axis the axis to query; the axis indices start at index 0
 * \returns a 16-bit signed integer representing the current position of the
 *          axis or 0 on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickNumAxes
 *)
  SDL_JoystickGetAxis: function(joystick: PSDL_Joystick; axis: Integer): Sint16; cdecl;

(**
 * Get the initial state of an axis control on a joystick.
 *
 * The state is a value ranging from -32768 to 32767.
 *
 * The axis indices start at index 0.
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \param axis the axis to query; the axis indices start at index 0
 * \param state Upon return, the initial value is supplied here.
 * \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_JoystickGetAxisInitialState: function(joystick: PSDL_Joystick; axis: Integer; state: PSint16): SDL_bool; cdecl;

(**
 * Get the current state of a POV hat on a joystick.
 *
 * The returned value will be one of the following positions:
 *
 * - `SDL_HAT_CENTERED`
 * - `SDL_HAT_UP`
 * - `SDL_HAT_RIGHT`
 * - `SDL_HAT_DOWN`
 * - `SDL_HAT_LEFT`
 * - `SDL_HAT_RIGHTUP`
 * - `SDL_HAT_RIGHTDOWN`
 * - `SDL_HAT_LEFTUP`
 * - `SDL_HAT_LEFTDOWN`
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \param hat the hat index to get the state from; indices start at index 0
 * \returns the current hat position.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickNumHats
 *)
  SDL_JoystickGetHat: function(joystick: PSDL_Joystick; hat: Integer): Uint8; cdecl;

(**
 * Get the ball axis change since the last poll.
 *
 * Trackballs can only return relative motion since the last call to
 * SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.
 *
 * Most joysticks do not have trackballs.
 *
 * \param joystick the SDL_Joystick to query
 * \param ball the ball index to query; ball indices start at index 0
 * \param dx stores the difference in the x axis position since the last poll
 * \param dy stores the difference in the y axis position since the last poll
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickNumBalls
 *)
  SDL_JoystickGetBall: function(joystick: PSDL_Joystick; ball: Integer; dx: PInteger; dy: PInteger): Integer; cdecl;

(**
 * Get the current state of a button on a joystick.
 *
 * \param joystick an SDL_Joystick structure containing joystick information
 * \param button the button index to get the state from; indices start at
 *               index 0
 * \returns 1 if the specified button is pressed, 0 otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickNumButtons
 *)
  SDL_JoystickGetButton: function(joystick: PSDL_Joystick; button: Integer): Uint8; cdecl;

(**
 * Start a rumble effect.
 *
 * Each call to this function cancels any previous rumble effect, and calling
 * it with 0 intensity stops any rumbling.
 *
 * \param joystick The joystick to vibrate
 * \param low_frequency_rumble The intensity of the low frequency (left)
 *                             rumble motor, from 0 to 0xFFFF
 * \param high_frequency_rumble The intensity of the high frequency (right)
 *                              rumble motor, from 0 to 0xFFFF
 * \param duration_ms The duration of the rumble effect, in milliseconds
 * \returns 0, or -1 if rumble isn't supported on this joystick
 *
 * \since This function is available since SDL 2.0.9.
 *
 * \sa SDL_JoystickHasRumble
 *)
  SDL_JoystickRumble: function(joystick: PSDL_Joystick; low_frequency_rumble: Uint16; high_frequency_rumble: Uint16; duration_ms: Uint32): Integer; cdecl;

(**
 * Start a rumble effect in the joystick's triggers
 *
 * Each call to this function cancels any previous trigger rumble effect, and
 * calling it with 0 intensity stops any rumbling.
 *
 * Note that this is rumbling of the _triggers_ and not the game controller as
 * a whole. This is currently only supported on Xbox One controllers. If you
 * want the (more common) whole-controller rumble, use SDL_JoystickRumble()
 * instead.
 *
 * \param joystick The joystick to vibrate
 * \param left_rumble The intensity of the left trigger rumble motor, from 0
 *                    to 0xFFFF
 * \param right_rumble The intensity of the right trigger rumble motor, from 0
 *                     to 0xFFFF
 * \param duration_ms The duration of the rumble effect, in milliseconds
 * \returns 0, or -1 if trigger rumble isn't supported on this joystick
 *
 * \since This function is available since SDL 2.0.14.
 *
 * \sa SDL_JoystickHasRumbleTriggers
 *)
  SDL_JoystickRumbleTriggers: function(joystick: PSDL_Joystick; left_rumble: Uint16; right_rumble: Uint16; duration_ms: Uint32): Integer; cdecl;

(**
 * Query whether a joystick has an LED.
 *
 * An example of a joystick LED is the light on the back of a PlayStation 4's
 * DualShock 4 controller.
 *
 * \param joystick The joystick to query
 * \return SDL_TRUE if the joystick has a modifiable LED, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickHasLED: function(joystick: PSDL_Joystick): SDL_bool; cdecl;

(**
 * Query whether a joystick has rumble support.
 *
 * \param joystick The joystick to query
 * \return SDL_TRUE if the joystick has rumble, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_JoystickRumble
 *)
  SDL_JoystickHasRumble: function(joystick: PSDL_Joystick): SDL_bool; cdecl;

(**
 * Query whether a joystick has rumble support on triggers.
 *
 * \param joystick The joystick to query
 * \return SDL_TRUE if the joystick has trigger rumble, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_JoystickRumbleTriggers
 *)
  SDL_JoystickHasRumbleTriggers: function(joystick: PSDL_Joystick): SDL_bool; cdecl;

(**
 * Update a joystick's LED color.
 *
 * An example of a joystick LED is the light on the back of a PlayStation 4's
 * DualShock 4 controller.
 *
 * \param joystick The joystick to update
 * \param red The intensity of the red LED
 * \param green The intensity of the green LED
 * \param blue The intensity of the blue LED
 * \returns 0 on success, -1 if this joystick does not have a modifiable LED
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_JoystickSetLED: function(joystick: PSDL_Joystick; red: Uint8; green: Uint8; blue: Uint8): Integer; cdecl;

(**
 * Send a joystick specific effect packet
 *
 * \param joystick The joystick to affect
 * \param data The data to send to the joystick
 * \param size The size of the data to send to the joystick
 * \returns 0, or -1 if this joystick or driver doesn't support effect packets
 *
 * \since This function is available since SDL 2.0.16.
 *)
  SDL_JoystickSendEffect: function(joystick: PSDL_Joystick; const data: Pointer; size: Integer): Integer; cdecl;

(**
 * Close a joystick previously opened with SDL_JoystickOpen().
 *
 * \param joystick The joystick device to close
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickOpen
 *)
  SDL_JoystickClose: procedure(joystick: PSDL_Joystick); cdecl;

(**
 * Get the battery level of a joystick as SDL_JoystickPowerLevel.
 *
 * \param joystick the SDL_Joystick to query
 * \returns the current battery level as SDL_JoystickPowerLevel on success or
 *          `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown
 *
 * \since This function is available since SDL 2.0.4.
 *)
  SDL_JoystickCurrentPowerLevel: function(joystick: PSDL_Joystick): SDL_JoystickPowerLevel; cdecl;

(**
 * Locking for multi-threaded access to the sensor API
 *
 * If you are using the sensor API or handling events from multiple threads
 * you should use these locking functions to protect access to the sensors.
 *
 * In particular, you are guaranteed that the sensor list won't change, so the
 * API functions that take a sensor index will be valid, and sensor events
 * will not be delivered.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_LockSensors: procedure(); cdecl;

  SDL_UnlockSensors: procedure(); cdecl;

(**
 * Count the number of sensors attached to the system right now.
 *
 * \returns the number of sensors detected.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_NumSensors: function(): Integer; cdecl;

(**
 * Get the implementation dependent name of a sensor.
 *
 * \param device_index The sensor to obtain name from
 * \returns the sensor name, or NULL if `device_index` is out of range.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetDeviceName: function(device_index: Integer): PUTF8Char; cdecl;

(**
 * Get the type of a sensor.
 *
 * \param device_index The sensor to get the type from
 * \returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `device_index` is
 *          out of range.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetDeviceType: function(device_index: Integer): SDL_SensorType; cdecl;

(**
 * Get the platform dependent type of a sensor.
 *
 * \param device_index The sensor to check
 * \returns the sensor platform dependent type, or -1 if `device_index` is out
 *          of range.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetDeviceNonPortableType: function(device_index: Integer): Integer; cdecl;

(**
 * Get the instance ID of a sensor.
 *
 * \param device_index The sensor to get instance id from
 * \returns the sensor instance ID, or -1 if `device_index` is out of range.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetDeviceInstanceID: function(device_index: Integer): SDL_SensorID; cdecl;

(**
 * Open a sensor for use.
 *
 * \param device_index The sensor to open
 * \returns an SDL_Sensor sensor object, or NULL if an error occurred.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorOpen: function(device_index: Integer): PSDL_Sensor; cdecl;

(**
 * Return the SDL_Sensor associated with an instance id.
 *
 * \param instance_id The sensor from instance id
 * \returns an SDL_Sensor object.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorFromInstanceID: function(instance_id: SDL_SensorID): PSDL_Sensor; cdecl;

(**
 * Get the implementation dependent name of a sensor
 *
 * \param sensor The SDL_Sensor object
 * \returns the sensor name, or NULL if `sensor` is NULL.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetName: function(sensor: PSDL_Sensor): PUTF8Char; cdecl;

(**
 * Get the type of a sensor.
 *
 * \param sensor The SDL_Sensor object to inspect
 * \returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is
 *          NULL.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetType: function(sensor: PSDL_Sensor): SDL_SensorType; cdecl;

(**
 * Get the platform dependent type of a sensor.
 *
 * \param sensor The SDL_Sensor object to inspect
 * \returns the sensor platform dependent type, or -1 if `sensor` is NULL.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetNonPortableType: function(sensor: PSDL_Sensor): Integer; cdecl;

(**
 * Get the instance ID of a sensor.
 *
 * \param sensor The SDL_Sensor object to inspect
 * \returns the sensor instance ID, or -1 if `sensor` is NULL.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetInstanceID: function(sensor: PSDL_Sensor): SDL_SensorID; cdecl;

(**
 * Get the current state of an opened sensor.
 *
 * The number of values and interpretation of the data is sensor dependent.
 *
 * \param sensor The SDL_Sensor object to query
 * \param data A pointer filled with the current sensor state
 * \param num_values The number of values to write to data
 * \returns 0 or -1 if an error occurred.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorGetData: function(sensor: PSDL_Sensor; data: PSingle; num_values: Integer): Integer; cdecl;

(**
 * Close a sensor previously opened with SDL_SensorOpen().
 *
 * \param sensor The SDL_Sensor object to close
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorClose: procedure(sensor: PSDL_Sensor); cdecl;

(**
 * Update the current state of the open sensors.
 *
 * This is called automatically by the event loop if sensor events are
 * enabled.
 *
 * This needs to be called from the thread that initialized the sensor
 * subsystem.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_SensorUpdate: procedure(); cdecl;

(**
 * Load a set of Game Controller mappings from a seekable SDL data stream.
 *
 * You can call this function several times, if needed, to load different
 * database files.
 *
 * If a new mapping is loaded for an already known controller GUID, the later
 * version will overwrite the one currently loaded.
 *
 * Mappings not belonging to the current platform or with no platform field
 * specified will be ignored (i.e. mappings for Linux will be ignored in
 * Windows, etc).
 *
 * This function will load the text database entirely in memory before
 * processing it, so take this into consideration if you are in a memory
 * constrained environment.
 *
 * \param rw the data stream for the mappings to be added
 * \param freerw non-zero to close the stream after being read
 * \returns the number of mappings added or -1 on error; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.2.
 *
 * \sa SDL_GameControllerAddMapping
 * \sa SDL_GameControllerAddMappingsFromFile
 * \sa SDL_GameControllerMappingForGUID
 *)
  SDL_GameControllerAddMappingsFromRW: function(rw: PSDL_RWops; freerw: Integer): Integer; cdecl;

(**
 * Add support for controllers that SDL is unaware of or to cause an existing
 * controller to have a different binding.
 *
 * The mapping string has the format "GUID,name,mapping", where GUID is the
 * string value from SDL_JoystickGetGUIDString(), name is the human readable
 * string for the device and mappings are controller mappings to joystick
 * ones. Under Windows there is a reserved GUID of "xinput" that covers all
 * XInput devices. The mapping format for joystick is: {| |bX |a joystick
 * button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick
 * |} Buttons can be used as a controller axes and vice versa.
 *
 * This string shows an example of a valid mapping for a controller:
 *
 * ```c
 * "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"
 * ```
 *
 * \param mappingString the mapping string
 * \returns 1 if a new mapping is added, 0 if an existing mapping is updated,
 *          -1 on error; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerMapping
 * \sa SDL_GameControllerMappingForGUID
 *)
  SDL_GameControllerAddMapping: function(const mappingString: PUTF8Char): Integer; cdecl;

(**
 * Get the number of mappings installed.
 *
 * \returns the number of mappings.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_GameControllerNumMappings: function(): Integer; cdecl;

(**
 * Get the mapping at a particular index.
 *
 * \returns the mapping string. Must be freed with SDL_free(). Returns NULL if
 *          the index is out of range.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_GameControllerMappingForIndex: function(mapping_index: Integer): PUTF8Char; cdecl;

(**
 * Get the game controller mapping string for a given GUID.
 *
 * The returned string must be freed with SDL_free().
 *
 * \param guid a structure containing the GUID for which a mapping is desired
 * \returns a mapping string or NULL on error; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickGetDeviceGUID
 * \sa SDL_JoystickGetGUID
 *)
  SDL_GameControllerMappingForGUID: function(guid: SDL_JoystickGUID): PUTF8Char; cdecl;

(**
 * Get the current mapping of a Game Controller.
 *
 * The returned string must be freed with SDL_free().
 *
 * Details about mappings are discussed with SDL_GameControllerAddMapping().
 *
 * \param gamecontroller the game controller you want to get the current
 *                       mapping for
 * \returns a string that has the controller's mapping or NULL if no mapping
 *          is available; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerAddMapping
 * \sa SDL_GameControllerMappingForGUID
 *)
  SDL_GameControllerMapping: function(gamecontroller: PSDL_GameController): PUTF8Char; cdecl;

(**
 * Check if the given joystick is supported by the game controller interface.
 *
 * `joystick_index` is the same as the `device_index` passed to
 * SDL_JoystickOpen().
 *
 * \param joystick_index the device_index of a device, up to
 *                       SDL_NumJoysticks()
 * \returns SDL_TRUE if the given joystick is supported by the game controller
 *          interface, SDL_FALSE if it isn't or it's an invalid index.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerNameForIndex
 * \sa SDL_GameControllerOpen
 *)
  SDL_IsGameController: function(joystick_index: Integer): SDL_bool; cdecl;

(**
 * Get the implementation dependent name for the game controller.
 *
 * This function can be called before any controllers are opened.
 *
 * `joystick_index` is the same as the `device_index` passed to
 * SDL_JoystickOpen().
 *
 * \param joystick_index the device_index of a device, from zero to
 *                       SDL_NumJoysticks()-1
 * \returns the implementation-dependent name for the game controller, or NULL
 *          if there is no name or the index is invalid.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerName
 * \sa SDL_GameControllerOpen
 * \sa SDL_IsGameController
 *)
  SDL_GameControllerNameForIndex: function(joystick_index: Integer): PUTF8Char; cdecl;

(**
 * Get the implementation dependent path for the game controller.
 *
 * This function can be called before any controllers are opened.
 *
 * `joystick_index` is the same as the `device_index` passed to
 * SDL_JoystickOpen().
 *
 * \param joystick_index the device_index of a device, from zero to
 *                       SDL_NumJoysticks()-1
 * \returns the implementation-dependent path for the game controller, or NULL
 *          if there is no path or the index is invalid.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GameControllerPath
 *)
  SDL_GameControllerPathForIndex: function(joystick_index: Integer): PUTF8Char; cdecl;

(**
 * Get the type of a game controller.
 *
 * This can be called before any controllers are opened.
 *
 * \param joystick_index the device_index of a device, from zero to
 *                       SDL_NumJoysticks()-1
 * \returns the controller type.
 *
 * \since This function is available since SDL 2.0.12.
 *)
  SDL_GameControllerTypeForIndex: function(joystick_index: Integer): SDL_GameControllerType; cdecl;

(**
 * Get the mapping of a game controller.
 *
 * This can be called before any controllers are opened.
 *
 * \param joystick_index the device_index of a device, from zero to
 *                       SDL_NumJoysticks()-1
 * \returns the mapping string. Must be freed with SDL_free(). Returns NULL if
 *          no mapping is available.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_GameControllerMappingForDeviceIndex: function(joystick_index: Integer): PUTF8Char; cdecl;

(**
 * Open a game controller for use.
 *
 * `joystick_index` is the same as the `device_index` passed to
 * SDL_JoystickOpen().
 *
 * The index passed as an argument refers to the N'th game controller on the
 * system. This index is not the value which will identify this controller in
 * future controller events. The joystick's instance id (SDL_JoystickID) will
 * be used there instead.
 *
 * \param joystick_index the device_index of a device, up to
 *                       SDL_NumJoysticks()
 * \returns a gamecontroller identifier or NULL if an error occurred; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerClose
 * \sa SDL_GameControllerNameForIndex
 * \sa SDL_IsGameController
 *)
  SDL_GameControllerOpen: function(joystick_index: Integer): PSDL_GameController; cdecl;

(**
 * Get the SDL_GameController associated with an instance id.
 *
 * \param joyid the instance id to get the SDL_GameController for
 * \returns an SDL_GameController on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.4.
 *)
  SDL_GameControllerFromInstanceID: function(joyid: SDL_JoystickID): PSDL_GameController; cdecl;

(**
 * Get the SDL_GameController associated with a player index.
 *
 * Please note that the player index is _not_ the device index, nor is it the
 * instance id!
 *
 * \param player_index the player index, which is not the device index or the
 *                     instance id!
 * \returns the SDL_GameController associated with a player index.
 *
 * \since This function is available since SDL 2.0.12.
 *
 * \sa SDL_GameControllerGetPlayerIndex
 * \sa SDL_GameControllerSetPlayerIndex
 *)
  SDL_GameControllerFromPlayerIndex: function(player_index: Integer): PSDL_GameController; cdecl;

(**
 * Get the implementation-dependent name for an opened game controller.
 *
 * This is the same name as returned by SDL_GameControllerNameForIndex(), but
 * it takes a controller identifier instead of the (unstable) device index.
 *
 * \param gamecontroller a game controller identifier previously returned by
 *                       SDL_GameControllerOpen()
 * \returns the implementation dependent name for the game controller, or NULL
 *          if there is no name or the identifier passed is invalid.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerNameForIndex
 * \sa SDL_GameControllerOpen
 *)
  SDL_GameControllerName: function(gamecontroller: PSDL_GameController): PUTF8Char; cdecl;

(**
 * Get the implementation-dependent path for an opened game controller.
 *
 * This is the same path as returned by SDL_GameControllerNameForIndex(), but
 * it takes a controller identifier instead of the (unstable) device index.
 *
 * \param gamecontroller a game controller identifier previously returned by
 *                       SDL_GameControllerOpen()
 * \returns the implementation dependent path for the game controller, or NULL
 *          if there is no path or the identifier passed is invalid.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GameControllerPathForIndex
 *)
  SDL_GameControllerPath: function(gamecontroller: PSDL_GameController): PUTF8Char; cdecl;

(**
 * Get the type of this currently opened controller
 *
 * This is the same name as returned by SDL_GameControllerTypeForIndex(), but
 * it takes a controller identifier instead of the (unstable) device index.
 *
 * \param gamecontroller the game controller object to query.
 * \returns the controller type.
 *
 * \since This function is available since SDL 2.0.12.
 *)
  SDL_GameControllerGetType: function(gamecontroller: PSDL_GameController): SDL_GameControllerType; cdecl;

(**
 * Get the player index of an opened game controller.
 *
 * For XInput controllers this returns the XInput user index.
 *
 * \param gamecontroller the game controller object to query.
 * \returns the player index for controller, or -1 if it's not available.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_GameControllerGetPlayerIndex: function(gamecontroller: PSDL_GameController): Integer; cdecl;

(**
 * Set the player index of an opened game controller.
 *
 * \param gamecontroller the game controller object to adjust.
 * \param player_index Player index to assign to this controller, or -1 to
 *                     clear the player index and turn off player LEDs.
 *
 * \since This function is available since SDL 2.0.12.
 *)
  SDL_GameControllerSetPlayerIndex: procedure(gamecontroller: PSDL_GameController; player_index: Integer); cdecl;

(**
 * Get the USB vendor ID of an opened controller, if available.
 *
 * If the vendor ID isn't available this function returns 0.
 *
 * \param gamecontroller the game controller object to query.
 * \return the USB vendor ID, or zero if unavailable.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_GameControllerGetVendor: function(gamecontroller: PSDL_GameController): Uint16; cdecl;

(**
 * Get the USB product ID of an opened controller, if available.
 *
 * If the product ID isn't available this function returns 0.
 *
 * \param gamecontroller the game controller object to query.
 * \return the USB product ID, or zero if unavailable.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_GameControllerGetProduct: function(gamecontroller: PSDL_GameController): Uint16; cdecl;

(**
 * Get the product version of an opened controller, if available.
 *
 * If the product version isn't available this function returns 0.
 *
 * \param gamecontroller the game controller object to query.
 * \return the USB product version, or zero if unavailable.
 *
 * \since This function is available since SDL 2.0.6.
 *)
  SDL_GameControllerGetProductVersion: function(gamecontroller: PSDL_GameController): Uint16; cdecl;

(**
 * Get the firmware version of an opened controller, if available.
 *
 * If the firmware version isn't available this function returns 0.
 *
 * \param gamecontroller the game controller object to query.
 * \return the controller firmware version, or zero if unavailable.
 *
 * \since This function is available since SDL 2.24.0.
 *)
  SDL_GameControllerGetFirmwareVersion: function(gamecontroller: PSDL_GameController): Uint16; cdecl;

(**
 * Get the serial number of an opened controller, if available.
 *
 * Returns the serial number of the controller, or NULL if it is not
 * available.
 *
 * \param gamecontroller the game controller object to query.
 * \return the serial number, or NULL if unavailable.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerGetSerial: function(gamecontroller: PSDL_GameController): PUTF8Char; cdecl;

(**
 * Check if a controller has been opened and is currently connected.
 *
 * \param gamecontroller a game controller identifier previously returned by
 *                       SDL_GameControllerOpen()
 * \returns SDL_TRUE if the controller has been opened and is currently
 *          connected, or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerClose
 * \sa SDL_GameControllerOpen
 *)
  SDL_GameControllerGetAttached: function(gamecontroller: PSDL_GameController): SDL_bool; cdecl;

(**
 * Get the Joystick ID from a Game Controller.
 *
 * This function will give you a SDL_Joystick object, which allows you to use
 * the SDL_Joystick functions with a SDL_GameController object. This would be
 * useful for getting a joystick's position at any given time, even if it
 * hasn't moved (moving it would produce an event, which would have the axis'
 * value).
 *
 * The pointer returned is owned by the SDL_GameController. You should not
 * call SDL_JoystickClose() on it, for example, since doing so will likely
 * cause SDL to crash.
 *
 * \param gamecontroller the game controller object that you want to get a
 *                       joystick from
 * \returns a SDL_Joystick object; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GameControllerGetJoystick: function(gamecontroller: PSDL_GameController): PSDL_Joystick; cdecl;

(**
 * Query or change current state of Game Controller events.
 *
 * If controller events are disabled, you must call SDL_GameControllerUpdate()
 * yourself and check the state of the controller when you want controller
 * information.
 *
 * Any number can be passed to SDL_GameControllerEventState(), but only -1, 0,
 * and 1 will have any effect. Other numbers will just be returned.
 *
 * \param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`
 * \returns the same value passed to the function, with exception to -1
 *          (SDL_QUERY), which will return the current state.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_JoystickEventState
 *)
  SDL_GameControllerEventState: function(state: Integer): Integer; cdecl;

(**
 * Manually pump game controller updates if not using the loop.
 *
 * This function is called automatically by the event loop if events are
 * enabled. Under such circumstances, it will not be necessary to call this
 * function.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GameControllerUpdate: procedure(); cdecl;

(**
 * Convert a string into SDL_GameControllerAxis enum.
 *
 * This function is called internally to translate SDL_GameController mapping
 * strings for the underlying joystick device into the consistent
 * SDL_GameController mapping. You do not normally need to call this function
 * unless you are parsing SDL_GameController mappings in your own code.
 *
 * Note specially that "righttrigger" and "lefttrigger" map to
 * `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,
 * respectively.
 *
 * \param str string representing a SDL_GameController axis
 * \returns the SDL_GameControllerAxis enum corresponding to the input string,
 *          or `SDL_CONTROLLER_AXIS_INVALID` if no match was found.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerGetStringForAxis
 *)
  SDL_GameControllerGetAxisFromString: function(const str: PUTF8Char): SDL_GameControllerAxis; cdecl;

(**
 * Convert from an SDL_GameControllerAxis enum to a string.
 *
 * The caller should not SDL_free() the returned string.
 *
 * \param axis an enum value for a given SDL_GameControllerAxis
 * \returns a string for the given axis, or NULL if an invalid axis is
 *          specified. The string returned is of the format used by
 *          SDL_GameController mapping strings.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerGetAxisFromString
 *)
  SDL_GameControllerGetStringForAxis: function(axis: SDL_GameControllerAxis): PUTF8Char; cdecl;

(**
 * Get the SDL joystick layer binding for a controller axis mapping.
 *
 * \param gamecontroller a game controller
 * \param axis an axis enum value (one of the SDL_GameControllerAxis values)
 * \returns a SDL_GameControllerButtonBind describing the bind. On failure
 *          (like the given Controller axis doesn't exist on the device), its
 *          `.bindType` will be `SDL_CONTROLLER_BINDTYPE_NONE`.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerGetBindForButton
 *)
  SDL_GameControllerGetBindForAxis: function(gamecontroller: PSDL_GameController; axis: SDL_GameControllerAxis): SDL_GameControllerButtonBind; cdecl;

(**
 * Query whether a game controller has a given axis.
 *
 * This merely reports whether the controller's mapping defined this axis, as
 * that is all the information SDL has about the physical device.
 *
 * \param gamecontroller a game controller
 * \param axis an axis enum value (an SDL_GameControllerAxis value)
 * \returns SDL_TRUE if the controller has this axis, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerHasAxis: function(gamecontroller: PSDL_GameController; axis: SDL_GameControllerAxis): SDL_bool; cdecl;

(**
 * Get the current state of an axis control on a game controller.
 *
 * The axis indices start at index 0.
 *
 * The state is a value ranging from -32768 to 32767. Triggers, however, range
 * from 0 to 32767 (they never return a negative value).
 *
 * \param gamecontroller a game controller
 * \param axis an axis index (one of the SDL_GameControllerAxis values)
 * \returns axis state (including 0) on success or 0 (also) on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerGetButton
 *)
  SDL_GameControllerGetAxis: function(gamecontroller: PSDL_GameController; axis: SDL_GameControllerAxis): Sint16; cdecl;

(**
 * Convert a string into an SDL_GameControllerButton enum.
 *
 * This function is called internally to translate SDL_GameController mapping
 * strings for the underlying joystick device into the consistent
 * SDL_GameController mapping. You do not normally need to call this function
 * unless you are parsing SDL_GameController mappings in your own code.
 *
 * \param str string representing a SDL_GameController axis
 * \returns the SDL_GameControllerButton enum corresponding to the input
 *          string, or `SDL_CONTROLLER_AXIS_INVALID` if no match was found.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GameControllerGetButtonFromString: function(const str: PUTF8Char): SDL_GameControllerButton; cdecl;

(**
 * Convert from an SDL_GameControllerButton enum to a string.
 *
 * The caller should not SDL_free() the returned string.
 *
 * \param button an enum value for a given SDL_GameControllerButton
 * \returns a string for the given button, or NULL if an invalid axis is
 *          specified. The string returned is of the format used by
 *          SDL_GameController mapping strings.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerGetButtonFromString
 *)
  SDL_GameControllerGetStringForButton: function(button: SDL_GameControllerButton): PUTF8Char; cdecl;

(**
 * Get the SDL joystick layer binding for a controller button mapping.
 *
 * \param gamecontroller a game controller
 * \param button an button enum value (an SDL_GameControllerButton value)
 * \returns a SDL_GameControllerButtonBind describing the bind. On failure
 *          (like the given Controller button doesn't exist on the device),
 *          its `.bindType` will be `SDL_CONTROLLER_BINDTYPE_NONE`.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerGetBindForAxis
 *)
  SDL_GameControllerGetBindForButton: function(gamecontroller: PSDL_GameController; button: SDL_GameControllerButton): SDL_GameControllerButtonBind; cdecl;

(**
 * Query whether a game controller has a given button.
 *
 * This merely reports whether the controller's mapping defined this button,
 * as that is all the information SDL has about the physical device.
 *
 * \param gamecontroller a game controller
 * \param button a button enum value (an SDL_GameControllerButton value)
 * \returns SDL_TRUE if the controller has this button, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerHasButton: function(gamecontroller: PSDL_GameController; button: SDL_GameControllerButton): SDL_bool; cdecl;

(**
 * Get the current state of a button on a game controller.
 *
 * \param gamecontroller a game controller
 * \param button a button index (one of the SDL_GameControllerButton values)
 * \returns 1 for pressed state or 0 for not pressed state or error; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerGetAxis
 *)
  SDL_GameControllerGetButton: function(gamecontroller: PSDL_GameController; button: SDL_GameControllerButton): Uint8; cdecl;

(**
 * Get the number of touchpads on a game controller.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerGetNumTouchpads: function(gamecontroller: PSDL_GameController): Integer; cdecl;

(**
 * Get the number of supported simultaneous fingers on a touchpad on a game
 * controller.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerGetNumTouchpadFingers: function(gamecontroller: PSDL_GameController; touchpad: Integer): Integer; cdecl;

(**
 * Get the current state of a finger on a touchpad on a game controller.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerGetTouchpadFinger: function(gamecontroller: PSDL_GameController; touchpad: Integer; finger: Integer; state: PUint8; x: PSingle; y: PSingle; pressure: PSingle): Integer; cdecl;

(**
 * Return whether a game controller has a particular sensor.
 *
 * \param gamecontroller The controller to query
 * \param type The type of sensor to query
 * \returns SDL_TRUE if the sensor exists, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerHasSensor: function(gamecontroller: PSDL_GameController; type_: SDL_SensorType): SDL_bool; cdecl;

(**
 * Set whether data reporting for a game controller sensor is enabled.
 *
 * \param gamecontroller The controller to update
 * \param type The type of sensor to enable/disable
 * \param enabled Whether data reporting should be enabled
 * \returns 0 or -1 if an error occurred.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerSetSensorEnabled: function(gamecontroller: PSDL_GameController; type_: SDL_SensorType; enabled: SDL_bool): Integer; cdecl;

(**
 * Query whether sensor data reporting is enabled for a game controller.
 *
 * \param gamecontroller The controller to query
 * \param type The type of sensor to query
 * \returns SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerIsSensorEnabled: function(gamecontroller: PSDL_GameController; type_: SDL_SensorType): SDL_bool; cdecl;

(**
 * Get the data rate (number of events per second) of a game controller
 * sensor.
 *
 * \param gamecontroller The controller to query
 * \param type The type of sensor to query
 * \return the data rate, or 0.0f if the data rate is not available.
 *
 * \since This function is available since SDL 2.0.16.
 *)
  SDL_GameControllerGetSensorDataRate: function(gamecontroller: PSDL_GameController; type_: SDL_SensorType): Single; cdecl;

(**
 * Get the current state of a game controller sensor.
 *
 * The number of values and interpretation of the data is sensor dependent.
 * See SDL_sensor.h for the details for each type of sensor.
 *
 * \param gamecontroller The controller to query
 * \param type The type of sensor to query
 * \param data A pointer filled with the current sensor state
 * \param num_values The number of values to write to data
 * \return 0 or -1 if an error occurred.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerGetSensorData: function(gamecontroller: PSDL_GameController; type_: SDL_SensorType; data: PSingle; num_values: Integer): Integer; cdecl;

(**
 * Start a rumble effect on a game controller.
 *
 * Each call to this function cancels any previous rumble effect, and calling
 * it with 0 intensity stops any rumbling.
 *
 * \param gamecontroller The controller to vibrate
 * \param low_frequency_rumble The intensity of the low frequency (left)
 *                             rumble motor, from 0 to 0xFFFF
 * \param high_frequency_rumble The intensity of the high frequency (right)
 *                              rumble motor, from 0 to 0xFFFF
 * \param duration_ms The duration of the rumble effect, in milliseconds
 * \returns 0, or -1 if rumble isn't supported on this controller
 *
 * \since This function is available since SDL 2.0.9.
 *
 * \sa SDL_GameControllerHasRumble
 *)
  SDL_GameControllerRumble: function(gamecontroller: PSDL_GameController; low_frequency_rumble: Uint16; high_frequency_rumble: Uint16; duration_ms: Uint32): Integer; cdecl;

(**
 * Start a rumble effect in the game controller's triggers.
 *
 * Each call to this function cancels any previous trigger rumble effect, and
 * calling it with 0 intensity stops any rumbling.
 *
 * Note that this is rumbling of the _triggers_ and not the game controller as
 * a whole. This is currently only supported on Xbox One controllers. If you
 * want the (more common) whole-controller rumble, use
 * SDL_GameControllerRumble() instead.
 *
 * \param gamecontroller The controller to vibrate
 * \param left_rumble The intensity of the left trigger rumble motor, from 0
 *                    to 0xFFFF
 * \param right_rumble The intensity of the right trigger rumble motor, from 0
 *                     to 0xFFFF
 * \param duration_ms The duration of the rumble effect, in milliseconds
 * \returns 0, or -1 if trigger rumble isn't supported on this controller
 *
 * \since This function is available since SDL 2.0.14.
 *
 * \sa SDL_GameControllerHasRumbleTriggers
 *)
  SDL_GameControllerRumbleTriggers: function(gamecontroller: PSDL_GameController; left_rumble: Uint16; right_rumble: Uint16; duration_ms: Uint32): Integer; cdecl;

(**
 * Query whether a game controller has an LED.
 *
 * \param gamecontroller The controller to query
 * \returns SDL_TRUE, or SDL_FALSE if this controller does not have a
 *          modifiable LED
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerHasLED: function(gamecontroller: PSDL_GameController): SDL_bool; cdecl;

(**
 * Query whether a game controller has rumble support.
 *
 * \param gamecontroller The controller to query
 * \returns SDL_TRUE, or SDL_FALSE if this controller does not have rumble
 *          support
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_GameControllerRumble
 *)
  SDL_GameControllerHasRumble: function(gamecontroller: PSDL_GameController): SDL_bool; cdecl;

(**
 * Query whether a game controller has rumble support on triggers.
 *
 * \param gamecontroller The controller to query
 * \returns SDL_TRUE, or SDL_FALSE if this controller does not have trigger
 *          rumble support
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_GameControllerRumbleTriggers
 *)
  SDL_GameControllerHasRumbleTriggers: function(gamecontroller: PSDL_GameController): SDL_bool; cdecl;

(**
 * Update a game controller's LED color.
 *
 * \param gamecontroller The controller to update
 * \param red The intensity of the red LED
 * \param green The intensity of the green LED
 * \param blue The intensity of the blue LED
 * \returns 0, or -1 if this controller does not have a modifiable LED
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GameControllerSetLED: function(gamecontroller: PSDL_GameController; red: Uint8; green: Uint8; blue: Uint8): Integer; cdecl;

(**
 * Send a controller specific effect packet
 *
 * \param gamecontroller The controller to affect
 * \param data The data to send to the controller
 * \param size The size of the data to send to the controller
 * \returns 0, or -1 if this controller or driver doesn't support effect
 *          packets
 *
 * \since This function is available since SDL 2.0.16.
 *)
  SDL_GameControllerSendEffect: function(gamecontroller: PSDL_GameController; const data: Pointer; size: Integer): Integer; cdecl;

(**
 * Close a game controller previously opened with SDL_GameControllerOpen().
 *
 * \param gamecontroller a game controller identifier previously returned by
 *                       SDL_GameControllerOpen()
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GameControllerOpen
 *)
  SDL_GameControllerClose: procedure(gamecontroller: PSDL_GameController); cdecl;

(**
 * Return the sfSymbolsName for a given button on a game controller on Apple
 * platforms.
 *
 * \param gamecontroller the controller to query
 * \param button a button on the game controller
 * \returns the sfSymbolsName or NULL if the name can't be found
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_GameControllerGetAppleSFSymbolsNameForAxis
 *)
  SDL_GameControllerGetAppleSFSymbolsNameForButton: function(gamecontroller: PSDL_GameController; button: SDL_GameControllerButton): PUTF8Char; cdecl;

(**
 * Return the sfSymbolsName for a given axis on a game controller on Apple
 * platforms.
 *
 * \param gamecontroller the controller to query
 * \param axis an axis on the game controller
 * \returns the sfSymbolsName or NULL if the name can't be found
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_GameControllerGetAppleSFSymbolsNameForButton
 *)
  SDL_GameControllerGetAppleSFSymbolsNameForAxis: function(gamecontroller: PSDL_GameController; axis: SDL_GameControllerAxis): PUTF8Char; cdecl;

(**
 * Get the number of registered touch devices.
 *
 * On some platforms SDL first sees the touch device if it was actually used.
 * Therefore SDL_GetNumTouchDevices() may return 0 although devices are
 * available. After using all devices at least once the number will be
 * correct.
 *
 * This was fixed for Android in SDL 2.0.1.
 *
 * \returns the number of registered touch devices.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetTouchDevice
 *)
  SDL_GetNumTouchDevices: function(): Integer; cdecl;

(**
 * Get the touch ID with the given index.
 *
 * \param index the touch device index
 * \returns the touch ID with the given index on success or 0 if the index is
 *          invalid; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetNumTouchDevices
 *)
  SDL_GetTouchDevice: function(index: Integer): SDL_TouchID; cdecl;

(**
 * Get the touch device name as reported from the driver or NULL if the index
 * is invalid.
 *
 * \since This function is available since SDL 2.0.22.
 *)
  SDL_GetTouchName: function(index: Integer): PUTF8Char; cdecl;

(**
 * Get the type of the given touch device.
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_GetTouchDeviceType: function(touchID: SDL_TouchID): SDL_TouchDeviceType; cdecl;

(**
 * Get the number of active fingers for a given touch device.
 *
 * \param touchID the ID of a touch device
 * \returns the number of active fingers for a given touch device on success
 *          or 0 on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetTouchFinger
 *)
  SDL_GetNumTouchFingers: function(touchID: SDL_TouchID): Integer; cdecl;

(**
 * Get the finger object for specified touch device ID and finger index.
 *
 * The returned resource is owned by SDL and should not be deallocated.
 *
 * \param touchID the ID of the requested touch device
 * \param index the index of the requested finger
 * \returns a pointer to the SDL_Finger object or NULL if no object at the
 *          given ID and index could be found.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RecordGesture
 *)
  SDL_GetTouchFinger: function(touchID: SDL_TouchID; index: Integer): PSDL_Finger; cdecl;

(**
 * Begin recording a gesture on a specified touch device or all touch devices.
 *
 * If the parameter `touchId` is -1 (i.e., all devices), this function will
 * always return 1, regardless of whether there actually are any devices.
 *
 * \param touchId the touch device id, or -1 for all touch devices
 * \returns 1 on success or 0 if the specified device could not be found.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetTouchDevice
 *)
  SDL_RecordGesture: function(touchId: SDL_TouchID): Integer; cdecl;

(**
 * Save all currently loaded Dollar Gesture templates.
 *
 * \param dst a SDL_RWops to save to
 * \returns the number of saved templates on success or 0 on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LoadDollarTemplates
 * \sa SDL_SaveDollarTemplate
 *)
  SDL_SaveAllDollarTemplates: function(dst: PSDL_RWops): Integer; cdecl;

(**
 * Save a currently loaded Dollar Gesture template.
 *
 * \param gestureId a gesture id
 * \param dst a SDL_RWops to save to
 * \returns 1 on success or 0 on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LoadDollarTemplates
 * \sa SDL_SaveAllDollarTemplates
 *)
  SDL_SaveDollarTemplate: function(gestureId: SDL_GestureID; dst: PSDL_RWops): Integer; cdecl;

(**
 * Load Dollar Gesture templates from a file.
 *
 * \param touchId a touch id
 * \param src a SDL_RWops to load from
 * \returns the number of loaded templates on success or a negative error code
 *          (or 0) on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SaveAllDollarTemplates
 * \sa SDL_SaveDollarTemplate
 *)
  SDL_LoadDollarTemplates: function(touchId: SDL_TouchID; src: PSDL_RWops): Integer; cdecl;

(**
 * Pump the event loop, gathering events from the input devices.
 *
 * This function updates the event queue and internal input device state.
 *
 * **WARNING**: This should only be run in the thread that initialized the
 * video subsystem, and for extra safety, you should consider only doing those
 * things on the main thread in any case.
 *
 * SDL_PumpEvents() gathers all the pending input information from devices and
 * places it in the event queue. Without calls to SDL_PumpEvents() no events
 * would ever be placed on the queue. Often the need for calls to
 * SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and
 * SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not
 * polling or waiting for events (e.g. you are filtering them), then you must
 * call SDL_PumpEvents() to force an event queue update.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_WaitEvent
 *)
  SDL_PumpEvents: procedure(); cdecl;

(**
 * Check the event queue for messages and optionally return them.
 *
 * `action` may be any of the following:
 *
 * - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the
 *   event queue.
 * - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,
 *   within the specified minimum and maximum type, will be returned to the
 *   caller and will _not_ be removed from the queue.
 * - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,
 *   within the specified minimum and maximum type, will be returned to the
 *   caller and will be removed from the queue.
 *
 * You may have to call SDL_PumpEvents() before calling this function.
 * Otherwise, the events may not be ready to be filtered when you call
 * SDL_PeepEvents().
 *
 * This function is thread-safe.
 *
 * \param events destination buffer for the retrieved events
 * \param numevents if action is SDL_ADDEVENT, the number of events to add
 *                  back to the event queue; if action is SDL_PEEKEVENT or
 *                  SDL_GETEVENT, the maximum number of events to retrieve
 * \param action action to take; see [[#action|Remarks]] for details
 * \param minType minimum value of the event type to be considered;
 *                SDL_FIRSTEVENT is a safe choice
 * \param maxType maximum value of the event type to be considered;
 *                SDL_LASTEVENT is a safe choice
 * \returns the number of events actually stored or a negative error code on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_PumpEvents
 * \sa SDL_PushEvent
 *)
  SDL_PeepEvents: function(events: PSDL_Event; numevents: Integer; action: SDL_eventaction; minType: Uint32; maxType: Uint32): Integer; cdecl;

(**
 * Check for the existence of a certain event type in the event queue.
 *
 * If you need to check for a range of event types, use SDL_HasEvents()
 * instead.
 *
 * \param type the type of event to be queried; see SDL_EventType for details
 * \returns SDL_TRUE if events matching `type` are present, or SDL_FALSE if
 *          events matching `type` are not present.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HasEvents
 *)
  SDL_HasEvent: function(type_: Uint32): SDL_bool; cdecl;

(**
 * Check for the existence of certain event types in the event queue.
 *
 * If you need to check for a single event type, use SDL_HasEvent() instead.
 *
 * \param minType the low end of event type to be queried, inclusive; see
 *                SDL_EventType for details
 * \param maxType the high end of event type to be queried, inclusive; see
 *                SDL_EventType for details
 * \returns SDL_TRUE if events with type >= `minType` and <= `maxType` are
 *          present, or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HasEvents
 *)
  SDL_HasEvents: function(minType: Uint32; maxType: Uint32): SDL_bool; cdecl;

(**
 * Clear events of a specific type from the event queue.
 *
 * This will unconditionally remove any events from the queue that match
 * `type`. If you need to remove a range of event types, use SDL_FlushEvents()
 * instead.
 *
 * It's also normal to just ignore events you don't care about in your event
 * loop without calling this function.
 *
 * This function only affects currently queued events. If you want to make
 * sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 * on the main thread immediately before the flush call.
 *
 * \param type the type of event to be cleared; see SDL_EventType for details
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FlushEvents
 *)
  SDL_FlushEvent: procedure(type_: Uint32); cdecl;

(**
 * Clear events of a range of types from the event queue.
 *
 * This will unconditionally remove any events from the queue that are in the
 * range of `minType` to `maxType`, inclusive. If you need to remove a single
 * event type, use SDL_FlushEvent() instead.
 *
 * It's also normal to just ignore events you don't care about in your event
 * loop without calling this function.
 *
 * This function only affects currently queued events. If you want to make
 * sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 * on the main thread immediately before the flush call.
 *
 * \param minType the low end of event type to be cleared, inclusive; see
 *                SDL_EventType for details
 * \param maxType the high end of event type to be cleared, inclusive; see
 *                SDL_EventType for details
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_FlushEvent
 *)
  SDL_FlushEvents: procedure(minType: Uint32; maxType: Uint32); cdecl;

(**
 * Poll for currently pending events.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`. The 1 returned refers to
 * this event, immediately stored in the SDL Event structure -- not an event
 * to follow.
 *
 * If `event` is NULL, it simply returns 1 if there is an event in the queue,
 * but will not remove it from the queue.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that set the video mode.
 *
 * SDL_PollEvent() is the favored way of receiving system events since it can
 * be done from the main loop and does not suspend the main loop while waiting
 * on an event to be posted.
 *
 * The common practice is to fully process the event queue once every frame,
 * usually as a first step before updating the game's state:
 *
 * ```c
 * while (game_is_still_running) {
 *     SDL_Event event;
 *     while (SDL_PollEvent(&event)) {  // poll until all events are handled!
 *         // decide what to do with this event.
 *     }
 *
 *     // update game state, draw the current frame
 * }
 * ```
 *
 * \param event the SDL_Event structure to be filled with the next event from
 *              the queue, or NULL
 * \returns 1 if there is a pending event or 0 if there are none available.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetEventFilter
 * \sa SDL_PeepEvents
 * \sa SDL_PushEvent
 * \sa SDL_SetEventFilter
 * \sa SDL_WaitEvent
 * \sa SDL_WaitEventTimeout
 *)
  SDL_PollEvent: function(event: PSDL_Event): Integer; cdecl;

(**
 * Wait indefinitely for the next available event.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * \param event the SDL_Event structure to be filled in with the next event
 *              from the queue, or NULL
 * \returns 1 on success or 0 if there was an error while waiting for events;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_PumpEvents
 * \sa SDL_WaitEventTimeout
 *)
  SDL_WaitEvent: function(event: PSDL_Event): Integer; cdecl;

(**
 * Wait until the specified timeout (in milliseconds) for the next available
 * event.
 *
 * If `event` is not NULL, the next event is removed from the queue and stored
 * in the SDL_Event structure pointed to by `event`.
 *
 * As this function may implicitly call SDL_PumpEvents(), you can only call
 * this function in the thread that initialized the video subsystem.
 *
 * \param event the SDL_Event structure to be filled in with the next event
 *              from the queue, or NULL
 * \param timeout the maximum number of milliseconds to wait for the next
 *                available event
 * \returns 1 on success or 0 if there was an error while waiting for events;
 *          call SDL_GetError() for more information. This also returns 0 if
 *          the timeout elapsed without an event arriving.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PollEvent
 * \sa SDL_PumpEvents
 * \sa SDL_WaitEvent
 *)
  SDL_WaitEventTimeout: function(event: PSDL_Event; timeout: Integer): Integer; cdecl;

(**
 * Add an event to the event queue.
 *
 * The event queue can actually be used as a two way communication channel.
 * Not only can events be read from the queue, but the user can also push
 * their own events onto it. `event` is a pointer to the event structure you
 * wish to push onto the queue. The event is copied into the queue, and the
 * caller may dispose of the memory pointed to after SDL_PushEvent() returns.
 *
 * Note: Pushing device input events onto the queue doesn't modify the state
 * of the device within SDL.
 *
 * This function is thread-safe, and can be called from other threads safely.
 *
 * Note: Events pushed onto the queue with SDL_PushEvent() get passed through
 * the event filter but events added with SDL_PeepEvents() do not.
 *
 * For pushing application-specific events, please use SDL_RegisterEvents() to
 * get an event type that does not conflict with other code that also wants
 * its own custom event types.
 *
 * \param event the SDL_Event to be added to the queue
 * \returns 1 on success, 0 if the event was filtered, or a negative error
 *          code on failure; call SDL_GetError() for more information. A
 *          common reason for error is the event queue being full.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PeepEvents
 * \sa SDL_PollEvent
 * \sa SDL_RegisterEvents
 *)
  SDL_PushEvent: function(event: PSDL_Event): Integer; cdecl;

(**
 * Set up a filter to process all events before they change internal state and
 * are posted to the internal event queue.
 *
 * If the filter function returns 1 when called, then the event will be added
 * to the internal queue. If it returns 0, then the event will be dropped from
 * the queue, but the internal state will still be updated. This allows
 * selective filtering of dynamically arriving events.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * On platforms that support it, if the quit event is generated by an
 * interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the
 * application at the next event poll.
 *
 * There is one caveat when dealing with the ::SDL_QuitEvent event type. The
 * event filter is only called when the window manager desires to close the
 * application window. If the event filter returns 1, then the window will be
 * closed, otherwise the window will remain open if possible.
 *
 * Note: Disabled events never make it to the event filter function; see
 * SDL_EventState().
 *
 * Note: If you just want to inspect events without filtering, you should use
 * SDL_AddEventWatch() instead.
 *
 * Note: Events pushed onto the queue with SDL_PushEvent() get passed through
 * the event filter, but events pushed onto the queue with SDL_PeepEvents() do
 * not.
 *
 * \param filter An SDL_EventFilter function to call when an event happens
 * \param userdata a pointer that is passed to `filter`
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AddEventWatch
 * \sa SDL_EventState
 * \sa SDL_GetEventFilter
 * \sa SDL_PeepEvents
 * \sa SDL_PushEvent
 *)
  SDL_SetEventFilter: procedure(filter: SDL_EventFilter; userdata: Pointer); cdecl;

(**
 * Query the current event filter.
 *
 * This function can be used to "chain" filters, by saving the existing filter
 * before replacing it with a function that will call that saved filter.
 *
 * \param filter the current callback function will be stored here
 * \param userdata the pointer that is passed to the current event filter will
 *                 be stored here
 * \returns SDL_TRUE on success or SDL_FALSE if there is no event filter set.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetEventFilter
 *)
  SDL_GetEventFilter: function(filter: PSDL_EventFilter; userdata: PPointer): SDL_bool; cdecl;

(**
 * Add a callback to be triggered when an event is added to the event queue.
 *
 * `filter` will be called when an event happens, and its return value is
 * ignored.
 *
 * **WARNING**: Be very careful of what you do in the event filter function,
 * as it may run in a different thread!
 *
 * If the quit event is generated by a signal (e.g. SIGINT), it will bypass
 * the internal queue and be delivered to the watch callback immediately, and
 * arrive at the next event poll.
 *
 * Note: the callback is called for events posted by the user through
 * SDL_PushEvent(), but not for disabled events, nor for events by a filter
 * callback set with SDL_SetEventFilter(), nor for events posted by the user
 * through SDL_PeepEvents().
 *
 * \param filter an SDL_EventFilter function to call when an event happens.
 * \param userdata a pointer that is passed to `filter`
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_DelEventWatch
 * \sa SDL_SetEventFilter
 *)
  SDL_AddEventWatch: procedure(filter: SDL_EventFilter; userdata: Pointer); cdecl;

(**
 * Remove an event watch callback added with SDL_AddEventWatch().
 *
 * This function takes the same input as SDL_AddEventWatch() to identify and
 * delete the corresponding callback.
 *
 * \param filter the function originally passed to SDL_AddEventWatch()
 * \param userdata the pointer originally passed to SDL_AddEventWatch()
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AddEventWatch
 *)
  SDL_DelEventWatch: procedure(filter: SDL_EventFilter; userdata: Pointer); cdecl;

(**
 * Run a specific filter function on the current event queue, removing any
 * events for which the filter returns 0.
 *
 * See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),
 * this function does not change the filter permanently, it only uses the
 * supplied filter until this function returns.
 *
 * \param filter the SDL_EventFilter function to call when an event happens
 * \param userdata a pointer that is passed to `filter`
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetEventFilter
 * \sa SDL_SetEventFilter
 *)
  SDL_FilterEvents: procedure(filter: SDL_EventFilter; userdata: Pointer); cdecl;

(**
 * Set the state of processing events by type.
 *
 * `state` may be any of the following:
 *
 * - `SDL_QUERY`: returns the current processing state of the specified event
 * - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped
 *   from the event queue and will not be filtered
 * - `SDL_ENABLE`: the event will be processed normally
 *
 * \param type the type of event; see SDL_EventType for details
 * \param state how to process the event
 * \returns `SDL_DISABLE` or `SDL_ENABLE`, representing the processing state
 *          of the event before this function makes any changes to it.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetEventState
 *)
  SDL_EventState: function(type_: Uint32; state: Integer): Uint8; cdecl;

(**
 * Allocate a set of user-defined events, and return the beginning event
 * number for that set of events.
 *
 * Calling this function with `numevents` <= 0 is an error and will return
 * (Uint32)-1.
 *
 * Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or
 * 0xFFFFFFFF), but is clearer to write.
 *
 * \param numevents the number of events to be allocated
 * \returns the beginning event number, or (Uint32)-1 if there are not enough
 *          user-defined events left.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_PushEvent
 *)
  SDL_RegisterEvents: function(numevents: Integer): Uint32; cdecl;

(**
 * Get the directory where the application was run from.
 *
 * This is not necessarily a fast call, so you should call this once near
 * startup and save the string if you need it.
 *
 * **Mac OS X and iOS Specific Functionality**: If the application is in a
 * ".app" bundle, this function returns the Resource directory (e.g.
 * MyApp.app/Contents/Resources/). This behaviour can be overridden by adding
 * a property to the Info.plist file. Adding a string key with the name
 * SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the
 * behaviour.
 *
 * Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an
 * application in /Applications/SDLApp/MyApp.app):
 *
 * - `resource`: bundle resource directory (the default). For example:
 *   `/Applications/SDLApp/MyApp.app/Contents/Resources`
 * - `bundle`: the Bundle directory. For example:
 *   `/Applications/SDLApp/MyApp.app/`
 * - `parent`: the containing directory of the bundle. For example:
 *   `/Applications/SDLApp/`
 *
 * The returned path is guaranteed to end with a path separator ('\' on
 * Windows, '/' on most other platforms).
 *
 * The pointer returned is owned by the caller. Please call SDL_free() on the
 * pointer when done with it.
 *
 * \returns an absolute path in UTF-8 encoding to the application data
 *          directory. NULL will be returned on error or when the platform
 *          doesn't implement this functionality, call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.1.
 *
 * \sa SDL_GetPrefPath
 *)
  SDL_GetBasePath: function(): PUTF8Char; cdecl;

(**
 * Get the user-and-app-specific path where files can be written.
 *
 * Get the "pref dir". This is meant to be where users can write personal
 * files (preferences and save games, etc) that are specific to your
 * application. This directory is unique per user, per application.
 *
 * This function will decide the appropriate location in the native
 * filesystem, create the directory if necessary, and return a string of the
 * absolute path to the directory in UTF-8 encoding.
 *
 * On Windows, the string might look like:
 *
 * `C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\`
 *
 * On Linux, the string might look like:
 *
 * `/home/bob/.local/share/My Program Name/`
 *
 * On Mac OS X, the string might look like:
 *
 * `/Users/bob/Library/Application Support/My Program Name/`
 *
 * You should assume the path returned by this function is the only safe place
 * to write files (and that SDL_GetBasePath(), while it might be writable, or
 * even the parent of the returned path, isn't where you should be writing
 * things).
 *
 * Both the org and app strings may become part of a directory name, so please
 * follow these rules:
 *
 * - Try to use the same org string (_including case-sensitivity_) for all
 *   your applications that use this function.
 * - Always use a unique app string for each one, and make sure it never
 *   changes for an app once you've decided on it.
 * - Unicode characters are legal, as long as it's UTF-8 encoded, but...
 * - ...only use letters, numbers, and spaces. Avoid punctuation like "Game
 *   Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
 *
 * The returned path is guaranteed to end with a path separator ('\' on
 * Windows, '/' on most other platforms).
 *
 * The pointer returned is owned by the caller. Please call SDL_free() on the
 * pointer when done with it.
 *
 * \param org the name of your organization
 * \param app the name of your application
 * \returns a UTF-8 string of the user directory in platform-dependent
 *          notation. NULL if there's a problem (creating directory failed,
 *          etc.).
 *
 * \since This function is available since SDL 2.0.1.
 *
 * \sa SDL_GetBasePath
 *)
  SDL_GetPrefPath: function(const org: PUTF8Char; const app: PUTF8Char): PUTF8Char; cdecl;

(**
 * Count the number of haptic devices attached to the system.
 *
 * \returns the number of haptic devices detected on the system or a negative
 *          error code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticName
 *)
  SDL_NumHaptics: function(): Integer; cdecl;

(**
 * Get the implementation dependent name of a haptic device.
 *
 * This can be called before any joysticks are opened. If no name can be
 * found, this function returns NULL.
 *
 * \param device_index index of the device to query.
 * \returns the name of the device or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_NumHaptics
 *)
  SDL_HapticName: function(device_index: Integer): PUTF8Char; cdecl;

(**
 * Open a haptic device for use.
 *
 * The index passed as an argument refers to the N'th haptic device on this
 * system.
 *
 * When opening a haptic device, its gain will be set to maximum and
 * autocenter will be disabled. To modify these values use SDL_HapticSetGain()
 * and SDL_HapticSetAutocenter().
 *
 * \param device_index index of the device to open
 * \returns the device identifier or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticClose
 * \sa SDL_HapticIndex
 * \sa SDL_HapticOpenFromJoystick
 * \sa SDL_HapticOpenFromMouse
 * \sa SDL_HapticPause
 * \sa SDL_HapticSetAutocenter
 * \sa SDL_HapticSetGain
 * \sa SDL_HapticStopAll
 *)
  SDL_HapticOpen: function(device_index: Integer): PSDL_Haptic; cdecl;

(**
 * Check if the haptic device at the designated index has been opened.
 *
 * \param device_index the index of the device to query
 * \returns 1 if it has been opened, 0 if it hasn't or on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticIndex
 * \sa SDL_HapticOpen
 *)
  SDL_HapticOpened: function(device_index: Integer): Integer; cdecl;

(**
 * Get the index of a haptic device.
 *
 * \param haptic the SDL_Haptic device to query
 * \returns the index of the specified haptic device or a negative error code
 *          on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticOpen
 * \sa SDL_HapticOpened
 *)
  SDL_HapticIndex: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Query whether or not the current mouse has haptic capabilities.
 *
 * \returns SDL_TRUE if the mouse is haptic or SDL_FALSE if it isn't.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticOpenFromMouse
 *)
  SDL_MouseIsHaptic: function(): Integer; cdecl;

(**
 * Try to open a haptic device from the current mouse.
 *
 * \returns the haptic device identifier or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticOpen
 * \sa SDL_MouseIsHaptic
 *)
  SDL_HapticOpenFromMouse: function(): PSDL_Haptic; cdecl;

(**
 * Query if a joystick has haptic features.
 *
 * \param joystick the SDL_Joystick to test for haptic capabilities
 * \returns SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't, or a
 *          negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticOpenFromJoystick
 *)
  SDL_JoystickIsHaptic: function(joystick: PSDL_Joystick): Integer; cdecl;

(**
 * Open a haptic device for use from a joystick device.
 *
 * You must still close the haptic device separately. It will not be closed
 * with the joystick.
 *
 * When opened from a joystick you should first close the haptic device before
 * closing the joystick device. If not, on some implementations the haptic
 * device will also get unallocated and you'll be unable to use force feedback
 * on that device.
 *
 * \param joystick the SDL_Joystick to create a haptic device from
 * \returns a valid haptic device identifier on success or NULL on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticClose
 * \sa SDL_HapticOpen
 * \sa SDL_JoystickIsHaptic
 *)
  SDL_HapticOpenFromJoystick: function(joystick: PSDL_Joystick): PSDL_Haptic; cdecl;

(**
 * Close a haptic device previously opened with SDL_HapticOpen().
 *
 * \param haptic the SDL_Haptic device to close
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticOpen
 *)
  SDL_HapticClose: procedure(haptic: PSDL_Haptic); cdecl;

(**
 * Get the number of effects a haptic device can store.
 *
 * On some platforms this isn't fully supported, and therefore is an
 * approximation. Always check to see if your created effect was actually
 * created and do not rely solely on SDL_HapticNumEffects().
 *
 * \param haptic the SDL_Haptic device to query
 * \returns the number of effects the haptic device can store or a negative
 *          error code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticNumEffectsPlaying
 * \sa SDL_HapticQuery
 *)
  SDL_HapticNumEffects: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Get the number of effects a haptic device can play at the same time.
 *
 * This is not supported on all platforms, but will always return a value.
 *
 * \param haptic the SDL_Haptic device to query maximum playing effects
 * \returns the number of effects the haptic device can play at the same time
 *          or a negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticNumEffects
 * \sa SDL_HapticQuery
 *)
  SDL_HapticNumEffectsPlaying: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Get the haptic device's supported features in bitwise manner.
 *
 * \param haptic the SDL_Haptic device to query
 * \returns a list of supported haptic features in bitwise manner (OR'd), or 0
 *          on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticEffectSupported
 * \sa SDL_HapticNumEffects
 *)
  SDL_HapticQuery: function(haptic: PSDL_Haptic): Cardinal; cdecl;

(**
 * Get the number of haptic axes the device has.
 *
 * The number of haptic axes might be useful if working with the
 * SDL_HapticDirection effect.
 *
 * \param haptic the SDL_Haptic device to query
 * \returns the number of axes on success or a negative error code on failure;
 *          call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_HapticNumAxes: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Check to see if an effect is supported by a haptic device.
 *
 * \param haptic the SDL_Haptic device to query
 * \param effect the desired effect to query
 * \returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a
 *          negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticNewEffect
 * \sa SDL_HapticQuery
 *)
  SDL_HapticEffectSupported: function(haptic: PSDL_Haptic; effect: PSDL_HapticEffect): Integer; cdecl;

(**
 * Create a new haptic effect on a specified device.
 *
 * \param haptic an SDL_Haptic device to create the effect on
 * \param effect an SDL_HapticEffect structure containing the properties of
 *               the effect to create
 * \returns the ID of the effect on success or a negative error code on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticDestroyEffect
 * \sa SDL_HapticRunEffect
 * \sa SDL_HapticUpdateEffect
 *)
  SDL_HapticNewEffect: function(haptic: PSDL_Haptic; effect: PSDL_HapticEffect): Integer; cdecl;

(**
 * Update the properties of an effect.
 *
 * Can be used dynamically, although behavior when dynamically changing
 * direction may be strange. Specifically the effect may re-upload itself and
 * start playing from the start. You also cannot change the type either when
 * running SDL_HapticUpdateEffect().
 *
 * \param haptic the SDL_Haptic device that has the effect
 * \param effect the identifier of the effect to update
 * \param data an SDL_HapticEffect structure containing the new effect
 *             properties to use
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticDestroyEffect
 * \sa SDL_HapticNewEffect
 * \sa SDL_HapticRunEffect
 *)
  SDL_HapticUpdateEffect: function(haptic: PSDL_Haptic; effect: Integer; data: PSDL_HapticEffect): Integer; cdecl;

(**
 * Run the haptic effect on its associated haptic device.
 *
 * To repeat the effect over and over indefinitely, set `iterations` to
 * `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make
 * one instance of the effect last indefinitely (so the effect does not fade),
 * set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`
 * instead.
 *
 * \param haptic the SDL_Haptic device to run the effect on
 * \param effect the ID of the haptic effect to run
 * \param iterations the number of iterations to run the effect; use
 *                   `SDL_HAPTIC_INFINITY` to repeat forever
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticDestroyEffect
 * \sa SDL_HapticGetEffectStatus
 * \sa SDL_HapticStopEffect
 *)
  SDL_HapticRunEffect: function(haptic: PSDL_Haptic; effect: Integer; iterations: Uint32): Integer; cdecl;

(**
 * Stop the haptic effect on its associated haptic device.
 *
 * *
 *
 * \param haptic the SDL_Haptic device to stop the effect on
 * \param effect the ID of the haptic effect to stop
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticDestroyEffect
 * \sa SDL_HapticRunEffect
 *)
  SDL_HapticStopEffect: function(haptic: PSDL_Haptic; effect: Integer): Integer; cdecl;

(**
 * Destroy a haptic effect on the device.
 *
 * This will stop the effect if it's running. Effects are automatically
 * destroyed when the device is closed.
 *
 * \param haptic the SDL_Haptic device to destroy the effect on
 * \param effect the ID of the haptic effect to destroy
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticNewEffect
 *)
  SDL_HapticDestroyEffect: procedure(haptic: PSDL_Haptic; effect: Integer); cdecl;

(**
 * Get the status of the current effect on the specified haptic device.
 *
 * Device must support the SDL_HAPTIC_STATUS feature.
 *
 * \param haptic the SDL_Haptic device to query for the effect status on
 * \param effect the ID of the haptic effect to query its status
 * \returns 0 if it isn't playing, 1 if it is playing, or a negative error
 *          code on failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticRunEffect
 * \sa SDL_HapticStopEffect
 *)
  SDL_HapticGetEffectStatus: function(haptic: PSDL_Haptic; effect: Integer): Integer; cdecl;

(**
 * Set the global gain of the specified haptic device.
 *
 * Device must support the SDL_HAPTIC_GAIN feature.
 *
 * The user may specify the maximum gain by setting the environment variable
 * `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to
 * SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the
 * maximum.
 *
 * \param haptic the SDL_Haptic device to set the gain on
 * \param gain value to set the gain to, should be between 0 and 100 (0 - 100)
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticQuery
 *)
  SDL_HapticSetGain: function(haptic: PSDL_Haptic; gain: Integer): Integer; cdecl;

(**
 * Set the global autocenter of the device.
 *
 * Autocenter should be between 0 and 100. Setting it to 0 will disable
 * autocentering.
 *
 * Device must support the SDL_HAPTIC_AUTOCENTER feature.
 *
 * \param haptic the SDL_Haptic device to set autocentering on
 * \param autocenter value to set autocenter to (0-100)
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticQuery
 *)
  SDL_HapticSetAutocenter: function(haptic: PSDL_Haptic; autocenter: Integer): Integer; cdecl;

(**
 * Pause a haptic device.
 *
 * Device must support the `SDL_HAPTIC_PAUSE` feature. Call
 * SDL_HapticUnpause() to resume playback.
 *
 * Do not modify the effects nor add new ones while the device is paused. That
 * can cause all sorts of weird errors.
 *
 * \param haptic the SDL_Haptic device to pause
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticUnpause
 *)
  SDL_HapticPause: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Unpause a haptic device.
 *
 * Call to unpause after SDL_HapticPause().
 *
 * \param haptic the SDL_Haptic device to unpause
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticPause
 *)
  SDL_HapticUnpause: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Stop all the currently playing effects on a haptic device.
 *
 * \param haptic the SDL_Haptic device to stop
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_HapticStopAll: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Check whether rumble is supported on a haptic device.
 *
 * \param haptic haptic device to check for rumble support
 * \returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a
 *          negative error code on failure; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticRumbleInit
 * \sa SDL_HapticRumblePlay
 * \sa SDL_HapticRumbleStop
 *)
  SDL_HapticRumbleSupported: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Initialize a haptic device for simple rumble playback.
 *
 * \param haptic the haptic device to initialize for simple rumble playback
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticOpen
 * \sa SDL_HapticRumblePlay
 * \sa SDL_HapticRumbleStop
 * \sa SDL_HapticRumbleSupported
 *)
  SDL_HapticRumbleInit: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Run a simple rumble effect on a haptic device.
 *
 * \param haptic the haptic device to play the rumble effect on
 * \param strength strength of the rumble to play as a 0-1 float value
 * \param length length of the rumble to play in milliseconds
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticRumbleInit
 * \sa SDL_HapticRumbleStop
 * \sa SDL_HapticRumbleSupported
 *)
  SDL_HapticRumblePlay: function(haptic: PSDL_Haptic; strength: Single; length: Uint32): Integer; cdecl;

(**
 * Stop the simple rumble on a haptic device.
 *
 * \param haptic the haptic device to stop the rumble effect on
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_HapticRumbleInit
 * \sa SDL_HapticRumblePlay
 * \sa SDL_HapticRumbleSupported
 *)
  SDL_HapticRumbleStop: function(haptic: PSDL_Haptic): Integer; cdecl;

(**
 * Initialize the HIDAPI library.
 *
 * This function initializes the HIDAPI library. Calling it is not strictly
 * necessary, as it will be called automatically by SDL_hid_enumerate() and
 * any of the SDL_hid_open_*() functions if it is needed. This function should
 * be called at the beginning of execution however, if there is a chance of
 * HIDAPI handles being opened by different threads simultaneously.
 *
 * Each call to this function should have a matching call to SDL_hid_exit()
 *
 * \returns 0 on success and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_hid_exit
 *)
  SDL_hid_init: function(): Integer; cdecl;

(**
 * Finalize the HIDAPI library.
 *
 * This function frees all of the static data associated with HIDAPI. It
 * should be called at the end of execution to avoid memory leaks.
 *
 * \returns 0 on success and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_hid_init
 *)
  SDL_hid_exit: function(): Integer; cdecl;

(**
 * Check to see if devices may have been added or removed.
 *
 * Enumerating the HID devices is an expensive operation, so you can call this
 * to see if there have been any system device changes since the last call to
 * this function. A change in the counter returned doesn't necessarily mean
 * that anything has changed, but you can call SDL_hid_enumerate() to get an
 * updated device list.
 *
 * Calling this function for the first time may cause a thread or other system
 * resource to be allocated to track device change notifications.
 *
 * \returns a change counter that is incremented with each potential device
 *          change, or 0 if device change detection isn't available.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_hid_enumerate
 *)
  SDL_hid_device_change_count: function(): Uint32; cdecl;

(**
 * Enumerate the HID Devices.
 *
 * This function returns a linked list of all the HID devices attached to the
 * system which match vendor_id and product_id. If `vendor_id` is set to 0
 * then any vendor matches. If `product_id` is set to 0 then any product
 * matches. If `vendor_id` and `product_id` are both set to 0, then all HID
 * devices will be returned.
 *
 * \param vendor_id The Vendor ID (VID) of the types of device to open.
 * \param product_id The Product ID (PID) of the types of device to open.
 * \returns a pointer to a linked list of type SDL_hid_device_info, containing
 *          information about the HID devices attached to the system, or NULL
 *          in the case of failure. Free this linked list by calling
 *          SDL_hid_free_enumeration().
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_hid_device_change_count
 *)
  SDL_hid_enumerate: function(vendor_id: Word; product_id: Word): PSDL_hid_device_info; cdecl;

(**
 * Free an enumeration Linked List
 *
 * This function frees a linked list created by SDL_hid_enumerate().
 *
 * \param devs Pointer to a list of struct_device returned from
 *             SDL_hid_enumerate().
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_free_enumeration: procedure(devs: PSDL_hid_device_info); cdecl;

(**
 * Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally
 * a serial number.
 *
 * If `serial_number` is NULL, the first device with the specified VID and PID
 * is opened.
 *
 * \param vendor_id The Vendor ID (VID) of the device to open.
 * \param product_id The Product ID (PID) of the device to open.
 * \param serial_number The Serial Number of the device to open (Optionally
 *                      NULL).
 * \returns a pointer to a SDL_hid_device object on success or NULL on
 *          failure.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_open: function(vendor_id: Word; product_id: Word; const serial_number: PWideChar): PSDL_hid_device; cdecl;

(**
 * Open a HID device by its path name.
 *
 * The path name be determined by calling SDL_hid_enumerate(), or a
 * platform-specific path name can be used (eg: /dev/hidraw0 on Linux).
 *
 * \param path The path name of the device to open
 * \returns a pointer to a SDL_hid_device object on success or NULL on
 *          failure.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_open_path: function(const path: PUTF8Char; bExclusive: Integer): PSDL_hid_device; cdecl;

(**
 * Write an Output report to a HID device.
 *
 * The first byte of `data` must contain the Report ID. For devices which only
 * support a single report, this must be set to 0x0. The remaining bytes
 * contain the report data. Since the Report ID is mandatory, calls to
 * SDL_hid_write() will always contain one more byte than the report contains.
 * For example, if a hid report is 16 bytes long, 17 bytes must be passed to
 * SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),
 * followed by the report data (16 bytes). In this example, the length passed
 * in would be 17.
 *
 * SDL_hid_write() will send the data on the first OUT endpoint, if one
 * exists. If it does not, it will send the data through the Control Endpoint
 * (Endpoint 0).
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param data The data to send, including the report number as the first
 *             byte.
 * \param length The length in bytes of the data to send.
 * \returns the actual number of bytes written and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_write: function(dev: PSDL_hid_device; const data: PByte; length: NativeUInt): Integer; cdecl;

(**
 * Read an Input report from a HID device with timeout.
 *
 * Input reports are returned to the host through the INTERRUPT IN endpoint.
 * The first byte will contain the Report number if the device uses numbered
 * reports.
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param data A buffer to put the read data into.
 * \param length The number of bytes to read. For devices with multiple
 *               reports, make sure to read an extra byte for the report
 *               number.
 * \param milliseconds timeout in milliseconds or -1 for blocking wait.
 * \returns the actual number of bytes read and -1 on error. If no packet was
 *          available to be read within the timeout period, this function
 *          returns 0.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_read_timeout: function(dev: PSDL_hid_device; data: PByte; length: NativeUInt; milliseconds: Integer): Integer; cdecl;

(**
 * Read an Input report from a HID device.
 *
 * Input reports are returned to the host through the INTERRUPT IN endpoint.
 * The first byte will contain the Report number if the device uses numbered
 * reports.
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param data A buffer to put the read data into.
 * \param length The number of bytes to read. For devices with multiple
 *               reports, make sure to read an extra byte for the report
 *               number.
 * \returns the actual number of bytes read and -1 on error. If no packet was
 *          available to be read and the handle is in non-blocking mode, this
 *          function returns 0.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_read: function(dev: PSDL_hid_device; data: PByte; length: NativeUInt): Integer; cdecl;

(**
 * Set the device handle to be non-blocking.
 *
 * In non-blocking mode calls to SDL_hid_read() will return immediately with a
 * value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()
 * will wait (block) until there is data to read before returning.
 *
 * Nonblocking can be turned on and off at any time.
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param nonblock enable or not the nonblocking reads - 1 to enable
 *                 nonblocking - 0 to disable nonblocking.
 * \returns 0 on success and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_set_nonblocking: function(dev: PSDL_hid_device; nonblock: Integer): Integer; cdecl;

(**
 * Send a Feature report to the device.
 *
 * Feature reports are sent over the Control endpoint as a Set_Report
 * transfer. The first byte of `data` must contain the Report ID. For devices
 * which only support a single report, this must be set to 0x0. The remaining
 * bytes contain the report data. Since the Report ID is mandatory, calls to
 * SDL_hid_send_feature_report() will always contain one more byte than the
 * report contains. For example, if a hid report is 16 bytes long, 17 bytes
 * must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for
 * devices which do not use numbered reports), followed by the report data (16
 * bytes). In this example, the length passed in would be 17.
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param data The data to send, including the report number as the first
 *             byte.
 * \param length The length in bytes of the data to send, including the report
 *               number.
 * \returns the actual number of bytes written and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_send_feature_report: function(dev: PSDL_hid_device; const data: PByte; length: NativeUInt): Integer; cdecl;

(**
 * Get a feature report from a HID device.
 *
 * Set the first byte of `data` to the Report ID of the report to be read.
 * Make sure to allow space for this extra byte in `data`. Upon return, the
 * first byte will still contain the Report ID, and the report data will start
 * in data[1].
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param data A buffer to put the read data into, including the Report ID.
 *             Set the first byte of `data` to the Report ID of the report to
 *             be read, or set it to zero if your device does not use numbered
 *             reports.
 * \param length The number of bytes to read, including an extra byte for the
 *               report ID. The buffer can be longer than the actual report.
 * \returns the number of bytes read plus one for the report ID (which is
 *          still in the first byte), or -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_get_feature_report: function(dev: PSDL_hid_device; data: PByte; length: NativeUInt): Integer; cdecl;

(**
 * Close a HID device.
 *
 * \param dev A device handle returned from SDL_hid_open().
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_close: procedure(dev: PSDL_hid_device); cdecl;

(**
 * Get The Manufacturer String from a HID device.
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param string A wide string buffer to put the data into.
 * \param maxlen The length of the buffer in multiples of wchar_t.
 * \returns 0 on success and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_get_manufacturer_string: function(dev: PSDL_hid_device; string_: PWideChar; maxlen: NativeUInt): Integer; cdecl;

(**
 * Get The Product String from a HID device.
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param string A wide string buffer to put the data into.
 * \param maxlen The length of the buffer in multiples of wchar_t.
 * \returns 0 on success and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_get_product_string: function(dev: PSDL_hid_device; string_: PWideChar; maxlen: NativeUInt): Integer; cdecl;

(**
 * Get The Serial Number String from a HID device.
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param string A wide string buffer to put the data into.
 * \param maxlen The length of the buffer in multiples of wchar_t.
 * \returns 0 on success and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_get_serial_number_string: function(dev: PSDL_hid_device; string_: PWideChar; maxlen: NativeUInt): Integer; cdecl;

(**
 * Get a string from a HID device, based on its string index.
 *
 * \param dev A device handle returned from SDL_hid_open().
 * \param string_index The index of the string to get.
 * \param string A wide string buffer to put the data into.
 * \param maxlen The length of the buffer in multiples of wchar_t.
 * \returns 0 on success and -1 on error.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_get_indexed_string: function(dev: PSDL_hid_device; string_index: Integer; string_: PWideChar; maxlen: NativeUInt): Integer; cdecl;

(**
 * Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers
 *
 * \param active SDL_TRUE to start the scan, SDL_FALSE to stop the scan
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_hid_ble_scan: procedure(active: SDL_bool); cdecl;

(**
 * Set a hint with a specific priority.
 *
 * The priority controls the behavior when setting a hint that already has a
 * value. Hints will replace existing hints of their priority and lower.
 * Environment variables are considered to have override priority.
 *
 * \param name the hint to set
 * \param value the value of the hint variable
 * \param priority the SDL_HintPriority level for the hint
 * \returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetHint
 * \sa SDL_SetHint
 *)
  SDL_SetHintWithPriority: function(const name: PUTF8Char; const value: PUTF8Char; priority: SDL_HintPriority): SDL_bool; cdecl;

(**
 * Set a hint with normal priority.
 *
 * Hints will not be set if there is an existing override hint or environment
 * variable that takes precedence. You can use SDL_SetHintWithPriority() to
 * set the hint with override priority instead.
 *
 * \param name the hint to set
 * \param value the value of the hint variable
 * \returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetHint
 * \sa SDL_SetHintWithPriority
 *)
  SDL_SetHint: function(const name: PUTF8Char; const value: PUTF8Char): SDL_bool; cdecl;

(**
 * Reset a hint to the default value.
 *
 * This will reset a hint to the value of the environment variable, or NULL if
 * the environment isn't set. Callbacks will be called normally with this
 * change.
 *
 * \param name the hint to set
 * \returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.24.0.
 *
 * \sa SDL_GetHint
 * \sa SDL_SetHint
 *)
  SDL_ResetHint: function(const name: PUTF8Char): SDL_bool; cdecl;

(**
 * Get the value of a hint.
 *
 * \param name the hint to query
 * \returns the string value of a hint or NULL if the hint isn't set.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetHint
 * \sa SDL_SetHintWithPriority
 *)
  SDL_GetHint: function(const name: PUTF8Char): PUTF8Char; cdecl;

(**
 * Get the boolean value of a hint variable.
 *
 * \param name the name of the hint to get the boolean value from
 * \param default_value the value to return if the hint does not exist
 * \returns the boolean value of a hint or the provided default value if the
 *          hint does not exist.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_GetHint
 * \sa SDL_SetHint
 *)
  SDL_GetHintBoolean: function(const name: PUTF8Char; default_value: SDL_bool): SDL_bool; cdecl;

(**
 * Add a function to watch a particular hint.
 *
 * \param name the hint to watch
 * \param callback An SDL_HintCallback function that will be called when the
 *                 hint value changes
 * \param userdata a pointer to pass to the callback function
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_DelHintCallback
 *)
  SDL_AddHintCallback: procedure(const name: PUTF8Char; callback: SDL_HintCallback; userdata: Pointer); cdecl;

(**
 * Remove a function watching a particular hint.
 *
 * \param name the hint being watched
 * \param callback An SDL_HintCallback function that will be called when the
 *                 hint value changes
 * \param userdata a pointer being passed to the callback function
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AddHintCallback
 *)
  SDL_DelHintCallback: procedure(const name: PUTF8Char; callback: SDL_HintCallback; userdata: Pointer); cdecl;

(**
 * Clear all hints.
 *
 * This function is automatically called during SDL_Quit().
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_ClearHints: procedure(); cdecl;

(**
 * Dynamically load a shared object.
 *
 * \param sofile a system-dependent name of the object file
 * \returns an opaque pointer to the object handle or NULL if there was an
 *          error; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LoadFunction
 * \sa SDL_UnloadObject
 *)
  SDL_LoadObject: function(const sofile: PUTF8Char): Pointer; cdecl;

(**
 * Look up the address of the named function in a shared object.
 *
 * This function pointer is no longer valid after calling SDL_UnloadObject().
 *
 * This function can only look up C function names. Other languages may have
 * name mangling and intrinsic language support that varies from compiler to
 * compiler.
 *
 * Make sure you declare your function pointers with the same calling
 * convention as the actual library function. Your code will crash
 * mysteriously if you do not do this.
 *
 * If the requested function doesn't exist, NULL is returned.
 *
 * \param handle a valid shared object handle returned by SDL_LoadObject()
 * \param name the name of the function to look up
 * \returns a pointer to the function or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LoadObject
 * \sa SDL_UnloadObject
 *)
  SDL_LoadFunction: function(handle: Pointer; const name: PUTF8Char): Pointer; cdecl;

(**
 * Unload a shared object from memory.
 *
 * \param handle a valid shared object handle returned by SDL_LoadObject()
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LoadFunction
 * \sa SDL_LoadObject
 *)
  SDL_UnloadObject: procedure(handle: Pointer); cdecl;

(**
 * Set the priority of all log categories.
 *
 * \param priority the SDL_LogPriority to assign
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LogSetPriority
 *)
  SDL_LogSetAllPriority: procedure(priority: SDL_LogPriority); cdecl;

(**
 * Set the priority of a particular log category.
 *
 * \param category the category to assign a priority to
 * \param priority the SDL_LogPriority to assign
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LogGetPriority
 * \sa SDL_LogSetAllPriority
 *)
  SDL_LogSetPriority: procedure(category: Integer; priority: SDL_LogPriority); cdecl;

(**
 * Get the priority of a particular log category.
 *
 * \param category the category to query
 * \returns the SDL_LogPriority for the requested category
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LogSetPriority
 *)
  SDL_LogGetPriority: function(category: Integer): SDL_LogPriority; cdecl;

(**
 * Reset all priorities to default.
 *
 * This is called by SDL_Quit().
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LogSetAllPriority
 * \sa SDL_LogSetPriority
 *)
  SDL_LogResetPriorities: procedure(); cdecl;

(**
 * Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO.
 *
 * = * \param fmt a printf() style message format string
 *
 * \param ... additional parameters matching % tokens in the `fmt` string, if
 *            any
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
  SDL_Log_: procedure(const fmt: PUTF8Char) varargs; cdecl;

(**
 * Log a message with SDL_LOG_PRIORITY_VERBOSE.
 *
 * \param category the category of the message
 * \param fmt a printf() style message format string
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogWarn
 *)
  SDL_LogVerbose: procedure(category: Integer; const fmt: PUTF8Char) varargs; cdecl;

(**
 * Log a message with SDL_LOG_PRIORITY_DEBUG.
 *
 * \param category the category of the message
 * \param fmt a printf() style message format string
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
  SDL_LogDebug: procedure(category: Integer; const fmt: PUTF8Char) varargs; cdecl;

(**
 * Log a message with SDL_LOG_PRIORITY_INFO.
 *
 * \param category the category of the message
 * \param fmt a printf() style message format string
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
  SDL_LogInfo: procedure(category: Integer; const fmt: PUTF8Char) varargs; cdecl;

(**
 * Log a message with SDL_LOG_PRIORITY_WARN.
 *
 * \param category the category of the message
 * \param fmt a printf() style message format string
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogVerbose
 *)
  SDL_LogWarn: procedure(category: Integer; const fmt: PUTF8Char) varargs; cdecl;

(**
 * Log a message with SDL_LOG_PRIORITY_ERROR.
 *
 * \param category the category of the message
 * \param fmt a printf() style message format string
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
  SDL_LogError: procedure(category: Integer; const fmt: PUTF8Char) varargs; cdecl;

(**
 * Log a message with SDL_LOG_PRIORITY_CRITICAL.
 *
 * \param category the category of the message
 * \param fmt a printf() style message format string
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogMessageV
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
  SDL_LogCritical: procedure(category: Integer; const fmt: PUTF8Char) varargs; cdecl;

(**
 * Log a message with the specified category and priority.
 *
 * \param category the category of the message
 * \param priority the priority of the message
 * \param fmt a printf() style message format string
 * \param ... additional parameters matching % tokens in the **fmt** string,
 *            if any
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessageV
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
  SDL_LogMessage: procedure(category: Integer; priority: SDL_LogPriority; const fmt: PUTF8Char) varargs; cdecl;

(**
 * Log a message with the specified category and priority.
 *
 * \param category the category of the message
 * \param priority the priority of the message
 * \param fmt a printf() style message format string
 * \param ap a variable argument list
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Log
 * \sa SDL_LogCritical
 * \sa SDL_LogDebug
 * \sa SDL_LogError
 * \sa SDL_LogInfo
 * \sa SDL_LogMessage
 * \sa SDL_LogVerbose
 * \sa SDL_LogWarn
 *)
  SDL_LogMessageV: procedure(category: Integer; priority: SDL_LogPriority; const fmt: PUTF8Char; ap: Pointer); cdecl;

(**
 * Get the current log output function.
 *
 * \param callback an SDL_LogOutputFunction filled in with the current log
 *                 callback
 * \param userdata a pointer filled in with the pointer that is passed to
 *                 `callback`
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LogSetOutputFunction
 *)
  SDL_LogGetOutputFunction: procedure(callback: PSDL_LogOutputFunction; userdata: PPointer); cdecl;

(**
 * Replace the default log output function with one of your own.
 *
 * \param callback an SDL_LogOutputFunction to call instead of the default
 * \param userdata a pointer that is passed to `callback`
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LogGetOutputFunction
 *)
  SDL_LogSetOutputFunction: procedure(callback: SDL_LogOutputFunction; userdata: Pointer); cdecl;

(**
 * Create a modal message box.
 *
 * If your needs aren't complex, it might be easier to use
 * SDL_ShowSimpleMessageBox.
 *
 * This function should be called on the thread that created the parent
 * window, or on the main thread if the messagebox has no parent. It will
 * block execution of that thread until the user clicks a button or closes the
 * messagebox.
 *
 * This function may be called at any time, even before SDL_Init(). This makes
 * it useful for reporting errors like a failure to create a renderer or
 * OpenGL context.
 *
 * On X11, SDL rolls its own dialog box with X11 primitives instead of a
 * formal toolkit like GTK+ or Qt.
 *
 * Note that if SDL_Init() would fail because there isn't any available video
 * target, this function is likely to fail for the same reasons. If this is a
 * concern, check the return value from this function and fall back to writing
 * to stderr if you can.
 *
 * \param messageboxdata the SDL_MessageBoxData structure with title, text and
 *                       other options
 * \param buttonid the pointer to which user id of hit button should be copied
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ShowSimpleMessageBox
 *)
  SDL_ShowMessageBox: function(const messageboxdata: PSDL_MessageBoxData; buttonid: PInteger): Integer; cdecl;

(**
 * Display a simple modal message box.
 *
 * If your needs aren't complex, this function is preferred over
 * SDL_ShowMessageBox.
 *
 * `flags` may be any of the following:
 *
 * - `SDL_MESSAGEBOX_ERROR`: error dialog
 * - `SDL_MESSAGEBOX_WARNING`: warning dialog
 * - `SDL_MESSAGEBOX_INFORMATION`: informational dialog
 *
 * This function should be called on the thread that created the parent
 * window, or on the main thread if the messagebox has no parent. It will
 * block execution of that thread until the user clicks a button or closes the
 * messagebox.
 *
 * This function may be called at any time, even before SDL_Init(). This makes
 * it useful for reporting errors like a failure to create a renderer or
 * OpenGL context.
 *
 * On X11, SDL rolls its own dialog box with X11 primitives instead of a
 * formal toolkit like GTK+ or Qt.
 *
 * Note that if SDL_Init() would fail because there isn't any available video
 * target, this function is likely to fail for the same reasons. If this is a
 * concern, check the return value from this function and fall back to writing
 * to stderr if you can.
 *
 * \param flags an SDL_MessageBoxFlags value
 * \param title UTF-8 title text
 * \param message UTF-8 message text
 * \param window the parent window, or NULL for no parent
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_ShowMessageBox
 *)
  SDL_ShowSimpleMessageBox: function(flags: Uint32; const title: PUTF8Char; const message_: PUTF8Char; window: PSDL_Window): Integer; cdecl;

(**
 * Create a CAMetalLayer-backed NSView/UIView and attach it to the specified
 * window.
 *
 * On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on
 * its own. It is up to user code to do that.
 *
 * The returned handle can be casted directly to a NSView or UIView. To access
 * the backing CAMetalLayer, call SDL_Metal_GetLayer().
 *
 * \since This function is available since SDL 2.0.12.
 *
 * \sa SDL_Metal_DestroyView
 * \sa SDL_Metal_GetLayer
 *)
  SDL_Metal_CreateView: function(window: PSDL_Window): SDL_MetalView; cdecl;

(**
 * Destroy an existing SDL_MetalView object.
 *
 * This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was
 * called after SDL_CreateWindow.
 *
 * \since This function is available since SDL 2.0.12.
 *
 * \sa SDL_Metal_CreateView
 *)
  SDL_Metal_DestroyView: procedure(view: SDL_MetalView); cdecl;

(**
 * Get a pointer to the backing CAMetalLayer for the given view.
 *
 * \since This function is available since SDL 2.0.14.
 *
 * \sa SDL_MetalCreateView
 *)
  SDL_Metal_GetLayer: function(view: SDL_MetalView): Pointer; cdecl;

(**
 * Get the size of a window's underlying drawable in pixels (for use with
 * setting viewport, scissor & etc).
 *
 * \param window SDL_Window from which the drawable size should be queried
 * \param w Pointer to variable for storing the width in pixels, may be NULL
 * \param h Pointer to variable for storing the height in pixels, may be NULL
 *
 * \since This function is available since SDL 2.0.14.
 *
 * \sa SDL_GetWindowSize
 * \sa SDL_CreateWindow
 *)
  SDL_Metal_GetDrawableSize: procedure(window: PSDL_Window; w: PInteger; h: PInteger); cdecl;

(**
 * Get the current power supply details.
 *
 * You should never take a battery status as absolute truth. Batteries
 * (especially failing batteries) are delicate hardware, and the values
 * reported here are best estimates based on what that hardware reports. It's
 * not uncommon for older batteries to lose stored power much faster than it
 * reports, or completely drain when reporting it has 20 percent left, etc.
 *
 * Battery status can change at any time; if you are concerned with power
 * state, you should call this function frequently, and perhaps ignore changes
 * until they seem to be stable for a few seconds.
 *
 * It's possible a platform can only report battery percentage or time left
 * but not both.
 *
 * \param secs seconds of battery life left, you can pass a NULL here if you
 *             don't care, will return -1 if we can't determine a value, or
 *             we're not running on a battery
 * \param pct percentage of battery life left, between 0 and 100, you can pass
 *            a NULL here if you don't care, will return -1 if we can't
 *            determine a value, or we're not running on a battery
 * \returns an SDL_PowerState enum representing the current battery state.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_GetPowerInfo: function(secs: PInteger; pct: PInteger): SDL_PowerState; cdecl;

(**
 * Get the number of 2D rendering drivers available for the current display.
 *
 * A render driver is a set of code that handles rendering and texture
 * management on a particular display. Normally there is only one, but some
 * drivers may have several available with different capabilities.
 *
 * There may be none if SDL was compiled without render support.
 *
 * \returns a number >= 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRenderer
 * \sa SDL_GetRenderDriverInfo
 *)
  SDL_GetNumRenderDrivers: function(): Integer; cdecl;

(**
 * Get info about a specific 2D rendering driver for the current display.
 *
 * \param index the index of the driver to query information about
 * \param info an SDL_RendererInfo structure to be filled with information on
 *             the rendering driver
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRenderer
 * \sa SDL_GetNumRenderDrivers
 *)
  SDL_GetRenderDriverInfo: function(index: Integer; info: PSDL_RendererInfo): Integer; cdecl;

(**
 * Create a window and default renderer.
 *
 * \param width the width of the window
 * \param height the height of the window
 * \param window_flags the flags used to create the window (see
 *                     SDL_CreateWindow())
 * \param window a pointer filled with the window, or NULL on error
 * \param renderer a pointer filled with the renderer, or NULL on error
 * \returns 0 on success, or -1 on error; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRenderer
 * \sa SDL_CreateWindow
 *)
  SDL_CreateWindowAndRenderer: function(width: Integer; height: Integer; window_flags: Uint32; window: PPSDL_Window; renderer: PPSDL_Renderer): Integer; cdecl;

(**
 * Create a 2D rendering context for a window.
 *
 * \param window the window where rendering is displayed
 * \param index the index of the rendering driver to initialize, or -1 to
 *              initialize the first one supporting the requested flags
 * \param flags 0, or one or more SDL_RendererFlags OR'd together
 * \returns a valid rendering context or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateSoftwareRenderer
 * \sa SDL_DestroyRenderer
 * \sa SDL_GetNumRenderDrivers
 * \sa SDL_GetRendererInfo
 *)
  SDL_CreateRenderer: function(window: PSDL_Window; index: Integer; flags: Uint32): PSDL_Renderer; cdecl;

(**
 * Create a 2D software rendering context for a surface.
 *
 * Two other API which can be used to create SDL_Renderer:
 * SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_
 * create a software renderer, but they are intended to be used with an
 * SDL_Window as the final destination and not an SDL_Surface.
 *
 * \param surface the SDL_Surface structure representing the surface where
 *                rendering is done
 * \returns a valid rendering context or NULL if there was an error; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRenderer
 * \sa SDL_CreateWindowRenderer
 * \sa SDL_DestroyRenderer
 *)
  SDL_CreateSoftwareRenderer: function(surface: PSDL_Surface): PSDL_Renderer; cdecl;

(**
 * Get the renderer associated with a window.
 *
 * \param window the window to query
 * \returns the rendering context on success or NULL on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRenderer
 *)
  SDL_GetRenderer: function(window: PSDL_Window): PSDL_Renderer; cdecl;

(**
 * Get the window associated with a renderer.
 *
 * \param renderer the renderer to query
 * \returns the window on success or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 2.0.22.
 *)
  SDL_RenderGetWindow: function(renderer: PSDL_Renderer): PSDL_Window; cdecl;

(**
 * Get information about a rendering context.
 *
 * \param renderer the rendering context
 * \param info an SDL_RendererInfo structure filled with information about the
 *             current renderer
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRenderer
 *)
  SDL_GetRendererInfo: function(renderer: PSDL_Renderer; info: PSDL_RendererInfo): Integer; cdecl;

(**
 * Get the output size in pixels of a rendering context.
 *
 * Due to high-dpi displays, you might end up with a rendering context that
 * has more pixels than the window that contains it, so use this instead of
 * SDL_GetWindowSize() to decide how much drawing area you have.
 *
 * \param renderer the rendering context
 * \param w an int filled with the width
 * \param h an int filled with the height
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRenderer
 *)
  SDL_GetRendererOutputSize: function(renderer: PSDL_Renderer; w: PInteger; h: PInteger): Integer; cdecl;

(**
 * Create a texture for a rendering context.
 *
 * You can set the texture scaling method by setting
 * `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.
 *
 * \param renderer the rendering context
 * \param format one of the enumerated values in SDL_PixelFormatEnum
 * \param access one of the enumerated values in SDL_TextureAccess
 * \param w the width of the texture in pixels
 * \param h the height of the texture in pixels
 * \returns a pointer to the created texture or NULL if no rendering context
 *          was active, the format was unsupported, or the width or height
 *          were out of range; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateTextureFromSurface
 * \sa SDL_DestroyTexture
 * \sa SDL_QueryTexture
 * \sa SDL_UpdateTexture
 *)
  SDL_CreateTexture: function(renderer: PSDL_Renderer; format: Uint32; access: Integer; w: Integer; h: Integer): PSDL_Texture; cdecl;

(**
 * Create a texture from an existing surface.
 *
 * The surface is not modified or freed by this function.
 *
 * The SDL_TextureAccess hint for the created texture is
 * `SDL_TEXTUREACCESS_STATIC`.
 *
 * The pixel format of the created texture may be different from the pixel
 * format of the surface. Use SDL_QueryTexture() to query the pixel format of
 * the texture.
 *
 * \param renderer the rendering context
 * \param surface the SDL_Surface structure containing pixel data used to fill
 *                the texture
 * \returns the created texture or NULL on failure; call SDL_GetError() for
 *          more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateTexture
 * \sa SDL_DestroyTexture
 * \sa SDL_QueryTexture
 *)
  SDL_CreateTextureFromSurface: function(renderer: PSDL_Renderer; surface: PSDL_Surface): PSDL_Texture; cdecl;

(**
 * Query the attributes of a texture.
 *
 * \param texture the texture to query
 * \param format a pointer filled in with the raw format of the texture; the
 *               actual format may differ, but pixel transfers will use this
 *               format (one of the SDL_PixelFormatEnum values). This argument
 *               can be NULL if you don't need this information.
 * \param access a pointer filled in with the actual access to the texture
 *               (one of the SDL_TextureAccess values). This argument can be
 *               NULL if you don't need this information.
 * \param w a pointer filled in with the width of the texture in pixels. This
 *          argument can be NULL if you don't need this information.
 * \param h a pointer filled in with the height of the texture in pixels. This
 *          argument can be NULL if you don't need this information.
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateTexture
 *)
  SDL_QueryTexture: function(texture: PSDL_Texture; format: PUint32; access: PInteger; w: PInteger; h: PInteger): Integer; cdecl;

(**
 * Set an additional color value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation each source color
 * channel is modulated by the appropriate color value according to the
 * following formula:
 *
 * `srcC = srcC * (color / 255)`
 *
 * Color modulation is not always supported by the renderer; it will return -1
 * if color modulation is not supported.
 *
 * \param texture the texture to update
 * \param r the red color value multiplied into copy operations
 * \param g the green color value multiplied into copy operations
 * \param b the blue color value multiplied into copy operations
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetTextureColorMod
 * \sa SDL_SetTextureAlphaMod
 *)
  SDL_SetTextureColorMod: function(texture: PSDL_Texture; r: Uint8; g: Uint8; b: Uint8): Integer; cdecl;

(**
 * Get the additional color value multiplied into render copy operations.
 *
 * \param texture the texture to query
 * \param r a pointer filled in with the current red color value
 * \param g a pointer filled in with the current green color value
 * \param b a pointer filled in with the current blue color value
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetTextureAlphaMod
 * \sa SDL_SetTextureColorMod
 *)
  SDL_GetTextureColorMod: function(texture: PSDL_Texture; r: PUint8; g: PUint8; b: PUint8): Integer; cdecl;

(**
 * Set an additional alpha value multiplied into render copy operations.
 *
 * When this texture is rendered, during the copy operation the source alpha
 * value is modulated by this alpha value according to the following formula:
 *
 * `srcA = srcA * (alpha / 255)`
 *
 * Alpha modulation is not always supported by the renderer; it will return -1
 * if alpha modulation is not supported.
 *
 * \param texture the texture to update
 * \param alpha the source alpha value multiplied into copy operations
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetTextureAlphaMod
 * \sa SDL_SetTextureColorMod
 *)
  SDL_SetTextureAlphaMod: function(texture: PSDL_Texture; alpha: Uint8): Integer; cdecl;

(**
 * Get the additional alpha value multiplied into render copy operations.
 *
 * \param texture the texture to query
 * \param alpha a pointer filled in with the current alpha value
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetTextureColorMod
 * \sa SDL_SetTextureAlphaMod
 *)
  SDL_GetTextureAlphaMod: function(texture: PSDL_Texture; alpha: PUint8): Integer; cdecl;

(**
 * Set the blend mode for a texture, used by SDL_RenderCopy().
 *
 * If the blend mode is not supported, the closest supported mode is chosen
 * and this function returns -1.
 *
 * \param texture the texture to update
 * \param blendMode the SDL_BlendMode to use for texture blending
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetTextureBlendMode
 * \sa SDL_RenderCopy
 *)
  SDL_SetTextureBlendMode: function(texture: PSDL_Texture; blendMode: SDL_BlendMode): Integer; cdecl;

(**
 * Get the blend mode used for texture copy operations.
 *
 * \param texture the texture to query
 * \param blendMode a pointer filled in with the current SDL_BlendMode
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetTextureBlendMode
 *)
  SDL_GetTextureBlendMode: function(texture: PSDL_Texture; blendMode: PSDL_BlendMode): Integer; cdecl;

(**
 * Set the scale mode used for texture scale operations.
 *
 * If the scale mode is not supported, the closest supported mode is chosen.
 *
 * \param texture The texture to update.
 * \param scaleMode the SDL_ScaleMode to use for texture scaling.
 * \returns 0 on success, or -1 if the texture is not valid.
 *
 * \since This function is available since SDL 2.0.12.
 *
 * \sa SDL_GetTextureScaleMode
 *)
  SDL_SetTextureScaleMode: function(texture: PSDL_Texture; scaleMode: SDL_ScaleMode): Integer; cdecl;

(**
 * Get the scale mode used for texture scale operations.
 *
 * \param texture the texture to query.
 * \param scaleMode a pointer filled in with the current scale mode.
 * \return 0 on success, or -1 if the texture is not valid.
 *
 * \since This function is available since SDL 2.0.12.
 *
 * \sa SDL_SetTextureScaleMode
 *)
  SDL_GetTextureScaleMode: function(texture: PSDL_Texture; scaleMode: PSDL_ScaleMode): Integer; cdecl;

(**
 * Associate a user-specified pointer with a texture.
 *
 * \param texture the texture to update.
 * \param userdata the pointer to associate with the texture.
 * \returns 0 on success, or -1 if the texture is not valid.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_GetTextureUserData
 *)
  SDL_SetTextureUserData: function(texture: PSDL_Texture; userdata: Pointer): Integer; cdecl;

(**
 * Get the user-specified pointer associated with a texture
 *
 * \param texture the texture to query.
 * \return the pointer associated with the texture, or NULL if the texture is
 *         not valid.
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_SetTextureUserData
 *)
  SDL_GetTextureUserData: function(texture: PSDL_Texture): Pointer; cdecl;

(**
 * Update the given texture rectangle with new pixel data.
 *
 * The pixel data must be in the pixel format of the texture. Use
 * SDL_QueryTexture() to query the pixel format of the texture.
 *
 * This is a fairly slow function, intended for use with static textures that
 * do not change often.
 *
 * If the texture is intended to be updated often, it is preferred to create
 * the texture as streaming and use the locking functions referenced below.
 * While this function will work with streaming textures, for optimization
 * reasons you may not get the pixels back if you lock the texture afterward.
 *
 * \param texture the texture to update
 * \param rect an SDL_Rect structure representing the area to update, or NULL
 *             to update the entire texture
 * \param pixels the raw pixel data in the format of the texture
 * \param pitch the number of bytes in a row of pixel data, including padding
 *              between lines
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateTexture
 * \sa SDL_LockTexture
 * \sa SDL_UnlockTexture
 *)
  SDL_UpdateTexture: function(texture: PSDL_Texture; const rect: PSDL_Rect; const pixels: Pointer; pitch: Integer): Integer; cdecl;

(**
 * Update a rectangle within a planar YV12 or IYUV texture with new pixel
 * data.
 *
 * You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
 * block of Y and U/V planes in the proper order, but this function is
 * available if your pixel data is not contiguous.
 *
 * \param texture the texture to update
 * \param rect a pointer to the rectangle of pixels to update, or NULL to
 *             update the entire texture
 * \param Yplane the raw pixel data for the Y plane
 * \param Ypitch the number of bytes between rows of pixel data for the Y
 *               plane
 * \param Uplane the raw pixel data for the U plane
 * \param Upitch the number of bytes between rows of pixel data for the U
 *               plane
 * \param Vplane the raw pixel data for the V plane
 * \param Vpitch the number of bytes between rows of pixel data for the V
 *               plane
 * \returns 0 on success or -1 if the texture is not valid; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.1.
 *
 * \sa SDL_UpdateTexture
 *)
  SDL_UpdateYUVTexture: function(texture: PSDL_Texture; const rect: PSDL_Rect; const Yplane: PUint8; Ypitch: Integer; const Uplane: PUint8; Upitch: Integer; const Vplane: PUint8; Vpitch: Integer): Integer; cdecl;

(**
 * Update a rectangle within a planar NV12 or NV21 texture with new pixels.
 *
 * You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
 * block of NV12/21 planes in the proper order, but this function is available
 * if your pixel data is not contiguous.
 *
 * \param texture the texture to update
 * \param rect a pointer to the rectangle of pixels to update, or NULL to
 *             update the entire texture.
 * \param Yplane the raw pixel data for the Y plane.
 * \param Ypitch the number of bytes between rows of pixel data for the Y
 *               plane.
 * \param UVplane the raw pixel data for the UV plane.
 * \param UVpitch the number of bytes between rows of pixel data for the UV
 *                plane.
 * \return 0 on success, or -1 if the texture is not valid.
 *
 * \since This function is available since SDL 2.0.16.
 *)
  SDL_UpdateNVTexture: function(texture: PSDL_Texture; const rect: PSDL_Rect; const Yplane: PUint8; Ypitch: Integer; const UVplane: PUint8; UVpitch: Integer): Integer; cdecl;

(**
 * Lock a portion of the texture for **write-only** pixel access.
 *
 * As an optimization, the pixels made available for editing don't necessarily
 * contain the old texture data. This is a write-only operation, and if you
 * need to keep a copy of the texture data you should do that at the
 * application level.
 *
 * You must use SDL_UnlockTexture() to unlock the pixels and apply any
 * changes.
 *
 * \param texture the texture to lock for access, which was created with
 *                `SDL_TEXTUREACCESS_STREAMING`
 * \param rect an SDL_Rect structure representing the area to lock for access;
 *             NULL to lock the entire texture
 * \param pixels this is filled in with a pointer to the locked pixels,
 *               appropriately offset by the locked area
 * \param pitch this is filled in with the pitch of the locked pixels; the
 *              pitch is the length of one row in bytes
 * \returns 0 on success or a negative error code if the texture is not valid
 *          or was not created with `SDL_TEXTUREACCESS_STREAMING`; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_UnlockTexture
 *)
  SDL_LockTexture: function(texture: PSDL_Texture; const rect: PSDL_Rect; pixels: PPointer; pitch: PInteger): Integer; cdecl;

(**
 * Lock a portion of the texture for **write-only** pixel access, and expose
 * it as a SDL surface.
 *
 * Besides providing an SDL_Surface instead of raw pixel data, this function
 * operates like SDL_LockTexture.
 *
 * As an optimization, the pixels made available for editing don't necessarily
 * contain the old texture data. This is a write-only operation, and if you
 * need to keep a copy of the texture data you should do that at the
 * application level.
 *
 * You must use SDL_UnlockTexture() to unlock the pixels and apply any
 * changes.
 *
 * The returned surface is freed internally after calling SDL_UnlockTexture()
 * or SDL_DestroyTexture(). The caller should not free it.
 *
 * \param texture the texture to lock for access, which was created with
 *                `SDL_TEXTUREACCESS_STREAMING`
 * \param rect a pointer to the rectangle to lock for access. If the rect is
 *             NULL, the entire texture will be locked
 * \param surface this is filled in with an SDL surface representing the
 *                locked area
 * \returns 0 on success, or -1 if the texture is not valid or was not created
 *          with `SDL_TEXTUREACCESS_STREAMING`
 *
 * \since This function is available since SDL 2.0.12.
 *
 * \sa SDL_LockTexture
 * \sa SDL_UnlockTexture
 *)
  SDL_LockTextureToSurface: function(texture: PSDL_Texture; const rect: PSDL_Rect; surface: PPSDL_Surface): Integer; cdecl;

(**
 * Unlock a texture, uploading the changes to video memory, if needed.
 *
 * **Warning**: Please note that SDL_LockTexture() is intended to be
 * write-only; it will not guarantee the previous contents of the texture will
 * be provided. You must fully initialize any area of a texture that you lock
 * before unlocking it, as the pixels might otherwise be uninitialized memory.
 *
 * Which is to say: locking and immediately unlocking a texture can result in
 * corrupted textures, depending on the renderer in use.
 *
 * \param texture a texture locked by SDL_LockTexture()
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_LockTexture
 *)
  SDL_UnlockTexture: procedure(texture: PSDL_Texture); cdecl;

(**
 * Determine whether a renderer supports the use of render targets.
 *
 * \param renderer the renderer that will be checked
 * \returns SDL_TRUE if supported or SDL_FALSE if not.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetRenderTarget
 *)
  SDL_RenderTargetSupported: function(renderer: PSDL_Renderer): SDL_bool; cdecl;

(**
 * Set a texture as the current rendering target.
 *
 * Before using this function, you should check the
 * `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if
 * render targets are supported.
 *
 * The default render target is the window for which the renderer was created.
 * To stop rendering to a texture and render to the window again, call this
 * function with a NULL `texture`.
 *
 * \param renderer the rendering context
 * \param texture the targeted texture, which must be created with the
 *                `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the
 *                window instead of a texture.
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRenderTarget
 *)
  SDL_SetRenderTarget: function(renderer: PSDL_Renderer; texture: PSDL_Texture): Integer; cdecl;

(**
 * Get the current render target.
 *
 * The default render target is the window for which the renderer was created,
 * and is reported a NULL here.
 *
 * \param renderer the rendering context
 * \returns the current render target or NULL for the default render target.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetRenderTarget
 *)
  SDL_GetRenderTarget: function(renderer: PSDL_Renderer): PSDL_Texture; cdecl;

(**
 * Set a device independent resolution for rendering.
 *
 * This function uses the viewport and scaling functionality to allow a fixed
 * logical resolution for rendering, regardless of the actual output
 * resolution. If the actual output resolution doesn't have the same aspect
 * ratio the output rendering will be centered within the output display.
 *
 * If the output display is a window, mouse and touch events in the window
 * will be filtered and scaled so they seem to arrive within the logical
 * resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether
 * relative motion events are also scaled.
 *
 * If this function results in scaling or subpixel drawing by the rendering
 * backend, it will be handled using the appropriate quality hints.
 *
 * \param renderer the renderer for which resolution should be set
 * \param w the width of the logical resolution
 * \param h the height of the logical resolution
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderGetLogicalSize
 *)
  SDL_RenderSetLogicalSize: function(renderer: PSDL_Renderer; w: Integer; h: Integer): Integer; cdecl;

(**
 * Get device independent resolution for rendering.
 *
 * When using the main rendering target (eg no target texture is set): this
 * may return 0 for `w` and `h` if the SDL_Renderer has never had its logical
 * size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical
 * width and height.
 *
 * When using a target texture: Never return 0 for `w` and `h` at first. Then
 * it returns the logical width and height that are set.
 *
 * \param renderer a rendering context
 * \param w an int to be filled with the width
 * \param h an int to be filled with the height
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderSetLogicalSize
 *)
  SDL_RenderGetLogicalSize: procedure(renderer: PSDL_Renderer; w: PInteger; h: PInteger); cdecl;

(**
 * Set whether to force integer scales for resolution-independent rendering.
 *
 * This function restricts the logical viewport to integer values - that is,
 * when a resolution is between two multiples of a logical size, the viewport
 * size is rounded down to the lower multiple.
 *
 * \param renderer the renderer for which integer scaling should be set
 * \param enable enable or disable the integer scaling for rendering
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_RenderGetIntegerScale
 * \sa SDL_RenderSetLogicalSize
 *)
  SDL_RenderSetIntegerScale: function(renderer: PSDL_Renderer; enable: SDL_bool): Integer; cdecl;

(**
 * Get whether integer scales are forced for resolution-independent rendering.
 *
 * \param renderer the renderer from which integer scaling should be queried
 * \returns SDL_TRUE if integer scales are forced or SDL_FALSE if not and on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.5.
 *
 * \sa SDL_RenderSetIntegerScale
 *)
  SDL_RenderGetIntegerScale: function(renderer: PSDL_Renderer): SDL_bool; cdecl;

(**
 * Set the drawing area for rendering on the current target.
 *
 * When the window is resized, the viewport is reset to fill the entire new
 * window size.
 *
 * \param renderer the rendering context
 * \param rect the SDL_Rect structure representing the drawing area, or NULL
 *             to set the viewport to the entire target
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderGetViewport
 *)
  SDL_RenderSetViewport: function(renderer: PSDL_Renderer; const rect: PSDL_Rect): Integer; cdecl;

(**
 * Get the drawing area for the current target.
 *
 * \param renderer the rendering context
 * \param rect an SDL_Rect structure filled in with the current drawing area
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderSetViewport
 *)
  SDL_RenderGetViewport: procedure(renderer: PSDL_Renderer; rect: PSDL_Rect); cdecl;

(**
 * Set the clip rectangle for rendering on the specified target.
 *
 * \param renderer the rendering context for which clip rectangle should be
 *                 set
 * \param rect an SDL_Rect structure representing the clip area, relative to
 *             the viewport, or NULL to disable clipping
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderGetClipRect
 * \sa SDL_RenderIsClipEnabled
 *)
  SDL_RenderSetClipRect: function(renderer: PSDL_Renderer; const rect: PSDL_Rect): Integer; cdecl;

(**
 * Get the clip rectangle for the current target.
 *
 * \param renderer the rendering context from which clip rectangle should be
 *                 queried
 * \param rect an SDL_Rect structure filled in with the current clipping area
 *             or an empty rectangle if clipping is disabled
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderIsClipEnabled
 * \sa SDL_RenderSetClipRect
 *)
  SDL_RenderGetClipRect: procedure(renderer: PSDL_Renderer; rect: PSDL_Rect); cdecl;

(**
 * Get whether clipping is enabled on the given renderer.
 *
 * \param renderer the renderer from which clip state should be queried
 * \returns SDL_TRUE if clipping is enabled or SDL_FALSE if not; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.4.
 *
 * \sa SDL_RenderGetClipRect
 * \sa SDL_RenderSetClipRect
 *)
  SDL_RenderIsClipEnabled: function(renderer: PSDL_Renderer): SDL_bool; cdecl;

(**
 * Set the drawing scale for rendering on the current target.
 *
 * The drawing coordinates are scaled by the x/y scaling factors before they
 * are used by the renderer. This allows resolution independent drawing with a
 * single coordinate system.
 *
 * If this results in scaling or subpixel drawing by the rendering backend, it
 * will be handled using the appropriate quality hints. For best results use
 * integer scaling factors.
 *
 * \param renderer a rendering context
 * \param scaleX the horizontal scaling factor
 * \param scaleY the vertical scaling factor
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderGetScale
 * \sa SDL_RenderSetLogicalSize
 *)
  SDL_RenderSetScale: function(renderer: PSDL_Renderer; scaleX: Single; scaleY: Single): Integer; cdecl;

(**
 * Get the drawing scale for the current target.
 *
 * \param renderer the renderer from which drawing scale should be queried
 * \param scaleX a pointer filled in with the horizontal scaling factor
 * \param scaleY a pointer filled in with the vertical scaling factor
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderSetScale
 *)
  SDL_RenderGetScale: procedure(renderer: PSDL_Renderer; scaleX: PSingle; scaleY: PSingle); cdecl;

(**
 * Get logical coordinates of point in renderer when given real coordinates of
 * point in window.
 *
 * Logical coordinates will differ from real coordinates when render is scaled
 * and logical renderer size set
 *
 * \param renderer the renderer from which the logical coordinates should be
 *                 calculated
 * \param windowX the real X coordinate in the window
 * \param windowY the real Y coordinate in the window
 * \param logicalX the pointer filled with the logical x coordinate
 * \param logicalY the pointer filled with the logical y coordinate
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_RenderGetScale
 * \sa SDL_RenderSetScale
 * \sa SDL_RenderGetLogicalSize
 * \sa SDL_RenderSetLogicalSize
 *)
  SDL_RenderWindowToLogical: procedure(renderer: PSDL_Renderer; windowX: Integer; windowY: Integer; logicalX: PSingle; logicalY: PSingle); cdecl;

(**
 * Get real coordinates of point in window when given logical coordinates of
 * point in renderer.
 *
 * Logical coordinates will differ from real coordinates when render is scaled
 * and logical renderer size set
 *
 * \param renderer the renderer from which the window coordinates should be
 *                 calculated
 * \param logicalX the logical x coordinate
 * \param logicalY the logical y coordinate
 * \param windowX the pointer filled with the real X coordinate in the window
 * \param windowY the pointer filled with the real Y coordinate in the window
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_RenderGetScale
 * \sa SDL_RenderSetScale
 * \sa SDL_RenderGetLogicalSize
 * \sa SDL_RenderSetLogicalSize
 *)
  SDL_RenderLogicalToWindow: procedure(renderer: PSDL_Renderer; logicalX: Single; logicalY: Single; windowX: PInteger; windowY: PInteger); cdecl;

(**
 * Set the color used for drawing operations (Rect, Line and Clear).
 *
 * Set the color for drawing or filling rectangles, lines, and points, and for
 * SDL_RenderClear().
 *
 * \param renderer the rendering context
 * \param r the red value used to draw on the rendering target
 * \param g the green value used to draw on the rendering target
 * \param b the blue value used to draw on the rendering target
 * \param a the alpha value used to draw on the rendering target; usually
 *          `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to
 *          specify how the alpha channel is used
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRenderDrawColor
 * \sa SDL_RenderClear
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 *)
  SDL_SetRenderDrawColor: function(renderer: PSDL_Renderer; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

(**
 * Get the color used for drawing operations (Rect, Line and Clear).
 *
 * \param renderer the rendering context
 * \param r a pointer filled in with the red value used to draw on the
 *          rendering target
 * \param g a pointer filled in with the green value used to draw on the
 *          rendering target
 * \param b a pointer filled in with the blue value used to draw on the
 *          rendering target
 * \param a a pointer filled in with the alpha value used to draw on the
 *          rendering target; usually `SDL_ALPHA_OPAQUE` (255)
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_GetRenderDrawColor: function(renderer: PSDL_Renderer; r: PUint8; g: PUint8; b: PUint8; a: PUint8): Integer; cdecl;

(**
 * Set the blend mode used for drawing operations (Fill and Line).
 *
 * If the blend mode is not supported, the closest supported mode is chosen.
 *
 * \param renderer the rendering context
 * \param blendMode the SDL_BlendMode to use for blending
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRenderDrawBlendMode
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 *)
  SDL_SetRenderDrawBlendMode: function(renderer: PSDL_Renderer; blendMode: SDL_BlendMode): Integer; cdecl;

(**
 * Get the blend mode used for drawing operations.
 *
 * \param renderer the rendering context
 * \param blendMode a pointer filled in with the current SDL_BlendMode
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetRenderDrawBlendMode
 *)
  SDL_GetRenderDrawBlendMode: function(renderer: PSDL_Renderer; blendMode: PSDL_BlendMode): Integer; cdecl;

(**
 * Clear the current rendering target with the drawing color.
 *
 * This function clears the entire rendering target, ignoring the viewport and
 * the clip rectangle.
 *
 * \param renderer the rendering context
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderClear: function(renderer: PSDL_Renderer): Integer; cdecl;

(**
 * Draw a point on the current rendering target.
 *
 * SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,
 * use SDL_RenderDrawPoints() instead.
 *
 * \param renderer the rendering context
 * \param x the x coordinate of the point
 * \param y the y coordinate of the point
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 * \sa SDL_RenderPresent
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderDrawPoint: function(renderer: PSDL_Renderer; x: Integer; y: Integer): Integer; cdecl;

(**
 * Draw multiple points on the current rendering target.
 *
 * \param renderer the rendering context
 * \param points an array of SDL_Point structures that represent the points to
 *               draw
 * \param count the number of points to draw
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 * \sa SDL_RenderPresent
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderDrawPoints: function(renderer: PSDL_Renderer; const points: PSDL_Point; count: Integer): Integer; cdecl;

(**
 * Draw a line on the current rendering target.
 *
 * SDL_RenderDrawLine() draws the line to include both end points. If you want
 * to draw multiple, connecting lines use SDL_RenderDrawLines() instead.
 *
 * \param renderer the rendering context
 * \param x1 the x coordinate of the start point
 * \param y1 the y coordinate of the start point
 * \param x2 the x coordinate of the end point
 * \param y2 the y coordinate of the end point
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 * \sa SDL_RenderPresent
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderDrawLine: function(renderer: PSDL_Renderer; x1: Integer; y1: Integer; x2: Integer; y2: Integer): Integer; cdecl;

(**
 * Draw a series of connected lines on the current rendering target.
 *
 * \param renderer the rendering context
 * \param points an array of SDL_Point structures representing points along
 *               the lines
 * \param count the number of points, drawing count-1 lines
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 * \sa SDL_RenderPresent
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderDrawLines: function(renderer: PSDL_Renderer; const points: PSDL_Point; count: Integer): Integer; cdecl;

(**
 * Draw a rectangle on the current rendering target.
 *
 * \param renderer the rendering context
 * \param rect an SDL_Rect structure representing the rectangle to draw, or
 *             NULL to outline the entire rendering target
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 * \sa SDL_RenderPresent
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderDrawRect: function(renderer: PSDL_Renderer; const rect: PSDL_Rect): Integer; cdecl;

(**
 * Draw some number of rectangles on the current rendering target.
 *
 * \param renderer the rendering context
 * \param rects an array of SDL_Rect structures representing the rectangles to
 *              be drawn
 * \param count the number of rectangles
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 * \sa SDL_RenderPresent
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderDrawRects: function(renderer: PSDL_Renderer; const rects: PSDL_Rect; count: Integer): Integer; cdecl;

(**
 * Fill a rectangle on the current rendering target with the drawing color.
 *
 * The current drawing color is set by SDL_SetRenderDrawColor(), and the
 * color's alpha value is ignored unless blending is enabled with the
 * appropriate call to SDL_SetRenderDrawBlendMode().
 *
 * \param renderer the rendering context
 * \param rect the SDL_Rect structure representing the rectangle to fill, or
 *             NULL for the entire rendering target
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRects
 * \sa SDL_RenderPresent
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderFillRect: function(renderer: PSDL_Renderer; const rect: PSDL_Rect): Integer; cdecl;

(**
 * Fill some number of rectangles on the current rendering target with the
 * drawing color.
 *
 * \param renderer the rendering context
 * \param rects an array of SDL_Rect structures representing the rectangles to
 *              be filled
 * \param count the number of rectangles
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderPresent
 *)
  SDL_RenderFillRects: function(renderer: PSDL_Renderer; const rects: PSDL_Rect; count: Integer): Integer; cdecl;

(**
 * Copy a portion of the texture to the current rendering target.
 *
 * The texture is blended with the destination based on its blend mode set
 * with SDL_SetTextureBlendMode().
 *
 * The texture color is affected based on its color modulation set by
 * SDL_SetTextureColorMod().
 *
 * The texture alpha is affected based on its alpha modulation set by
 * SDL_SetTextureAlphaMod().
 *
 * \param renderer the rendering context
 * \param texture the source texture
 * \param srcrect the source SDL_Rect structure or NULL for the entire texture
 * \param dstrect the destination SDL_Rect structure or NULL for the entire
 *                rendering target; the texture will be stretched to fill the
 *                given rectangle
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderCopyEx
 * \sa SDL_SetTextureAlphaMod
 * \sa SDL_SetTextureBlendMode
 * \sa SDL_SetTextureColorMod
 *)
  SDL_RenderCopy: function(renderer: PSDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_Rect; const dstrect: PSDL_Rect): Integer; cdecl;

(**
 * Copy a portion of the texture to the current rendering, with optional
 * rotation and flipping.
 *
 * Copy a portion of the texture to the current rendering target, optionally
 * rotating it by angle around the given center and also flipping it
 * top-bottom and/or left-right.
 *
 * The texture is blended with the destination based on its blend mode set
 * with SDL_SetTextureBlendMode().
 *
 * The texture color is affected based on its color modulation set by
 * SDL_SetTextureColorMod().
 *
 * The texture alpha is affected based on its alpha modulation set by
 * SDL_SetTextureAlphaMod().
 *
 * \param renderer the rendering context
 * \param texture the source texture
 * \param srcrect the source SDL_Rect structure or NULL for the entire texture
 * \param dstrect the destination SDL_Rect structure or NULL for the entire
 *                rendering target
 * \param angle an angle in degrees that indicates the rotation that will be
 *              applied to dstrect, rotating it in a clockwise direction
 * \param center a pointer to a point indicating the point around which
 *               dstrect will be rotated (if NULL, rotation will be done
 *               around `dstrect.w / 2`, `dstrect.h / 2`)
 * \param flip a SDL_RendererFlip value stating which flipping actions should
 *             be performed on the texture
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderCopy
 * \sa SDL_SetTextureAlphaMod
 * \sa SDL_SetTextureBlendMode
 * \sa SDL_SetTextureColorMod
 *)
  SDL_RenderCopyEx: function(renderer: PSDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_Rect; const dstrect: PSDL_Rect; const angle: Double; const center: PSDL_Point; const flip: SDL_RendererFlip): Integer; cdecl;

(**
 * Draw a point on the current rendering target at subpixel precision.
 *
 * \param renderer The renderer which should draw a point.
 * \param x The x coordinate of the point.
 * \param y The y coordinate of the point.
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderDrawPointF: function(renderer: PSDL_Renderer; x: Single; y: Single): Integer; cdecl;

(**
 * Draw multiple points on the current rendering target at subpixel precision.
 *
 * \param renderer The renderer which should draw multiple points.
 * \param points The points to draw
 * \param count The number of points to draw
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderDrawPointsF: function(renderer: PSDL_Renderer; const points: PSDL_FPoint; count: Integer): Integer; cdecl;

(**
 * Draw a line on the current rendering target at subpixel precision.
 *
 * \param renderer The renderer which should draw a line.
 * \param x1 The x coordinate of the start point.
 * \param y1 The y coordinate of the start point.
 * \param x2 The x coordinate of the end point.
 * \param y2 The y coordinate of the end point.
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderDrawLineF: function(renderer: PSDL_Renderer; x1: Single; y1: Single; x2: Single; y2: Single): Integer; cdecl;

(**
 * Draw a series of connected lines on the current rendering target at
 * subpixel precision.
 *
 * \param renderer The renderer which should draw multiple lines.
 * \param points The points along the lines
 * \param count The number of points, drawing count-1 lines
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderDrawLinesF: function(renderer: PSDL_Renderer; const points: PSDL_FPoint; count: Integer): Integer; cdecl;

(**
 * Draw a rectangle on the current rendering target at subpixel precision.
 *
 * \param renderer The renderer which should draw a rectangle.
 * \param rect A pointer to the destination rectangle, or NULL to outline the
 *             entire rendering target.
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderDrawRectF: function(renderer: PSDL_Renderer; const rect: PSDL_FRect): Integer; cdecl;

(**
 * Draw some number of rectangles on the current rendering target at subpixel
 * precision.
 *
 * \param renderer The renderer which should draw multiple rectangles.
 * \param rects A pointer to an array of destination rectangles.
 * \param count The number of rectangles.
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderDrawRectsF: function(renderer: PSDL_Renderer; const rects: PSDL_FRect; count: Integer): Integer; cdecl;

(**
 * Fill a rectangle on the current rendering target with the drawing color at
 * subpixel precision.
 *
 * \param renderer The renderer which should fill a rectangle.
 * \param rect A pointer to the destination rectangle, or NULL for the entire
 *             rendering target.
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderFillRectF: function(renderer: PSDL_Renderer; const rect: PSDL_FRect): Integer; cdecl;

(**
 * Fill some number of rectangles on the current rendering target with the
 * drawing color at subpixel precision.
 *
 * \param renderer The renderer which should fill multiple rectangles.
 * \param rects A pointer to an array of destination rectangles.
 * \param count The number of rectangles.
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderFillRectsF: function(renderer: PSDL_Renderer; const rects: PSDL_FRect; count: Integer): Integer; cdecl;

(**
 * Copy a portion of the texture to the current rendering target at subpixel
 * precision.
 *
 * \param renderer The renderer which should copy parts of a texture.
 * \param texture The source texture.
 * \param srcrect A pointer to the source rectangle, or NULL for the entire
 *                texture.
 * \param dstrect A pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderCopyF: function(renderer: PSDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_Rect; const dstrect: PSDL_FRect): Integer; cdecl;

(**
 * Copy a portion of the source texture to the current rendering target, with
 * rotation and flipping, at subpixel precision.
 *
 * \param renderer The renderer which should copy parts of a texture.
 * \param texture The source texture.
 * \param srcrect A pointer to the source rectangle, or NULL for the entire
 *                texture.
 * \param dstrect A pointer to the destination rectangle, or NULL for the
 *                entire rendering target.
 * \param angle An angle in degrees that indicates the rotation that will be
 *              applied to dstrect, rotating it in a clockwise direction
 * \param center A pointer to a point indicating the point around which
 *               dstrect will be rotated (if NULL, rotation will be done
 *               around dstrect.w/2, dstrect.h/2).
 * \param flip An SDL_RendererFlip value stating which flipping actions should
 *             be performed on the texture
 * \return 0 on success, or -1 on error
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderCopyExF: function(renderer: PSDL_Renderer; texture: PSDL_Texture; const srcrect: PSDL_Rect; const dstrect: PSDL_FRect; const angle: Double; const center: PSDL_FPoint; const flip: SDL_RendererFlip): Integer; cdecl;

(**
 * Render a list of triangles, optionally using a texture and indices into the
 * vertex array Color and alpha modulation is done per vertex
 * (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
 *
 * \param renderer The rendering context.
 * \param texture (optional) The SDL texture to use.
 * \param vertices Vertices.
 * \param num_vertices Number of vertices.
 * \param indices (optional) An array of integer indices into the 'vertices'
 *                array, if NULL all vertices will be rendered in sequential
 *                order.
 * \param num_indices Number of indices.
 * \return 0 on success, or -1 if the operation is not supported
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_RenderGeometryRaw
 * \sa SDL_Vertex
 *)
  SDL_RenderGeometry: function(renderer: PSDL_Renderer; texture: PSDL_Texture; const vertices: PSDL_Vertex; num_vertices: Integer; const indices: PInteger; num_indices: Integer): Integer; cdecl;

(**
 * Render a list of triangles, optionally using a texture and indices into the
 * vertex arrays Color and alpha modulation is done per vertex
 * (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
 *
 * \param renderer The rendering context.
 * \param texture (optional) The SDL texture to use.
 * \param xy Vertex positions
 * \param xy_stride Byte size to move from one element to the next element
 * \param color Vertex colors (as SDL_Color)
 * \param color_stride Byte size to move from one element to the next element
 * \param uv Vertex normalized texture coordinates
 * \param uv_stride Byte size to move from one element to the next element
 * \param num_vertices Number of vertices.
 * \param indices (optional) An array of indices into the 'vertices' arrays,
 *                if NULL all vertices will be rendered in sequential order.
 * \param num_indices Number of indices.
 * \param size_indices Index size: 1 (byte), 2 (short), 4 (int)
 * \return 0 on success, or -1 if the operation is not supported
 *
 * \since This function is available since SDL 2.0.18.
 *
 * \sa SDL_RenderGeometry
 * \sa SDL_Vertex
 *)
  SDL_RenderGeometryRaw: function(renderer: PSDL_Renderer; texture: PSDL_Texture; const xy: PSingle; xy_stride: Integer; const color: PSDL_Color; color_stride: Integer; const uv: PSingle; uv_stride: Integer; num_vertices: Integer; const indices: Pointer; num_indices: Integer; size_indices: Integer): Integer; cdecl;

(**
 * Read pixels from the current rendering target to an array of pixels.
 *
 * **WARNING**: This is a very slow operation, and should not be used
 * frequently. If you're using this on the main rendering target, it should be
 * called after rendering and before SDL_RenderPresent().
 *
 * `pitch` specifies the number of bytes between rows in the destination
 * `pixels` data. This allows you to write to a subrectangle or have padded
 * rows in the destination. Generally, `pitch` should equal the number of
 * pixels per row in the `pixels` data times the number of bytes per pixel,
 * but it might contain additional padding (for example, 24bit RGB Windows
 * Bitmap data pads all rows to multiples of 4 bytes).
 *
 * \param renderer the rendering context
 * \param rect an SDL_Rect structure representing the area to read, or NULL
 *             for the entire render target
 * \param format an SDL_PixelFormatEnum value of the desired format of the
 *               pixel data, or 0 to use the format of the rendering target
 * \param pixels a pointer to the pixel data to copy into
 * \param pitch the pitch of the `pixels` parameter
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_RenderReadPixels: function(renderer: PSDL_Renderer; const rect: PSDL_Rect; format: Uint32; pixels: Pointer; pitch: Integer): Integer; cdecl;

(**
 * Update the screen with any rendering performed since the previous call.
 *
 * SDL's rendering functions operate on a backbuffer; that is, calling a
 * rendering function such as SDL_RenderDrawLine() does not directly put a
 * line on the screen, but rather updates the backbuffer. As such, you compose
 * your entire scene and *present* the composed backbuffer to the screen as a
 * complete picture.
 *
 * Therefore, when using SDL's rendering API, one does all drawing intended
 * for the frame, and then calls this function once per frame to present the
 * final drawing to the user.
 *
 * The backbuffer should be considered invalidated after each present; do not
 * assume that previous contents will exist between frames. You are strongly
 * encouraged to call SDL_RenderClear() to initialize the backbuffer before
 * starting each new frame's drawing, even if you plan to overwrite every
 * pixel.
 *
 * \param renderer the rendering context
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RenderClear
 * \sa SDL_RenderDrawLine
 * \sa SDL_RenderDrawLines
 * \sa SDL_RenderDrawPoint
 * \sa SDL_RenderDrawPoints
 * \sa SDL_RenderDrawRect
 * \sa SDL_RenderDrawRects
 * \sa SDL_RenderFillRect
 * \sa SDL_RenderFillRects
 * \sa SDL_SetRenderDrawBlendMode
 * \sa SDL_SetRenderDrawColor
 *)
  SDL_RenderPresent: procedure(renderer: PSDL_Renderer); cdecl;

(**
 * Destroy the specified texture.
 *
 * Passing NULL or an otherwise invalid texture will set the SDL error message
 * to "Invalid texture".
 *
 * \param texture the texture to destroy
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateTexture
 * \sa SDL_CreateTextureFromSurface
 *)
  SDL_DestroyTexture: procedure(texture: PSDL_Texture); cdecl;

(**
 * Destroy the rendering context for a window and free associated textures.
 *
 * If `renderer` is NULL, this function will return immediately after setting
 * the SDL error message to "Invalid renderer". See SDL_GetError().
 *
 * \param renderer the rendering context
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateRenderer
 *)
  SDL_DestroyRenderer: procedure(renderer: PSDL_Renderer); cdecl;

(**
 * Force the rendering context to flush any pending commands to the underlying
 * rendering API.
 *
 * You do not need to (and in fact, shouldn't) call this function unless you
 * are planning to call into OpenGL/Direct3D/Metal/whatever directly in
 * addition to using an SDL_Renderer.
 *
 * This is for a very-specific case: if you are using SDL's render API, you
 * asked for a specific renderer backend (OpenGL, Direct3D, etc), you set
 * SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever
 * calls in addition to SDL render API calls. If all of this applies, you
 * should call SDL_RenderFlush() between calls to SDL's render API and the
 * low-level API you're using in cooperation.
 *
 * In all other cases, you can ignore this function. This is only here to get
 * maximum performance out of a specific situation. In all other cases, SDL
 * will do the right thing, perhaps at a performance loss.
 *
 * This function is first available in SDL 2.0.10, and is not needed in 2.0.9
 * and earlier, as earlier versions did not queue rendering commands at all,
 * instead flushing them to the OS immediately.
 *
 * \param renderer the rendering context
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.10.
 *)
  SDL_RenderFlush: function(renderer: PSDL_Renderer): Integer; cdecl;

(**
 * Bind an OpenGL/ES/ES2 texture to the current context.
 *
 * This is for use with OpenGL instructions when rendering OpenGL primitives
 * directly.
 *
 * If not NULL, `texw` and `texh` will be filled with the width and height
 * values suitable for the provided texture. In most cases, both will be 1.0,
 * however, on systems that support the GL_ARB_texture_rectangle extension,
 * these values will actually be the pixel width and height used to create the
 * texture, so this factor needs to be taken into account when providing
 * texture coordinates to OpenGL.
 *
 * You need a renderer to create an SDL_Texture, therefore you can only use
 * this function with an implicit OpenGL context from SDL_CreateRenderer(),
 * not with your own OpenGL context. If you need control over your OpenGL
 * context, you need to write your own texture-loading methods.
 *
 * Also note that SDL may upload RGB textures as BGR (or vice-versa), and
 * re-order the color channels in the shaders phase, so the uploaded texture
 * may have swapped color channels.
 *
 * \param texture the texture to bind to the current OpenGL/ES/ES2 context
 * \param texw a pointer to a float value which will be filled with the
 *             texture width or NULL if you don't need that value
 * \param texh a pointer to a float value which will be filled with the
 *             texture height or NULL if you don't need that value
 * \returns 0 on success, or -1 if the operation is not supported; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_MakeCurrent
 * \sa SDL_GL_UnbindTexture
 *)
  SDL_GL_BindTexture: function(texture: PSDL_Texture; texw: PSingle; texh: PSingle): Integer; cdecl;

(**
 * Unbind an OpenGL/ES/ES2 texture from the current context.
 *
 * See SDL_GL_BindTexture() for examples on how to use these functions
 *
 * \param texture the texture to unbind from the current OpenGL/ES/ES2 context
 * \returns 0 on success, or -1 if the operation is not supported
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GL_BindTexture
 * \sa SDL_GL_MakeCurrent
 *)
  SDL_GL_UnbindTexture: function(texture: PSDL_Texture): Integer; cdecl;

(**
 * Get the CAMetalLayer associated with the given Metal renderer.
 *
 * This function returns `void *`, so SDL doesn't have to include Metal's
 * headers, but it can be safely cast to a `CAMetalLayer *`.
 *
 * \param renderer The renderer to query
 * \returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a
 *          Metal renderer
 *
 * \since This function is available since SDL 2.0.8.
 *
 * \sa SDL_RenderGetMetalCommandEncoder
 *)
  SDL_RenderGetMetalLayer: function(renderer: PSDL_Renderer): Pointer; cdecl;

(**
 * Get the Metal command encoder for the current frame
 *
 * This function returns `void *`, so SDL doesn't have to include Metal's
 * headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.
 *
 * Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give
 * SDL a drawable to render to, which might happen if the window is
 * hidden/minimized/offscreen. This doesn't apply to command encoders for
 * render targets, just the window's backbacker. Check your return values!
 *
 * \param renderer The renderer to query
 * \returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the
 *          renderer isn't a Metal renderer or there was an error.
 *
 * \since This function is available since SDL 2.0.8.
 *
 * \sa SDL_RenderGetMetalLayer
 *)
  SDL_RenderGetMetalCommandEncoder: function(renderer: PSDL_Renderer): Pointer; cdecl;

(**
 * Toggle VSync of the given renderer.
 *
 * \param renderer The renderer to toggle
 * \param vsync 1 for on, 0 for off. All other values are reserved
 * \returns a 0 int on success, or non-zero on failure
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_RenderSetVSync: function(renderer: PSDL_Renderer; vsync: Integer): Integer; cdecl;

(**
 * Create a window that can be shaped with the specified position, dimensions,
 * and flags.
 *
 * \param title The title of the window, in UTF-8 encoding.
 * \param x The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
 *          ::SDL_WINDOWPOS_UNDEFINED.
 * \param y The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
 *          ::SDL_WINDOWPOS_UNDEFINED.
 * \param w The width of the window.
 * \param h The height of the window.
 * \param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with
 *              any of the following: ::SDL_WINDOW_OPENGL,
 *              ::SDL_WINDOW_INPUT_GRABBED, ::SDL_WINDOW_HIDDEN,
 *              ::SDL_WINDOW_RESIZABLE, ::SDL_WINDOW_MAXIMIZED,
 *              ::SDL_WINDOW_MINIMIZED, ::SDL_WINDOW_BORDERLESS is always set,
 *              and ::SDL_WINDOW_FULLSCREEN is always unset.
 * \return the window created, or NULL if window creation failed.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_DestroyWindow
 *)
  SDL_CreateShapedWindow: function(const title: PUTF8Char; x: Cardinal; y: Cardinal; w: Cardinal; h: Cardinal; flags: Uint32): PSDL_Window; cdecl;

(**
 * Return whether the given window is a shaped window.
 *
 * \param window The window to query for being shaped.
 * \return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if
 *         the window is unshaped or NULL.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_CreateShapedWindow
 *)
  SDL_IsShapedWindow: function(const window: PSDL_Window): SDL_bool; cdecl;

(**
 * Set the shape and parameters of a shaped window.
 *
 * \param window The shaped window whose parameters should be set.
 * \param shape A surface encoding the desired shape for the window.
 * \param shape_mode The parameters to set for the shaped window.
 * \return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape
 *         argument, or SDL_NONSHAPEABLE_WINDOW if the SDL_Window given does
 *         not reference a valid shaped window.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WindowShapeMode
 * \sa SDL_GetShapedWindowMode
 *)
  SDL_SetWindowShape: function(window: PSDL_Window; shape: PSDL_Surface; shape_mode: PSDL_WindowShapeMode): Integer; cdecl;

(**
 * Get the shape parameters of a shaped window.
 *
 * \param window The shaped window whose parameters should be retrieved.
 * \param shape_mode An empty shape-mode structure to fill, or NULL to check
 *                   whether the window has a shape.
 * \return 0 if the window has a shape and, provided shape_mode was not NULL,
 *         shape_mode has been filled with the mode data,
 *         SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped
 *         window, or SDL_WINDOW_LACKS_SHAPE if the SDL_Window given is a
 *         shapeable window currently lacking a shape.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_WindowShapeMode
 * \sa SDL_SetWindowShape
 *)
  SDL_GetShapedWindowMode: function(window: PSDL_Window; shape_mode: PSDL_WindowShapeMode): Integer; cdecl;

(**
 * Set a callback for every Windows message, run before TranslateMessage().
 *
 * \param callback The SDL_WindowsMessageHook function to call.
 * \param userdata a pointer to pass to every iteration of `callback`
 *
 * \since This function is available since SDL 2.0.4.
 *)
  SDL_SetWindowsMessageHook: procedure(callback: SDL_WindowsMessageHook; userdata: Pointer); cdecl;

(**
 * Get the D3D9 adapter index that matches the specified display index.
 *
 * The returned adapter index can be passed to `IDirect3D9::CreateDevice` and
 * controls on which monitor a full screen application will appear.
 *
 * \param displayIndex the display index for which to get the D3D9 adapter
 *                     index
 * \returns the D3D9 adapter index on success or a negative error code on
 *          failure; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.1.
 *)
  SDL_Direct3D9GetAdapterIndex: function(displayIndex: Integer): Integer; cdecl;

(**
 * Get the D3D9 device associated with a renderer.
 *
 * Once you are done using the device, you should release it to avoid a
 * resource leak.
 *
 * \param renderer the renderer from which to get the associated D3D device
 * \returns the D3D9 device associated with given renderer or NULL if it is
 *          not a D3D9 renderer; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.1.
 *)
  SDL_RenderGetD3D9Device: function(renderer: PSDL_Renderer): PIDirect3DDevice9; cdecl;

(**
 * Get the D3D11 device associated with a renderer.
 *
 * Once you are done using the device, you should release it to avoid a
 * resource leak.
 *
 * \param renderer the renderer from which to get the associated D3D11 device
 * \returns the D3D11 device associated with given renderer or NULL if it is
 *          not a D3D11 renderer; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.16.
 *)
  SDL_RenderGetD3D11Device: function(renderer: PSDL_Renderer): PID3D11Device; cdecl;

(**
 * Get the D3D12 device associated with a renderer.
 *
 * Once you are done using the device, you should release it to avoid a
 * resource leak.
 *
 * \param renderer the renderer from which to get the associated D3D12 device
 * \returns the D3D12 device associated with given renderer or NULL if it is
 *          not a D3D12 renderer; call SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.24.0.
 *)
  SDL_RenderGetD3D12Device: function(renderer: PSDL_Renderer): PID3D12Device; cdecl;

(**
 * Get the DXGI Adapter and Output indices for the specified display index.
 *
 * The DXGI Adapter and Output indices can be passed to `EnumAdapters` and
 * `EnumOutputs` respectively to get the objects required to create a DX10 or
 * DX11 device and swap chain.
 *
 * Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it
 * returns an SDL_bool.
 *
 * \param displayIndex the display index for which to get both indices
 * \param adapterIndex a pointer to be filled in with the adapter index
 * \param outputIndex a pointer to be filled in with the output index
 * \returns SDL_TRUE on success or SDL_FALSE on failure; call SDL_GetError()
 *          for more information.
 *
 * \since This function is available since SDL 2.0.2.
 *)
  SDL_DXGIGetOutputInfo: function(displayIndex: Integer; adapterIndex: PInteger; outputIndex: PInteger): SDL_bool; cdecl;

(**
 * Query if the current device is a tablet.
 *
 * If SDL can't determine this, it will return SDL_FALSE.
 *
 * \returns SDL_TRUE if the device is a tablet, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL 2.0.9.
 *)
  SDL_IsTablet: function(): SDL_bool; cdecl;

  SDL_OnApplicationWillTerminate: procedure(); cdecl;

  SDL_OnApplicationDidReceiveMemoryWarning: procedure(); cdecl;

  SDL_OnApplicationWillResignActive: procedure(); cdecl;

  SDL_OnApplicationDidEnterBackground: procedure(); cdecl;

  SDL_OnApplicationWillEnterForeground: procedure(); cdecl;

  SDL_OnApplicationDidBecomeActive: procedure(); cdecl;

(**
 * Get the number of milliseconds since SDL library initialization.
 *
 * This value wraps if the program runs for more than ~49 days.
 *
 * This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()
 * instead, where the value doesn't wrap every ~49 days. There are places in
 * SDL where we provide a 32-bit timestamp that can not change without
 * breaking binary compatibility, though, so this function isn't officially
 * deprecated.
 *
 * \returns an unsigned 32-bit value representing the number of milliseconds
 *          since the SDL library initialized.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_TICKS_PASSED
 *)
  SDL_GetTicks: function(): Uint32; cdecl;

(**
 * Get the number of milliseconds since SDL library initialization.
 *
 * Note that you should not use the SDL_TICKS_PASSED macro with values
 * returned by this function, as that macro does clever math to compensate for
 * the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit
 * values from this function can be safely compared directly.
 *
 * For example, if you want to wait 100 ms, you could do this:
 *
 * ```c
 * const Uint64 timeout = SDL_GetTicks64() + 100;
 * while (SDL_GetTicks64() < timeout) {
 *     // ... do work until timeout has elapsed
 * }
 * ```
 *
 * \returns an unsigned 64-bit value representing the number of milliseconds
 *          since the SDL library initialized.
 *
 * \since This function is available since SDL 2.0.18.
 *)
  SDL_GetTicks64: function(): Uint64; cdecl;

(**
 * Get the current value of the high resolution counter.
 *
 * This function is typically used for profiling.
 *
 * The counter values are only meaningful relative to each other. Differences
 * between values can be converted to times by using
 * SDL_GetPerformanceFrequency().
 *
 * \returns the current counter value.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetPerformanceFrequency
 *)
  SDL_GetPerformanceCounter: function(): Uint64; cdecl;

(**
 * Get the count per second of the high resolution counter.
 *
 * \returns a platform-specific count per second.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetPerformanceCounter
 *)
  SDL_GetPerformanceFrequency: function(): Uint64; cdecl;

(**
 * Wait a specified number of milliseconds before returning.
 *
 * This function waits a specified number of milliseconds before returning. It
 * waits at least the specified time, but possibly longer due to OS
 * scheduling.
 *
 * \param ms the number of milliseconds to delay
 *
 * \since This function is available since SDL 2.0.0.
 *)
  SDL_Delay: procedure(ms: Uint32); cdecl;

(**
 * Call a callback function at a future time.
 *
 * If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().
 *
 * The callback function is passed the current timer interval and the user
 * supplied parameter from the SDL_AddTimer() call and should return the next
 * timer interval. If the value returned from the callback is 0, the timer is
 * canceled.
 *
 * The callback is run on a separate thread.
 *
 * Timers take into account the amount of time it took to execute the
 * callback. For example, if the callback took 250 ms to execute and returned
 * 1000 (ms), the timer would only wait another 750 ms before its next
 * iteration.
 *
 * Timing may be inexact due to OS scheduling. Be sure to note the current
 * time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your
 * callback needs to adjust for variances.
 *
 * \param interval the timer delay, in milliseconds, passed to `callback`
 * \param callback the SDL_TimerCallback function to call when the specified
 *                 `interval` elapses
 * \param param a pointer that is passed to `callback`
 * \returns a timer ID or 0 if an error occurs; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_RemoveTimer
 *)
  SDL_AddTimer: function(interval: Uint32; callback: SDL_TimerCallback; param: Pointer): SDL_TimerID; cdecl;

(**
 * Remove a timer created with SDL_AddTimer().
 *
 * \param id the ID of the timer to remove
 * \returns SDL_TRUE if the timer is removed or SDL_FALSE if the timer wasn't
 *          found.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_AddTimer
 *)
  SDL_RemoveTimer: function(id: SDL_TimerID): SDL_bool; cdecl;

(**
 * Get the version of SDL that is linked against your program.
 *
 * If you are linking to SDL dynamically, then it is possible that the current
 * version will be different than the version you compiled against. This
 * function returns the current version, while SDL_VERSION() is a macro that
 * tells you what version you compiled with.
 *
 * This function may be called safely at any time, even before SDL_Init().
 *
 * \param ver the SDL_version structure that contains the version information
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRevision
 *)
  SDL_GetVersion: procedure(ver: PSDL_version); cdecl;

(**
 * Get the code revision of SDL that is linked against your program.
 *
 * This value is the revision of the code you are linked with and may be
 * different from the code you are compiling with, which is found in the
 * constant SDL_REVISION.
 *
 * The revision is arbitrary string (a hash value) uniquely identifying the
 * exact revision of the SDL library in use, and is only useful in comparing
 * against other revisions. It is NOT an incrementing number.
 *
 * If SDL wasn't built from a git repository with the appropriate tools, this
 * will return an empty string.
 *
 * Prior to SDL 2.0.16, before development moved to GitHub, this returned a
 * hash for a Mercurial repository.
 *
 * You shouldn't use this function for anything but logging it for debugging
 * purposes. The string is not intended to be reliable in any way.
 *
 * \returns an arbitrary string, uniquely identifying the exact revision of
 *          the SDL library in use.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetVersion
 *)
  SDL_GetRevision: function(): PUTF8Char; cdecl;

(**
 * Obsolete function, do not use.
 *
 * When SDL was hosted in a Mercurial repository, and was built carefully,
 * this would return the revision number that the build was created from. This
 * number was not reliable for several reasons, but more importantly, SDL is
 * now hosted in a git repository, which does not offer numbers at all, only
 * hashes. This function only ever returns zero now. Don't use it.
 *
 * Before SDL 2.0.16, this might have returned an unreliable, but non-zero
 * number.
 *
 * \deprecated Use SDL_GetRevision() instead; if SDL was carefully built, it
 *             will return a git hash.
 *
 * \returns zero, always, in modern SDL releases.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_GetRevision
 *)
  SDL_GetRevisionNumber: function(): Integer; cdecl;

(**
 * Report the user's preferred locale.
 *
 * This returns an array of SDL_Locale structs, the final item zeroed out.
 * When the caller is done with this array, it should call SDL_free() on the
 * returned value; all the memory involved is allocated in a single block, so
 * a single SDL_free() will suffice.
 *
 * Returned language strings are in the format xx, where 'xx' is an ISO-639
 * language specifier (such as "en" for English, "de" for German, etc).
 * Country strings are in the format YY, where "YY" is an ISO-3166 country
 * code (such as "US" for the United States, "CA" for Canada, etc). Country
 * might be NULL if there's no specific guidance on them (so you might get {
 * "en", "US" } for American English, but { "en", NULL } means "English
 * language, generically"). Language strings are never NULL, except to
 * terminate the array.
 *
 * Please note that not all of these strings are 2 characters; some are three
 * or more.
 *
 * The returned list of locales are in the order of the user's preference. For
 * example, a German citizen that is fluent in US English and knows enough
 * Japanese to navigate around Tokyo might have a list like: { "de", "en_US",
 * "jp", NULL }. Someone from England might prefer British English (where
 * "color" is spelled "colour", etc), but will settle for anything like it: {
 * "en_GB", "en", NULL }.
 *
 * This function returns NULL on error, including when the platform does not
 * supply this information at all.
 *
 * This might be a "slow" call that has to query the operating system. It's
 * best to ask for this once and save the results. However, this list can
 * change, usually because the user has changed a system preference outside of
 * your program; SDL will send an SDL_LOCALECHANGED event in this case, if
 * possible, and you can call this function again to get an updated copy of
 * preferred locales.
 *
 * \return array of locales, terminated with a locale with a NULL language
 *         field. Will return NULL on error.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_GetPreferredLocales: function(): PSDL_Locale; cdecl;

(**
 * Open a URL/URI in the browser or other appropriate external application.
 *
 * Open a URL in a separate, system-provided application. How this works will
 * vary wildly depending on the platform. This will likely launch what makes
 * sense to handle a specific URL's protocol (a web browser for `http://`,
 * etc), but it might also be able to launch file managers for directories and
 * other things.
 *
 * What happens when you open a URL varies wildly as well: your game window
 * may lose focus (and may or may not lose focus if your game was fullscreen
 * or grabbing input at the time). On mobile devices, your app will likely
 * move to the background or your process might be paused. Any given platform
 * may or may not handle a given URL.
 *
 * If this is unimplemented (or simply unavailable) for a platform, this will
 * fail with an error. A successful result does not mean the URL loaded, just
 * that we launched _something_ to handle it (or at least believe we did).
 *
 * All this to say: this function can be useful, but you should definitely
 * test it on every platform you target.
 *
 * \param url A valid URL/URI to open. Use `file:///full/path/to/file` for
 *            local files, if supported.
 * \returns 0 on success, or -1 on error; call SDL_GetError() for more
 *          information.
 *
 * \since This function is available since SDL 2.0.14.
 *)
  SDL_OpenURL: function(const url: PUTF8Char): Integer; cdecl;

(**
 * Initialize the SDL library.
 *
 * SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the
 * two may be used interchangeably. Though for readability of your code
 * SDL_InitSubSystem() might be preferred.
 *
 * The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)
 * subsystems are initialized by default. Message boxes
 * (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
 * video subsystem, in hopes of being useful in showing an error dialog when
 * SDL_Init fails. You must specifically initialize other subsystems if you
 * use them in your application.
 *
 * Logging (such as SDL_Log) works without initialization, too.
 *
 * `flags` may be any of the following OR'd together:
 *
 * - `SDL_INIT_TIMER`: timer subsystem
 * - `SDL_INIT_AUDIO`: audio subsystem
 * - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events
 *   subsystem
 * - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the
 *   events subsystem
 * - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem
 * - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically
 *   initializes the joystick subsystem
 * - `SDL_INIT_EVENTS`: events subsystem
 * - `SDL_INIT_EVERYTHING`: all of the above subsystems
 * - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored
 *
 * Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()
 * for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or
 * call SDL_Quit() to force shutdown). If a subsystem is already loaded then
 * this call will increase the ref-count and return.
 *
 * \param flags subsystem initialization flags
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_InitSubSystem
 * \sa SDL_Quit
 * \sa SDL_SetMainReady
 * \sa SDL_WasInit
 *)
  SDL_Init: function(flags: Uint32): Integer; cdecl;

(**
 * Compatibility function to initialize the SDL library.
 *
 * In SDL2, this function and SDL_Init() are interchangeable.
 *
 * \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 * \returns 0 on success or a negative error code on failure; call
 *          SDL_GetError() for more information.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Init
 * \sa SDL_Quit
 * \sa SDL_QuitSubSystem
 *)
  SDL_InitSubSystem: function(flags: Uint32): Integer; cdecl;

(**
 * Shut down specific SDL subsystems.
 *
 * If you start a subsystem using a call to that subsystem's init function
 * (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),
 * SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use
 * that subsystem's quit function (SDL_VideoQuit()) directly instead. But
 * generally, you should not be using those functions directly anyhow; use
 * SDL_Init() instead.
 *
 * You still need to call SDL_Quit() even if you close all open subsystems
 * with SDL_QuitSubSystem().
 *
 * \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_InitSubSystem
 * \sa SDL_Quit
 *)
  SDL_QuitSubSystem: procedure(flags: Uint32); cdecl;

(**
 * Get a mask of the specified subsystems which are currently initialized.
 *
 * \param flags any of the flags used by SDL_Init(); see SDL_Init for details.
 * \returns a mask of all initialized subsystems if `flags` is 0, otherwise it
 *          returns the initialization status of the specified subsystems.
 *
 *          The return value does not include SDL_INIT_NOPARACHUTE.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Init
 * \sa SDL_InitSubSystem
 *)
  SDL_WasInit: function(flags: Uint32): Uint32; cdecl;

(**
 * Clean up all initialized subsystems.
 *
 * You should call this function even if you have already shutdown each
 * initialized subsystem with SDL_QuitSubSystem(). It is safe to call this
 * function even in the case of errors in initialization.
 *
 * If you start a subsystem using a call to that subsystem's init function
 * (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),
 * then you must use that subsystem's quit function (SDL_VideoQuit()) to shut
 * it down before calling SDL_Quit(). But generally, you should not be using
 * those functions directly anyhow; use SDL_Init() instead.
 *
 * You can use this function with atexit() to ensure that it is run when your
 * application is shutdown, but it is not wise to do this from a library or
 * other dynamically loaded code.
 *
 * \since This function is available since SDL 2.0.0.
 *
 * \sa SDL_Init
 * \sa SDL_QuitSubSystem
 *)
  SDL_Quit: procedure(); cdecl;

(**
 * This function gets the version of the dynamically linked SDL_image library.
 *
 * it should NOT be used to fill a version structure, instead you should use
 * the SDL_IMAGE_VERSION() macro.
 *
 * \returns SDL_image version
 *)
  IMG_Linked_Version: function(): PSDL_version; cdecl;

(**
 * Initialize SDL_image.
 *
 * This function loads dynamic libraries that SDL_image needs, and prepares
 * them for use. This must be the first function you call in SDL_image, and if
 * it fails you should not continue with the library.
 *
 * Flags should be one or more flags from IMG_InitFlags OR'd together. It
 * returns the flags successfully initialized, or 0 on failure.
 *
 * Currently, these flags are:
 *
 * - `_INIT_JPG`
 * - `_INIT_PNG`
 * - `_INIT_TIF`
 * - `_INIT_WEBP`
 * - `_INIT_JXL`
 * - `_INIT_AVIF`
 *
 * More flags may be added in a future SDL_image release.
 *
 * This function may need to load external shared libraries to support various
 * codecs, which means this function can fail to initialize that support on an
 * otherwise-reasonable system if the library isn't available; this is not
 * just a question of exceptional circumstances like running out of memory at
 * startup!
 *
 * Note that you may call this function more than once to initialize with
 * additional flags. The return value will reflect both new flags that
 * successfully initialized, and also include flags that had previously been
 * initialized as well.
 *
 * As this will return previously-initialized flags, it's legal to call this
 * with zero (no flags set). This is a safe no-op that can be used to query
 * the current initialization state without changing it at all.
 *
 * Since this returns previously-initialized flags as well as new ones, and
 * you can call this with zero, you should not check for a zero return value
 * to determine an error condition. Instead, you should check to make sure all
 * the flags you require are set in the return value. If you have a game with
 * data in a specific format, this might be a fatal error. If you're a generic
 * image displaying app, perhaps you are fine with only having JPG and PNG
 * support and can live without WEBP, even if you request support for
 * everything.
 *
 * Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a
 * single call to IMG_Quit() will deinitialize everything and does not have to
 * be paired with a matching IMG_Init call. For that reason, it's considered
 * best practices to have a single IMG_Init and IMG_Quit call in your program.
 * While this isn't required, be aware of the risks of deviating from that
 * behavior.
 *
 * After initializing SDL_image, the app may begin to load images into
 * SDL_Surfaces or SDL_Textures.
 *
 * \param flags initialization flags, OR'd together.
 * \returns all currently initialized flags.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_Quit
 *)
  IMG_Init: function(flags: Integer): Integer; cdecl;

(**
 * Deinitialize SDL_image.
 *
 * This should be the last function you call in SDL_image, after freeing all
 * other resources. This will unload any shared libraries it is using for
 * various codecs.
 *
 * After this call, a call to IMG_Init(0) will return 0 (no codecs loaded).
 *
 * You can safely call IMG_Init() to reload various codec support after this
 * call.
 *
 * Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a
 * single call to IMG_Quit() will deinitialize everything and does not have to
 * be paired with a matching IMG_Init call. For that reason, it's considered
 * best practices to have a single IMG_Init and IMG_Quit call in your program.
 * While this isn't required, be aware of the risks of deviating from that
 * behavior.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_Init
 *)
  IMG_Quit: procedure(); cdecl;

(**
 * Load an image from an SDL data source into a software surface.
 *
 * An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use
 * this if you plan to hand the data to something else or manipulate it
 * further in code.
 *
 * There are no guarantees about what format the new SDL_Surface data will be;
 * in many cases, SDL_image will attempt to supply a surface that exactly
 * matches the provided image, but in others it might have to convert (either
 * because the image is in a format that SDL doesn't directly support or
 * because it's compressed data that could reasonably uncompress to various
 * formats and SDL_image had to pick one). You can inspect an SDL_Surface for
 * its specifics, and use SDL_ConvertSurface to then migrate to any supported
 * format.
 *
 * If the image format supports a transparent pixel, SDL will set the colorkey
 * for the surface. You can enable RLE acceleration on the surface afterwards
 * by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_image reads everything it needs
 * from the RWops during this call in any case.
 *
 * Even though this function accepts a file type, SDL_image may still try
 * other decoders that are capable of detecting file type from the contents of
 * the image data, but may rely on the caller-provided type string for formats
 * that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on
 * its ability to guess the format.
 *
 * There is a separate function to read files from disk without having to deal
 * with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and
 * manage those details for you, determining the file type from the filename's
 * extension.
 *
 * There is also IMG_Load_RW(), which is equivalent to this function except
 * that it will rely on SDL_image to determine what type of data it is
 * loading, much like passing a NULL for type.
 *
 * If you are using SDL's 2D rendering API, there is an equivalent call to
 * load images directly into an SDL_Texture for use by the GPU without using a
 * software surface: call IMG_LoadTextureTyped_RW() instead.
 *
 * When done with the returned surface, the app should dispose of it with a
 * call to SDL_FreeSurface().
 *
 * \param src an SDL_RWops that data will be read from.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \param type a filename extension that represent this data ("BMP", "GIF",
 *             "PNG", etc).
 * \returns a new SDL surface, or NULL on error.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_Load
 * \sa IMG_Load_RW
 * \sa SDL_FreeSurface
 *)
  IMG_LoadTyped_RW: function(src: PSDL_RWops; freesrc: Integer; const type_: PUTF8Char): PSDL_Surface; cdecl;

(**
 * Load an image from a filesystem path into a software surface.
 *
 * An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use
 * this if you plan to hand the data to something else or manipulate it
 * further in code.
 *
 * There are no guarantees about what format the new SDL_Surface data will be;
 * in many cases, SDL_image will attempt to supply a surface that exactly
 * matches the provided image, but in others it might have to convert (either
 * because the image is in a format that SDL doesn't directly support or
 * because it's compressed data that could reasonably uncompress to various
 * formats and SDL_image had to pick one). You can inspect an SDL_Surface for
 * its specifics, and use SDL_ConvertSurface to then migrate to any supported
 * format.
 *
 * If the image format supports a transparent pixel, SDL will set the colorkey
 * for the surface. You can enable RLE acceleration on the surface afterwards
 * by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);
 *
 * There is a separate function to read files from an SDL_RWops, if you need
 * an i/o abstraction to provide data from anywhere instead of a simple
 * filesystem read; that function is IMG_Load_RW().
 *
 * If you are using SDL's 2D rendering API, there is an equivalent call to
 * load images directly into an SDL_Texture for use by the GPU without using a
 * software surface: call IMG_LoadTexture() instead.
 *
 * When done with the returned surface, the app should dispose of it with a
 * call to SDL_FreeSurface().
 *
 * \param file a path on the filesystem to load an image from.
 * \returns a new SDL surface, or NULL on error.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadTyped_RW
 * \sa IMG_Load_RW
 * \sa SDL_FreeSurface
 *)
  IMG_Load: function(const file_: PUTF8Char): PSDL_Surface; cdecl;

(**
 * Load an image from an SDL data source into a software surface.
 *
 * An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use
 * this if you plan to hand the data to something else or manipulate it
 * further in code.
 *
 * There are no guarantees about what format the new SDL_Surface data will be;
 * in many cases, SDL_image will attempt to supply a surface that exactly
 * matches the provided image, but in others it might have to convert (either
 * because the image is in a format that SDL doesn't directly support or
 * because it's compressed data that could reasonably uncompress to various
 * formats and SDL_image had to pick one). You can inspect an SDL_Surface for
 * its specifics, and use SDL_ConvertSurface to then migrate to any supported
 * format.
 *
 * If the image format supports a transparent pixel, SDL will set the colorkey
 * for the surface. You can enable RLE acceleration on the surface afterwards
 * by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_image reads everything it needs
 * from the RWops during this call in any case.
 *
 * There is a separate function to read files from disk without having to deal
 * with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and
 * manage those details for you, determining the file type from the filename's
 * extension.
 *
 * There is also IMG_LoadTyped_RW(), which is equivalent to this function
 * except a file extension (like "BMP", "JPG", etc) can be specified, in case
 * SDL_image cannot autodetect the file format.
 *
 * If you are using SDL's 2D rendering API, there is an equivalent call to
 * load images directly into an SDL_Texture for use by the GPU without using a
 * software surface: call IMG_LoadTexture_RW() instead.
 *
 * When done with the returned surface, the app should dispose of it with a
 * call to SDL_FreeSurface().
 *
 * \param src an SDL_RWops that data will be read from.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \returns a new SDL surface, or NULL on error.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_Load
 * \sa IMG_LoadTyped_RW
 * \sa SDL_FreeSurface
 *)
  IMG_Load_RW: function(src: PSDL_RWops; freesrc: Integer): PSDL_Surface; cdecl;

(**
 * Load an image from a filesystem path into a GPU texture.
 *
 * An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render
 * API. This can be significantly more efficient than using a CPU-bound
 * SDL_Surface if you don't need to manipulate the image directly after
 * loading it.
 *
 * If the loaded image has transparency or a colorkey, a texture with an alpha
 * channel will be created. Otherwise, SDL_image will attempt to create an
 * SDL_Texture in the most format that most reasonably represents the image
 * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
 * RGBA).
 *
 * There is a separate function to read files from an SDL_RWops, if you need
 * an i/o abstraction to provide data from anywhere instead of a simple
 * filesystem read; that function is IMG_LoadTexture_RW().
 *
 * If you would rather decode an image to an SDL_Surface (a buffer of pixels
 * in CPU memory), call IMG_Load() instead.
 *
 * When done with the returned texture, the app should dispose of it with a
 * call to SDL_DestroyTexture().
 *
 * \param renderer the SDL_Renderer to use to create the GPU texture.
 * \param file a path on the filesystem to load an image from.
 * \returns a new texture, or NULL on error.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadTextureTyped_RW
 * \sa IMG_LoadTexture_RW
 * \sa [SDL_DestroyTexture](https://wiki.libsdl.org/SDL_DestroyTexture)
 *)
  IMG_LoadTexture: function(renderer: PSDL_Renderer; const file_: PUTF8Char): PSDL_Texture; cdecl;

(**
 * Load an image from an SDL data source into a GPU texture.
 *
 * An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render
 * API. This can be significantly more efficient than using a CPU-bound
 * SDL_Surface if you don't need to manipulate the image directly after
 * loading it.
 *
 * If the loaded image has transparency or a colorkey, a texture with an alpha
 * channel will be created. Otherwise, SDL_image will attempt to create an
 * SDL_Texture in the most format that most reasonably represents the image
 * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
 * RGBA).
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_image reads everything it needs
 * from the RWops during this call in any case.
 *
 * There is a separate function to read files from disk without having to deal
 * with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this
 * function and manage those details for you, determining the file type from
 * the filename's extension.
 *
 * There is also IMG_LoadTextureTyped_RW(), which is equivalent to this
 * function except a file extension (like "BMP", "JPG", etc) can be specified,
 * in case SDL_image cannot autodetect the file format.
 *
 * If you would rather decode an image to an SDL_Surface (a buffer of pixels
 * in CPU memory), call IMG_Load() instead.
 *
 * When done with the returned texture, the app should dispose of it with a
 * call to SDL_DestroyTexture().
 *
 * \param renderer the SDL_Renderer to use to create the GPU texture.
 * \param src an SDL_RWops that data will be read from.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \returns a new texture, or NULL on error.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadTexture
 * \sa IMG_LoadTextureTyped_RW
 * \sa SDL_DestroyTexture
 *)
  IMG_LoadTexture_RW: function(renderer: PSDL_Renderer; src: PSDL_RWops; freesrc: Integer): PSDL_Texture; cdecl;

(**
 * Load an image from an SDL data source into a GPU texture.
 *
 * An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render
 * API. This can be significantly more efficient than using a CPU-bound
 * SDL_Surface if you don't need to manipulate the image directly after
 * loading it.
 *
 * If the loaded image has transparency or a colorkey, a texture with an alpha
 * channel will be created. Otherwise, SDL_image will attempt to create an
 * SDL_Texture in the most format that most reasonably represents the image
 * data (but in many cases, this will just end up being 32-bit RGB or 32-bit
 * RGBA).
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_image reads everything it needs
 * from the RWops during this call in any case.
 *
 * Even though this function accepts a file type, SDL_image may still try
 * other decoders that are capable of detecting file type from the contents of
 * the image data, but may rely on the caller-provided type string for formats
 * that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on
 * its ability to guess the format.
 *
 * There is a separate function to read files from disk without having to deal
 * with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function
 * and manage those details for you, determining the file type from the
 * filename's extension.
 *
 * There is also IMG_LoadTexture_RW(), which is equivalent to this function
 * except that it will rely on SDL_image to determine what type of data it is
 * loading, much like passing a NULL for type.
 *
 * If you would rather decode an image to an SDL_Surface (a buffer of pixels
 * in CPU memory), call IMG_LoadTyped_RW() instead.
 *
 * When done with the returned texture, the app should dispose of it with a
 * call to SDL_DestroyTexture().
 *
 * \param renderer the SDL_Renderer to use to create the GPU texture.
 * \param src an SDL_RWops that data will be read from.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \param type a filename extension that represent this data ("BMP", "GIF",
 *             "PNG", etc).
 * \returns a new texture, or NULL on error.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadTexture
 * \sa IMG_LoadTexture_RW
 * \sa SDL_DestroyTexture
 *)
  IMG_LoadTextureTyped_RW: function(renderer: PSDL_Renderer; src: PSDL_RWops; freesrc: Integer; const type_: PUTF8Char): PSDL_Texture; cdecl;

(**
 * Detect AVIF image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is AVIF data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isAVIF: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect ICO image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is ICO data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isICO: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect CUR image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is CUR data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isCUR: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect BMP image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is BMP data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isBMP: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect GIF image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is GIF data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isGIF: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect JPG image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is JPG data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isJPG: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect JXL image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is JXL data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isJXL: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect LBM image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is LBM data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isLBM: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect PCX image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is PCX data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isPCX: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect PNG image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is PNG data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isPNG: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect PNM image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is PNM data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isPNM: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect SVG image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is SVG data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.2.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isSVG: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect QOI image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is QOI data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isQOI: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect TIFF image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is TIFF data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isTIF: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect XCF image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is XCF data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isXCF: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect XPM image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is XPM data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXV
 * \sa IMG_isWEBP
 *)
  IMG_isXPM: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect XV image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is XV data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isWEBP
 *)
  IMG_isXV: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Detect WEBP image data on a readable/seekable SDL_RWops.
 *
 * This function attempts to determine if a file is a given filetype, reading
 * the least amount possible from the SDL_RWops (usually a few bytes).
 *
 * There is no distinction made between "not the filetype in question" and
 * basic i/o errors.
 *
 * This function will always attempt to seek the RWops back to where it
 * started when this function was called, but it will not report any errors in
 * doing so, but assuming seeking works, this means you can immediately use
 * this with a different IMG_isTYPE function, or load the image without
 * further seeking.
 *
 * You do not need to call this function to load data; SDL_image can work to
 * determine file type in many cases in its standard load functions.
 *
 * \param src a seekable/readable SDL_RWops to provide image data.
 * \returns non-zero if this is WEBP data, zero otherwise.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_isAVIF
 * \sa IMG_isICO
 * \sa IMG_isCUR
 * \sa IMG_isBMP
 * \sa IMG_isGIF
 * \sa IMG_isJPG
 * \sa IMG_isJXL
 * \sa IMG_isLBM
 * \sa IMG_isPCX
 * \sa IMG_isPNG
 * \sa IMG_isPNM
 * \sa IMG_isSVG
 * \sa IMG_isQOI
 * \sa IMG_isTIF
 * \sa IMG_isXCF
 * \sa IMG_isXPM
 * \sa IMG_isXV
 *)
  IMG_isWEBP: function(src: PSDL_RWops): Integer; cdecl;

(**
 * Load a AVIF image directly.
 *
 * If you know you definitely have a AVIF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadAVIF_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a ICO image directly.
 *
 * If you know you definitely have a ICO image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadICO_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a CUR image directly.
 *
 * If you know you definitely have a CUR image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadCUR_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a BMP image directly.
 *
 * If you know you definitely have a BMP image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadBMP_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a GIF image directly.
 *
 * If you know you definitely have a GIF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadGIF_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a JPG image directly.
 *
 * If you know you definitely have a JPG image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadJPG_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a JXL image directly.
 *
 * If you know you definitely have a JXL image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadJXL_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a LBM image directly.
 *
 * If you know you definitely have a LBM image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadLBM_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a PCX image directly.
 *
 * If you know you definitely have a PCX image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadPCX_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a PNG image directly.
 *
 * If you know you definitely have a PNG image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadPNG_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a PNM image directly.
 *
 * If you know you definitely have a PNM image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadPNM_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a SVG image directly.
 *
 * If you know you definitely have a SVG image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.2.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadSVG_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a QOI image directly.
 *
 * If you know you definitely have a QOI image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadQOI_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a TGA image directly.
 *
 * If you know you definitely have a TGA image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadTGA_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a TIFF image directly.
 *
 * If you know you definitely have a TIFF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadTIF_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a XCF image directly.
 *
 * If you know you definitely have a XCF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadXCF_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a XPM image directly.
 *
 * If you know you definitely have a XPM image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXV_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadXPM_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a XV image directly.
 *
 * If you know you definitely have a XV image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadWEBP_RW
 *)
  IMG_LoadXV_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load a WEBP image directly.
 *
 * If you know you definitely have a WEBP image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops to load image data from.
 * \returns SDL surface, or NULL on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_LoadAVIF_RW
 * \sa IMG_LoadICO_RW
 * \sa IMG_LoadCUR_RW
 * \sa IMG_LoadBMP_RW
 * \sa IMG_LoadGIF_RW
 * \sa IMG_LoadJPG_RW
 * \sa IMG_LoadJXL_RW
 * \sa IMG_LoadLBM_RW
 * \sa IMG_LoadPCX_RW
 * \sa IMG_LoadPNG_RW
 * \sa IMG_LoadPNM_RW
 * \sa IMG_LoadSVG_RW
 * \sa IMG_LoadQOI_RW
 * \sa IMG_LoadTGA_RW
 * \sa IMG_LoadTIF_RW
 * \sa IMG_LoadXCF_RW
 * \sa IMG_LoadXPM_RW
 * \sa IMG_LoadXV_RW
 *)
  IMG_LoadWEBP_RW: function(src: PSDL_RWops): PSDL_Surface; cdecl;

(**
 * Load an SVG image, scaled to a specific size.
 *
 * Since SVG files are resolution-independent, you specify the size you would
 * like the output image to be and it will be generated at those dimensions.
 *
 * Either width or height may be 0 and the image will be auto-sized to
 * preserve aspect ratio.
 *
 * When done with the returned surface, the app should dispose of it with a
 * call to SDL_FreeSurface().
 *
 * \param src an SDL_RWops to load SVG data from.
 * \param width desired width of the generated surface, in pixels.
 * \param height desired height of the generated surface, in pixels.
 * \returns a new SDL surface, or NULL on error.
 *
 * \since This function is available since SDL_image 2.6.0.
 *)
  IMG_LoadSizedSVG_RW: function(src: PSDL_RWops; width: Integer; height: Integer): PSDL_Surface; cdecl;

(**
 * Load an XPM image from a memory array.
 *
 * The returned surface will be an 8bpp indexed surface, if possible,
 * otherwise it will be 32bpp. If you always want 32-bit data, use
 * IMG_ReadXPMFromArrayToRGB888() instead.
 *
 * When done with the returned surface, the app should dispose of it with a
 * call to SDL_FreeSurface().
 *
 * \param xpm a null-terminated array of strings that comprise XPM data.
 * \returns a new SDL surface, or NULL on error.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_ReadXPMFromArrayToRGB888
 *)
  IMG_ReadXPMFromArray: function(xpm: PPUTF8Char): PSDL_Surface; cdecl;

(**
 * Load an XPM image from a memory array.
 *
 * The returned surface will always be a 32-bit RGB surface. If you want 8-bit
 * indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()
 * instead.
 *
 * When done with the returned surface, the app should dispose of it with a
 * call to SDL_FreeSurface().
 *
 * \param xpm a null-terminated array of strings that comprise XPM data.
 * \returns a new SDL surface, or NULL on error.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_ReadXPMFromArray
 *)
  IMG_ReadXPMFromArrayToRGB888: function(xpm: PPUTF8Char): PSDL_Surface; cdecl;

(**
 * Save an SDL_Surface into a PNG image file.
 *
 * If the file already exists, it will be overwritten.
 *
 * \param surface the SDL surface to save
 * \param file path on the filesystem to write new file to.
 * \returns 0 if successful, -1 on error
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_SavePNG_RW
 * \sa IMG_SaveJPG
 * \sa IMG_SaveJPG_RW
 *)
  IMG_SavePNG: function(surface: PSDL_Surface; const file_: PUTF8Char): Integer; cdecl;

(**
 * Save an SDL_Surface into PNG image data, via an SDL_RWops.
 *
 * If you just want to save to a filename, you can use IMG_SavePNG() instead.
 *
 * \param surface the SDL surface to save
 * \param dst the SDL_RWops to save the image data to.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_image 2.0.0.
 *
 * \sa IMG_SavePNG
 * \sa IMG_SaveJPG
 * \sa IMG_SaveJPG_RW
 *)
  IMG_SavePNG_RW: function(surface: PSDL_Surface; dst: PSDL_RWops; freedst: Integer): Integer; cdecl;

(**
 * Save an SDL_Surface into a JPEG image file.
 *
 * If the file already exists, it will be overwritten.
 *
 * \param surface the SDL surface to save
 * \param file path on the filesystem to write new file to.
 * \param quality [0; 33] is Lowest quality, [34; 66] is Middle quality, [67;
 *                100] is Highest quality
 * \returns 0 if successful, -1 on error
 *
 * \since This function is available since SDL_image 2.0.2.
 *
 * \sa IMG_SaveJPG_RW
 * \sa IMG_SavePNG
 * \sa IMG_SavePNG_RW
 *)
  IMG_SaveJPG: function(surface: PSDL_Surface; const file_: PUTF8Char; quality: Integer): Integer; cdecl;

(**
 * Save an SDL_Surface into JPEG image data, via an SDL_RWops.
 *
 * If you just want to save to a filename, you can use IMG_SaveJPG() instead.
 *
 * \param surface the SDL surface to save
 * \param dst the SDL_RWops to save the image data to.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_image 2.0.2.
 *
 * \sa IMG_SaveJPG
 * \sa IMG_SavePNG
 * \sa IMG_SavePNG_RW
 *)
  IMG_SaveJPG_RW: function(surface: PSDL_Surface; dst: PSDL_RWops; freedst: Integer; quality: Integer): Integer; cdecl;

(**
 * Load an animation from a file.
 *
 * When done with the returned animation, the app should dispose of it with a
 * call to IMG_FreeAnimation().
 *
 * \param file path on the filesystem containing an animated image.
 * \returns a new IMG_Animation, or NULL on error.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_FreeAnimation
 *)
  IMG_LoadAnimation: function(const file_: PUTF8Char): PIMG_Animation; cdecl;

(**
 * Load an animation from an SDL_RWops.
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_image reads everything it needs
 * from the RWops during this call in any case.
 *
 * When done with the returned animation, the app should dispose of it with a
 * call to IMG_FreeAnimation().
 *
 * \param src an SDL_RWops that data will be read from.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \returns a new IMG_Animation, or NULL on error.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_FreeAnimation
 *)
  IMG_LoadAnimation_RW: function(src: PSDL_RWops; freesrc: Integer): PIMG_Animation; cdecl;

(**
 * Load an animation from an SDL datasource
 *
 * Even though this function accepts a file type, SDL_image may still try
 * other decoders that are capable of detecting file type from the contents of
 * the image data, but may rely on the caller-provided type string for formats
 * that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on
 * its ability to guess the format.
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_image reads everything it needs
 * from the RWops during this call in any case.
 *
 * When done with the returned animation, the app should dispose of it with a
 * call to IMG_FreeAnimation().
 *
 * \param src an SDL_RWops that data will be read from.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \param type a filename extension that represent this data ("GIF", etc).
 * \returns a new IMG_Animation, or NULL on error.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_LoadAnimation
 * \sa IMG_LoadAnimation_RW
 * \sa IMG_FreeAnimation
 *)
  IMG_LoadAnimationTyped_RW: function(src: PSDL_RWops; freesrc: Integer; const type_: PUTF8Char): PIMG_Animation; cdecl;

(**
 * Dispose of an IMG_Animation and free its resources.
 *
 * The provided `anim` pointer is not valid once this call returns.
 *
 * \param anim IMG_Animation to dispose of.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_LoadAnimation
 * \sa IMG_LoadAnimation_RW
 * \sa IMG_LoadAnimationTyped_RW
 *)
  IMG_FreeAnimation: procedure(anim: PIMG_Animation); cdecl;

(**
 * Load a GIF animation directly.
 *
 * If you know you definitely have a GIF image, you can call this function,
 * which will skip SDL_image's file format detection routines. Generally it's
 * better to use the abstract interfaces; also, there is only an SDL_RWops
 * interface available here.
 *
 * \param src an SDL_RWops that data will be read from.
 * \returns a new IMG_Animation, or NULL on error.
 *
 * \since This function is available since SDL_image 2.6.0.
 *
 * \sa IMG_LoadAnimation
 * \sa IMG_LoadAnimation_RW
 * \sa IMG_LoadAnimationTyped_RW
 * \sa IMG_FreeAnimation
 *)
  IMG_LoadGIFAnimation_RW: function(src: PSDL_RWops): PIMG_Animation; cdecl;

(**
 * Query the version of SDL_mixer that the program is linked against.
 *
 * This function gets the version of the dynamically linked SDL_mixer library.
 * This is separate from the SDL_MIXER_VERSION() macro, which tells you what
 * version of the SDL_mixer headers you compiled against.
 *
 * This returns static internal data; do not free or modify it!
 *
 * \returns a pointer to the version information.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_Linked_Version: function(): PSDL_version; cdecl;

(**
 * Initialize SDL_mixer.
 *
 * This function loads dynamic libraries that SDL_mixer needs, and prepares
 * them for use. This must be the first function you call in SDL_mixer, and if
 * it fails you should not continue with the library.
 *
 * Flags should be one or more flags from MIX_InitFlags OR'd together. It
 * returns the flags successfully initialized, or 0 on failure.
 *
 * Currently, these flags are:
 *
 * - `MIX_INIT_FLAC`
 * - `MIX_INIT_MOD`
 * - `MIX_INIT_MP3`
 * - `MIX_INIT_OGG`
 * - `MIX_INIT_MID`
 * - `MIX_INIT_OPUS`
 *
 * More flags may be added in a future SDL_mixer release.
 *
 * This function may need to load external shared libraries to support various
 * codecs, which means this function can fail to initialize that support on an
 * otherwise-reasonable system if the library isn't available; this is not
 * just a question of exceptional circumstances like running out of memory at
 * startup!
 *
 * Note that you may call this function more than once to initialize with
 * additional flags. The return value will reflect both new flags that
 * successfully initialized, and also include flags that had previously been
 * initialized as well.
 *
 * As this will return previously-initialized flags, it's legal to call this
 * with zero (no flags set). This is a safe no-op that can be used to query
 * the current initialization state without changing it at all.
 *
 * Since this returns previously-initialized flags as well as new ones, and
 * you can call this with zero, you should not check for a zero return value
 * to determine an error condition. Instead, you should check to make sure all
 * the flags you require are set in the return value. If you have a game with
 * data in a specific format, this might be a fatal error. If you're a generic
 * media player, perhaps you are fine with only having WAV and MP3 support and
 * can live without Opus playback, even if you request support for everything.
 *
 * Unlike other SDL satellite libraries, calls to Mix_Init do not stack; a
 * single call to Mix_Quit() will deinitialize everything and does not have to
 * be paired with a matching Mix_Init call. For that reason, it's considered
 * best practices to have a single Mix_Init and Mix_Quit call in your program.
 * While this isn't required, be aware of the risks of deviating from that
 * behavior.
 *
 * After initializing SDL_mixer, the next step is to open an audio device to
 * prepare to play sound (with Mix_OpenAudio() or Mix_OpenAudioDevice()), and
 * load audio data to play with that device.
 *
 * \param flags initialization flags, OR'd together.
 * \returns all currently initialized flags.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_Quit
 *)
  Mix_Init: function(flags: Integer): Integer; cdecl;

(**
 * Deinitialize SDL_mixer.
 *
 * This should be the last function you call in SDL_mixer, after freeing all
 * other resources and closing all audio devices. This will unload any shared
 * libraries it is using for various codecs.
 *
 * After this call, a call to Mix_Init(0) will return 0 (no codecs loaded).
 *
 * You can safely call Mix_Init() to reload various codec support after this
 * call.
 *
 * Unlike other SDL satellite libraries, calls to Mix_Init do not stack; a
 * single call to Mix_Quit() will deinitialize everything and does not have to
 * be paired with a matching Mix_Init call. For that reason, it's considered
 * best practices to have a single Mix_Init and Mix_Quit call in your program.
 * While this isn't required, be aware of the risks of deviating from that
 * behavior.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_Init
 *)
  Mix_Quit: procedure(); cdecl;

(**
 * Open the default audio device for playback.
 *
 * An audio device is what generates sound, so the app must open one to make
 * noise.
 *
 * This function will check if SDL's audio system is initialized, and if not,
 * it will initialize it by calling `SDL_Init(SDL_INIT_AUDIO)` on your behalf.
 * You are free to (and encouraged to!) initialize it yourself before calling
 * this function, as this gives your program more control over the process.
 *
 * This function might cover all of an application's needs, but for those that
 * need more flexibility, the more powerful version of this function is
 * Mix_OpenAudioDevice(). This function is equivalent to calling:
 *
 * ```c
 * Mix_OpenAudioDevice(frequency, format, nchannels, chunksize, NULL,
 *                     SDL_AUDIO_ALLOW_FREQUENCY_CHANGE |
 *                     SDL_AUDIO_ALLOW_CHANNELS_CHANGE);
 * ```
 *
 * If you aren't particularly concerned with the specifics of the audio
 * device, and your data isn't in a specific format, the values you use here
 * can just be reasonable defaults. SDL_mixer will convert audio data you feed
 * it to the correct format on demand.
 *
 * That being said, if you have control of your audio data and you know its
 * format ahead of time, you can save CPU time by opening the audio device in
 * that exact format so SDL_mixer does not have to spend time converting
 * anything behind the scenes, and can just pass the data straight through to
 * the hardware. On some platforms, where the hardware only supports specific
 * settings, you might have to be careful to make everything match, but your
 * own data is often easier to control, so aim to open the device for what you
 * need.
 *
 * The other reason to care about specific formats: if you plan to touch the
 * mix buffer directly (with Mix_SetPostMix, a registered effect, or
 * Mix_HookMusic), you might have code that expects it to be in a specific
 * format, and you should specify that here.
 *
 * The audio device frequency is specified in Hz; in modern times, 48000 is
 * often a reasonable default.
 *
 * The audio device format is one of SDL's AUDIO_* constants. AUDIO_S16SYS
 * (16-bit audio) is probably a safe default. More modern systems may prefer
 * AUDIO_F32SYS (32-bit floating point audio).
 *
 * The audio device channels are generally 1 for mono output, or 2 for stereo,
 * but the brave can try surround sound configs with 4 (quad), 6 (5.1), 7
 * (6.1) or 8 (7.1).
 *
 * The audio device's chunk size is the number of sample frames (one sample
 * per frame for mono output, two samples per frame in a stereo setup, etc)
 * that are fed to the device at once. The lower the number, the lower the
 * latency, but you risk dropouts if it gets too low. 2048 is often a
 * reasonable default, but your app might want to experiment with 1024 or
 * 4096.
 *
 * You may only have one audio device open at a time; if you want to change a
 * setting, you must close the device and reopen it, which is not something
 * you can do seamlessly during playback.
 *
 * This function does not allow you to select a specific audio device on the
 * system, it always chooses the best default it can on your behalf (which, in
 * many cases, is exactly what you want anyhow). If you must choose a specific
 * device, you can do so with Mix_OpenAudioDevice() instead.
 *
 * If this function reports success, you are ready to start making noise! Load
 * some audio data and start playing!
 *
 * The app can use Mix_QuerySpec() to determine the final device settings.
 *
 * When done with an audio device, probably at the end of the program, the app
 * should dispose of the device with Mix_CloseDevice().
 *
 * \param frequency the frequency to playback audio at (in Hz).
 * \param format audio format, one of SDL's AUDIO_* values.
 * \param channels number of channels (1 is mono, 2 is stereo, etc).
 * \param chunksize audio buffer size in sample FRAMES (total samples divided
 *                  by channel count).
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_OpenAudioDevice
 * \sa Mix_CloseDevice
 *)
  Mix_OpenAudio: function(frequency: Integer; format: Uint16; channels: Integer; chunksize: Integer): Integer; cdecl;

(**
 * Open a specific audio device for playback.
 *
 * (A slightly simpler version of this function is available in
 * Mix_OpenAudio(), which still might meet most applications' needs.)
 *
 * An audio device is what generates sound, so the app must open one to make
 * noise.
 *
 * This function will check if SDL's audio system is initialized, and if not,
 * it will initialize it by calling `SDL_Init(SDL_INIT_AUDIO)` on your behalf.
 * You are free to (and encouraged to!) initialize it yourself before calling
 * this function, as this gives your program more control over the process.
 *
 * If you aren't particularly concerned with the specifics of the audio
 * device, and your data isn't in a specific format, the values you use here
 * can just be reasonable defaults. SDL_mixer will convert audio data you feed
 * it to the correct format on demand.
 *
 * That being said, if you have control of your audio data and you know its
 * format ahead of time, you can save CPU time by opening the audio device in
 * that exact format so SDL_mixer does not have to spend time converting
 * anything behind the scenes, and can just pass the data straight through to
 * the hardware. On some platforms, where the hardware only supports specific
 * settings, you might have to be careful to make everything match, but your
 * own data is often easier to control, so aim to open the device for what you
 * need.
 *
 * The other reason to care about specific formats: if you plan to touch the
 * mix buffer directly (with Mix_SetPostMix, a registered effect, or
 * Mix_HookMusic), you might have code that expects it to be in a specific
 * format, and you should specify that here.
 *
 * The audio device frequency is specified in Hz; in modern times, 48000 is
 * often a reasonable default.
 *
 * The audio device format is one of SDL's AUDIO_* constants. AUDIO_S16SYS
 * (16-bit audio) is probably a safe default. More modern systems may prefer
 * AUDIO_F32SYS (32-bit floating point audio).
 *
 * The audio device channels are generally 1 for mono output, or 2 for stereo,
 * but the brave can try surround sound configs with 4 (quad), 6 (5.1), 7
 * (6.1) or 8 (7.1).
 *
 * The audio device's chunk size is the number of sample frames (one sample
 * per frame for mono output, two samples per frame in a stereo setup, etc)
 * that are fed to the device at once. The lower the number, the lower the
 * latency, but you risk dropouts if it gets too low. 2048 is often a
 * reasonable default, but your app might want to experiment with 1024 or
 * 4096.
 *
 * You may only have one audio device open at a time; if you want to change a
 * setting, you must close the device and reopen it, which is not something
 * you can do seamlessly during playback.
 *
 * This function allows you to select specific audio hardware on the system
 * with the `device` parameter. If you specify NULL, SDL_mixer will choose the
 * best default it can on your behalf (which, in many cases, is exactly what
 * you want anyhow). SDL_mixer does not offer a mechanism to determine device
 * names to open, but you can use SDL_GetNumAudioDevices() to get a count of
 * available devices and then SDL_GetAudioDeviceName() in a loop to obtain a
 * list. If you do this, be sure to call `SDL_Init(SDL_INIT_AUDIO)` first to
 * initialize SDL's audio system!
 *
 * The `allowed_changes` parameter specifies what settings are flexible. These
 * are the `SDL_AUDIO_ALLOW_*` flags from SDL. These tell SDL_mixer that the
 * app doesn't mind if a specific setting changes. For example, the app might
 * need stereo data in Sint16 format, but if the sample rate or chunk size
 * changes, the app can handle that. In that case, the app would specify
 * `SDL_AUDIO_ALLOW_FORMAT_CHANGE|SDL_AUDIO_ALLOW_SAMPLES_CHANGE`. In this
 * case, if the system's hardware requires something other than the requested
 * format, SDL_mixer can select what the hardware demands instead of the app.
 * If the `SDL_AUDIO_ALLOW_` flag is not specified, SDL_mixer must convert
 * data behind the scenes between what the app demands and what the hardware
 * requires. If your app needs precisely what is requested, specify zero for
 * `allowed_changes`.
 *
 * If changes were allowed, the app can use Mix_QuerySpec() to determine the
 * final device settings.
 *
 * If this function reports success, you are ready to start making noise! Load
 * some audio data and start playing!
 *
 * When done with an audio device, probably at the end of the program, the app
 * should dispose of the device with Mix_CloseDevice().
 *
 * \param frequency the frequency to playback audio at (in Hz).
 * \param format audio format, one of SDL's AUDIO_* values.
 * \param channels number of channels (1 is mono, 2 is stereo, etc).
 * \param chunksize audio buffer size in sample FRAMES (total samples divided
 *                  by channel count).
 * \param device the device name to open, or NULL to choose a reasonable
 *               default.
 * \param allowed_changes Allow change flags (see SDL_AUDIO_ALLOW_* flags)
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_mixer 2.0.2.
 *
 * \sa Mix_OpenAudio
 * \sa Mix_CloseDevice
 * \sa Mix_QuerySpec
 *)
  Mix_OpenAudioDevice: function(frequency: Integer; format: Uint16; channels: Integer; chunksize: Integer; const device: PUTF8Char; allowed_changes: Integer): Integer; cdecl;

(**
 * Find out what the actual audio device parameters are.
 *
 * If Mix_OpenAudioDevice() was called with `allowed_changes` set to anything
 * but zero, or Mix_OpenAudio() was used, some audio device settings may be
 * different from the application's request. This function will report what
 * the device is actually running at.
 *
 * Note this is only important if the app intends to touch the audio buffers
 * being sent to the hardware directly. If an app just wants to play audio
 * files and let SDL_mixer handle the low-level details, this function can
 * probably be ignored.
 *
 * If the audio device is not opened, this function will return 0.
 *
 * \param frequency On return, will be filled with the audio device's
 *                  frequency in Hz.
 * \param format On return, will be filled with the audio device's format.
 * \param channels On return, will be filled with the audio device's channel
 *                 count.
 * \returns 1 if the audio device has been opened, 0 otherwise.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_OpenAudio
 * \sa Mix_OpenAudioDevice
 *)
  Mix_QuerySpec: function(frequency: PInteger; format: PUint16; channels: PInteger): Integer; cdecl;

(**
 * Dynamically change the number of channels managed by the mixer.
 *
 * SDL_mixer deals with "channels," which is not the same thing as the
 * mono/stereo channels; they might be better described as "tracks," as each
 * one corresponds to a separate source of audio data. Three different WAV
 * files playing at the same time would be three separate SDL_mixer channels,
 * for example.
 *
 * An app needs as many channels as it has audio data it wants to play
 * simultaneously, mixing them into a single stream to send to the audio
 * device.
 *
 * SDL_mixer allocates `MIX_CHANNELS` (currently 8) channels when you open an
 * audio device, which may be more than an app needs, but if the app needs
 * more or wants less, this function can change it.
 *
 * If decreasing the number of channels, any upper channels currently playing
 * are stopped. This will deregister all effects on those channels and call
 * any callback specified by Mix_ChannelFinished() for each removed channel.
 *
 * If `numchans` is less than zero, this will return the current number of
 * channels without changing anything.
 *
 * \param numchans the new number of channels, or < 0 to query current channel
 *                 count.
 * \returns the new number of allocated channels.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_AllocateChannels: function(numchans: Integer): Integer; cdecl;

(**
 * Load a supported audio format into a chunk.
 *
 * SDL_mixer has two separate data structures for audio data. One it calls a
 * "chunk," which is meant to be a file completely decoded into memory up
 * front, and the other it calls "music" which is a file intended to be
 * decoded on demand. Originally, simple formats like uncompressed WAV files
 * were meant to be chunks and compressed things, like MP3s, were meant to be
 * music, and you would stream one thing for a game's music and make repeating
 * sound effects with the chunks.
 *
 * In modern times, this isn't split by format anymore, and most are
 * interchangeable, so the question is what the app thinks is worth
 * predecoding or not. Chunks might take more memory, but once they are loaded
 * won't need to decode again, whereas music always needs to be decoded on the
 * fly. Also, crucially, there are as many channels for chunks as the app can
 * allocate, but SDL_mixer only offers a single "music" channel.
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_mixer reads everything it needs
 * from the RWops during this call in any case.
 *
 * There is a separate function (a macro, before SDL_mixer 2.6.0) to read
 * files from disk without having to deal with SDL_RWops:
 * `Mix_LoadWAV("filename.wav")` will call this function and manage those
 * details for you.
 *
 * When done with a chunk, the app should dispose of it with a call to
 * Mix_FreeChunk().
 *
 * \param src an SDL_RWops that data will be read from.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \returns a new chunk, or NULL on error.
 *
 * \since This function is available since SDL_mixer 2.6.0 (and as a macro
 *        since 2.0.0).
 *
 * \sa Mix_LoadWAV
 * \sa Mix_FreeChunk
 *)
  Mix_LoadWAV_RW: function(src: PSDL_RWops; freesrc: Integer): PMix_Chunk; cdecl;

(**
 * Load a supported audio format into a chunk.
 *
 * SDL_mixer has two separate data structures for audio data. One it calls a
 * "chunk," which is meant to be a file completely decoded into memory up
 * front, and the other it calls "music" which is a file intended to be
 * decoded on demand. Originally, simple formats like uncompressed WAV files
 * were meant to be chunks and compressed things, like MP3s, were meant to be
 * music, and you would stream one thing for a game's music and make repeating
 * sound effects with the chunks.
 *
 * In modern times, this isn't split by format anymore, and most are
 * interchangeable, so the question is what the app thinks is worth
 * predecoding or not. Chunks might take more memory, but once they are loaded
 * won't need to decode again, whereas music always needs to be decoded on the
 * fly. Also, crucially, there are as many channels for chunks as the app can
 * allocate, but SDL_mixer only offers a single "music" channel.
 *
 * If you would rather use the abstract SDL_RWops interface to load data from
 * somewhere other than the filesystem, you can use Mix_LoadWAV_RW() instead.
 *
 * When done with a chunk, the app should dispose of it with a call to
 * Mix_FreeChunk().
 *
 * Note that before SDL_mixer 2.6.0, this function was a macro that called
 * Mix_LoadWAV_RW(), creating a RWops and setting `freesrc` to 1. This macro
 * has since been promoted to a proper API function. Older binaries linked
 * against a newer SDL_mixer will still call Mix_LoadWAV_RW directly, as they
 * are using the macro, which was available since the dawn of time.
 *
 * \param file the filesystem path to load data from.
 * \returns a new chunk, or NULL on error.
 *
 * \since This function is available since SDL_mixer 2.6.0 (and as a macro
 *        since 2.0.0).
 *
 * \sa Mix_LoadWAV_RW
 * \sa Mix_FreeChunk
 *)
  Mix_LoadWAV: function(const file_: PUTF8Char): PMix_Chunk; cdecl;

(**
 * Load a supported audio format into a music object.
 *
 * SDL_mixer has two separate data structures for audio data. One it calls a
 * "chunk," which is meant to be a file completely decoded into memory up
 * front, and the other it calls "music" which is a file intended to be
 * decoded on demand. Originally, simple formats like uncompressed WAV files
 * were meant to be chunks and compressed things, like MP3s, were meant to be
 * music, and you would stream one thing for a game's music and make repeating
 * sound effects with the chunks.
 *
 * In modern times, this isn't split by format anymore, and most are
 * interchangeable, so the question is what the app thinks is worth
 * predecoding or not. Chunks might take more memory, but once they are loaded
 * won't need to decode again, whereas music always needs to be decoded on the
 * fly. Also, crucially, there are as many channels for chunks as the app can
 * allocate, but SDL_mixer only offers a single "music" channel.
 *
 * When done with this music, the app should dispose of it with a call to
 * Mix_FreeMusic().
 *
 * \param file a file path from where to load music data.
 * \returns a new music object, or NULL on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_FreeMusic
 *)
  Mix_LoadMUS: function(const file_: PUTF8Char): PMix_Music; cdecl;

(**
 * Load a supported audio format into a music object.
 *
 * SDL_mixer has two separate data structures for audio data. One it calls a
 * "chunk," which is meant to be a file completely decoded into memory up
 * front, and the other it calls "music" which is a file intended to be
 * decoded on demand. Originally, simple formats like uncompressed WAV files
 * were meant to be chunks and compressed things, like MP3s, were meant to be
 * music, and you would stream one thing for a game's music and make repeating
 * sound effects with the chunks.
 *
 * In modern times, this isn't split by format anymore, and most are
 * interchangeable, so the question is what the app thinks is worth
 * predecoding or not. Chunks might take more memory, but once they are loaded
 * won't need to decode again, whereas music always needs to be decoded on the
 * fly. Also, crucially, there are as many channels for chunks as the app can
 * allocate, but SDL_mixer only offers a single "music" channel.
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_mixer reads everything it needs
 * from the RWops during this call in any case.
 *
 * As a convenience, there is a function to read files from disk without
 * having to deal with SDL_RWops: `Mix_LoadMUS("filename.mp3")` will manage
 * those details for you.
 *
 * This function attempts to guess the file format from incoming data. If the
 * caller knows the format, or wants to force it, it should use
 * Mix_LoadMUSType_RW() instead.
 *
 * When done with this music, the app should dispose of it with a call to
 * Mix_FreeMusic().
 *
 * \param src an SDL_RWops that data will be read from.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \returns a new music object, or NULL on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_FreeMusic
 *)
  Mix_LoadMUS_RW: function(src: PSDL_RWops; freesrc: Integer): PMix_Music; cdecl;

(**
 * Load an audio format into a music object, assuming a specific format.
 *
 * SDL_mixer has two separate data structures for audio data. One it calls a
 * "chunk," which is meant to be a file completely decoded into memory up
 * front, and the other it calls "music" which is a file intended to be
 * decoded on demand. Originally, simple formats like uncompressed WAV files
 * were meant to be chunks and compressed things, like MP3s, were meant to be
 * music, and you would stream one thing for a game's music and make repeating
 * sound effects with the chunks.
 *
 * In modern times, this isn't split by format anymore, and most are
 * interchangeable, so the question is what the app thinks is worth
 * predecoding or not. Chunks might take more memory, but once they are loaded
 * won't need to decode again, whereas music always needs to be decoded on the
 * fly. Also, crucially, there are as many channels for chunks as the app can
 * allocate, but SDL_mixer only offers a single "music" channel.
 *
 * This function loads music data, and lets the application specify the type
 * of music being loaded, which might be useful if SDL_mixer cannot figure it
 * out from the data stream itself.
 *
 * Currently, the following types are supported:
 *
 * - `MUS_NONE` (SDL_mixer should guess, based on the data)
 * - `MUS_WAV` (Microsoft WAV files)
 * - `MUS_MOD` (Various tracker formats)
 * - `MUS_MID` (MIDI files)
 * - `MUS_OGG` (Ogg Vorbis files)
 * - `MUS_MP3` (MP3 files)
 * - `MUS_FLAC` (FLAC files)
 * - `MUS_OPUS` (Opus files)
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_mixer reads everything it needs
 * from the RWops during this call in any case.
 *
 * As a convenience, there is a function to read files from disk without
 * having to deal with SDL_RWops: `Mix_LoadMUS("filename.mp3")` will manage
 * those details for you (but not let you specify the music type explicitly)..
 *
 * When done with this music, the app should dispose of it with a call to
 * Mix_FreeMusic().
 *
 * \param src an SDL_RWops that data will be read from.
 * \param type the type of audio data provided by `src`.
 * \param freesrc non-zero to close/free the SDL_RWops before returning, zero
 *                to leave it open.
 * \returns a new music object, or NULL on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_FreeMusic
 *)
  Mix_LoadMUSType_RW: function(src: PSDL_RWops; type_: Mix_MusicType; freesrc: Integer): PMix_Music; cdecl;

(**
 * Load a WAV file from memory as quickly as possible.
 *
 * Unlike Mix_LoadWAV_RW, this function has several requirements, and unless
 * you control all your audio data and know what you're doing, you should
 * consider this function unsafe and not use it.
 *
 * - The provided audio data MUST be in Microsoft WAV format.
 * - The provided audio data shouldn't use any strange WAV extensions.
 * - The audio data MUST be in the exact same format as the audio device. This
 *   function will not attempt to convert it, or even verify it's in the right
 *   format.
 * - The audio data must be valid; this function does not know the size of the
 *   memory buffer, so if the WAV data is corrupted, it can read past the end
 *   of the buffer, causing a crash.
 * - The audio data must live at least as long as the returned Mix_Chunk,
 *   because SDL_mixer will use that data directly and not make a copy of it.
 *
 * This function will do NO error checking! Be extremely careful here!
 *
 * (Seriously, use Mix_LoadWAV_RW instead.)
 *
 * If this function is successful, the provided memory buffer must remain
 * available until Mix_FreeChunk() is called on the returned chunk.
 *
 * \param mem memory buffer containing of a WAV file.
 * \returns a new chunk, or NULL on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_LoadWAV_RW
 * \sa Mix_FreeChunk
 *)
  Mix_QuickLoad_WAV: function(mem: PUint8): PMix_Chunk; cdecl;

(**
 * Load a raw audio data from memory as quickly as possible.
 *
 * The audio data MUST be in the exact same format as the audio device. This
 * function will not attempt to convert it, or even verify it's in the right
 * format.
 *
 * If this function is successful, the provided memory buffer must remain
 * available until Mix_FreeChunk() is called on the returned chunk.
 *
 * \param mem memory buffer containing raw PCM data.
 * \param len length of buffer pointed to by `mem`, in bytes.
 * \returns a new chunk, or NULL on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_FreeChunk
 *)
  Mix_QuickLoad_RAW: function(mem: PUint8; len: Uint32): PMix_Chunk; cdecl;

(**
 * Free an audio chunk.
 *
 * An app should call this function when it is done with a Mix_Chunk and wants
 * to dispose of its resources.
 *
 * SDL_mixer will stop any channels this chunk is currently playing on. This
 * will deregister all effects on those channels and call any callback
 * specified by Mix_ChannelFinished() for each removed channel.
 *
 * \param chunk the chunk to free.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_LoadWAV
 * \sa Mix_LoadWAV_RW
 * \sa Mix_QuickLoad_WAV
 * \sa Mix_QuickLoad_RAW
 *)
  Mix_FreeChunk: procedure(chunk: PMix_Chunk); cdecl;

(**
 * Free a music object.
 *
 * If this music is currently playing, it will be stopped.
 *
 * If this music is in the process of fading out (via Mix_FadeOutMusic()),
 * this function will *block* until the fade completes. If you need to avoid
 * this, be sure to call Mix_HaltMusic() before freeing the music.
 *
 * \param music the music object to free.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_LoadMUS
 * \sa Mix_LoadMUS_RW
 * \sa Mix_LoadMUSType_RW
 *)
  Mix_FreeMusic: procedure(music: PMix_Music); cdecl;

(**
 * Get a list of chunk decoders that this build of SDL_mixer provides.
 *
 * This list can change between builds AND runs of the program, if external
 * libraries that add functionality become available. You must successfully
 * call Mix_OpenAudio() or Mix_OpenAudioDevice() before calling this function,
 * as decoders are activated at device open time.
 *
 * Appearing in this list doesn't promise your specific audio file will
 * decode...but it's handy to know if you have, say, a functioning Ogg Vorbis
 * install.
 *
 * These return values are static, read-only data; do not modify or free it.
 * The pointers remain valid until you call Mix_CloseAudio().
 *
 * \returns number of chunk decoders available.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_GetChunkDecoder
 * \sa Mix_HasChunkDecoder
 *)
  Mix_GetNumChunkDecoders: function(): Integer; cdecl;

(**
 * Get a chunk decoder's name.
 *
 * The requested decoder's index must be between zero and
 * Mix_GetNumChunkDecoders()-1. It's safe to call this with an invalid index;
 * this function will return NULL in that case.
 *
 * This list can change between builds AND runs of the program, if external
 * libraries that add functionality become available. You must successfully
 * call Mix_OpenAudio() or Mix_OpenAudioDevice() before calling this function,
 * as decoders are activated at device open time.
 *
 * \param index index of the chunk decoder.
 * \returns the chunk decoder's name.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_GetNumChunkDecoders
 *)
  Mix_GetChunkDecoder: function(index: Integer): PUTF8Char; cdecl;

(**
 * Check if a chunk decoder is available by name.
 *
 * This result can change between builds AND runs of the program, if external
 * libraries that add functionality become available. You must successfully
 * call Mix_OpenAudio() or Mix_OpenAudioDevice() before calling this function,
 * as decoders are activated at device open time.
 *
 * Decoder names are arbitrary but also obvious, so you have to know what
 * you're looking for ahead of time, but usually it's the file extension in
 * capital letters (some example names are "AIFF", "VOC", "WAV").
 *
 * \param name the decoder name to query.
 * \returns SDL_TRUE if a decoder by that name is available, SDL_FALSE
 *          otherwise.
 *
 * \since This function is available since SDL_mixer 2.0.2.
 *
 * \sa Mix_GetNumChunkDecoders
 * \sa Mix_GetChunkDecoder
 *)
  Mix_HasChunkDecoder: function(const name: PUTF8Char): SDL_bool; cdecl;

(**
 * Get a list of music decoders that this build of SDL_mixer provides.
 *
 * This list can change between builds AND runs of the program, if external
 * libraries that add functionality become available. You must successfully
 * call Mix_OpenAudio() or Mix_OpenAudioDevice() before calling this function,
 * as decoders are activated at device open time.
 *
 * Appearing in this list doesn't promise your specific audio file will
 * decode...but it's handy to know if you have, say, a functioning Ogg Vorbis
 * install.
 *
 * These return values are static, read-only data; do not modify or free it.
 * The pointers remain valid until you call Mix_CloseAudio().
 *
 * \returns number of chunk decoders available.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_GetMusicDecoder
 * \sa Mix_HasMusicDecoder
 *)
  Mix_GetNumMusicDecoders: function(): Integer; cdecl;

(**
 * Get a music decoder's name.
 *
 * The requested decoder's index must be between zero and
 * Mix_GetNumMusicDecoders()-1. It's safe to call this with an invalid index;
 * this function will return NULL in that case.
 *
 * This list can change between builds AND runs of the program, if external
 * libraries that add functionality become available. You must successfully
 * call Mix_OpenAudio() or Mix_OpenAudioDevice() before calling this function,
 * as decoders are activated at device open time.
 *
 * \param index index of the music decoder.
 * \returns the music decoder's name.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_GetNumMusicDecoders
 *)
  Mix_GetMusicDecoder: function(index: Integer): PUTF8Char; cdecl;

(**
 * Check if a music decoder is available by name.
 *
 * This result can change between builds AND runs of the program, if external
 * libraries that add functionality become available. You must successfully
 * call Mix_OpenAudio() or Mix_OpenAudioDevice() before calling this function,
 * as decoders are activated at device open time.
 *
 * Decoder names are arbitrary but also obvious, so you have to know what
 * you're looking for ahead of time, but usually it's the file extension in
 * capital letters (some example names are "MOD", "MP3", "FLAC").
 *
 * \param name the decoder name to query.
 * \returns SDL_TRUE if a decoder by that name is available, SDL_FALSE
 *          otherwise.
 *
 * \since This function is available since SDL_mixer 2.6.0
 *
 * \sa Mix_GetNumMusicDecoders
 * \sa Mix_GetMusicDecoder
 *)
  Mix_HasMusicDecoder: function(const name: PUTF8Char): SDL_bool; cdecl;

(**
 * Find out the format of a mixer music.
 *
 * If `music` is NULL, this will query the currently playing music (and return
 * MUS_NONE if nothing is currently playing).
 *
 * \param music the music object to query, or NULL for the currently-playing
 *              music.
 * \returns the Mix_MusicType for the music object.
 *
 * \since This function is available since SDL_mixer 2.0.0
 *)
  Mix_GetMusicType: function(const music: PMix_Music): Mix_MusicType; cdecl;

(**
 * Get the title for a music object, or its filename.
 *
 * This returns format-specific metadata. Not all file formats supply this!
 *
 * If `music` is NULL, this will query the currently-playing music.
 *
 * If music's title tag is missing or empty, the filename will be returned. If
 * you'd rather have the actual metadata or nothing, use
 * Mix_GetMusicTitleTag() instead.
 *
 * Please note that if the music was loaded from an SDL_RWops instead of a
 * filename, the filename returned will be an empty string ("").
 *
 * This function never returns NULL! If no data is available, it will return
 * an empty string ("").
 *
 * \param music the music object to query, or NULL for the currently-playing
 *              music.
 * \returns the music's title if available, or the filename if not, or "".
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *
 * \sa Mix_GetMusicTitleTag
 * \sa Mix_GetMusicArtistTag
 * \sa Mix_GetMusicAlbumTag
 * \sa Mix_GetMusicCopyrightTag
 *)
  Mix_GetMusicTitle: function(const music: PMix_Music): PUTF8Char; cdecl;

(**
 * Get the title for a music object.
 *
 * This returns format-specific metadata. Not all file formats supply this!
 *
 * If `music` is NULL, this will query the currently-playing music.
 *
 * Unlike this function, Mix_GetMusicTitle() produce a string with the music's
 * filename if a title isn't available, which might be preferable for some
 * applications.
 *
 * This function never returns NULL! If no data is available, it will return
 * an empty string ("").
 *
 * \param music the music object to query, or NULL for the currently-playing
 *              music.
 * \returns the music's title if available, or "".
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *
 * \sa Mix_GetMusicTitle
 * \sa Mix_GetMusicArtistTag
 * \sa Mix_GetMusicAlbumTag
 * \sa Mix_GetMusicCopyrightTag
 *)
  Mix_GetMusicTitleTag: function(const music: PMix_Music): PUTF8Char; cdecl;

(**
 * Get the artist name for a music object.
 *
 * This returns format-specific metadata. Not all file formats supply this!
 *
 * If `music` is NULL, this will query the currently-playing music.
 *
 * This function never returns NULL! If no data is available, it will return
 * an empty string ("").
 *
 * \param music the music object to query, or NULL for the currently-playing
 *              music.
 * \returns the music's artist name if available, or "".
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *
 * \sa Mix_GetMusicTitleTag
 * \sa Mix_GetMusicAlbumTag
 * \sa Mix_GetMusicCopyrightTag
 *)
  Mix_GetMusicArtistTag: function(const music: PMix_Music): PUTF8Char; cdecl;

(**
 * Get the album name for a music object.
 *
 * This returns format-specific metadata. Not all file formats supply this!
 *
 * If `music` is NULL, this will query the currently-playing music.
 *
 * This function never returns NULL! If no data is available, it will return
 * an empty string ("").
 *
 * \param music the music object to query, or NULL for the currently-playing
 *              music.
 * \returns the music's album name if available, or "".
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *
 * \sa Mix_GetMusicTitleTag
 * \sa Mix_GetMusicArtistTag
 * \sa Mix_GetMusicCopyrightTag
 *)
  Mix_GetMusicAlbumTag: function(const music: PMix_Music): PUTF8Char; cdecl;

(**
 * Get the copyright text for a music object.
 *
 * This returns format-specific metadata. Not all file formats supply this!
 *
 * If `music` is NULL, this will query the currently-playing music.
 *
 * This function never returns NULL! If no data is available, it will return
 * an empty string ("").
 *
 * \param music the music object to query, or NULL for the currently-playing
 *              music.
 * \returns the music's copyright text if available, or "".
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *
 * \sa Mix_GetMusicTitleTag
 * \sa Mix_GetMusicArtistTag
 * \sa Mix_GetMusicAlbumTag
 *)
  Mix_GetMusicCopyrightTag: function(const music: PMix_Music): PUTF8Char; cdecl;

type
  Mix_SetPostMix_mix_func = procedure(udata: Pointer; stream: PUint8; len: Integer); cdecl;

var
(**
 * Set a function that is called after all mixing is performed.
 *
 * This can be used to provide real-time visual display of the audio stream or
 * add a custom mixer filter for the stream data.
 *
 * The callback will fire every time SDL_mixer is ready to supply more data to
 * the audio device, after it has finished all its mixing work. This runs
 * inside an SDL audio callback, so it's important that the callback return
 * quickly, or there could be problems in the audio playback.
 *
 * The data provided to the callback is in the format that the audio device
 * was opened in, and it represents the exact waveform SDL_mixer has mixed
 * from all playing chunks and music for playback. You are allowed to modify
 * the data, but it cannot be resized (so you can't add a reverb effect that
 * goes past the end of the buffer without saving some state between runs to
 * add it into the next callback, or resample the buffer to a smaller size to
 * speed it up, etc).
 *
 * The `arg` pointer supplied here is passed to the callback as-is, for
 * whatever the callback might want to do with it (keep track of some ongoing
 * state, settings, etc).
 *
 * Passing a NULL callback disables the post-mix callback until such a time as
 * a new one callback is set.
 *
 * There is only one callback available. If you need to mix multiple inputs,
 * be prepared to handle them from a single function.
 *
 * \param mix_func the callback function to become the new post-mix callback.
 * \param arg a pointer that is passed, untouched, to the callback.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_HookMusic
 *)
  Mix_SetPostMix: procedure(mix_func: Mix_SetPostMix_mix_func; arg: Pointer); cdecl;

type
  Mix_HookMusic_mix_func = procedure(udata: Pointer; stream: PUint8; len: Integer); cdecl;

var
(**
 * Add your own music player or additional mixer function.
 *
 * This works something like Mix_SetPostMix(), but it has some crucial
 * differences. Note that an app can use this _and_ Mix_SetPostMix() at the
 * same time. This allows an app to replace the built-in music playback,
 * either with it's own music decoder or with some sort of
 * procedurally-generated audio output.
 *
 * The supplied callback will fire every time SDL_mixer is preparing to supply
 * more data to the audio device. This runs inside an SDL audio callback, so
 * it's important that the callback return quickly, or there could be problems
 * in the audio playback.
 *
 * Running this callback is the first thing SDL_mixer will do when starting to
 * mix more audio. The buffer will contain silence upon entry, so the callback
 * does not need to mix into existing data or initialize the buffer.
 *
 * Note that while a callback is set through this function, SDL_mixer will not
 * mix any playing music; this callback is used instead. To disable this
 * callback (and thus reenable built-in music playback) call this function
 * with a NULL callback.
 *
 * The data written to by the callback is in the format that the audio device
 * was opened in, and upon return from the callback, SDL_mixer will mix any
 * playing chunks (but not music!) into the buffer. The callback cannot resize
 * the buffer (so you must be prepared to provide exactly the amount of data
 * demanded or leave it as silence).
 *
 * The `arg` pointer supplied here is passed to the callback as-is, for
 * whatever the callback might want to do with it (keep track of some ongoing
 * state, settings, etc).
 *
 * As there is only one music "channel" mixed, there is only one callback
 * available. If you need to mix multiple inputs, be prepared to handle them
 * from a single function.
 *
 * \param mix_func the callback function to become the new post-mix callback.
 * \param arg a pointer that is passed, untouched, to the callback.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_SetPostMix
 *)
  Mix_HookMusic: procedure(mix_func: Mix_HookMusic_mix_func; arg: Pointer); cdecl;

type
  Mix_HookMusicFinished_music_finished = procedure(); cdecl;

var
(**
 * Set a callback that runs when a music object has stopped playing.
 *
 * This callback will fire when the currently-playing music has completed, or
 * when it has been explicitly stopped from a call to Mix_HaltMusic. As such,
 * this callback might fire from an arbitrary background thread at almost any
 * time; try to limit what you do here.
 *
 * It is legal to start a new music object playing in this callback (or
 * restart the one that just stopped). If the music finished normally, this
 * can be used to loop the music without a gap in the audio playback.
 *
 * Do not call SDL_LockAudio() from this callback; you will either be inside
 * the audio callback, or SDL_mixer will explicitly lock the audio before
 * calling your callback.
 *
 * A NULL pointer will disable the callback.
 *
 * \param music_finished the callback function to become the new notification
 *                       mechanism.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_HookMusicFinished: procedure(music_finished: Mix_HookMusicFinished_music_finished); cdecl;

(**
 * Get a pointer to the user data for the current music hook.
 *
 * This returns the `arg` pointer last passed to Mix_HookMusic(), or NULL if
 * that function has never been called.
 *
 * \returns pointer to the user data previously passed to Mix_HookMusic.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_GetMusicHookData: function(): Pointer; cdecl;

type
  Mix_ChannelFinished_channel_finished = procedure(channel: Integer); cdecl;

var
(**
 * Set a callback that runs when a channel has finished playing.
 *
 * The callback may be called from the mixer's audio callback or it could be
 * called as a result of Mix_HaltChannel(), etc.
 *
 * The callback has a single parameter, `channel`, which says what mixer
 * channel has just stopped.
 *
 * Do not call SDL_LockAudio() from this callback; you will either be inside
 * the audio callback, or SDL_mixer will explicitly lock the audio before
 * calling your callback.
 *
 * A NULL pointer will disable the callback.
 *
 * \param channel_finished the callback function to become the new
 *                         notification mechanism.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_ChannelFinished: procedure(channel_finished: Mix_ChannelFinished_channel_finished); cdecl;

(**
 * Register a special effect function.
 *
 * At mixing time, the channel data is copied into a buffer and passed through
 * each registered effect function. After it passes through all the functions,
 * it is mixed into the final output stream. The copy to buffer is performed
 * once, then each effect function performs on the output of the previous
 * effect. Understand that this extra copy to a buffer is not performed if
 * there are no effects registered for a given chunk, which saves CPU cycles,
 * and any given effect will be extra cycles, too, so it is crucial that your
 * code run fast. Also note that the data that your function is given is in
 * the format of the sound device, and not the format you gave to
 * Mix_OpenAudio(), although they may in reality be the same. This is an
 * unfortunate but necessary speed concern. Use Mix_QuerySpec() to determine
 * if you can handle the data before you register your effect, and take
 * appropriate actions.
 *
 * You may also specify a callback (Mix_EffectDone_t) that is called when the
 * channel finishes playing. This gives you a more fine-grained control than
 * Mix_ChannelFinished(), in case you need to free effect-specific resources,
 * etc. If you don't need this, you can specify NULL.
 *
 * You may set the callbacks before or after calling Mix_PlayChannel().
 *
 * Things like Mix_SetPanning() are just internal special effect functions, so
 * if you are using that, you've already incurred the overhead of a copy to a
 * separate buffer, and that these effects will be in the queue with any
 * functions you've registered. The list of registered effects for a channel
 * is reset when a chunk finishes playing, so you need to explicitly set them
 * with each call to Mix_PlayChannel*().
 *
 * You may also register a special effect function that is to be run after
 * final mixing occurs. The rules for these callbacks are identical to those
 * in Mix_RegisterEffect, but they are run after all the channels and the
 * music have been mixed into a single stream, whereas channel-specific
 * effects run on a given channel before any other mixing occurs. These global
 * effect callbacks are call "posteffects". Posteffects only have their
 * Mix_EffectDone_t function called when they are unregistered (since the main
 * output stream is never "done" in the same sense as a channel). You must
 * unregister them manually when you've had enough. Your callback will be told
 * that the channel being mixed is `MIX_CHANNEL_POST` if the processing is
 * considered a posteffect.
 *
 * After all these effects have finished processing, the callback registered
 * through Mix_SetPostMix() runs, and then the stream goes to the audio
 * device.
 *
 * DO NOT EVER call SDL_LockAudio() from your callback function! You are
 * already running in the audio thread and the lock is already held!
 *
 * Note that unlike most SDL and SDL_mixer functions, this function returns
 * zero if there's an error, not on success. We apologize for the API design
 * inconsistency here.
 *
 * \param chan the channel to register an effect to, or MIX_CHANNEL_POST.
 * \param f effect the callback to run when more of this channel is to be
 *          mixed.
 * \param d effect done callback
 * \param arg argument
 * \returns zero if error (no such channel), nonzero if added. Error messages
 *          can be retrieved from Mix_GetError().
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_RegisterEffect: function(chan: Integer; f: Mix_EffectFunc_t; d: Mix_EffectDone_t; arg: Pointer): Integer; cdecl;

(**
 * Explicitly unregister a special effect function.
 *
 * You may not need to call this at all, unless you need to stop an effect
 * from processing in the middle of a chunk's playback.
 *
 * Posteffects are never implicitly unregistered as they are for channels (as
 * the output stream does not have an end), but they may be explicitly
 * unregistered through this function by specifying MIX_CHANNEL_POST for a
 * channel.
 *
 * Note that unlike most SDL and SDL_mixer functions, this function returns
 * zero if there's an error, not on success. We apologize for the API design
 * inconsistency here.
 *
 * \param chan the channel to unregister an effect on, or MIX_CHANNEL_POST.
 * \param f effect the callback stop calling in future mixing iterations.
 * \returns zero if error (no such channel or effect), nonzero if removed.
 *          Error messages can be retrieved from Mix_GetError().
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_UnregisterEffect: function(channel: Integer; f: Mix_EffectFunc_t): Integer; cdecl;

(**
 * Explicitly unregister all special effect functions.
 *
 * You may not need to call this at all, unless you need to stop all effects
 * from processing in the middle of a chunk's playback.
 *
 * Note that this will also shut off some internal effect processing, since
 * Mix_SetPanning() and others may use this API under the hood. This is called
 * internally when a channel completes playback. Posteffects are never
 * implicitly unregistered as they are for channels, but they may be
 * explicitly unregistered through this function by specifying
 * MIX_CHANNEL_POST for a channel.
 *
 * Note that unlike most SDL and SDL_mixer functions, this function returns
 * zero if there's an error, not on success. We apologize for the API design
 * inconsistency here.
 *
 * \param chan the channel to unregister all effects on, or MIX_CHANNEL_POST.
 * \returns zero if error (no such channel), nonzero if all effects removed.
 *          Error messages can be retrieved from Mix_GetError().
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_UnregisterAllEffects: function(channel: Integer): Integer; cdecl;

(**
 * Set the panning of a channel.
 *
 * The left and right channels are specified as integers between 0 and 255,
 * quietest to loudest, respectively.
 *
 * Technically, this is just individual volume control for a sample with two
 * (stereo) channels, so it can be used for more than just panning. If you
 * want real panning, call it like this:
 *
 * ```c
 * Mix_SetPanning(channel, left, 255 - left);
 * ```
 *
 * Setting `channel` to MIX_CHANNEL_POST registers this as a posteffect, and
 * the panning will be done to the final mixed stream before passing it on to
 * the audio device.
 *
 * This uses the Mix_RegisterEffect() API internally, and returns without
 * registering the effect function if the audio device is not configured for
 * stereo output. Setting both `left` and `right` to 255 causes this effect to
 * be unregistered, since that is the data's normal state.
 *
 * Note that an audio device in mono mode is a no-op, but this call will
 * return successful in that case. Error messages can be retrieved from
 * Mix_GetError().
 *
 * Note that unlike most SDL and SDL_mixer functions, this function returns
 * zero if there's an error, not on success. We apologize for the API design
 * inconsistency here.
 *
 * \param channel The mixer channel to pan or MIX_CHANNEL_POST.
 * \param left Volume of stereo left channel, 0 is silence, 255 is full
 *             volume.
 * \param right Volume of stereo right channel, 0 is silence, 255 is full
 *              volume.
 * \returns zero if error (no such channel or Mix_RegisterEffect() fails),
 *          nonzero if panning effect enabled.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_SetPosition
 * \sa Mix_SetDistance
 *)
  Mix_SetPanning: function(channel: Integer; left: Uint8; right: Uint8): Integer; cdecl;

(**
 * Set the position of a channel.
 *
 * `angle` is an integer from 0 to 360, that specifies the location of the
 * sound in relation to the listener. `angle` will be reduced as neccesary
 * (540 becomes 180 degrees, -100 becomes 260). Angle 0 is due north, and
 * rotates clockwise as the value increases. For efficiency, the precision of
 * this effect may be limited (angles 1 through 7 might all produce the same
 * effect, 8 through 15 are equal, etc). `distance` is an integer between 0
 * and 255 that specifies the space between the sound and the listener. The
 * larger the number, the further away the sound is. Using 255 does not
 * guarantee that the channel will be removed from the mixing process or be
 * completely silent. For efficiency, the precision of this effect may be
 * limited (distance 0 through 5 might all produce the same effect, 6 through
 * 10 are equal, etc). Setting `angle` and `distance` to 0 unregisters this
 * effect, since the data would be unchanged.
 *
 * If you need more precise positional audio, consider using OpenAL for
 * spatialized effects instead of SDL_mixer. This is only meant to be a basic
 * effect for simple "3D" games.
 *
 * If the audio device is configured for mono output, then you won't get any
 * effectiveness from the angle; however, distance attenuation on the channel
 * will still occur. While this effect will function with stereo voices, it
 * makes more sense to use voices with only one channel of sound, so when they
 * are mixed through this effect, the positioning will sound correct. You can
 * convert them to mono through SDL before giving them to the mixer in the
 * first place if you like.
 *
 * Setting the channel to MIX_CHANNEL_POST registers this as a posteffect, and
 * the positioning will be done to the final mixed stream before passing it on
 * to the audio device.
 *
 * This is a convenience wrapper over Mix_SetDistance() and Mix_SetPanning().
 *
 * Note that unlike most SDL and SDL_mixer functions, this function returns
 * zero if there's an error, not on success. We apologize for the API design
 * inconsistency here.
 *
 * \param channel The mixer channel to position, or MIX_CHANNEL_POST.
 * \param angle angle, in degrees. North is 0, and goes clockwise.
 * \param distance distance; 0 is the listener, 255 is maxiumum distance away.
 * \returns zero if error (no such channel or Mix_RegisterEffect() fails),
 *          nonzero if position effect is enabled. Error messages can be
 *          retrieved from Mix_GetError().
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_SetPosition: function(channel: Integer; angle: Sint16; distance: Uint8): Integer; cdecl;

(**
 * Set the "distance" of a channel.
 *
 * `distance` is an integer from 0 to 255 that specifies the location of the
 * sound in relation to the listener. Distance 0 is overlapping the listener,
 * and 255 is as far away as possible. A distance of 255 does not guarantee
 * silence; in such a case, you might want to try changing the chunk's volume,
 * or just cull the sample from the mixing process with Mix_HaltChannel(). For
 * efficiency, the precision of this effect may be limited (distances 1
 * through 7 might all produce the same effect, 8 through 15 are equal, etc).
 * (distance) is an integer between 0 and 255 that specifies the space between
 * the sound and the listener. The larger the number, the further away the
 * sound is. Setting the distance to 0 unregisters this effect, since the data
 * would be unchanged. If you need more precise positional audio, consider
 * using OpenAL for spatialized effects instead of SDL_mixer. This is only
 * meant to be a basic effect for simple "3D" games.
 *
 * Setting the channel to MIX_CHANNEL_POST registers this as a posteffect, and
 * the distance attenuation will be done to the final mixed stream before
 * passing it on to the audio device.
 *
 * This uses the Mix_RegisterEffect() API internally.
 *
 * Note that unlike most SDL and SDL_mixer functions, this function returns
 * zero if there's an error, not on success. We apologize for the API design
 * inconsistency here.
 *
 * \param channel The mixer channel to attenuate, or MIX_CHANNEL_POST.
 * \param distance distance; 0 is the listener, 255 is maxiumum distance away.
 * \returns zero if error (no such channel or Mix_RegisterEffect() fails),
 *          nonzero if position effect is enabled. Error messages can be
 *          retrieved from Mix_GetError().
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_SetDistance: function(channel: Integer; distance: Uint8): Integer; cdecl;

(**
 * Cause a channel to reverse its stereo.
 *
 * This is handy if the user has his speakers hooked up backwards, or you
 * would like to have a trippy sound effect.
 *
 * Calling this function with `flip` set to non-zero reverses the chunks's
 * usual channels. If `flip` is zero, the effect is unregistered.
 *
 * This uses the Mix_RegisterEffect() API internally, and thus is probably
 * more CPU intensive than having the user just plug in his speakers
 * correctly. Mix_SetReverseStereo() returns without registering the effect
 * function if the audio device is not configured for stereo output.
 *
 * If you specify MIX_CHANNEL_POST for `channel`, then this effect is used on
 * the final mixed stream before sending it on to the audio device (a
 * posteffect).
 *
 * Note that unlike most SDL and SDL_mixer functions, this function returns
 * zero if there's an error, not on success. We apologize for the API design
 * inconsistency here.
 *
 * \param channel The mixer channel to reverse, or MIX_CHANNEL_POST.
 * \param flip non-zero to reverse stereo, zero to disable this effect.
 * \returns zero if error (no such channel or Mix_RegisterEffect() fails),
 *          nonzero if reversing effect is enabled. Note that an audio device
 *          in mono mode is a no-op, but this call will return successful in
 *          that case. Error messages can be retrieved from Mix_GetError().
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_SetReverseStereo: function(channel: Integer; flip: Integer): Integer; cdecl;

(**
 * Reserve the first channels for the application.
 *
 * While SDL_mixer will use up to the number of channels allocated by
 * Mix_AllocateChannels(), this sets channels aside that will not be available
 * when calling Mix_PlayChannel with a channel of -1 (play on the first unused
 * channel). In this case, SDL_mixer will treat reserved channels as "used"
 * whether anything is playing on them at the moment or not.
 *
 * This is useful if you've budgeted some channels for dedicated audio and the
 * rest are just used as they are available.
 *
 * Calling this function will set channels 0 to `n - 1` to be reserved. This
 * will not change channel allocations. The number of reserved channels will
 * be clamped to the current number allocated.
 *
 * By default, no channels are reserved.
 *
 * \param num number of channels to reserve, starting at index zero.
 * \returns the number of reserved channels.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_ReserveChannels: function(num: Integer): Integer; cdecl;

(**
 * Assign a tag to a channel.
 *
 * A tag is an arbitary number that can be assigned to several mixer channels,
 * to form groups of channels.
 *
 * If 'tag' is -1, the tag is removed (actually -1 is the tag used to
 * represent the group of all the channels).
 *
 * This function replaces the requested channel's current tag; you may only
 * have one tag per channel.
 *
 * You may not specify MAX_CHANNEL_POST for a channel.
 *
 * \param which the channel to set the tag on.
 * \param tag an arbitrary value to assign a channel.
 * \returns non-zero on success, zero on error (no such channel).
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_GroupChannel: function(which: Integer; tag: Integer): Integer; cdecl;

(**
 * Assign several consecutive channels to the same tag.
 *
 * A tag is an arbitary number that can be assigned to several mixer channels,
 * to form groups of channels.
 *
 * If 'tag' is -1, the tag is removed (actually -1 is the tag used to
 * represent the group of all the channels).
 *
 * This function replaces the requested channels' current tags; you may only
 * have one tag per channel.
 *
 * You may not specify MAX_CHANNEL_POST for a channel.
 *
 * Note that this returns success and failure in the _opposite_ way from
 * Mix_GroupChannel(). We regret the API design mistake.
 *
 * \param from the first channel to set the tag on.
 * \param to the last channel to set the tag on, inclusive.
 * \param tag an arbitrary value to assign a channel.
 * \returns 0 if successful, negative on error
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_GroupChannels: function(from: Integer; to_: Integer; tag: Integer): Integer; cdecl;

(**
 * Finds the first available channel in a group of channels.
 *
 * A tag is an arbitary number that can be assigned to several mixer channels,
 * to form groups of channels.
 *
 * This function searches all channels with a specified tag, and returns the
 * channel number of the first one it finds that is currently unused.
 *
 * If no channels with the specified tag are unused, this function returns -1.
 *
 * \param tag an arbitrary value, assigned to channels, to search for.
 * \returns first available channel, or -1 if none are available.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_GroupAvailable: function(tag: Integer): Integer; cdecl;

(**
 * Returns the number of channels in a group.
 *
 * If tag is -1, this will return the total number of channels allocated,
 * regardless of what their tag might be.
 *
 * \param tag an arbitrary value, assigned to channels, to search for.
 * \returns the number of channels assigned the specified tag.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_GroupCount: function(tag: Integer): Integer; cdecl;

(**
 * Find the "oldest" sample playing in a group of channels.
 *
 * Specifically, this function returns the channel number that is assigned the
 * specified tag, is currently playing, and has the lowest start time, based
 * on the value of SDL_GetTicks() when the channel started playing.
 *
 * If no channel with this tag is currently playing, this function returns -1.
 *
 * \param tag an arbitrary value, assigned to channels, to search through.
 * \returns the "oldest" sample playing in a group of channels
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_GroupNewer
 *)
  Mix_GroupOldest: function(tag: Integer): Integer; cdecl;

(**
 * Find the "most recent" sample playing in a group of channels.
 *
 * Specifically, this function returns the channel number that is assigned the
 * specified tag, is currently playing, and has the highest start time, based
 * on the value of SDL_GetTicks() when the channel started playing.
 *
 * If no channel with this tag is currently playing, this function returns -1.
 *
 * \param tag an arbitrary value, assigned to channels, to search through.
 * \returns the "most recent" sample playing in a group of channels
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_GroupOldest
 *)
  Mix_GroupNewer: function(tag: Integer): Integer; cdecl;

(**
 * Play an audio chunk on a specific channel.
 *
 * If the specified channel is -1, play on the first free channel (and return
 * -1 without playing anything new if no free channel was available).
 *
 * If a specific channel was requested, and there is a chunk already playing
 * there, that chunk will be halted and the new chunk will take its place.
 *
 * If `loops` is greater than zero, loop the sound that many times. If `loops`
 * is -1, loop "infinitely" (~65000 times).
 *
 * Note that before SDL_mixer 2.6.0, this function was a macro that called
 * Mix_PlayChannelTimed() with a fourth parameter ("ticks") of -1. This
 * function still does the same thing, but promotes it to a proper API
 * function. Older binaries linked against a newer SDL_mixer will still call
 * Mix_PlayChannelTimed directly, as they are using the macro, which was
 * available since the dawn of time.
 *
 * \param channel the channel on which to play the new chunk.
 * \param chunk the new chunk to play.
 * \param loop the number of times the chunk should loop, -1 to loop (not
 *             actually) infinitely.
 * \returns which channel was used to play the sound, or -1 if sound could not
 *          be played.
 *
 * \since This function is available since SDL_mixer 2.6.0 (and as a macro
 *        since 2.0.0).
 *)
  Mix_PlayChannel: function(channel: Integer; chunk: PMix_Chunk; loops: Integer): Integer; cdecl;

(**
 * Play an audio chunk on a specific channel for a maximum time.
 *
 * If the specified channel is -1, play on the first free channel (and return
 * -1 without playing anything new if no free channel was available).
 *
 * If a specific channel was requested, and there is a chunk already playing
 * there, that chunk will be halted and the new chunk will take its place.
 *
 * If `loops` is greater than zero, loop the sound that many times. If `loops`
 * is -1, loop "infinitely" (~65000 times).
 *
 * `ticks` specifies the maximum number of milliseconds to play this chunk
 * before halting it. If you want the chunk to play until all data has been
 * mixed, specify -1.
 *
 * Note that this function does not block for the number of ticks requested;
 * it just schedules the chunk to play and notes the maximum for the mixer to
 * manage later, and returns immediately.
 *
 * \param channel the channel on which to play the new chunk.
 * \param chunk the new chunk to play.
 * \param loop the number of times the chunk should loop, -1 to loop (not
 *             actually) infinitely.
 * \param ticks the maximum number of milliseconds of this chunk to mix for
 *              playback.
 * \returns which channel was used to play the sound, or -1 if sound could not
 *          be played.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_PlayChannelTimed: function(channel: Integer; chunk: PMix_Chunk; loops: Integer; ticks: Integer): Integer; cdecl;

(**
 * Play a new music object.
 *
 * This will schedule the music object to begin mixing for playback.
 *
 * There is only ever one music object playing at a time; if this is called
 * when another music object is playing, the currently-playing music is halted
 * and the new music will replace it.
 *
 * Please note that if the currently-playing music is in the process of fading
 * out (via Mix_FadeOutMusic()), this function will *block* until the fade
 * completes. If you need to avoid this, be sure to call Mix_HaltMusic()
 * before starting new music.
 *
 * \param music the new music object to schedule for mixing.
 * \param loops the number of loops to play the music for (0 means "play once
 *              and stop").
 * \returns zero on success, -1 on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_PlayMusic: function(music: PMix_Music; loops: Integer): Integer; cdecl;

(**
 * Play a new music object, fading in the audio.
 *
 * This will start the new music playing, much like Mix_PlayMusic() will, but
 * will start the music playing at silence and fade in to its normal volume
 * over the specified number of milliseconds.
 *
 * If there is already music playing, that music will be halted and the new
 * music object will take its place.
 *
 * If `loops` is greater than zero, loop the music that many times. If `loops`
 * is -1, loop "infinitely" (~65000 times).
 *
 * Fading music will change it's volume progressively, as if Mix_VolumeMusic()
 * was called on it (which is to say: you probably shouldn't call
 * Mix_VolumeMusic() on fading music).
 *
 * \param music the new music object to play.
 * \param loop the number of times the chunk should loop, -1 to loop (not
 *             actually) infinitely.
 * \param ms the number of milliseconds to spend fading in.
 * \returns zero on success, -1 on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_FadeInMusic: function(music: PMix_Music; loops: Integer; ms: Integer): Integer; cdecl;

(**
 * Play a new music object, fading in the audio, from a starting position.
 *
 * This will start the new music playing, much like Mix_PlayMusic() will, but
 * will start the music playing at silence and fade in to its normal volume
 * over the specified number of milliseconds.
 *
 * If there is already music playing, that music will be halted and the new
 * music object will take its place.
 *
 * If `loops` is greater than zero, loop the music that many times. If `loops`
 * is -1, loop "infinitely" (~65000 times).
 *
 * Fading music will change it's volume progressively, as if Mix_VolumeMusic()
 * was called on it (which is to say: you probably shouldn't call
 * Mix_VolumeMusic() on fading music).
 *
 * This function allows the caller to start the music playback past the
 * beginning of its audio data. You may specify a start position, in seconds,
 * and the playback and fade-in will start there instead of with the first
 * samples of the music.
 *
 * An app can specify a `position` of 0.0 to start at the beginning of the
 * music (or just call Mix_FadeInMusic() instead).
 *
 * To convert from milliseconds, divide by 1000.0.
 *
 * \param music the new music object to play.
 * \param loop the number of times the chunk should loop, -1 to loop (not
 *             actually) infinitely.
 * \param ms the number of milliseconds to spend fading in.
 * \param position the start position within the music, in seconds, where
 *                 playback should start.
 * \returns zero on success, -1 on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_FadeInMusicPos: function(music: PMix_Music; loops: Integer; ms: Integer; position: Double): Integer; cdecl;

(**
 * Play an audio chunk on a specific channel, fading in the audio.
 *
 * This will start the new sound playing, much like Mix_PlayChannel() will,
 * but will start the sound playing at silence and fade in to its normal
 * volume over the specified number of milliseconds.
 *
 * If the specified channel is -1, play on the first free channel (and return
 * -1 without playing anything new if no free channel was available).
 *
 * If a specific channel was requested, and there is a chunk already playing
 * there, that chunk will be halted and the new chunk will take its place.
 *
 * If `loops` is greater than zero, loop the sound that many times. If `loops`
 * is -1, loop "infinitely" (~65000 times).
 *
 * A fading channel will change it's volume progressively, as if Mix_Volume()
 * was called on it (which is to say: you probably shouldn't call Mix_Volume()
 * on a fading channel).
 *
 * Note that before SDL_mixer 2.6.0, this function was a macro that called
 * Mix_FadeInChannelTimed() with a fourth parameter ("ticks") of -1. This
 * function still does the same thing, but promotes it to a proper API
 * function. Older binaries linked against a newer SDL_mixer will still call
 * Mix_FadeInChannelTimed directly, as they are using the macro, which was
 * available since the dawn of time.
 *
 * \param channel the channel on which to play the new chunk, or -1 to find
 *                any available.
 * \param chunk the new chunk to play.
 * \param loop the number of times the chunk should loop, -1 to loop (not
 *             actually) infinitely.
 * \param ms the number of milliseconds to spend fading in.
 * \returns which channel was used to play the sound, or -1 if sound could not
 *          be played.
 *
 * \since This function is available since SDL_mixer 2.6.0 (and as a macro
 *        since 2.0.0).
 *)
  Mix_FadeInChannel: function(channel: Integer; chunk: PMix_Chunk; loops: Integer; ms: Integer): Integer; cdecl;

(**
 * Play an audio chunk on a specific channel, fading in the audio, for a
 * maximum time.
 *
 * This will start the new sound playing, much like Mix_PlayChannel() will,
 * but will start the sound playing at silence and fade in to its normal
 * volume over the specified number of milliseconds.
 *
 * If the specified channel is -1, play on the first free channel (and return
 * -1 without playing anything new if no free channel was available).
 *
 * If a specific channel was requested, and there is a chunk already playing
 * there, that chunk will be halted and the new chunk will take its place.
 *
 * If `loops` is greater than zero, loop the sound that many times. If `loops`
 * is -1, loop "infinitely" (~65000 times).
 *
 * `ticks` specifies the maximum number of milliseconds to play this chunk
 * before halting it. If you want the chunk to play until all data has been
 * mixed, specify -1.
 *
 * Note that this function does not block for the number of ticks requested;
 * it just schedules the chunk to play and notes the maximum for the mixer to
 * manage later, and returns immediately.
 *
 * A fading channel will change it's volume progressively, as if Mix_Volume()
 * was called on it (which is to say: you probably shouldn't call Mix_Volume()
 * on a fading channel).
 *
 * \param channel the channel on which to play the new chunk, or -1 to find
 *                any available.
 * \param chunk the new chunk to play.
 * \param loop the number of times the chunk should loop, -1 to loop (not
 *             actually) infinitely.
 * \param ms the number of milliseconds to spend fading in.
 * \param ticks the maximum number of milliseconds of this chunk to mix for
 *              playback.
 * \returns which channel was used to play the sound, or -1 if sound could not
 *          be played.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_FadeInChannelTimed: function(channel: Integer; chunk: PMix_Chunk; loops: Integer; ms: Integer; ticks: Integer): Integer; cdecl;

(**
 * Set the volume for a specific channel.
 *
 * The volume must be between 0 (silence) and MIX_MAX_VOLUME (full volume).
 * Note that MIX_MAX_VOLUME is 128. Values greater than MIX_MAX_VOLUME are
 * clamped to MIX_MAX_VOLUME.
 *
 * Specifying a negative volume will not change the current volume; as such,
 * this can be used to query the current volume without making changes, as
 * this function returns the previous (in this case, still-current) value.
 *
 * If the specified channel is -1, this function sets the volume for all
 * channels, and returns _the average_ of all channels' volumes prior to this
 * call.
 *
 * The default volume for a channel is MIX_MAX_VOLUME (no attenuation).
 *
 * \param channel the channel on set/query the volume on, or -1 for all
 *                channels.
 * \param volume the new volume, between 0 and MIX_MAX_VOLUME, or -1 to query.
 * \returns the previous volume. If the specified volume is -1, this returns
 *          the current volume. If `channel` is -1, this returns the average
 *          of all channels.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_Volume: function(channel: Integer; volume: Integer): Integer; cdecl;

(**
 * Set the volume for a specific chunk.
 *
 * In addition to channels having a volume setting, individual chunks also
 * maintain a seperate volume. Both values are considered when mixing, so both
 * affect the final attenuation of the sound. This lets an app adjust the
 * volume for all instances of a sound in addition to specific instances of
 * that sound.
 *
 * The volume must be between 0 (silence) and MIX_MAX_VOLUME (full volume).
 * Note that MIX_MAX_VOLUME is 128. Values greater than MIX_MAX_VOLUME are
 * clamped to MIX_MAX_VOLUME.
 *
 * Specifying a negative volume will not change the current volume; as such,
 * this can be used to query the current volume without making changes, as
 * this function returns the previous (in this case, still-current) value.
 *
 * The default volume for a chunk is MIX_MAX_VOLUME (no attenuation).
 *
 * \param channel the channel on set/query the volume on, or -1 for all
 *                channels.
 * \param volume the new volume, between 0 and MIX_MAX_VOLUME, or -1 to query.
 * \returns the previous volume. If the specified volume is -1, this returns
 *          the current volume. If `chunk` is NULL, this returns -1.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_VolumeChunk: function(chunk: PMix_Chunk; volume: Integer): Integer; cdecl;

(**
 * Set the volume for the music channel.
 *
 * The volume must be between 0 (silence) and MIX_MAX_VOLUME (full volume).
 * Note that MIX_MAX_VOLUME is 128. Values greater than MIX_MAX_VOLUME are
 * clamped to MIX_MAX_VOLUME.
 *
 * Specifying a negative volume will not change the current volume; as such,
 * this can be used to query the current volume without making changes, as
 * this function returns the previous (in this case, still-current) value.
 *
 * The default volume for music is MIX_MAX_VOLUME (no attenuation).
 *
 * \param volume the new volume, between 0 and MIX_MAX_VOLUME, or -1 to query.
 * \returns the previous volume. If the specified volume is -1, this returns
 *          the current volume.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_VolumeMusic: function(volume: Integer): Integer; cdecl;

(**
 * Query the current volume value for a music object.
 *
 * \param music the music object to query.
 * \returns the music's current volume, between 0 and MIX_MAX_VOLUME (128).
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_GetMusicVolume: function(music: PMix_Music): Integer; cdecl;

(**
 * Set the master volume for all channels.
 *
 * SDL_mixer keeps a per-channel volume, a per-chunk volume, and a master
 * volume, and considers all three when mixing audio. This function sets the
 * master volume, which is applied to all playing channels when mixing.
 *
 * The volume must be between 0 (silence) and MIX_MAX_VOLUME (full volume).
 * Note that MIX_MAX_VOLUME is 128. Values greater than MIX_MAX_VOLUME are
 * clamped to MIX_MAX_VOLUME.
 *
 * Specifying a negative volume will not change the current volume; as such,
 * this can be used to query the current volume without making changes, as
 * this function returns the previous (in this case, still-current) value.
 *
 * Note that the master volume does not affect any playing music; it is only
 * applied when mixing chunks. Use Mix_MusicVolume() for that.\
 *
 * \param volume the new volume, between 0 and MIX_MAX_VOLUME, or -1 to query.
 * \returns the previous volume. If the specified volume is -1, this returns
 *          the current volume.
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_MasterVolume: function(volume: Integer): Integer; cdecl;

(**
 * Halt playing of a particular channel.
 *
 * This will stop further playback on that channel until a new chunk is
 * started there.
 *
 * Specifying a channel of -1 will halt _all_ channels, except for any playing
 * music.
 *
 * Any halted channels will have any currently-registered effects
 * deregistered, and will call any callback specified by Mix_ChannelFinished()
 * before this function returns.
 *
 * You may not specify MAX_CHANNEL_POST for a channel.
 *
 * \param channel channel to halt, or -1 to halt all channels.
 * \returns 0 on success, or -1 on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_HaltChannel: function(channel: Integer): Integer; cdecl;

(**
 * Halt playing of a group of channels by arbitrary tag.
 *
 * This will stop further playback on all channels with a specific tag, until
 * a new chunk is started there.
 *
 * A tag is an arbitary number that can be assigned to several mixer channels,
 * to form groups of channels.
 *
 * The default tag for a channel is -1.
 *
 * Any halted channels will have any currently-registered effects
 * deregistered, and will call any callback specified by Mix_ChannelFinished()
 * before this function returns.
 *
 * \param tag an arbitrary value, assigned to channels, to search for.
 * \returns zero, whether any channels were halted or not.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_HaltGroup: function(tag: Integer): Integer; cdecl;

(**
 * Halt playing of the music stream.
 *
 * This will stop further playback of music until a new music object is
 * started there.
 *
 * Any halted music will call any callback specified by
 * Mix_HookMusicFinished() before this function returns.
 *
 * \returns zero, regardless of whether any music was halted.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_HaltMusic: function(): Integer; cdecl;

(**
 * Change the expiration delay for a particular channel.
 *
 * The channel will halt after the 'ticks' milliseconds have elapsed, or
 * remove the expiration if 'ticks' is -1.
 *
 * This overrides the value passed to the fourth parameter of
 * Mix_PlayChannelTimed().
 *
 * Specifying a channel of -1 will set an expiration for _all_ channels.
 *
 * Any halted channels will have any currently-registered effects
 * deregistered, and will call any callback specified by Mix_ChannelFinished()
 * once the halt occurs.
 *
 * Note that this function does not block for the number of ticks requested;
 * it just schedules the chunk to expire and notes the time for the mixer to
 * manage later, and returns immediately.
 *
 * \param channel the channel to change the expiration time on.
 * \param ticks number of milliseconds from now to let channel play before
 *              halting, -1 to not halt.
 * \returns the number of channels that changed expirations.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_ExpireChannel: function(channel: Integer; ticks: Integer): Integer; cdecl;

(**
 * Halt a channel after fading it out for a specified time.
 *
 * This will begin a channel fading from its current volume to silence over
 * `ms` milliseconds. After that time, the channel is halted.
 *
 * Any halted channels will have any currently-registered effects
 * deregistered, and will call any callback specified by Mix_ChannelFinished()
 * once the halt occurs.
 *
 * A fading channel will change it's volume progressively, as if Mix_Volume()
 * was called on it (which is to say: you probably shouldn't call Mix_Volume()
 * on a fading channel).
 *
 * Note that this function does not block for the number of milliseconds
 * requested; it just schedules the chunk to fade and notes the time for the
 * mixer to manage later, and returns immediately.
 *
 * \param which the channel to fade out.
 * \param ms number of milliseconds to fade before halting the channel.
 * \returns 0 on success, or -1 on error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_FadeOutChannel: function(which: Integer; ms: Integer): Integer; cdecl;

(**
 * Halt a playing group of channels by arbitrary tag, after fading them out
 * for a specified time.
 *
 * This will begin fading a group of channels with a specific tag from their
 * current volumes to silence over `ms` milliseconds. After that time, those
 * channels are halted.
 *
 * A tag is an arbitary number that can be assigned to several mixer channels,
 * to form groups of channels.
 *
 * The default tag for a channel is -1.
 *
 * Any halted channels will have any currently-registered effects
 * deregistered, and will call any callback specified by Mix_ChannelFinished()
 * once the halt occurs.
 *
 * A fading channel will change it's volume progressively, as if Mix_Volume()
 * was called on it (which is to say: you probably shouldn't call Mix_Volume()
 * on a fading channel).
 *
 * Note that this function does not block for the number of milliseconds
 * requested; it just schedules the group to fade and notes the time for the
 * mixer to manage later, and returns immediately.
 *
 * \param tag an arbitrary value, assigned to channels, to search for.
 * \param ms number of milliseconds to fade before halting the group.
 * \returns the number of channels that were scheduled for fading.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_FadeOutGroup: function(tag: Integer; ms: Integer): Integer; cdecl;

(**
 * Halt the music stream after fading it out for a specified time.
 *
 * This will begin the music fading from its current volume to silence over
 * `ms` milliseconds. After that time, the music is halted.
 *
 * Any halted music will call any callback specified by
 * Mix_HookMusicFinished() once the halt occurs.
 *
 * Fading music will change it's volume progressively, as if Mix_VolumeMusic()
 * was called on it (which is to say: you probably shouldn't call
 * Mix_VolumeMusic() on a fading channel).
 *
 * Note that this function does not block for the number of milliseconds
 * requested; it just schedules the music to fade and notes the time for the
 * mixer to manage later, and returns immediately.
 *
 * \param which the channel to fade out.
 * \param ms number of milliseconds to fade before halting the channel.
 * \returns non-zero if music was scheduled to fade, zero otherwise. If no
 *          music is currently playing, this returns zero.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_FadeOutMusic: function(ms: Integer): Integer; cdecl;

(**
 * Query the fading status of the music stream.
 *
 * This reports one of three values:
 *
 * - `MIX_NO_FADING`
 * - `MIX_FADING_OUT`
 * - `MIX_FADING_IN`
 *
 * If music is not currently playing, this returns `MIX_NO_FADING`.
 *
 * \returns the current fading status of the music stream.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_FadingMusic: function(): Mix_Fading; cdecl;

(**
 * Query the fading status of a channel.
 *
 * This reports one of three values:
 *
 * - `MIX_NO_FADING`
 * - `MIX_FADING_OUT`
 * - `MIX_FADING_IN`
 *
 * If nothing is currently playing on the channel, or an invalid channel is
 * specified, this returns `MIX_NO_FADING`.
 *
 * You may not specify MAX_CHANNEL_POST for a channel.
 *
 * You may not specify -1 for all channels; only individual channels may be
 * queried.
 *
 * \param which the channel to query.
 * \returns the current fading status of the channel.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_FadingChannel: function(which: Integer): Mix_Fading; cdecl;

(**
 * Pause a particular channel.
 *
 * Pausing a channel will prevent further playback of the assigned chunk but
 * will maintain the chunk's current mixing position. When resumed, this
 * channel will continue to mix the chunk where it left off.
 *
 * A paused channel can be resumed by calling Mix_Resume().
 *
 * A paused channel with an expiration will not expire while paused (the
 * expiration countdown will be adjusted once resumed).
 *
 * It is legal to halt a paused channel. Playing a new chunk on a paused
 * channel will replace the current chunk and unpause the channel.
 *
 * Specifying a channel of -1 will pause _all_ channels. Any music is
 * unaffected.
 *
 * You may not specify MAX_CHANNEL_POST for a channel.
 *
 * \param channel the channel to pause, or -1 to pause all channels.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_Pause: procedure(channel: Integer); cdecl;

(**
 * Resume a particular channel.
 *
 * It is legal to resume an unpaused or invalid channel; it causes no effect
 * and reports no error.
 *
 * If the paused channel has an expiration, its expiration countdown resumes
 * now, as well.
 *
 * Specifying a channel of -1 will resume _all_ paused channels. Any music is
 * unaffected.
 *
 * \param channel the channel to resume, or -1 to resume all paused channels.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_Resume: procedure(channel: Integer); cdecl;

(**
 * Query whether a particular channel is paused.
 *
 * If an invalid channel is specified, this function returns zero.
 *
 * \param channel the channel to query, or -1 to query all channels.
 * \return 1 if channel paused, 0 otherwise. If `channel` is -1, returns the
 *         number of paused channels.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_Paused: function(channel: Integer): Integer; cdecl;

(**
 * Pause the music stream.
 *
 * Pausing the music stream will prevent further playback of the assigned
 * music object, but will maintain the object's current mixing position. When
 * resumed, this channel will continue to mix the music where it left off.
 *
 * Paused music can be resumed by calling Mix_ResumeMusic().
 *
 * It is legal to halt paused music. Playing a new music object when music is
 * paused will replace the current music and unpause the music stream.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_PauseMusic: procedure(); cdecl;

(**
 * Resume the music stream.
 *
 * It is legal to resume an unpaused music stream; it causes no effect and
 * reports no error.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_ResumeMusic: procedure(); cdecl;

(**
 * Rewind the music stream.
 *
 * This causes the currently-playing music to start mixing from the beginning
 * of the music, as if it were just started.
 *
 * It's a legal no-op to rewind the music stream when not playing.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_RewindMusic: procedure(); cdecl;

(**
 * Query whether the music stream is paused.
 *
 * \return 1 if music is paused, 0 otherwise.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_PauseMusic
 * \sa Mix_ResumeMusic
 *)
  Mix_PausedMusic: function(): Integer; cdecl;

(**
 * Jump to a given order in mod music.
 *
 * This only applies to MOD music formats.
 *
 * \param order order
 * \returns 0 if successful, or -1 if failed or isn't implemented.
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_ModMusicJumpToOrder: function(order: Integer): Integer; cdecl;

(**
 * Set the current position in the music stream, in seconds.
 *
 * To convert from milliseconds, divide by 1000.0.
 *
 * This function is only implemented for MOD music formats (set pattern order
 * number) and for WAV, OGG, FLAC, MP3, and MODPLUG music at the moment.
 *
 * \param position the new position, in seconds (as a double).
 * \returns 0 if successful, or -1 if it failed or not implemented.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_SetMusicPosition: function(position: Double): Integer; cdecl;

(**
 * Get the time current position of music stream, in seconds.
 *
 * To convert to milliseconds, multiply by 1000.0.
 *
 * \param music the music object to query.
 * \returns -1.0 if this feature is not supported for some codec.
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_GetMusicPosition: function(music: PMix_Music): Double; cdecl;

(**
 * Get a music object's duration, in seconds.
 *
 * To convert to milliseconds, multiply by 1000.0.
 *
 * If NULL is passed, returns duration of current playing music.
 *
 * \param music the music object to query.
 * \returns music duration in seconds, or -1.0 on error.
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_MusicDuration: function(music: PMix_Music): Double; cdecl;

(**
 * Get the loop start time position of music stream, in seconds.
 *
 * To convert to milliseconds, multiply by 1000.0.
 *
 * If NULL is passed, returns duration of current playing music.
 *
 * \param music the music object to query.
 * \returns -1.0 if this feature is not used for this music or not supported
 *          for some codec
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_GetMusicLoopStartTime: function(music: PMix_Music): Double; cdecl;

(**
 * Get the loop end time position of music stream, in seconds.
 *
 * To convert to milliseconds, multiply by 1000.0.
 *
 * If NULL is passed, returns duration of current playing music.
 *
 * \param music the music object to query.
 * \returns -1.0 if this feature is not used for this music or not supported
 *          for some codec
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_GetMusicLoopEndTime: function(music: PMix_Music): Double; cdecl;

(**
 * Get the loop time length of music stream, in seconds.
 *
 * To convert to milliseconds, multiply by 1000.0.
 *
 * If NULL is passed, returns duration of current playing music.
 *
 * \param music the music object to query.
 * \returns -1.0 if this feature is not used for this music or not supported
 *          for some codec
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_GetMusicLoopLengthTime: function(music: PMix_Music): Double; cdecl;

(**
 * Check the playing status of a specific channel.
 *
 * If the channel is currently playing, this function returns 1. Otherwise it
 * returns 0.
 *
 * If the specified channel is -1, all channels are checked, and this function
 * returns the number of channels currently playing.
 *
 * You may not specify MAX_CHANNEL_POST for a channel.
 *
 * Paused channels are treated as playing, even though they are not currently
 * making forward progress in mixing.
 *
 * \param channel channel
 * \returns non-zero if channel is playing, zero otherwise. If `channel` is
 *          -1, return the total number of channel playings.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_Playing: function(channel: Integer): Integer; cdecl;

(**
 * Check the playing status of the music stream.
 *
 * If music is currently playing, this function returns 1. Otherwise it
 * returns 0.
 *
 * Paused music is treated as playing, even though it is not currently making
 * forward progress in mixing.
 *
 * \returns non-zero if music is playing, zero otherwise.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_PlayingMusic: function(): Integer; cdecl;

(**
 * Run an external command as the music stream.
 *
 * This halts any currently-playing music, and next time the music stream is
 * played, SDL_mixer will spawn a process using the command line specified in
 * `command`. This command is not subject to shell expansion, and beyond some
 * basic splitting up of arguments, is passed to execvp() on most platforms,
 * not system().
 *
 * The command is responsible for generating sound; it is NOT mixed by
 * SDL_mixer! SDL_mixer will kill the child process if asked to halt the
 * music, but otherwise does not have any control over what the process does.
 *
 * You are strongly encouraged not to use this function without an extremely
 * good reason.
 *
 * \param command command
 * \returns 0 if successful, -1 on error
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_SetMusicCMD: function(const command: PUTF8Char): Integer; cdecl;

(**
 * This function does nothing, do not use.
 *
 * This was probably meant to expose a feature, but no codecs support it, so
 * it only remains for binary compatibility.
 *
 * Calling this function is a legal no-op that returns -1.
 *
 * \param value this parameter is ignored.
 * \returns -1.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_SetSynchroValue: function(value: Integer): Integer; cdecl;

(**
 * This function does nothing, do not use.
 *
 * This was probably meant to expose a feature, but no codecs support it, so
 * it only remains for binary compatibility.
 *
 * Calling this function is a legal no-op that returns -1.
 *
 * \returns -1.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_GetSynchroValue: function(): Integer; cdecl;

(**
 * Set SoundFonts paths to use by supported MIDI backends.
 *
 * You may specify multiple paths in a single string by separating them with
 * semicolons; they will be searched in the order listed.
 *
 * This function replaces any previously-specified paths.
 *
 * Passing a NULL path will remove any previously-specified paths.
 *
 * Note that unlike most SDL and SDL_mixer functions, this function returns
 * zero if there's an error, not on success. We apologize for the API design
 * inconsistency here.
 *
 * \param paths Paths on the filesystem where SoundFonts are available,
 *              separated by semicolons.
 * \returns 1 if successful, 0 on error (out of memory).
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_SetSoundFonts: function(const paths: PUTF8Char): Integer; cdecl;

(**
 * Get SoundFonts paths to use by supported MIDI backends.
 *
 * There are several factors that determine what will be reported by this
 * function:
 *
 * - If the boolean _SDL hint_ `"SDL_FORCE_SOUNDFONTS"` is set, AND the
 *   `"SDL_SOUNDFONTS"` _environment variable_ is also set, this function will
 *   return that environment variable regardless of whether
 *   Mix_SetSoundFounts() was ever called.
 * - Otherwise, if Mix_SetSoundFonts() was successfully called with a non-NULL
 *   path, this function will return the string passed to that function.
 * - Otherwise, if the `"SDL_SOUNDFONTS"` variable is set, this function will
 *   return that environment variable.
 * - Otherwise, this function will search some common locations on the
 *   filesystem, and if it finds a SoundFont there, it will return that.
 * - Failing everything else, this function returns NULL.
 *
 * This returns a pointer to internal (possibly read-only) memory, and it
 * should not be modified or free'd by the caller.
 *
 * \returns semicolon-separated list of sound font paths.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_GetSoundFonts: function(): PUTF8Char; cdecl;

type
  Mix_EachSoundFont_function = function(const p1: PUTF8Char; p2: Pointer): Integer; cdecl;

var
(**
 * Iterate SoundFonts paths to use by supported MIDI backends.
 *
 * This function will take the string reported by Mix_GetSoundFonts(), split
 * it up into separate paths, as delimited by semicolons in the string, and
 * call a callback function for each separate path.
 *
 * If there are no paths available, this returns 0 without calling the
 * callback at all.
 *
 * If the callback returns non-zero, this function stops iterating and returns
 * non-zero. If the callback returns 0, this function will continue iterating,
 * calling the callback again for further paths. If the callback never returns
 * 1, this function returns 0, so this can be used to decide if an available
 * soundfont is acceptable for use.
 *
 * \param function the callback function to call once per path.
 * \param data a pointer to pass to the callback for its own personal use.
 * \returns non-zero if callback ever returned non-zero, 0 on error or the
 *          callback never returned non-zero.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_GetSoundFonts
 *)
  Mix_EachSoundFont: function(function_: Mix_EachSoundFont_function; data: Pointer): Integer; cdecl;

(**
 * Set full path of the Timidity config file.
 *
 * For example, "/etc/timidity.cfg"
 *
 * This is obviously only useful if SDL_mixer is using Timidity internally to
 * play MIDI files.
 *
 * \param path path to a Timidity config file.
 * \returns 1 if successful, 0 on error
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *)
  Mix_SetTimidityCfg: function(const path: PUTF8Char): Integer; cdecl;

(**
 * Get full path of a previously-specified Timidity config file.
 *
 * For example, "/etc/timidity.cfg"
 *
 * If a path has never been specified, this returns NULL.
 *
 * This returns a pointer to internal memory, and it should not be modified or
 * free'd by the caller.
 *
 * \returns the previously-specified path, or NULL if not set.
 *
 * \since This function is available since SDL_mixer 2.6.0.
 *
 * \sa Mix_SetTimidityCfg
 *)
  Mix_GetTimidityCfg: function(): PUTF8Char; cdecl;

(**
 * Get the Mix_Chunk currently associated with a mixer channel.
 *
 * You may not specify MAX_CHANNEL_POST or -1 for a channel.
 *
 * \param channel the channel to query.
 * \returns the associated chunk, if any, or NULL if it's an invalid channel.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *)
  Mix_GetChunk: function(channel: Integer): PMix_Chunk; cdecl;

(**
 * Close the mixer, halting all playing audio.
 *
 * Any halted channels will have any currently-registered effects
 * deregistered, and will call any callback specified by Mix_ChannelFinished()
 * before this function returns.
 *
 * Any halted music will call any callback specified by
 * Mix_HookMusicFinished() before this function returns.
 *
 * Do not start any new audio playing during callbacks in this function.
 *
 * This will close the audio device. Attempting to play new audio after this
 * function returns will fail, until another successful call to
 * Mix_OpenAudio() or Mix_OpenAudioDevice().
 *
 * Note that (unlike Mix_OpenAudio optionally calling SDL_Init(SDL_INIT_AUDIO)
 * on the app's behalf), this will _not_ deinitialize the SDL audio subsystem
 * in any case. At some point after calling this function and Mix_Quit(), some
 * part of the application should be responsible for calling SDL_Quit() to
 * deinitialize all of SDL, including its audio subsystem.
 *
 * This function should be the last thing you call in SDL_mixer before
 * Mix_Quit(). However, the following notes apply if you don't follow this
 * advice:
 *
 * Note that this will not free any loaded chunks or music; you should dispose
 * of those resources separately. It is probably poor form to dispose of them
 * _after_ this function, but it is safe to call Mix_FreeChunk() and
 * Mix_FreeMusic() after closing the device.
 *
 * Note that any chunks or music you don't free may or may not work if you
 * call Mix_OpenAudio again, as the audio device may be in a new format and
 * the existing chunks will not be converted to match.
 *
 * \since This function is available since SDL_mixer 2.0.0.
 *
 * \sa Mix_Quit
 *)
  Mix_CloseAudio: procedure(); cdecl;

(**
 * Query the version of SDL_net that the program is linked against.
 *
 * This function gets the version of the dynamically linked SDL_net library.
 * This is separate from the SDL_NET_VERSION() macro, which tells you what
 * version of the SDL_net headers you compiled against.
 *
 * This returns static internal data; do not free or modify it!
 *
 * \returns a pointer to the version information.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_Linked_Version: function(): PSDLNet_version; cdecl;

(**
 * Initialize SDL_net.
 *
 * You must successfully call this function before it is safe to call any
 * other function in this library, with one exception: a human-readable error
 * message can be retrieved from SDLNet_GetError() if this function fails.
 *
 * SDL must be initialized before calls to functions in this library, because
 * this library uses utility functions from the SDL library.
 *
 * It is safe to call this more than once; the library keeps a counter of init
 * calls, and decrements it on each call to SDLNet_Quit, so you must pair your
 * init and quit calls.
 *
 * \returns 0 on success, -1 on error.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_Init: function(): Integer; cdecl;

(**
 * Deinitialize SDL_net.
 *
 * You must call this when done with the library, to free internal resources.
 * It is safe to call this when the library isn't initialized, as it will just
 * return immediately.
 *
 * Once you have as many quit calls as you have had successful calls to
 * SDLNet_Init, the library will actually deinitialize.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_Quit: procedure(); cdecl;

(**
 * Resolve a host name and port to an IP address in network form.
 *
 * If `host` is NULL, the resolved host will be set to `INADDR_ANY`.
 *
 * If the host couldn't be resolved, the host portion of the returned address
 * will be INADDR_NONE, and the function will return -1.
 *
 * \param address to be filled in with the resolved address and port.
 * \param host the hostname to lookup (like "libsdl.org")
 * \param port the port intended to be connected to, to fill into address.
 * \returns zero on success, -1 on error.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_ResolveHost: function(address: PIPaddress; const host: PUTF8Char; port: Uint16): Integer; cdecl;

(**
 * Resolve an IP address to a host name in canonical form.
 *
 * If the IP couldn't be resolved, this function returns NULL, otherwise a
 * pointer to a static buffer containing the hostname is returned.
 *
 * **Warning**: This function is not thread-safe!
 *
 * \param ip the IP address to resolve into a hostname.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_ResolveIP: function(const ip: PIPaddress): PUTF8Char; cdecl;

(**
 * Get the addresses of network interfaces on this system.
 *
 * \param addresses where to store the returned information.
 * \param maxcount the number of results that can be stored at `addresses`
 * \returns the number of addresses saved in `addresses`
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_GetLocalAddresses: function(addresses: PIPaddress; maxcount: Integer): Integer; cdecl;

(**
 * Open a TCP network socket.
 *
 * If `ip->host` is INADDR_NONE or INADDR_ANY, this creates a local server
 * socket on the given port, otherwise a TCP connection to the remote host and
 * port is attempted. The address passed in should already be swapped to
 * network byte order (addresses returned from SDLNet_ResolveHost() are
 * already in the correct form).
 *
 * \param ip The address to open a connection to (or to host a server on).
 * \returns the newly created socket, or NULL if there was an error.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_TCP_Close
 *)
  SDLNet_TCP_Open: function(ip: PIPaddress): TCPsocket; cdecl;

(**
 * Accept an incoming connection on the given server socket.
 *
 * `server` must be a socket returned by SDLNet_TCP_Open with an address of
 * INADDR_NONE or INADDR_ANY (a "server socket"). Other sockets do not accept
 * connections.
 *
 * \param server the server socket to accept a connection on.
 * \returns the newly created socket, or NULL if there was an error.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_TCP_Accept: function(server: TCPsocket): TCPsocket; cdecl;

(**
 * Get the IP address of the remote system associated with the socket.
 *
 * If the socket is a server socket, this function returns NULL.
 *
 * This returns a pointer to internal memory; you should not modify or free
 * it, and should assume it's only valid until the socket is given to
 * SDLNet_TCP_Close.
 *
 * \param sock the socket to query.
 * \returns the address information for the socket.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_TCP_GetPeerAddress: function(sock: TCPsocket): PIPaddress; cdecl;

(**
 * Send data over a non-server socket.
 *
 * `sock` must be a valid socket that was created by SDLNet_TCP_Open with a
 * specific address, or SDLNet_TCP_Accept.
 *
 * This function sends `len` bytes, pointed to by `data` over the non-server
 * socket `sock`.
 *
 * This function returns the actual amount of data sent. If the return value
 * is less than the amount of data sent, then either the remote connection was
 * closed, or an unknown socket error occurred.
 *
 * This function may block!
 *
 * \param sock the socket to send data to.
 * \param data a pointer to the bytes to send.
 * \param len the number of bytes, pointed to by `data`, to transmit.
 * \returns number of bytes sent, which might be less if there was a problem
 *          or connection failure. If the socket is invalid, this function can
 *          return -1, but in valid uses it'll return >= 0.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_TCP_Recv
 *)
  SDLNet_TCP_Send: function(sock: TCPsocket; const data: Pointer; len: Integer): Integer; cdecl;

(**
 * Receive data from a non-server socket.
 *
 * `sock` must be a valid socket that was created by SDLNet_TCP_Open with a
 * specific address, or SDLNet_TCP_Accept.
 *
 * Receive up to `maxlen` bytes of data over the non-server socket `sock`, and
 * store them in the buffer pointed to by `data`.
 *
 * This function returns the actual amount of data received. If the return
 * value is less than or equal to zero, then either the remote connection was
 * closed, or an unknown socket error occurred.
 *
 * Note that this will return the number of bytes available at the first
 * moment the socket is able to see new data. If packets are coming in slowly
 * from the network, this might be less data than you expect at a given time.
 *
 * This function may block! Use SDLNet_CheckSockets() to make sure there is
 * data available before calling this function, if you want to avoid blocking.
 *
 * \param sock the socket to send data to.
 * \param data a pointer to where to store received data.
 * \param maxlen the maximum number of bytes that can be stored at `data`.
 * \returns number of bytes received, which might be less than `maxlen`.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_TCP_Send
 * \sa SDLNet_CheckSockets
 *)
  SDLNet_TCP_Recv: function(sock: TCPsocket; data: Pointer; maxlen: Integer): Integer; cdecl;

(**
 * Close a TCP network socket.
 *
 * All TCP sockets (server and non-server) are deinitialized through this
 * function. Call this once you are done with a socket, and assume the handle
 * is invalid once you have.
 *
 * Closing a socket will disconnect any communication and free its resources.
 *
 * \param sock socket to close.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_TCP_Close: procedure(sock: TCPsocket); cdecl;

(**
 * Allocate a single UDP packet.
 *
 * This allocates a packet with `size` bytes of space for payload.
 *
 * When done with this packet, you can free it with SDLNet_FreePacket. Packets
 * can be reused multiple times; you don't have to allocate a new one for each
 * piece of data you intend to send.
 *
 * You can allocate multiple packets at once with SDLNet_AllocPacketV.
 *
 * \param size the maximum number of bytes of payload this packet will
 *             contain.
 * \returns the new packet, or NULL if the function ran out of memory.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_ResizePacket
 * \sa SDLNet_FreePacket
 * \sa SDLNet_AllocPacketV
 *)
  SDLNet_AllocPacket: function(size: Integer): PUDPpacket; cdecl;

(**
 * Reallocate a UDP packet's payload space.
 *
 * This takes an existing packet and makes sure it can contain at least
 * `newsize` bytes of space for payload.
 *
 * When done with this packet, you can free it with SDLNet_FreePacket. Packets
 * can be used multiple times; you don't have to allocate a new one for each
 * piece of data you intend to send.
 *
 * Please note that on memory allocation failure, this function will leave the
 * existing buffer alone, and _will return the original buffer size_. It will
 * not return an error value, it'll just leave the packet as it was!
 *
 * **Warning**: Existing contents of the packet's data are lost when resizing,
 * whether you are growing or shrinking the payload space, since SDL_net does
 * not realloc the existing data.
 *
 * \param newsize the new maximum number of bytes of payload this packet will
 *                contain.
 * \returns the new maximum payload size, which will be unchanged from the
 *          previous if the system ran out of memory.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_AllocPacket
 * \sa SDLNet_FreePacket
 *)
  SDLNet_ResizePacket: function(packet: PUDPpacket; newsize: Integer): Integer; cdecl;

(**
 * Dispose of a UDP packet.
 *
 * This frees both the packet's payload and the packet itself. Once this call
 * completes, the packet's pointer is invalid and should not be used anymore.
 *
 * \param packet the packet to free.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_AllocPacket
 * \sa SDLNet_ResizePacket
 *)
  SDLNet_FreePacket: procedure(packet: PUDPpacket); cdecl;

(**
 * Allocate a UDP packet vector (array of packets).
 *
 * This allocates `howmany` packets at once, each `size` bytes long.
 *
 * You must free the results of this function with SDLNet_FreePacketV, and
 * must not free individual packets from this function with SDLNet_FreePacket.
 *
 * \param howmany the number of packets to allocate.
 * \param size the maximum bytes of payload each packet should contain.
 * \returns a pointer to the first packet in the array, or NULL if the
 *          function ran out of memory.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_FreePacketV
 *)
  SDLNet_AllocPacketV: function(howmany: Integer; size: Integer): PPUDPpacket; cdecl;

(**
 * Free a UDP packet vector (array of packets).
 *
 * This frees the results of a previous call to SDLNet_AllocPacketV(), freeing
 * both the set of packets and the array that holds them.
 *
 * It is safe to free a NULL array through here; it's a harmless no-op.
 *
 * You must not use this to free packets allocated through any function other
 * than SDLNet_AllocPacketV().
 *
 * \param packetV the results of a call to SDLNet_AllocPacketV().
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_AllocPacketV
 *)
  SDLNet_FreePacketV: procedure(packetV: PPUDPpacket); cdecl;

(**
 * Open a UDP network socket.
 *
 * If `port` is non-zero, the UDP socket is bound to a local port.
 *
 * The `port` should be given in native byte order, but is used internally in
 * network (big endian) byte order, in addresses, etc. This allows other
 * systems to send to this socket via a known port.
 *
 * Note that UDP sockets at the platform layer "bind" to a nework port number,
 * but SDL_net's UDP sockets also "bind" to a "channel" on top of that, with
 * SDLNet_UDP_Bind(). But the term is used for both.
 *
 * When you are done communicating over the returned socket, you can shut it
 * down and free its resources with SDLNet_UDP_Close().
 *
 * \param port the UDP port to bind this socket to.
 * \returns a new UDP socket, ready to communicate.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_UDP_Close
 * \sa SDLNet_UDP_Bind
 *)
  SDLNet_UDP_Open: function(port: Uint16): UDPsocket; cdecl;

(**
 * Set the percentage of simulated packet loss for packets sent on the socket.
 *
 * SDL_net can optionally, at random, drop packets that are being sent and
 * received, to simulate bad networking conditions. As these sort of
 * conditions can happen in the real world but likely won't between machines
 * on the same LAN, you can use this function in testing to make sure your app
 * is robust against network problems even on a fast, reliable network.
 *
 * You probably don't want to use this function outside of local testing.
 *
 * \param sock the socket to simulate packet loss on.
 * \param percent a value from 0 to 100 of likelihood to drop a packet (higher
 *                the number means more likelihood of dropping.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_UDP_SetPacketLoss: procedure(sock: UDPsocket; percent: Integer); cdecl;

(**
 * Bind an address to the requested channel on the UDP socket.
 *
 * Note that UDP sockets at the platform layer "bind" to a nework port number,
 * but SDL_net's UDP sockets also "bind" to a "channel" on top of that, with
 * SDLNet_UDP_Bind(). But the term is used for both.
 *
 * If `channel` is -1, then the first unbound channel that has not yet been
 * bound to the maximum number of addresses will be bound with the given
 * address as it's primary address.
 *
 * If the channel is already bound, this new address will be added to the list
 * of valid source addresses for packets arriving on the channel. If the
 * channel is not already bound, then the address becomes the primary address,
 * to which all outbound packets on the channel are sent.
 *
 * \param sock the UDP socket to bind an address to a channel on.
 * \param channel the channel of the socket to bind to, or -1 to use the first
 *                available channel.
 * \param address the address to bind to the socket's channel.
 * \returns the channel which was bound, or -1 on error.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_UDP_Unbind
 *)
  SDLNet_UDP_Bind: function(sock: UDPsocket; channel: Integer; const address: PIPaddress): Integer; cdecl;

(**
 * Unbind all addresses from the given channel.
 *
 * Note that UDP sockets at the platform layer "bind" to a nework port number,
 * but SDL_net's UDP sockets also "bind" to a "channel" on top of that, with
 * SDLNet_UDP_Bind(). But the term is used for both.
 *
 * \param sock the UDP socket to unbind addresses from a channel on.
 * \param channel the channel of the socket to unbind.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_UDP_Bind
 *)
  SDLNet_UDP_Unbind: procedure(sock: UDPsocket; channel: Integer); cdecl;

(**
 * Get the IP address of the remote system for a socket and channel.
 *
 * If `channel` is -1, then the primary IP port of the UDP socket is returned
 * -- this is only meaningful for sockets opened with a specific port.
 *
 * If the channel is not bound and not -1, this function returns NULL.
 *
 * \param sock the UDP socket to unbind addresses from a channel on.
 * \param channel the channel of the socket to unbind.
 * \returns the address bound to the socket's channel, or
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_UDP_GetPeerAddress: function(sock: UDPsocket; channel: Integer): PIPaddress; cdecl;

(**
 * Send a vector of packets to the the channels specified within the packet.
 *
 * If the channel specified in the packet is -1, the packet will be sent to
 * the address in the `src` member of the packet.
 *
 * Each packet will be updated with the status of the packet after it has been
 * sent, -1 if the packet send failed.
 *
 * This function takes an array of packets but does not need to be allocated
 * through SDLNet_AllocPacketV; if you supply your own array of packets you
 * allocated individually, that is okay.
 *
 * **Warning**: UDP is an _unreliable protocol_, which means we can report
 * that your packet has been successfully sent from your machine, but then it
 * never makes it to its destination when a router along the way quietly drops
 * it. If this happens--and this is a common result on the internet!--you will
 * not know the packet never made it. Also, packets may arrive in a different
 * order than you sent them. Plan accordingly!
 *
 * **Warning**: The maximum size of the packet is limited by the MTU (Maximum
 * Transfer Unit) of the transport medium. It can be as low as 250 bytes for
 * some PPP links, and as high as 1500 bytes for ethernet. Different sizes can
 * be sent, but the system might split it into multiple transmission fragments
 * behind the scenes, that need to be reassembled on the other side (and the
 * packet is lost if any fragment is lost in transit). So the less you can
 * reasonably send in a single packet, the better, as it will be more reliable
 * and lower latency.
 *
 * \param sock the UDP socket to send packets on.
 * \param packets an array of packets to send to the network.
 * \param npackets the number of packets in the `packets` array.
 * \returns the number of packets successfully sent from this machine.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_UDP_RecV
 *)
  SDLNet_UDP_SendV: function(sock: UDPsocket; packets: PPUDPpacket; npackets: Integer): Integer; cdecl;

(**
 * Send a single UDP packet to the specified channel.
 *
 * If the channel specified is -1, the packet will be sent to the address in
 * the `src` member of the packet.
 *
 * The packet will be updated with the status of the packet after it has been
 * sent.
 *
 * **Warning**: UDP is an _unreliable protocol_, which means we can report
 * that your packet has been successfully sent from your machine, but then it
 * never makes it to its destination when a router along the way quietly drops
 * it. If this happens--and this is a common result on the internet!--you will
 * not know the packet never made it. Also, packets may arrive in a different
 * order than you sent them. Plan accordingly!
 *
 * **Warning**: The maximum size of the packet is limited by the MTU (Maximum
 * Transfer Unit) of the transport medium. It can be as low as 250 bytes for
 * some PPP links, and as high as 1500 bytes for ethernet. Different sizes can
 * be sent, but the system might split it into multiple transmission fragments
 * behind the scenes, that need to be reassembled on the other side (and the
 * packet is lost if any fragment is lost in transit). So the less you can
 * reasonably send in a single packet, the better, as it will be more reliable
 * and lower latency.
 *
 * \param sock the UDP socket to send packets on.
 * \param packet a single packet to send to the network.
 * \returns 1 if the packet was sent, or 0 on error.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_UDP_Send: function(sock: UDPsocket; channel: Integer; packet: PUDPpacket): Integer; cdecl;

(**
 * Receive a vector of pending packets from a UDP socket.
 *
 * The returned packets contain the source address and the channel they
 * arrived on. If they did not arrive on a bound channel, the the channel will
 * be set to -1.
 *
 * The channels are checked in highest to lowest order, so if an address is
 * bound to multiple channels, the highest channel with the source address
 * bound will be returned.
 *
 * This function takes an array of packets but does not need to be allocated
 * through SDLNet_AllocPacketV; if you supply your own array of packets you
 * allocated individually, that is okay, as long as the last element in the
 * array is NULL, so SDL_net knows the array bounds. The arrays returned by
 * SDLNet_AllocPacketV are properly NULL-terminated for these purposes.
 *
 * This function does not block, so it can return 0 packets pending, which is
 * not an error condition.
 *
 * \param sock the UDP socket to receive packets on.
 * \param packets an array of packets, NULL terminated.
 * \returns the number of packets read from the network, or -1 on error. 0
 *          means no packets were currently available.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_UDP_SendV
 * \sa SDLNet_UDP_Recv
 *)
  SDLNet_UDP_RecvV: function(sock: UDPsocket; packets: PPUDPpacket): Integer; cdecl;

(**
 * Receive a single packet from a UDP socket.
 *
 * The returned packets contain the source address and the channel they
 * arrived on. If they did not arrive on a bound channel, the the channel will
 * be set to -1.
 *
 * The channels are checked in highest to lowest order, so if an address is
 * bound to multiple channels, the highest channel with the source address
 * bound will be returned.
 *
 * This function does not block, so it can return 0 packets pending, which is
 * not an error condition.
 *
 * \param sock the UDP socket to receive packets on.
 * \param packet a single packet to receive data into from the network.
 * \returns 1 if a new packet is available, or -1 on error. 0 means no packets
 *          were currently available.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_UDP_Send
 * \sa SDLNet_UDP_RecvV
 *)
  SDLNet_UDP_Recv: function(sock: UDPsocket; packet: PUDPpacket): Integer; cdecl;

(**
 * Close a UDP socket.
 *
 * This disconnects the socket and frees any resources it retains.
 *
 * This socket may not be used again once given to this function.
 *
 * \param sock UDP socket to close.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_UDP_Close: procedure(sock: UDPsocket); cdecl;

(**
 * Allocate a socket set for use with SDLNet_CheckSockets().
 *
 * To query if new data is available on a socket, you use a "socket set" with
 * SDLNet_CheckSockets(). A socket set is just a list of sockets behind the
 * scenes; you allocate a set and then add/remove individual sockets to/from
 * the set.
 *
 * When done with a socket set, you can free it with SDLNet_FreeSocketSet.
 *
 * \param maxsockets the maximum amount of sockets to include in this set.
 * \returns a socket set for up to `maxsockets` sockets, or NULL if the
 *          function ran out of memory.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_FreeSocketSet
 *)
  SDLNet_AllocSocketSet: function(maxsockets: Integer): SDLNet_SocketSet; cdecl;

(**
 * Add a socket to a socket set, to be checked for available data.
 *
 * Generally you don't want to call this generic function, but rather the
 * specific, inline function that wraps it: SDLNet_TCP_AddSocket() or
 * SDLNet_UDP_AddSocket().
 *
 * This function will fail if you add a socket to the set when the set already
 * has its maximum number of sockets added, but otherwise it will always
 * succeed.
 *
 * If `sock` is NULL, nothing is added to the set; this lets you query the
 * number of sockets currently contained in the set.
 *
 * \param set the socket set to add a new socket to.
 * \param sock the socket to add to the set.
 * \returns the total number of sockets contained in the set (including this
 *          new one), or -1 if the set is already full.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_TCP_AddSocket
 * \sa SDLNet_UDP_AddSocket
 * \sa SDLNet_DelSocket
 * \sa SDLNet_TCP_DelSocket
 * \sa SDLNet_UDP_DelSocket
 * \sa SDLNet_CheckSockets
 *)
  SDLNet_AddSocket: function(set_: SDLNet_SocketSet; sock: SDLNet_GenericSocket): Integer; cdecl;

(**
 * Remove a socket from a set of sockets to be checked for available data.
 *
 * Generally you don't want to call this generic function, but rather the
 * specific, inline function that wraps it: SDLNet_TCP_DelSocket() or
 * SDLNet_UDP_DelSocket().
 *
 * If `sock` is NULL, nothing is removed from the set; this lets you query the
 * number of sockets currently contained in the set.
 *
 * This will return -1 if the socket was not found in the set; in such a case,
 * nothing is removed from the set.
 *
 * \param set the socket set to remove a socket from.
 * \param sock the socket to remove from the set.
 * \returns the total number of sockets contained in the set (after `sock`'s
 *          removal), or -1 if `sock` was not in the set.
 *
 * \since This function is available since SDL_net 2.0.0.
 *
 * \sa SDLNet_TCP_DelSocket
 * \sa SDLNet_UDP_DelSocket
 * \sa SDLNet_AddSocket
 * \sa SDLNet_TCP_AddSocket
 * \sa SDLNet_UDP_AddSocket
 * \sa SDLNet_CheckSockets
 *)
  SDLNet_DelSocket: function(set_: SDLNet_SocketSet; sock: SDLNet_GenericSocket): Integer; cdecl;

(**
 * Check a socket set for data availability.
 *
 * This function checks to see if data is available for reading on the given
 * set of sockets. If 'timeout' is 0, it performs a quick poll, otherwise the
 * function returns when either data is available for reading, or the timeout
 * in milliseconds has elapsed, whichever occurs first.
 *
 * \param set the socket set to check for ready sockets.
 * \param timeout the time to wait in milliseconds for new data to arrive. A
 *                timeout of zero checks for new data and returns without
 *                blocking.
 * \returns the number of sockets ready for reading, or -1 if there was an
 *          error with the select() system call.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_CheckSockets: function(set_: SDLNet_SocketSet; timeout: Uint32): Integer; cdecl;

(**
 * Free a set of sockets allocated by SDLNet_AllocSocketSet().
 *
 * When done with a socket set, call this function to free its resources.
 *
 * This only frees the socket set, not the individual sockets in the set,
 * which would still (at some future point) need to be closed with
 * SDLNet_TCP_Close or SDLNet_UDP_Close.
 *
 * \param set the socket set to free.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_FreeSocketSet: procedure(set_: SDLNet_SocketSet); cdecl;

(**
 * Set an error message to be retrieved with SDLNet_GetError.
 *
 * Generally you don't need to call this (SDL_net will use it internally to
 * report errors), but it could be useful if you need to inject an error
 * message of your own in here.
 *
 * \param fmt a printf-style format string for the error message.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_SetError: procedure(const fmt: PUTF8Char) varargs; cdecl;

(**
 * Get the latest error message from SDL_net.
 *
 * The error message, depending on how SDL_net was built, may or may not be
 * thread-local data. Sometimes things will set an error message when no
 * failure was reported; the error string is only meaningful right after a
 * public API reports a failure, and should be ignored otherwise.
 *
 * \returns the last set error message in UTF-8 encoding.
 *
 * \since This function is available since SDL_net 2.0.0.
 *)
  SDLNet_GetError: function(): PUTF8Char; cdecl;

(**
 * Query the version of SDL_ttf that the program is linked against.
 *
 * This function gets the version of the dynamically linked SDL_ttf library.
 * This is separate from the SDL_TTF_VERSION() macro, which tells you what
 * version of the SDL_ttf headers you compiled against.
 *
 * This returns static internal data; do not free or modify it!
 *
 * \returns a pointer to the version information.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_Linked_Version: function(): PSDL_version; cdecl;

(**
 * Query the version of the FreeType library in use.
 *
 * TTF_Init() should be called before calling this function.
 *
 * \param major to be filled in with the major version number. Can be NULL.
 * \param minor to be filled in with the minor version number. Can be NULL.
 * \param patch to be filled in with the param version number. Can be NULL.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_Init
 *)
  TTF_GetFreeTypeVersion: procedure(major: PInteger; minor: PInteger; patch: PInteger); cdecl;

(**
 * Query the version of the HarfBuzz library in use.
 *
 * If HarfBuzz is not available, the version reported is 0.0.0.
 *
 * \param major to be filled in with the major version number. Can be NULL.
 * \param minor to be filled in with the minor version number. Can be NULL.
 * \param patch to be filled in with the param version number. Can be NULL.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *)
  TTF_GetHarfBuzzVersion: procedure(major: PInteger; minor: PInteger; patch: PInteger); cdecl;

(**
 * Tell SDL_ttf whether UNICODE text is generally byteswapped.
 *
 * A UNICODE BOM character in a string will override this setting for the
 * remainder of that string.
 *
 * \param swapped boolean to indicate whether text is byteswapped
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_ByteSwappedUNICODE: procedure(swapped: SDL_bool); cdecl;

(**
 * Initialize SDL_ttf.
 *
 * You must successfully call this function before it is safe to call any
 * other function in this library, with one exception: a human-readable error
 * message can be retrieved from TTF_GetError() if this function fails.
 *
 * SDL must be initialized before calls to functions in this library, because
 * this library uses utility functions from the SDL library.
 *
 * It is safe to call this more than once; the library keeps a counter of init
 * calls, and decrements it on each call to TTF_Quit, so you must pair your
 * init and quit calls.
 *
 * \returns 0 on success, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_Quit
 *)
  TTF_Init: function(): Integer; cdecl;

(**
 * Create a font from a file, using a specified point size.
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.
 *
 * \param file path to font file.
 * \param ptsize point size to use for the newly-opened font.
 * \returns a valid TTF_Font, or NULL on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_CloseFont
 *)
  TTF_OpenFont: function(const file_: PUTF8Char; ptsize: Integer): PTTF_Font; cdecl;

(**
 * Create a font from a file, using a specified face index.
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * Some fonts have multiple "faces" included. The index specifies which face
 * to use from the font file. Font files with only one face should specify
 * zero for the index.
 *
 * When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.
 *
 * \param file path to font file.
 * \param ptsize point size to use for the newly-opened font.
 * \param index index of the face in the font file.
 * \returns a valid TTF_Font, or NULL on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_CloseFont
 *)
  TTF_OpenFontIndex: function(const file_: PUTF8Char; ptsize: Integer; index: Integer): PTTF_Font; cdecl;

(**
 * Create a font from an SDL_RWops, using a specified point size.
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_ttf reads everything it needs
 * from the RWops during this call in any case.
 *
 * When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.
 *
 * \param src an SDL_RWops to provide a font file's data.
 * \param freesrc non-zero to close the RWops before returning, zero to leave
 *                it open.
 * \param ptsize point size to use for the newly-opened font.
 * \returns a valid TTF_Font, or NULL on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_CloseFont
 *)
  TTF_OpenFontRW: function(src: PSDL_RWops; freesrc: Integer; ptsize: Integer): PTTF_Font; cdecl;

(**
 * Create a font from an SDL_RWops, using a specified face index.
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_ttf reads everything it needs
 * from the RWops during this call in any case.
 *
 * Some fonts have multiple "faces" included. The index specifies which face
 * to use from the font file. Font files with only one face should specify
 * zero for the index.
 *
 * When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.
 *
 * \param src an SDL_RWops to provide a font file's data.
 * \param freesrc non-zero to close the RWops before returning, zero to leave
 *                it open.
 * \param ptsize point size to use for the newly-opened font.
 * \param index index of the face in the font file.
 * \returns a valid TTF_Font, or NULL on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_CloseFont
 *)
  TTF_OpenFontIndexRW: function(src: PSDL_RWops; freesrc: Integer; ptsize: Integer; index: Integer): PTTF_Font; cdecl;

(**
 * Create a font from a file, using target resolutions (in DPI).
 *
 * DPI scaling only applies to scalable fonts (e.g. TrueType).
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.
 *
 * \param file path to font file.
 * \param ptsize point size to use for the newly-opened font.
 * \param hdpi the target horizontal DPI.
 * \param vdpi the target vertical DPI.
 * \returns a valid TTF_Font, or NULL on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_CloseFont
 *)
  TTF_OpenFontDPI: function(const file_: PUTF8Char; ptsize: Integer; hdpi: Cardinal; vdpi: Cardinal): PTTF_Font; cdecl;

(**
 * Create a font from a file, using target resolutions (in DPI).
 *
 * DPI scaling only applies to scalable fonts (e.g. TrueType).
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * Some fonts have multiple "faces" included. The index specifies which face
 * to use from the font file. Font files with only one face should specify
 * zero for the index.
 *
 * When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.
 *
 * \param file path to font file.
 * \param ptsize point size to use for the newly-opened font.
 * \param index index of the face in the font file.
 * \param hdpi the target horizontal DPI.
 * \param vdpi the target vertical DPI.
 * \returns a valid TTF_Font, or NULL on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_CloseFont
 *)
  TTF_OpenFontIndexDPI: function(const file_: PUTF8Char; ptsize: Integer; index: Integer; hdpi: Cardinal; vdpi: Cardinal): PTTF_Font; cdecl;

(**
 * Opens a font from an SDL_RWops with target resolutions (in DPI).
 *
 * DPI scaling only applies to scalable fonts (e.g. TrueType).
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_ttf reads everything it needs
 * from the RWops during this call in any case.
 *
 * When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.
 *
 * \param src an SDL_RWops to provide a font file's data.
 * \param freesrc non-zero to close the RWops before returning, zero to leave
 *                it open.
 * \param ptsize point size to use for the newly-opened font.
 * \param hdpi the target horizontal DPI.
 * \param vdpi the target vertical DPI.
 * \returns a valid TTF_Font, or NULL on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_CloseFont
 *)
  TTF_OpenFontDPIRW: function(src: PSDL_RWops; freesrc: Integer; ptsize: Integer; hdpi: Cardinal; vdpi: Cardinal): PTTF_Font; cdecl;

(**
 * Opens a font from an SDL_RWops with target resolutions (in DPI).
 *
 * DPI scaling only applies to scalable fonts (e.g. TrueType).
 *
 * Some .fon fonts will have several sizes embedded in the file, so the point
 * size becomes the index of choosing which size. If the value is too high,
 * the last indexed size will be the default.
 *
 * If `freesrc` is non-zero, the RWops will be closed before returning,
 * whether this function succeeds or not. SDL_ttf reads everything it needs
 * from the RWops during this call in any case.
 *
 * Some fonts have multiple "faces" included. The index specifies which face
 * to use from the font file. Font files with only one face should specify
 * zero for the index.
 *
 * When done with the returned TTF_Font, use TTF_CloseFont() to dispose of it.
 *
 * \param src an SDL_RWops to provide a font file's data.
 * \param freesrc non-zero to close the RWops before returning, zero to leave
 *                it open.
 * \param ptsize point size to use for the newly-opened font.
 * \param index index of the face in the font file.
 * \param hdpi the target horizontal DPI.
 * \param vdpi the target vertical DPI.
 * \returns a valid TTF_Font, or NULL on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_CloseFont
 *)
  TTF_OpenFontIndexDPIRW: function(src: PSDL_RWops; freesrc: Integer; ptsize: Integer; index: Integer; hdpi: Cardinal; vdpi: Cardinal): PTTF_Font; cdecl;

(**
 * Set a font's size dynamically.
 *
 * This clears already-generated glyphs, if any, from the cache.
 *
 * \param font the font to resize.
 * \param ptsize the new point size.
 * \returns 0 if successful, -1 on error
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *)
  TTF_SetFontSize: function(font: PTTF_Font; ptsize: Integer): Integer; cdecl;

(**
 * Set font size dynamically with target resolutions (in DPI).
 *
 * This clears already-generated glyphs, if any, from the cache.
 *
 * \param font the font to resize.
 * \param ptsize the new point size.
 * \param hdpi the target horizontal DPI.
 * \param vdpi the target vertical DPI.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *)
  TTF_SetFontSizeDPI: function(font: PTTF_Font; ptsize: Integer; hdpi: Cardinal; vdpi: Cardinal): Integer; cdecl;

(**
 * Query a font's current style.
 *
 * The font styles are a set of bit flags, OR'd together:
 *
 * - `TTF_STYLE_NORMAL` (is zero)
 * - `TTF_STYLE_BOLD`
 * - `TTF_STYLE_ITALIC`
 * - `TTF_STYLE_UNDERLINE`
 * - `TTF_STYLE_STRIKETHROUGH`
 *
 * \param font the font to query.
 * \returns the current font style, as a set of bit flags.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_SetFontStyle
 *)
  TTF_GetFontStyle: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Set a font's current style.
 *
 * Setting the style clears already-generated glyphs, if any, from the cache.
 *
 * The font styles are a set of bit flags, OR'd together:
 *
 * - `TTF_STYLE_NORMAL` (is zero)
 * - `TTF_STYLE_BOLD`
 * - `TTF_STYLE_ITALIC`
 * - `TTF_STYLE_UNDERLINE`
 * - `TTF_STYLE_STRIKETHROUGH`
 *
 * \param font the font to set a new style on.
 * \param style the new style values to set, OR'd together.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_GetFontStyle
 *)
  TTF_SetFontStyle: procedure(font: PTTF_Font; style: Integer); cdecl;

(**
 * Query a font's current outline.
 *
 * \param font the font to query.
 * \returns the font's current outline value.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_SetFontOutline
 *)
  TTF_GetFontOutline: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Set a font's current outline.
 *
 * \param font the font to set a new outline on.
 * \param outline positive outline value, 0 to default.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_GetFontOutline
 *)
  TTF_SetFontOutline: procedure(font: PTTF_Font; outline: Integer); cdecl;

(**
 * Query a font's current FreeType hinter setting.
 *
 * The hinter setting is a single value:
 *
 * - `TTF_HINTING_NORMAL`
 * - `TTF_HINTING_LIGHT`
 * - `TTF_HINTING_MONO`
 * - `TTF_HINTING_NONE`
 * - `TTF_HINTING_LIGHT_SUBPIXEL` (available in SDL_ttf 2.0.18 and later)
 *
 * \param font the font to query.
 * \returns the font's current hinter value.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_SetFontHinting
 *)
  TTF_GetFontHinting: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Set a font's current hinter setting.
 *
 * Setting it clears already-generated glyphs, if any, from the cache.
 *
 * The hinter setting is a single value:
 *
 * - `TTF_HINTING_NORMAL`
 * - `TTF_HINTING_LIGHT`
 * - `TTF_HINTING_MONO`
 * - `TTF_HINTING_NONE`
 * - `TTF_HINTING_LIGHT_SUBPIXEL` (available in SDL_ttf 2.0.18 and later)
 *
 * \param font the font to set a new hinter setting on.
 * \param hinting the new hinter setting.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_GetFontHinting
 *)
  TTF_SetFontHinting: procedure(font: PTTF_Font; hinting: Integer); cdecl;

(**
 * Query a font's current wrap alignment option.
 *
 * The wrap alignment option can be one of the following:
 *
 * - `TTF_WRAPPED_ALIGN_LEFT`
 * - `TTF_WRAPPED_ALIGN_CENTER`
 * - `TTF_WRAPPED_ALIGN_RIGHT`
 *
 * \param font the font to query.
 * \returns the font's current wrap alignment option.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_SetFontWrappedAlign
 *)
  TTF_GetFontWrappedAlign: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Set a font's current wrap alignment option.
 *
 * The wrap alignment option can be one of the following:
 *
 * - `TTF_WRAPPED_ALIGN_LEFT`
 * - `TTF_WRAPPED_ALIGN_CENTER`
 * - `TTF_WRAPPED_ALIGN_RIGHT`
 *
 * \param font the font to set a new wrap alignment option on.
 * \param align the new wrap alignment option.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_GetFontWrappedAlign
 *)
  TTF_SetFontWrappedAlign: procedure(font: PTTF_Font; align: Integer); cdecl;

(**
 * Query the total height of a font.
 *
 * This is usually equal to point size.
 *
 * \param font the font to query.
 * \returns the font's height.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_FontHeight: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Query the offset from the baseline to the top of a font.
 *
 * This is a positive value, relative to the baseline.
 *
 * \param font the font to query.
 * \returns the font's ascent.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_FontAscent: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Query the offset from the baseline to the bottom of a font.
 *
 * This is a negative value, relative to the baseline.
 *
 * \param font the font to query.
 * \returns the font's descent.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_FontDescent: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Query the recommended spacing between lines of text for a font.
 *
 * \param font the font to query.
 * \returns the font's recommended spacing.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_FontLineSkip: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Query whether or not kerning is allowed for a font.
 *
 * \param font the font to query.
 * \returns non-zero if kerning is enabled, zero otherwise.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_GetFontKerning: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Set if kerning is allowed for a font.
 *
 * Newly-opened fonts default to allowing kerning. This is generally a good
 * policy unless you have a strong reason to disable it, as it tends to
 * produce better rendering (with kerning disabled, some fonts might render
 * the word `kerning` as something that looks like `keming` for example).
 *
 * \param font the font to set kerning on.
 * \param allowed non-zero to allow kerning, zero to disallow.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_SetFontKerning: procedure(font: PTTF_Font; allowed: Integer); cdecl;

(**
 * Query the number of faces of a font.
 *
 * \param font the font to query.
 * \returns the number of FreeType font faces.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_FontFaces: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Query whether a font is fixed-width.
 *
 * A "fixed-width" font means all glyphs are the same width across; a
 * lowercase 'i' will be the same size across as a capital 'W', for example.
 * This is common for terminals and text editors, and other apps that treat
 * text as a grid. Most other things (WYSIWYG word processors, web pages, etc)
 * are more likely to not be fixed-width in most cases.
 *
 * \param font the font to query.
 * \returns non-zero if fixed-width, zero if not.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_FontFaceIsFixedWidth: function(const font: PTTF_Font): Integer; cdecl;

(**
 * Query a font's family name.
 *
 * This string is dictated by the contents of the font file.
 *
 * Note that the returned string is to internal storage, and should not be
 * modifed or free'd by the caller. The string becomes invalid, with the rest
 * of the font, when `font` is handed to TTF_CloseFont().
 *
 * \param font the font to query.
 * \returns the font's family name.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_FontFaceFamilyName: function(const font: PTTF_Font): PUTF8Char; cdecl;

(**
 * Query a font's style name.
 *
 * This string is dictated by the contents of the font file.
 *
 * Note that the returned string is to internal storage, and should not be
 * modifed or free'd by the caller. The string becomes invalid, with the rest
 * of the font, when `font` is handed to TTF_CloseFont().
 *
 * \param font the font to query.
 * \returns the font's style name.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_FontFaceStyleName: function(const font: PTTF_Font): PUTF8Char; cdecl;

(**
 * Check whether a glyph is provided by the font for a 16-bit codepoint.
 *
 * Note that this version of the function takes a 16-bit character code, which
 * covers the Basic Multilingual Plane, but is insufficient to cover the
 * entire set of possible Unicode values, including emoji glyphs. You should
 * use TTF_GlyphIsProvided32() instead, which offers the same functionality
 * but takes a 32-bit codepoint instead.
 *
 * The only reason to use this function is that it was available since the
 * beginning of time, more or less.
 *
 * \param font the font to query.
 * \param ch the character code to check.
 * \returns non-zero if font provides a glyph for this character, zero if not.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_GlyphIsProvided32
 *)
  TTF_GlyphIsProvided: function(font: PTTF_Font; ch: Uint16): Integer; cdecl;

(**
 * Check whether a glyph is provided by the font for a 32-bit codepoint.
 *
 * This is the same as TTF_GlyphIsProvided(), but takes a 32-bit character
 * instead of 16-bit, and thus can query a larger range. If you are sure
 * you'll have an SDL_ttf that's version 2.0.18 or newer, there's no reason
 * not to use this function exclusively.
 *
 * \param font the font to query.
 * \param ch the character code to check.
 * \returns non-zero if font provides a glyph for this character, zero if not.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *)
  TTF_GlyphIsProvided32: function(font: PTTF_Font; ch: Uint32): Integer; cdecl;

(**
 * Query the metrics (dimensions) of a font's 16-bit glyph.
 *
 * To understand what these metrics mean, here is a useful link:
 *
 * https://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html
 *
 * Note that this version of the function takes a 16-bit character code, which
 * covers the Basic Multilingual Plane, but is insufficient to cover the
 * entire set of possible Unicode values, including emoji glyphs. You should
 * use TTF_GlyphMetrics32() instead, which offers the same functionality but
 * takes a 32-bit codepoint instead.
 *
 * The only reason to use this function is that it was available since the
 * beginning of time, more or less.
 *
 * \param font the font to query.
 * \param ch the character code to check.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_GlyphMetrics32
 *)
  TTF_GlyphMetrics: function(font: PTTF_Font; ch: Uint16; minx: PInteger; maxx: PInteger; miny: PInteger; maxy: PInteger; advance: PInteger): Integer; cdecl;

(**
 * Query the metrics (dimensions) of a font's 32-bit glyph.
 *
 * To understand what these metrics mean, here is a useful link:
 *
 * https://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html
 *
 * This is the same as TTF_GlyphMetrics(), but takes a 32-bit character
 * instead of 16-bit, and thus can query a larger range. If you are sure
 * you'll have an SDL_ttf that's version 2.0.18 or newer, there's no reason
 * not to use this function exclusively.
 *
 * \param font the font to query.
 * \param ch the character code to check.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *)
  TTF_GlyphMetrics32: function(font: PTTF_Font; ch: Uint32; minx: PInteger; maxx: PInteger; miny: PInteger; maxy: PInteger; advance: PInteger): Integer; cdecl;

(**
 * Calculate the dimensions of a rendered string of Latin1 text.
 *
 * This will report the width and height, in pixels, of the space that the
 * specified string will take to fully render.
 *
 * This does not need to render the string to do this calculation.
 *
 * You almost certainly want TTF_SizeUTF8() unless you're sure you have a
 * 1-byte Latin1 encoding. US ASCII characters will work with either function,
 * but most other Unicode characters packed into a `const char *` will need
 * UTF-8.
 *
 * \param font the font to query.
 * \param text text to calculate, in Latin1 encoding.
 * \param w will be filled with width, in pixels, on return.
 * \param h will be filled with height, in pixels, on return.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_SizeUTF8
 * \sa TTF_SizeUNICODE
 *)
  TTF_SizeText: function(font: PTTF_Font; const text: PUTF8Char; w: PInteger; h: PInteger): Integer; cdecl;

(**
 * Calculate the dimensions of a rendered string of UTF-8 text.
 *
 * This will report the width and height, in pixels, of the space that the
 * specified string will take to fully render.
 *
 * This does not need to render the string to do this calculation.
 *
 * \param font the font to query.
 * \param text text to calculate, in Latin1 encoding.
 * \param w will be filled with width, in pixels, on return.
 * \param h will be filled with height, in pixels, on return.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_SizeUNICODE
 *)
  TTF_SizeUTF8: function(font: PTTF_Font; const text: PUTF8Char; w: PInteger; h: PInteger): Integer; cdecl;

(**
 * Calculate the dimensions of a rendered string of UCS-2 text.
 *
 * This will report the width and height, in pixels, of the space that the
 * specified string will take to fully render.
 *
 * This does not need to render the string to do this calculation.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * \param font the font to query.
 * \param text text to calculate, in UCS-2 encoding.
 * \param w will be filled with width, in pixels, on return.
 * \param h will be filled with height, in pixels, on return.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_SizeUTF8
 *)
  TTF_SizeUNICODE: function(font: PTTF_Font; const text: PUint16; w: PInteger; h: PInteger): Integer; cdecl;

(**
 * Calculate how much of a Latin1 string will fit in a given width.
 *
 * This reports the number of characters that can be rendered before reaching
 * `measure_width`.
 *
 * This does not need to render the string to do this calculation.
 *
 * You almost certainly want TTF_MeasureUTF8() unless you're sure you have a
 * 1-byte Latin1 encoding. US ASCII characters will work with either function,
 * but most other Unicode characters packed into a `const char *` will need
 * UTF-8.
 *
 * \param font the font to query.
 * \param text text to calculate, in Latin1 encoding.
 * \param measure_width maximum width, in pixels, available for the string.
 * \param count on return, filled with number of characters that can be
 *              rendered.
 * \param extent on return, filled with latest calculated width.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_MeasureText
 * \sa TTF_MeasureUTF8
 * \sa TTF_MeasureUNICODE
 *)
  TTF_MeasureText: function(font: PTTF_Font; const text: PUTF8Char; measure_width: Integer; extent: PInteger; count: PInteger): Integer; cdecl;

(**
 * Calculate how much of a UTF-8 string will fit in a given width.
 *
 * This reports the number of characters that can be rendered before reaching
 * `measure_width`.
 *
 * This does not need to render the string to do this calculation.
 *
 * \param font the font to query.
 * \param text text to calculate, in UTF-8 encoding.
 * \param measure_width maximum width, in pixels, available for the string.
 * \param count on return, filled with number of characters that can be
 *              rendered.
 * \param extent on return, filled with latest calculated width.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_MeasureText
 * \sa TTF_MeasureUTF8
 * \sa TTF_MeasureUNICODE
 *)
  TTF_MeasureUTF8: function(font: PTTF_Font; const text: PUTF8Char; measure_width: Integer; extent: PInteger; count: PInteger): Integer; cdecl;

(**
 * Calculate how much of a UCS-2 string will fit in a given width.
 *
 * This reports the number of characters that can be rendered before reaching
 * `measure_width`.
 *
 * This does not need to render the string to do this calculation.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * \param font the font to query.
 * \param text text to calculate, in UCS-2 encoding.
 * \param measure_width maximum width, in pixels, available for the string.
 * \param count on return, filled with number of characters that can be
 *              rendered.
 * \param extent on return, filled with latest calculated width.
 * \returns 0 if successful, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_MeasureText
 * \sa TTF_MeasureUTF8
 * \sa TTF_MeasureUNICODE
 *)
  TTF_MeasureUNICODE: function(font: PTTF_Font; const text: PUint16; measure_width: Integer; extent: PInteger; count: PInteger): Integer; cdecl;

(**
 * Render Latin1 text at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderText_Solid_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You almost certainly want TTF_RenderUTF8_Solid() unless you're sure you
 * have a 1-byte Latin1 encoding. US ASCII characters will work with either
 * function, but most other Unicode characters packed into a `const char *`
 * will need UTF-8.
 *
 * You can render at other quality levels with TTF_RenderText_Shaded,
 * TTF_RenderText_Blended, and TTF_RenderText_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in Latin1 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUTF8_Solid
 * \sa TTF_RenderUNICODE_Solid
 *)
  TTF_RenderText_Solid: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render UTF-8 text at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderUTF8_Solid_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You can render at other quality levels with TTF_RenderUTF8_Shaded,
 * TTF_RenderUTF8_Blended, and TTF_RenderUTF8_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in UTF-8 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUTF8_Shaded
 * \sa TTF_RenderUTF8_Blended
 * \sa TTF_RenderUTF8_LCD
 *)
  TTF_RenderUTF8_Solid: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render UCS-2 text at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderUNICODE_Solid_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * You can render at other quality levels with TTF_RenderUNICODE_Shaded,
 * TTF_RenderUNICODE_Blended, and TTF_RenderUNICODE_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in UCS-2 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUTF8_Solid
 *)
  TTF_RenderUNICODE_Solid: function(font: PTTF_Font; const text: PUint16; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render word-wrapped Latin1 text at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You almost certainly want TTF_RenderUTF8_Solid_Wrapped() unless you're sure
 * you have a 1-byte Latin1 encoding. US ASCII characters will work with
 * either function, but most other Unicode characters packed into a `const
 * char *` will need UTF-8.
 *
 * You can render at other quality levels with TTF_RenderText_Shaded_Wrapped,
 * TTF_RenderText_Blended_Wrapped, and TTF_RenderText_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in Latin1 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Solid_Wrapped
 * \sa TTF_RenderUNICODE_Solid_Wrapped
 *)
  TTF_RenderText_Solid_Wrapped: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render word-wrapped UTF-8 text at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You can render at other quality levels with TTF_RenderUTF8_Shaded_Wrapped,
 * TTF_RenderUTF8_Blended_Wrapped, and TTF_RenderUTF8_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in UTF-8 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Shaded_Wrapped
 * \sa TTF_RenderUTF8_Blended_Wrapped
 * \sa TTF_RenderUTF8_LCD_Wrapped
 *)
  TTF_RenderUTF8_Solid_Wrapped: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render word-wrapped UCS-2 text at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * You can render at other quality levels with
 * TTF_RenderUNICODE_Shaded_Wrapped, TTF_RenderUNICODE_Blended_Wrapped, and
 * TTF_RenderUNICODE_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in UCS-2 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Solid_Wrapped
 *)
  TTF_RenderUNICODE_Solid_Wrapped: function(font: PTTF_Font; const text: PUint16; fg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render a single 16-bit glyph at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * Note that this version of the function takes a 16-bit character code, which
 * covers the Basic Multilingual Plane, but is insufficient to cover the
 * entire set of possible Unicode values, including emoji glyphs. You should
 * use TTF_RenderGlyph32_Solid() instead, which offers the same functionality
 * but takes a 32-bit codepoint instead.
 *
 * The only reason to use this function is that it was available since the
 * beginning of time, more or less.
 *
 * You can render at other quality levels with TTF_RenderGlyph_Shaded,
 * TTF_RenderGlyph_Blended, and TTF_RenderGlyph_LCD.
 *
 * \param font the font to render with.
 * \param ch the character to render.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderGlyph32_Solid
 *)
  TTF_RenderGlyph_Solid: function(font: PTTF_Font; ch: Uint16; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render a single 32-bit glyph at fast quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the colorkey, giving a transparent background. The 1 pixel
 * will be set to the text color.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * This is the same as TTF_RenderGlyph_Solid(), but takes a 32-bit character
 * instead of 16-bit, and thus can render a larger range. If you are sure
 * you'll have an SDL_ttf that's version 2.0.18 or newer, there's no reason
 * not to use this function exclusively.
 *
 * You can render at other quality levels with TTF_RenderGlyph32_Shaded,
 * TTF_RenderGlyph32_Blended, and TTF_RenderGlyph32_LCD.
 *
 * \param font the font to render with.
 * \param ch the character to render.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderGlyph32_Shaded
 * \sa TTF_RenderGlyph32_Blended
 * \sa TTF_RenderGlyph32_LCD
 *)
  TTF_RenderGlyph32_Solid: function(font: PTTF_Font; ch: Uint32; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render Latin1 text at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderText_Shaded_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You almost certainly want TTF_RenderUTF8_Shaded() unless you're sure you
 * have a 1-byte Latin1 encoding. US ASCII characters will work with either
 * function, but most other Unicode characters packed into a `const char *`
 * will need UTF-8.
 *
 * You can render at other quality levels with TTF_RenderText_Solid,
 * TTF_RenderText_Blended, and TTF_RenderText_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in Latin1 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUTF8_Shaded
 * \sa TTF_RenderUNICODE_Shaded
 *)
  TTF_RenderText_Shaded: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render UTF-8 text at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderUTF8_Shaded_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You can render at other quality levels with TTF_RenderUTF8_Solid,
 * TTF_RenderUTF8_Blended, and TTF_RenderUTF8_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in UTF-8 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUNICODE_Shaded
 *)
  TTF_RenderUTF8_Shaded: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render UCS-2 text at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderUNICODE_Shaded_Wrapped() instead if you need to wrap the output
 * to multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * You can render at other quality levels with TTF_RenderUNICODE_Solid,
 * TTF_RenderUNICODE_Blended, and TTF_RenderUNICODE_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in UCS-2 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUTF8_Shaded
 *)
  TTF_RenderUNICODE_Shaded: function(font: PTTF_Font; const text: PUint16; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render word-wrapped Latin1 text at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You almost certainly want TTF_RenderUTF8_Shaded_Wrapped() unless you're
 * sure you have a 1-byte Latin1 encoding. US ASCII characters will work with
 * either function, but most other Unicode characters packed into a `const
 * char *` will need UTF-8.
 *
 * You can render at other quality levels with TTF_RenderText_Solid_Wrapped,
 * TTF_RenderText_Blended_Wrapped, and TTF_RenderText_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in Latin1 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Shaded_Wrapped
 * \sa TTF_RenderUNICODE_Shaded_Wrapped
 *)
  TTF_RenderText_Shaded_Wrapped: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; bg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render word-wrapped UTF-8 text at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You can render at other quality levels with TTF_RenderUTF8_Solid_Wrapped,
 * TTF_RenderUTF8_Blended_Wrapped, and TTF_RenderUTF8_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in UTF-8 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Solid_Wrapped
 * \sa TTF_RenderUTF8_Blended_Wrapped
 * \sa TTF_RenderUTF8_LCD_Wrapped
 *)
  TTF_RenderUTF8_Shaded_Wrapped: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; bg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render word-wrapped UCS-2 text at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * You can render at other quality levels with
 * TTF_RenderUNICODE_Solid_Wrapped, TTF_RenderUNICODE_Blended_Wrapped, and
 * TTF_RenderUNICODE_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in UCS-2 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Shaded_Wrapped
 *)
  TTF_RenderUNICODE_Shaded_Wrapped: function(font: PTTF_Font; const text: PUint16; fg: SDL_Color; bg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render a single 16-bit glyph at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or NULL if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * Note that this version of the function takes a 16-bit character code, which
 * covers the Basic Multilingual Plane, but is insufficient to cover the
 * entire set of possible Unicode values, including emoji glyphs. You should
 * use TTF_RenderGlyph32_Shaded() instead, which offers the same functionality
 * but takes a 32-bit codepoint instead.
 *
 * The only reason to use this function is that it was available since the
 * beginning of time, more or less.
 *
 * You can render at other quality levels with TTF_RenderGlyph_Solid,
 * TTF_RenderGlyph_Blended, and TTF_RenderGlyph_LCD.
 *
 * \param font the font to render with.
 * \param ch the character to render.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderGlyph32_Shaded
 *)
  TTF_RenderGlyph_Shaded: function(font: PTTF_Font; ch: Uint16; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render a single 32-bit glyph at high quality to a new 8-bit surface.
 *
 * This function will allocate a new 8-bit, palettized surface. The surface's
 * 0 pixel will be the specified background color, while other pixels have
 * varying degrees of the foreground color. This function returns the new
 * surface, or NULL if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * This is the same as TTF_RenderGlyph_Shaded(), but takes a 32-bit character
 * instead of 16-bit, and thus can render a larger range. If you are sure
 * you'll have an SDL_ttf that's version 2.0.18 or newer, there's no reason
 * not to use this function exclusively.
 *
 * You can render at other quality levels with TTF_RenderGlyph32_Solid,
 * TTF_RenderGlyph32_Blended, and TTF_RenderGlyph32_LCD.
 *
 * \param font the font to render with.
 * \param ch the character to render.
 * \param fg the foreground color for the text.
 * \returns a new 8-bit, palettized surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderGlyph32_Solid
 * \sa TTF_RenderGlyph32_Blended
 * \sa TTF_RenderGlyph32_LCD
 *)
  TTF_RenderGlyph32_Shaded: function(font: PTTF_Font; ch: Uint32; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render Latin1 text at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderText_Blended_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You almost certainly want TTF_RenderUTF8_Blended() unless you're sure you
 * have a 1-byte Latin1 encoding. US ASCII characters will work with either
 * function, but most other Unicode characters packed into a `const char *`
 * will need UTF-8.
 *
 * You can render at other quality levels with TTF_RenderText_Solid,
 * TTF_RenderText_Blended, and TTF_RenderText_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in Latin1 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUTF8_Shaded
 * \sa TTF_RenderUNICODE_Shaded
 *)
  TTF_RenderText_Blended: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render UTF-8 text at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderUTF8_Blended_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You can render at other quality levels with TTF_RenderUTF8_Solid,
 * TTF_RenderUTF8_Shaded, and TTF_RenderUTF8_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in UTF-8 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUNICODE_Blended
 *)
  TTF_RenderUTF8_Blended: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render UCS-2 text at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderUNICODE_Blended_Wrapped() instead if you need to wrap the output
 * to multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * You can render at other quality levels with TTF_RenderUNICODE_Solid,
 * TTF_RenderUNICODE_Shaded, and TTF_RenderUNICODE_LCD.
 *
 * \param font the font to render with.
 * \param text text to render, in UCS-2 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderUTF8_Blended
 *)
  TTF_RenderUNICODE_Blended: function(font: PTTF_Font; const text: PUint16; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render word-wrapped Latin1 text at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You almost certainly want TTF_RenderUTF8_Blended_Wrapped() unless you're
 * sure you have a 1-byte Latin1 encoding. US ASCII characters will work with
 * either function, but most other Unicode characters packed into a `const
 * char *` will need UTF-8.
 *
 * You can render at other quality levels with TTF_RenderText_Solid_Wrapped,
 * TTF_RenderText_Shaded_Wrapped, and TTF_RenderText_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in Latin1 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Blended_Wrapped
 * \sa TTF_RenderUNICODE_Blended_Wrapped
 *)
  TTF_RenderText_Blended_Wrapped: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render word-wrapped UTF-8 text at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You can render at other quality levels with TTF_RenderUTF8_Solid_Wrapped,
 * TTF_RenderUTF8_Shaded_Wrapped, and TTF_RenderUTF8_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in UTF-8 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Solid_Wrapped
 * \sa TTF_RenderUTF8_Shaded_Wrapped
 * \sa TTF_RenderUTF8_LCD_Wrapped
 *)
  TTF_RenderUTF8_Blended_Wrapped: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render word-wrapped UCS-2 text at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * You can render at other quality levels with
 * TTF_RenderUNICODE_Solid_Wrapped, TTF_RenderUNICODE_Shaded_Wrapped, and
 * TTF_RenderUNICODE_LCD_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in UCS-2 encoding.
 * \param fg the foreground color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderUTF8_Blended_Wrapped
 *)
  TTF_RenderUNICODE_Blended_Wrapped: function(font: PTTF_Font; const text: PUint16; fg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render a single 16-bit glyph at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or NULL if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * Note that this version of the function takes a 16-bit character code, which
 * covers the Basic Multilingual Plane, but is insufficient to cover the
 * entire set of possible Unicode values, including emoji glyphs. You should
 * use TTF_RenderGlyph32_Blended() instead, which offers the same
 * functionality but takes a 32-bit codepoint instead.
 *
 * The only reason to use this function is that it was available since the
 * beginning of time, more or less.
 *
 * You can render at other quality levels with TTF_RenderGlyph_Solid,
 * TTF_RenderGlyph_Shaded, and TTF_RenderGlyph_LCD.
 *
 * \param font the font to render with.
 * \param ch the character to render.
 * \param fg the foreground color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_RenderGlyph32_Blended
 *)
  TTF_RenderGlyph_Blended: function(font: PTTF_Font; ch: Uint16; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render a single 32-bit glyph at high quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, using alpha
 * blending to dither the font with the given color. This function returns the
 * new surface, or NULL if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * This is the same as TTF_RenderGlyph_Blended(), but takes a 32-bit character
 * instead of 16-bit, and thus can render a larger range. If you are sure
 * you'll have an SDL_ttf that's version 2.0.18 or newer, there's no reason
 * not to use this function exclusively.
 *
 * You can render at other quality levels with TTF_RenderGlyph32_Solid,
 * TTF_RenderGlyph32_Shaded, and TTF_RenderGlyph32_LCD.
 *
 * \param font the font to render with.
 * \param ch the character to render.
 * \param fg the foreground color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_RenderGlyph32_Solid
 * \sa TTF_RenderGlyph32_Shaded
 * \sa TTF_RenderGlyph32_LCD
 *)
  TTF_RenderGlyph32_Blended: function(font: PTTF_Font; ch: Uint32; fg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render Latin1 text at LCD subpixel quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderText_LCD_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You almost certainly want TTF_RenderUTF8_LCD() unless you're sure you have
 * a 1-byte Latin1 encoding. US ASCII characters will work with either
 * function, but most other Unicode characters packed into a `const char *`
 * will need UTF-8.
 *
 * You can render at other quality levels with TTF_RenderText_Solid,
 * TTF_RenderText_Shaded, and TTF_RenderText_Blended.
 *
 * \param font the font to render with.
 * \param text text to render, in Latin1 encoding.
 * \param fg the foreground color for the text.
 * \param bg the background color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_RenderUTF8_LCD
 * \sa TTF_RenderUNICODE_LCD
 *)
  TTF_RenderText_LCD: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render UTF-8 text at LCD subpixel quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderUTF8_LCD_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * You can render at other quality levels with TTF_RenderUTF8_Solid,
 * TTF_RenderUTF8_Shaded, and TTF_RenderUTF8_Blended.
 *
 * \param font the font to render with.
 * \param text text to render, in UTF-8 encoding.
 * \param fg the foreground color for the text.
 * \param bg the background color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_RenderUNICODE_LCD
 *)
  TTF_RenderUTF8_LCD: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render UCS-2 text at LCD subpixel quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or NULL if there was an error.
 *
 * This will not word-wrap the string; you'll get a surface with a single line
 * of text, as long as the string requires. You can use
 * TTF_RenderUNICODE_LCD_Wrapped() instead if you need to wrap the output to
 * multiple lines.
 *
 * This will not wrap on newline characters.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * You can render at other quality levels with TTF_RenderUNICODE_Solid,
 * TTF_RenderUNICODE_Shaded, and TTF_RenderUNICODE_Blended.
 *
 * \param font the font to render with.
 * \param text text to render, in UCS-2 encoding.
 * \param fg the foreground color for the text.
 * \param bg the background color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_RenderUTF8_LCD
 *)
  TTF_RenderUNICODE_LCD: function(font: PTTF_Font; const text: PUint16; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render word-wrapped Latin1 text at LCD subpixel quality to a new ARGB
 * surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You almost certainly want TTF_RenderUTF8_LCD_Wrapped() unless you're sure
 * you have a 1-byte Latin1 encoding. US ASCII characters will work with
 * either function, but most other Unicode characters packed into a `const
 * char *` will need UTF-8.
 *
 * You can render at other quality levels with TTF_RenderText_Solid_Wrapped,
 * TTF_RenderText_Shaded_Wrapped, and TTF_RenderText_Blended_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in Latin1 encoding.
 * \param fg the foreground color for the text.
 * \param bg the background color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_RenderUTF8_LCD_Wrapped
 * \sa TTF_RenderUNICODE_LCD_Wrapped
 *)
  TTF_RenderText_LCD_Wrapped: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; bg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render word-wrapped UTF-8 text at LCD subpixel quality to a new ARGB
 * surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * You can render at other quality levels with TTF_RenderUTF8_Solid_Wrapped,
 * TTF_RenderUTF8_Shaded_Wrapped, and TTF_RenderUTF8_Blended_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in UTF-8 encoding.
 * \param fg the foreground color for the text.
 * \param bg the background color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_RenderUTF8_Solid_Wrapped
 * \sa TTF_RenderUTF8_Shaded_Wrapped
 * \sa TTF_RenderUTF8_Blended_Wrapped
 *)
  TTF_RenderUTF8_LCD_Wrapped: function(font: PTTF_Font; const text: PUTF8Char; fg: SDL_Color; bg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render word-wrapped UCS-2 text at LCD subpixel quality to a new ARGB
 * surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or NULL if there was an error.
 *
 * Text is wrapped to multiple lines on line endings and on word boundaries if
 * it extends beyond `wrapLength` in pixels.
 *
 * If wrapLength is 0, this function will only wrap on newline characters.
 *
 * Please note that this function is named "Unicode" but currently expects
 * UCS-2 encoding (16 bits per codepoint). This does not give you access to
 * large Unicode values, such as emoji glyphs. These codepoints are accessible
 * through the UTF-8 version of this function.
 *
 * You can render at other quality levels with
 * TTF_RenderUNICODE_Solid_Wrapped, TTF_RenderUNICODE_Shaded_Wrapped, and
 * TTF_RenderUNICODE_Blended_Wrapped.
 *
 * \param font the font to render with.
 * \param text text to render, in UCS-2 encoding.
 * \param fg the foreground color for the text.
 * \param bg the background color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_RenderUTF8_LCD_Wrapped
 *)
  TTF_RenderUNICODE_LCD_Wrapped: function(font: PTTF_Font; const text: PUint16; fg: SDL_Color; bg: SDL_Color; wrapLength: Uint32): PSDL_Surface; cdecl;

(**
 * Render a single 16-bit glyph at LCD subpixel quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or NULL if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * Note that this version of the function takes a 16-bit character code, which
 * covers the Basic Multilingual Plane, but is insufficient to cover the
 * entire set of possible Unicode values, including emoji glyphs. You should
 * use TTF_RenderGlyph32_LCD() instead, which offers the same functionality
 * but takes a 32-bit codepoint instead.
 *
 * This function only exists for consistency with the existing API at the time
 * of its addition.
 *
 * You can render at other quality levels with TTF_RenderGlyph_Solid,
 * TTF_RenderGlyph_Shaded, and TTF_RenderGlyph_Blended.
 *
 * \param font the font to render with.
 * \param ch the character to render.
 * \param fg the foreground color for the text.
 * \param bg the background color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_RenderGlyph32_LCD
 *)
  TTF_RenderGlyph_LCD: function(font: PTTF_Font; ch: Uint16; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Render a single 32-bit glyph at LCD subpixel quality to a new ARGB surface.
 *
 * This function will allocate a new 32-bit, ARGB surface, and render
 * alpha-blended text using FreeType's LCD subpixel rendering. This function
 * returns the new surface, or NULL if there was an error.
 *
 * The glyph is rendered without any padding or centering in the X direction,
 * and aligned normally in the Y direction.
 *
 * This is the same as TTF_RenderGlyph_LCD(), but takes a 32-bit character
 * instead of 16-bit, and thus can render a larger range. Between the two, you
 * should always use this function.
 *
 * You can render at other quality levels with TTF_RenderGlyph32_Solid,
 * TTF_RenderGlyph32_Shaded, and TTF_RenderGlyph32_Blended.
 *
 * \param font the font to render with.
 * \param ch the character to render.
 * \param fg the foreground color for the text.
 * \param bg the background color for the text.
 * \returns a new 32-bit, ARGB surface, or NULL if there was an error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *
 * \sa TTF_RenderGlyph32_Solid
 * \sa TTF_RenderGlyph32_Shaded
 * \sa TTF_RenderGlyph32_Blended
 *)
  TTF_RenderGlyph32_LCD: function(font: PTTF_Font; ch: Uint32; fg: SDL_Color; bg: SDL_Color): PSDL_Surface; cdecl;

(**
 * Dispose of a previously-created font.
 *
 * Call this when done with a font. This function will free any resources
 * associated with it.
 *
 * The font is not valid after being passed to this function. String pointers
 * from functions that return information on this font, such as
 * TTF_FontFaceFamilyName() and TTF_FontFaceStyleName(), are no longer valid
 * after this call, as well.
 *
 * \param font the font to dispose of.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_OpenFontIndexDPIRW
 * \sa TTF_OpenFontRW
 * \sa TTF_OpenFontDPI
 * \sa TTF_OpenFontDPIRW
 * \sa TTF_OpenFontIndex
 * \sa TTF_OpenFontIndexDPI
 * \sa TTF_OpenFontIndexDPIRW
 * \sa TTF_OpenFontIndexRW
 *)
  TTF_CloseFont: procedure(font: PTTF_Font); cdecl;

(**
 * Deinitialize SDL_ttf.
 *
 * You must call this when done with the library, to free internal resources.
 * It is safe to call this when the library isn't initialized, as it will just
 * return immediately.
 *
 * Once you have as many quit calls as you have had successful calls to
 * TTF_Init, the library will actually deinitialize.
 *
 * Please note that this does not automatically close any fonts that are still
 * open at the time of deinitialization, and it is possibly not safe to close
 * them afterwards, as parts of the library will no longer be initialized to
 * deal with it. A well-written program should call TTF_CloseFont() on any
 * open fonts before calling this function!
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *)
  TTF_Quit: procedure(); cdecl;

(**
 * Check if SDL_ttf is initialized.
 *
 * This reports the number of times the library has been initialized by a call
 * to TTF_Init(), without a paired deinitialization request from TTF_Quit().
 *
 * In short: if it's greater than zero, the library is currently initialized
 * and ready to work. If zero, it is not initialized.
 *
 * Despite the return value being a signed integer, this function should not
 * return a negative number.
 *
 * \returns the current number of initialization calls, that need to
 *          eventually be paired with this many calls to TTF_Quit().
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_Init
 * \sa TTF_Quit
 *)
  TTF_WasInit: function(): Integer; cdecl;

(**
 * Query the kerning size of two glyphs indices.
 *
 * \deprecated This function accidentally requires FreeType font indexes,
 *             not codepoints, which we don't expose through this API, so
 *             it could give wildly incorrect results, especially with
 *             non-ASCII values. Going forward, please use
 *             TTF_GetFontKerningSizeGlyphs() instead, which does what you
 *             probably expected this function to do.
 *
 * \param font the font to query.
 * \param prev_index the font index, NOT codepoint, of the previous character.
 * \param index the font index, NOT codepoint, of the current character.
 * \returns The kerning size between the two specified characters, in pixels, or -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.12.
 *
 * \sa TTF_GetFontKerningSizeGlyphs
 *)
  TTF_GetFontKerningSize: function(font: PTTF_Font; prev_index: Integer; index: Integer): Integer; cdecl;

(**
 * Query the kerning size of two 16-bit glyphs.
 *
 * Note that this version of the function takes 16-bit character
 * codes, which covers the Basic Multilingual Plane, but is insufficient
 * to cover the entire set of possible Unicode values, including emoji
 * glyphs. You should use TTF_GetFontKerningSizeGlyphs32() instead, which
 * offers the same functionality but takes a 32-bit codepoints instead.
 *
 * The only reason to use this function is that it was available since
 * the beginning of time, more or less.
 *
 * \param font the font to query.
 * \param previous_ch the previous character's code, 16 bits.
 * \param ch the current character's code, 16 bits.
 * \returns The kerning size between the two specified characters, in pixels, or -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.14.
 *
 * \sa TTF_GetFontKerningSizeGlyphs32
 *)
  TTF_GetFontKerningSizeGlyphs: function(font: PTTF_Font; previous_ch: Uint16; ch: Uint16): Integer; cdecl;

(**
 * Query the kerning size of two 32-bit glyphs.
 *
 * This is the same as TTF_GetFontKerningSizeGlyphs(), but takes 32-bit
 * characters instead of 16-bit, and thus can manage a larger range. If
 * you are sure you'll have an SDL_ttf that's version 2.0.18 or newer,
 * there's no reason not to use this function exclusively.
 *
 * \param font the font to query.
 * \param previous_ch the previous character's code, 32 bits.
 * \param ch the current character's code, 32 bits.
 * \returns The kerning size between the two specified characters, in pixels, or -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *)
  TTF_GetFontKerningSizeGlyphs32: function(font: PTTF_Font; previous_ch: Uint32; ch: Uint32): Integer; cdecl;

(**
 * Enable Signed Distance Field rendering for a font.
 *
 * This works with the Blended APIs. SDF is a technique that
 * helps fonts look sharp even when scaling and rotating.
 *
 * This clears already-generated glyphs, if any, from the cache.
 *
 * \param font the font to set SDF support on.
 * \param on_off SDL_TRUE to enable SDF, SDL_FALSE to disable.
 *
 * \returns 0 on success, -1 on error.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_GetFontSDF
 *)
  TTF_SetFontSDF: function(font: PTTF_Font; on_off: SDL_bool): Integer; cdecl;

(**
 * Query whether Signed Distance Field rendering is enabled for a font.
 *
 * \param font the font to query
 *
 * \returns SDL_TRUE if enabled, SDL_FALSE otherwise.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_SetFontSDF
 *)
  TTF_GetFontSDF: function(const font: PTTF_Font): SDL_bool; cdecl;

(**
 * Set a global direction to be used for text shaping.
 *
 * \deprecated This function expects an hb_direction_t value, from HarfBuzz,
 *             cast to an int, and affects all fonts globally. Please use
 *             TTF_SetFontDirection() instead, which uses an enum supplied by
 *             SDL_ttf itself and operates on a per-font basis.
 *
 *             This is a global setting; fonts will favor a value set with
 *             TTF_SetFontDirection(), but if they have not had one explicitly
 *             set, they will use the value specified here.
 *
 *             The default value is `HB_DIRECTION_LTR` (left-to-right text
 *             flow).
 *
 * \param direction an hb_direction_t value.
 * \returns 0, or -1 if SDL_ttf is not compiled with HarfBuzz support.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_SetFontDirection
 *)
  TTF_SetDirection: function(direction: Integer): Integer; cdecl;

(**
 * Set a global script to be used for text shaping.
 *
 * \deprecated This function expects an hb_script_t value, from HarfBuzz, cast
 *             to an int, and affects all fonts globally. Please use
 *             TTF_SetFontScriptName() instead, which accepts a string that is
 *             converted to an equivalent int internally, and operates on a
 *             per-font basis.
 *
 *             This is a global setting; fonts will favor a value set with
 *             TTF_SetFontScriptName(), but if they have not had one
 *             explicitly set, they will use the value specified here.
 *
 *             The default value is `HB_SCRIPT_UNKNOWN`.
 *
 * \returns 0, or -1 if SDL_ttf is not compiled with HarfBuzz support.
 *
 * \since This function is available since SDL_ttf 2.0.18.
 *
 * \sa TTF_SetFontScriptName
 *)
  TTF_SetScript: function(script: Integer): Integer; cdecl;

(**
 * Set direction to be used for text shaping by a font.
 *
 * Any value supplied here will override the global direction set with the
 * deprecated TTF_SetDirection().
 *
 * Possible direction values are:
 *
 * - `TTF_DIRECTION_LTR` (Left to Right)
 * - `TTF_DIRECTION_RTL` (Right to Left)
 * - `TTF_DIRECTION_TTB` (Top to Bottom)
 * - `TTF_DIRECTION_BTT` (Bottom to Top)
 *
 * If SDL_ttf was not built with HarfBuzz support, this function returns -1.
 *
 * \param font the font to specify a direction for.
 * \param direction the new direction for text to flow.
 * \returns 0 on success, or -1 on error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *)
  TTF_SetFontDirection: function(font: PTTF_Font; direction: TTF_Direction): Integer; cdecl;

(**
 * Set script to be used for text shaping by a font.
 *
 * Any value supplied here will override the global script set with the
 * deprecated TTF_SetScript().
 *
 * The supplied script value must be a null-terminated string of exactly four
 * characters.
 *
 * If SDL_ttf was not built with HarfBuzz support, this function returns -1.
 *
 * \param font the font to specify a direction for.
 * \param script null-terminated string of exactly 4 characters.
 * \returns 0 on success, or -1 on error.
 *
 * \since This function is available since SDL_ttf 2.20.0.
 *)
  TTF_SetFontScriptName: function(font: PTTF_Font; const script: PUTF8Char): Integer; cdecl;

(**
 * \fn int PHYSFS_init(const char *argv0)
 * \brief Initialize the PhysicsFS library.
 *
 * This must be called before any other PhysicsFS function.
 *
 * This should be called prior to any attempts to change your process's
 *  current working directory.
 *
 * \warning On Android, argv0 should be a non-NULL pointer to a
 *          PHYSFS_AndroidInit struct. This struct must hold a valid JNIEnv *
 *          and a JNI jobject of a Context (either the application context or
 *          the current Activity is fine). Both are cast to a void * so we
 *          don't need jni.h included wherever physfs.h is. PhysicsFS
 *          uses these objects to query some system details. PhysicsFS does
 *          not hold a reference to the JNIEnv or Context past the call to
 *          PHYSFS_init(). If you pass a NULL here, PHYSFS_init can still
 *          succeed, but PHYSFS_getBaseDir() and PHYSFS_getPrefDir() will be
 *          incorrect.
 *
 *   \param argv0 the argv[0] string passed to your program's mainline.
 *          This may be NULL on most platforms (such as ones without a
 *          standard main() function), but you should always try to pass
 *          something in here. Many Unix-like systems _need_ to pass argv[0]
 *          from main() in here. See warning about Android, too!
 *  \return nonzero on success, zero on error. Specifics of the error can be
 *          gleaned from PHYSFS_getLastError().
 *
 * \sa PHYSFS_deinit
 * \sa PHYSFS_isInit
 *)
  PHYSFS_init: function(const argv0: PUTF8Char): Integer; cdecl;

(**
 * \fn int PHYSFS_deinit(void)
 * \brief Deinitialize the PhysicsFS library.
 *
 * This closes any files opened via PhysicsFS, blanks the search/write paths,
 *  frees memory, and invalidates all of your file handles.
 *
 * Note that this call can FAIL if there's a file open for writing that
 *  refuses to close (for example, the underlying operating system was
 *  buffering writes to network filesystem, and the fileserver has crashed,
 *  or a hard drive has failed, etc). It is usually best to close all write
 *  handles yourself before calling this function, so that you can gracefully
 *  handle a specific failure.
 *
 * Once successfully deinitialized, PHYSFS_init() can be called again to
 *  restart the subsystem. All default API states are restored at this
 *  point, with the exception of any custom allocator you might have
 *  specified, which survives between initializations.
 *
 *  \return nonzero on success, zero on error. Specifics of the error can be
 *          gleaned from PHYSFS_getLastError(). If failure, state of PhysFS is
 *          undefined, and probably badly screwed up.
 *
 * \sa PHYSFS_init
 * \sa PHYSFS_isInit
 *)
  PHYSFS_deinit: function(): Integer; cdecl;

(**
 * \fn const char *PHYSFS_getWriteDir(void)
 * \brief Get path where PhysicsFS will allow file writing.
 *
 * Get the current write dir. The default write dir is NULL.
 *
 *  \return READ ONLY string of write dir in platform-dependent notation,
 *           OR NULL IF NO WRITE PATH IS CURRENTLY SET.
 *
 * \sa PHYSFS_setWriteDir
 *)
  PHYSFS_getWriteDir: function(): PUTF8Char; cdecl;

(**
 * \fn int PHYSFS_setWriteDir(const char *newDir)
 * \brief Tell PhysicsFS where it may write files.
 *
 * Set a new write dir. This will override the previous setting.
 *
 * This call will fail (and fail to change the write dir) if the current
 *  write dir still has files open in it.
 *
 *   \param newDir The new directory to be the root of the write dir,
 *                   specified in platform-dependent notation. Setting to NULL
 *                   disables the write dir, so no files can be opened for
 *                   writing via PhysicsFS.
 *  \return non-zero on success, zero on failure. All attempts to open a file
 *           for writing via PhysicsFS will fail until this call succeeds.
 *           Use PHYSFS_getLastErrorCode() to obtain the specific error.
 *
 * \sa PHYSFS_getWriteDir
 *)
  PHYSFS_setWriteDir: function(const newDir: PUTF8Char): Integer; cdecl;

(**
 * \fn int PHYSFS_mount(const char *newDir, const char *mountPoint, int appendToPath)
 * \brief Add an archive or directory to the search path.
 *
 * If this is a duplicate, the entry is not added again, even though the
 *  function succeeds. You may not add the same archive to two different
 *  mountpoints: duplicate checking is done against the archive and not the
 *  mountpoint.
 *
 * When you mount an archive, it is added to a virtual file system...all files
 *  in all of the archives are interpolated into a single hierachical file
 *  tree. Two archives mounted at the same place (or an archive with files
 *  overlapping another mountpoint) may have overlapping files: in such a case,
 *  the file earliest in the search path is selected, and the other files are
 *  inaccessible to the application. This allows archives to be used to
 *  override previous revisions; you can use the mounting mechanism to place
 *  archives at a specific point in the file tree and prevent overlap; this
 *  is useful for downloadable mods that might trample over application data
 *  or each other, for example.
 *
 * The mountpoint does not need to exist prior to mounting, which is different
 *  than those familiar with the Unix concept of "mounting" may expect.
 *  As well, more than one archive can be mounted to the same mountpoint, or
 *  mountpoints and archive contents can overlap...the interpolation mechanism
 *  still functions as usual.
 *
 * Specifying a symbolic link to an archive or directory is allowed here,
 *  regardless of the state of PHYSFS_permitSymbolicLinks(). That function
 *  only deals with symlinks inside the mounted directory or archive.
 *
 *   \param newDir directory or archive to add to the path, in
 *                   platform-dependent notation.
 *   \param mountPoint Location in the interpolated tree that this archive
 *                     will be "mounted", in platform-independent notation.
 *                     NULL or "" is equivalent to "/".
 *   \param appendToPath nonzero to append to search path, zero to prepend.
 *  \return nonzero if added to path, zero on failure (bogus archive, dir
 *          missing, etc). Use PHYSFS_getLastErrorCode() to obtain
 *          the specific error.
 *
 * \sa PHYSFS_removeFromSearchPath
 * \sa PHYSFS_getSearchPath
 * \sa PHYSFS_getMountPoint
 * \sa PHYSFS_mountIo
 *)
  PHYSFS_mount: function(const newDir: PUTF8Char; const mountPoint: PUTF8Char; appendToPath: Integer): Integer; cdecl;

(**
 * \fn int PHYSFS_unmount(const char *oldDir)
 * \brief Remove a directory or archive from the search path.
 *
 * This is functionally equivalent to PHYSFS_removeFromSearchPath(), but that
 *  function is deprecated to keep the vocabulary paired with PHYSFS_mount().
 *
 * This must be a (case-sensitive) match to a dir or archive already in the
 *  search path, specified in platform-dependent notation.
 *
 * This call will fail (and fail to remove from the path) if the element still
 *  has files open in it.
 *
 * \warning This function wants the path to the archive or directory that was
 *          mounted (the same string used for the "newDir" argument of
 *          PHYSFS_addToSearchPath or any of the mount functions), not the
 *          path where it is mounted in the tree (the "mountPoint" argument
 *          to any of the mount functions).
 *
 *    \param oldDir dir/archive to remove.
 *   \return nonzero on success, zero on failure. Use
 *           PHYSFS_getLastErrorCode() to obtain the specific error.
 *
 * \sa PHYSFS_getSearchPath
 * \sa PHYSFS_mount
 *)
  PHYSFS_unmount: function(const oldDir: PUTF8Char): Integer; cdecl;

(**
 * Open a platform-independent filename for reading, and make it accessible
 *  via an SDL_RWops structure. The file will be closed in PhysicsFS when the
 *  RWops is closed. PhysicsFS should be configured to your liking before
 *  opening files through this method.
 *
 *   @param filename File to open in platform-independent notation.
 *  @return A valid SDL_RWops structure on success, NULL on error. Specifics
 *           of the error can be gleaned from PHYSFS_getLastError().
 *)
  PHYSFSRWOPS_openRead: function(const fname: PUTF8Char): PSDL_RWops; cdecl;

(**
 * Open a platform-independent filename for writing, and make it accessible
 *  via an SDL_RWops structure. The file will be closed in PhysicsFS when the
 *  RWops is closed. PhysicsFS should be configured to your liking before
 *  opening files through this method.
 *
 *   @param filename File to open in platform-independent notation.
 *  @return A valid SDL_RWops structure on success, NULL on error. Specifics
 *           of the error can be gleaned from PHYSFS_getLastError().
 *)
  PHYSFSRWOPS_openWrite: function(const fname: PUTF8Char): PSDL_RWops; cdecl;

(**
 * Open a platform-independent filename for appending, and make it accessible
 *  via an SDL_RWops structure. The file will be closed in PhysicsFS when the
 *  RWops is closed. PhysicsFS should be configured to your liking before
 *  opening files through this method.
 *
 *   @param filename File to open in platform-independent notation.
 *  @return A valid SDL_RWops structure on success, NULL on error. Specifics
 *           of the error can be gleaned from PHYSFS_getLastError().
 *)
  PHYSFSRWOPS_openAppend: function(const fname: PUTF8Char): PSDL_RWops; cdecl;

  nk_init_default: function(p1: Pnk_context; const p2: Pnk_user_font): nk_bool; cdecl;

  nk_init_fixed: function(p1: Pnk_context; memory: Pointer; size: nk_size; const p4: Pnk_user_font): nk_bool; cdecl;

  nk_init: function(p1: Pnk_context; p2: Pnk_allocator; const p3: Pnk_user_font): nk_bool; cdecl;

  nk_init_custom: function(p1: Pnk_context; cmds: Pnk_buffer; pool: Pnk_buffer; const p4: Pnk_user_font): nk_bool; cdecl;

  nk_clear: procedure(p1: Pnk_context); cdecl;

  nk_free: procedure(p1: Pnk_context); cdecl;

  nk_input_begin: procedure(p1: Pnk_context); cdecl;

  nk_input_motion: procedure(p1: Pnk_context; x: Integer; y: Integer); cdecl;

  nk_input_key: procedure(p1: Pnk_context; p2: nk_keys; down: nk_bool); cdecl;

  nk_input_button: procedure(p1: Pnk_context; p2: nk_buttons; x: Integer; y: Integer; down: nk_bool); cdecl;

  nk_input_scroll: procedure(p1: Pnk_context; val: nk_vec2); cdecl;

  nk_input_char: procedure(p1: Pnk_context; p2: UTF8Char); cdecl;

  nk_input_glyph: procedure(p1: Pnk_context; const p2: nk_glyph); cdecl;

  nk_input_unicode: procedure(p1: Pnk_context; p2: nk_rune); cdecl;

  nk_input_end: procedure(p1: Pnk_context); cdecl;

  nk__begin: function(p1: Pnk_context): Pnk_command; cdecl;

  nk__next: function(p1: Pnk_context; const p2: Pnk_command): Pnk_command; cdecl;

  nk_convert: function(p1: Pnk_context; cmds: Pnk_buffer; vertices: Pnk_buffer; elements: Pnk_buffer; const p5: Pnk_convert_config): nk_flags; cdecl;

  nk__draw_begin: function(const p1: Pnk_context; const p2: Pnk_buffer): Pnk_draw_command; cdecl;

  nk__draw_end: function(const p1: Pnk_context; const p2: Pnk_buffer): Pnk_draw_command; cdecl;

  nk__draw_next: function(const p1: Pnk_draw_command; const p2: Pnk_buffer; const p3: Pnk_context): Pnk_draw_command; cdecl;

  nk_begin: function(ctx: Pnk_context; const title: PUTF8Char; bounds: nk_rect; flags: nk_flags): nk_bool; cdecl;

  nk_begin_titled: function(ctx: Pnk_context; const name: PUTF8Char; const title: PUTF8Char; bounds: nk_rect; flags: nk_flags): nk_bool; cdecl;

  nk_end: procedure(ctx: Pnk_context); cdecl;

  nk_window_find: function(ctx: Pnk_context; const name: PUTF8Char): Pnk_window; cdecl;

  nk_window_get_bounds: function(const ctx: Pnk_context): nk_rect; cdecl;

  nk_window_get_position: function(const ctx: Pnk_context): nk_vec2; cdecl;

  nk_window_get_size: function(const p1: Pnk_context): nk_vec2; cdecl;

  nk_window_get_width: function(const p1: Pnk_context): Single; cdecl;

  nk_window_get_height: function(const p1: Pnk_context): Single; cdecl;

  nk_window_get_panel: function(p1: Pnk_context): Pnk_panel; cdecl;

  nk_window_get_content_region: function(p1: Pnk_context): nk_rect; cdecl;

  nk_window_get_content_region_min: function(p1: Pnk_context): nk_vec2; cdecl;

  nk_window_get_content_region_max: function(p1: Pnk_context): nk_vec2; cdecl;

  nk_window_get_content_region_size: function(p1: Pnk_context): nk_vec2; cdecl;

  nk_window_get_canvas: function(p1: Pnk_context): Pnk_command_buffer; cdecl;

  nk_window_get_scroll: procedure(p1: Pnk_context; offset_x: Pnk_uint; offset_y: Pnk_uint); cdecl;

  nk_window_has_focus: function(const p1: Pnk_context): nk_bool; cdecl;

  nk_window_is_hovered: function(p1: Pnk_context): nk_bool; cdecl;

  nk_window_is_collapsed: function(ctx: Pnk_context; const name: PUTF8Char): nk_bool; cdecl;

  nk_window_is_closed: function(p1: Pnk_context; const p2: PUTF8Char): nk_bool; cdecl;

  nk_window_is_hidden: function(p1: Pnk_context; const p2: PUTF8Char): nk_bool; cdecl;

  nk_window_is_active: function(p1: Pnk_context; const p2: PUTF8Char): nk_bool; cdecl;

  nk_window_is_any_hovered: function(p1: Pnk_context): nk_bool; cdecl;

  nk_item_is_any_active: function(p1: Pnk_context): nk_bool; cdecl;

  nk_window_set_bounds: procedure(p1: Pnk_context; const name: PUTF8Char; bounds: nk_rect); cdecl;

  nk_window_set_position: procedure(p1: Pnk_context; const name: PUTF8Char; pos: nk_vec2); cdecl;

  nk_window_set_size: procedure(p1: Pnk_context; const name: PUTF8Char; p3: nk_vec2); cdecl;

  nk_window_set_focus: procedure(p1: Pnk_context; const name: PUTF8Char); cdecl;

  nk_window_set_scroll: procedure(p1: Pnk_context; offset_x: nk_uint; offset_y: nk_uint); cdecl;

  nk_window_close: procedure(ctx: Pnk_context; const name: PUTF8Char); cdecl;

  nk_window_collapse: procedure(p1: Pnk_context; const name: PUTF8Char; state: nk_collapse_states); cdecl;

  nk_window_collapse_if: procedure(p1: Pnk_context; const name: PUTF8Char; p3: nk_collapse_states; cond: Integer); cdecl;

  nk_window_show: procedure(p1: Pnk_context; const name: PUTF8Char; p3: nk_show_states); cdecl;

  nk_window_show_if: procedure(p1: Pnk_context; const name: PUTF8Char; p3: nk_show_states; cond: Integer); cdecl;

  nk_layout_set_min_row_height: procedure(p1: Pnk_context; height: Single); cdecl;

  nk_layout_reset_min_row_height: procedure(p1: Pnk_context); cdecl;

  nk_layout_widget_bounds: function(p1: Pnk_context): nk_rect; cdecl;

  nk_layout_ratio_from_pixel: function(p1: Pnk_context; pixel_width: Single): Single; cdecl;

  nk_layout_row_dynamic: procedure(ctx: Pnk_context; height: Single; cols: Integer); cdecl;

  nk_layout_row_static: procedure(ctx: Pnk_context; height: Single; item_width: Integer; cols: Integer); cdecl;

  nk_layout_row_begin: procedure(ctx: Pnk_context; fmt: nk_layout_format; row_height: Single; cols: Integer); cdecl;

  nk_layout_row_push: procedure(p1: Pnk_context; value: Single); cdecl;

  nk_layout_row_end: procedure(p1: Pnk_context); cdecl;

  nk_layout_row: procedure(p1: Pnk_context; p2: nk_layout_format; height: Single; cols: Integer; const ratio: PSingle); cdecl;

  nk_layout_row_template_begin: procedure(p1: Pnk_context; row_height: Single); cdecl;

  nk_layout_row_template_push_dynamic: procedure(p1: Pnk_context); cdecl;

  nk_layout_row_template_push_variable: procedure(p1: Pnk_context; min_width: Single); cdecl;

  nk_layout_row_template_push_static: procedure(p1: Pnk_context; width: Single); cdecl;

  nk_layout_row_template_end: procedure(p1: Pnk_context); cdecl;

  nk_layout_space_begin: procedure(p1: Pnk_context; p2: nk_layout_format; height: Single; widget_count: Integer); cdecl;

  nk_layout_space_push: procedure(p1: Pnk_context; bounds: nk_rect); cdecl;

  nk_layout_space_end: procedure(p1: Pnk_context); cdecl;

  nk_layout_space_bounds: function(p1: Pnk_context): nk_rect; cdecl;

  nk_layout_space_to_screen: function(p1: Pnk_context; p2: nk_vec2): nk_vec2; cdecl;

  nk_layout_space_to_local: function(p1: Pnk_context; p2: nk_vec2): nk_vec2; cdecl;

  nk_layout_space_rect_to_screen: function(p1: Pnk_context; p2: nk_rect): nk_rect; cdecl;

  nk_layout_space_rect_to_local: function(p1: Pnk_context; p2: nk_rect): nk_rect; cdecl;

  nk_spacer: procedure(p1: Pnk_context); cdecl;

  nk_group_begin: function(p1: Pnk_context; const title: PUTF8Char; p3: nk_flags): nk_bool; cdecl;

  nk_group_begin_titled: function(p1: Pnk_context; const name: PUTF8Char; const title: PUTF8Char; p4: nk_flags): nk_bool; cdecl;

  nk_group_end: procedure(p1: Pnk_context); cdecl;

  nk_group_scrolled_offset_begin: function(p1: Pnk_context; x_offset: Pnk_uint; y_offset: Pnk_uint; const title: PUTF8Char; flags: nk_flags): nk_bool; cdecl;

  nk_group_scrolled_begin: function(p1: Pnk_context; off: Pnk_scroll; const title: PUTF8Char; p4: nk_flags): nk_bool; cdecl;

  nk_group_scrolled_end: procedure(p1: Pnk_context); cdecl;

  nk_group_get_scroll: procedure(p1: Pnk_context; const id: PUTF8Char; x_offset: Pnk_uint; y_offset: Pnk_uint); cdecl;

  nk_group_set_scroll: procedure(p1: Pnk_context; const id: PUTF8Char; x_offset: nk_uint; y_offset: nk_uint); cdecl;

  nk_tree_push_hashed: function(p1: Pnk_context; p2: nk_tree_type; const title: PUTF8Char; initial_state: nk_collapse_states; const hash: PUTF8Char; len: Integer; seed: Integer): nk_bool; cdecl;

  nk_tree_image_push_hashed: function(p1: Pnk_context; p2: nk_tree_type; p3: nk_image; const title: PUTF8Char; initial_state: nk_collapse_states; const hash: PUTF8Char; len: Integer; seed: Integer): nk_bool; cdecl;

  nk_tree_pop: procedure(p1: Pnk_context); cdecl;

  nk_tree_state_push: function(p1: Pnk_context; p2: nk_tree_type; const title: PUTF8Char; state: Pnk_collapse_states): nk_bool; cdecl;

  nk_tree_state_image_push: function(p1: Pnk_context; p2: nk_tree_type; p3: nk_image; const title: PUTF8Char; state: Pnk_collapse_states): nk_bool; cdecl;

  nk_tree_state_pop: procedure(p1: Pnk_context); cdecl;

  nk_tree_element_push_hashed: function(p1: Pnk_context; p2: nk_tree_type; const title: PUTF8Char; initial_state: nk_collapse_states; selected: Pnk_bool; const hash: PUTF8Char; len: Integer; seed: Integer): nk_bool; cdecl;

  nk_tree_element_image_push_hashed: function(p1: Pnk_context; p2: nk_tree_type; p3: nk_image; const title: PUTF8Char; initial_state: nk_collapse_states; selected: Pnk_bool; const hash: PUTF8Char; len: Integer; seed: Integer): nk_bool; cdecl;

  nk_tree_element_pop: procedure(p1: Pnk_context); cdecl;

  nk_list_view_begin: function(p1: Pnk_context; out_: Pnk_list_view; const id: PUTF8Char; p4: nk_flags; row_height: Integer; row_count: Integer): nk_bool; cdecl;

  nk_list_view_end: procedure(p1: Pnk_list_view); cdecl;

  nk_widget: function(p1: Pnk_rect; const p2: Pnk_context): nk_widget_layout_states; cdecl;

  nk_widget_fitting: function(p1: Pnk_rect; p2: Pnk_context; p3: nk_vec2): nk_widget_layout_states; cdecl;

  nk_widget_bounds: function(p1: Pnk_context): nk_rect; cdecl;

  nk_widget_position: function(p1: Pnk_context): nk_vec2; cdecl;

  nk_widget_size: function(p1: Pnk_context): nk_vec2; cdecl;

  nk_widget_width: function(p1: Pnk_context): Single; cdecl;

  nk_widget_height: function(p1: Pnk_context): Single; cdecl;

  nk_widget_is_hovered: function(p1: Pnk_context): nk_bool; cdecl;

  nk_widget_is_mouse_clicked: function(p1: Pnk_context; p2: nk_buttons): nk_bool; cdecl;

  nk_widget_has_mouse_click_down: function(p1: Pnk_context; p2: nk_buttons; down: nk_bool): nk_bool; cdecl;

  nk_spacing: procedure(p1: Pnk_context; cols: Integer); cdecl;

  nk_text: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; p4: nk_flags); cdecl;

  nk_text_colored: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; p4: nk_flags; p5: nk_color); cdecl;

  nk_text_wrap: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Integer); cdecl;

  nk_text_wrap_colored: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; p4: nk_color); cdecl;

  nk_label: procedure(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags); cdecl;

  nk_label_colored: procedure(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; p4: nk_color); cdecl;

  nk_label_wrap: procedure(p1: Pnk_context; const p2: PUTF8Char); cdecl;

  nk_label_colored_wrap: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: nk_color); cdecl;

  nk_image_rtn: procedure(p1: Pnk_context; p2: nk_image); cdecl;

  nk_image_color: procedure(p1: Pnk_context; p2: nk_image; p3: nk_color); cdecl;

  nk_labelf: procedure(p1: Pnk_context; p2: nk_flags; const p3: PUTF8Char) varargs; cdecl;

  nk_labelf_colored: procedure(p1: Pnk_context; p2: nk_flags; p3: nk_color; const p4: PUTF8Char) varargs; cdecl;

  nk_labelf_wrap: procedure(p1: Pnk_context; const p2: PUTF8Char) varargs; cdecl;

  nk_labelf_colored_wrap: procedure(p1: Pnk_context; p2: nk_color; const p3: PUTF8Char) varargs; cdecl;

  nk_labelfv: procedure(p1: Pnk_context; p2: nk_flags; const p3: PUTF8Char; p4: Pointer); cdecl;

  nk_labelfv_colored: procedure(p1: Pnk_context; p2: nk_flags; p3: nk_color; const p4: PUTF8Char; p5: Pointer); cdecl;

  nk_labelfv_wrap: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Pointer); cdecl;

  nk_labelfv_colored_wrap: procedure(p1: Pnk_context; p2: nk_color; const p3: PUTF8Char; p4: Pointer); cdecl;

  nk_value_bool: procedure(p1: Pnk_context; const prefix: PUTF8Char; p3: Integer); cdecl;

  nk_value_int: procedure(p1: Pnk_context; const prefix: PUTF8Char; p3: Integer); cdecl;

  nk_value_uint: procedure(p1: Pnk_context; const prefix: PUTF8Char; p3: Cardinal); cdecl;

  nk_value_float: procedure(p1: Pnk_context; const prefix: PUTF8Char; p3: Single); cdecl;

  nk_value_color_byte: procedure(p1: Pnk_context; const prefix: PUTF8Char; p3: nk_color); cdecl;

  nk_value_color_float: procedure(p1: Pnk_context; const prefix: PUTF8Char; p3: nk_color); cdecl;

  nk_value_color_hex: procedure(p1: Pnk_context; const prefix: PUTF8Char; p3: nk_color); cdecl;

  nk_button_text: function(p1: Pnk_context; const title: PUTF8Char; len: Integer): nk_bool; cdecl;

  nk_button_label: function(p1: Pnk_context; const title: PUTF8Char): nk_bool; cdecl;

  nk_button_color: function(p1: Pnk_context; p2: nk_color): nk_bool; cdecl;

  nk_button_symbol: function(p1: Pnk_context; p2: nk_symbol_type): nk_bool; cdecl;

  nk_button_image: function(p1: Pnk_context; img: nk_image): nk_bool; cdecl;

  nk_button_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; text_alignment: nk_flags): nk_bool; cdecl;

  nk_button_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_button_image_label: function(p1: Pnk_context; img: nk_image; const p3: PUTF8Char; text_alignment: nk_flags): nk_bool; cdecl;

  nk_button_image_text: function(p1: Pnk_context; img: nk_image; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_button_text_styled: function(p1: Pnk_context; const p2: Pnk_style_button; const title: PUTF8Char; len: Integer): nk_bool; cdecl;

  nk_button_label_styled: function(p1: Pnk_context; const p2: Pnk_style_button; const title: PUTF8Char): nk_bool; cdecl;

  nk_button_symbol_styled: function(p1: Pnk_context; const p2: Pnk_style_button; p3: nk_symbol_type): nk_bool; cdecl;

  nk_button_image_styled: function(p1: Pnk_context; const p2: Pnk_style_button; img: nk_image): nk_bool; cdecl;

  nk_button_symbol_text_styled: function(p1: Pnk_context; const p2: Pnk_style_button; p3: nk_symbol_type; const p4: PUTF8Char; p5: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_button_symbol_label_styled: function(ctx: Pnk_context; const style: Pnk_style_button; symbol: nk_symbol_type; const title: PUTF8Char; align: nk_flags): nk_bool; cdecl;

  nk_button_image_label_styled: function(p1: Pnk_context; const p2: Pnk_style_button; img: nk_image; const p4: PUTF8Char; text_alignment: nk_flags): nk_bool; cdecl;

  nk_button_image_text_styled: function(p1: Pnk_context; const p2: Pnk_style_button; img: nk_image; const p4: PUTF8Char; p5: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_button_set_behavior: procedure(p1: Pnk_context; p2: nk_button_behavior); cdecl;

  nk_button_push_behavior: function(p1: Pnk_context; p2: nk_button_behavior): nk_bool; cdecl;

  nk_button_pop_behavior: function(p1: Pnk_context): nk_bool; cdecl;

  nk_check_label: function(p1: Pnk_context; const p2: PUTF8Char; active: nk_bool): nk_bool; cdecl;

  nk_check_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; active: nk_bool): nk_bool; cdecl;

  nk_check_flags_label: function(p1: Pnk_context; const p2: PUTF8Char; flags: Cardinal; value: Cardinal): Cardinal; cdecl;

  nk_check_flags_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; flags: Cardinal; value: Cardinal): Cardinal; cdecl;

  nk_checkbox_label: function(p1: Pnk_context; const p2: PUTF8Char; active: Pnk_bool): nk_bool; cdecl;

  nk_checkbox_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; active: Pnk_bool): nk_bool; cdecl;

  nk_checkbox_flags_label: function(p1: Pnk_context; const p2: PUTF8Char; flags: PCardinal; value: Cardinal): nk_bool; cdecl;

  nk_checkbox_flags_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; flags: PCardinal; value: Cardinal): nk_bool; cdecl;

  nk_radio_label: function(p1: Pnk_context; const p2: PUTF8Char; active: Pnk_bool): nk_bool; cdecl;

  nk_radio_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; active: Pnk_bool): nk_bool; cdecl;

  nk_option_label: function(p1: Pnk_context; const p2: PUTF8Char; active: nk_bool): nk_bool; cdecl;

  nk_option_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; active: nk_bool): nk_bool; cdecl;

  nk_selectable_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;

  nk_selectable_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;

  nk_selectable_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;

  nk_selectable_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; p4: Integer; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;

  nk_selectable_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;

  nk_selectable_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; align: nk_flags; value: Pnk_bool): nk_bool; cdecl;

  nk_select_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; value: nk_bool): nk_bool; cdecl;

  nk_select_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags; value: nk_bool): nk_bool; cdecl;

  nk_select_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; align: nk_flags; value: nk_bool): nk_bool; cdecl;

  nk_select_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; p4: Integer; align: nk_flags; value: nk_bool): nk_bool; cdecl;

  nk_select_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; align: nk_flags; value: nk_bool): nk_bool; cdecl;

  nk_select_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; align: nk_flags; value: nk_bool): nk_bool; cdecl;

  nk_slide_float: function(p1: Pnk_context; min: Single; val: Single; max: Single; step: Single): Single; cdecl;

  nk_slide_int: function(p1: Pnk_context; min: Integer; val: Integer; max: Integer; step: Integer): Integer; cdecl;

  nk_slider_float: function(p1: Pnk_context; min: Single; val: PSingle; max: Single; step: Single): nk_bool; cdecl;

  nk_slider_int: function(p1: Pnk_context; min: Integer; val: PInteger; max: Integer; step: Integer): nk_bool; cdecl;

  nk_progress: function(p1: Pnk_context; cur: Pnk_size; max: nk_size; modifyable: nk_bool): nk_bool; cdecl;

  nk_prog: function(p1: Pnk_context; cur: nk_size; max: nk_size; modifyable: nk_bool): nk_size; cdecl;

  nk_color_picker: function(p1: Pnk_context; p2: nk_colorf; p3: nk_color_format): nk_colorf; cdecl;

  nk_color_pick: function(p1: Pnk_context; p2: Pnk_colorf; p3: nk_color_format): nk_bool; cdecl;

  nk_property_int: procedure(p1: Pnk_context; const name: PUTF8Char; min: Integer; val: PInteger; max: Integer; step: Integer; inc_per_pixel: Single); cdecl;

  nk_property_float: procedure(p1: Pnk_context; const name: PUTF8Char; min: Single; val: PSingle; max: Single; step: Single; inc_per_pixel: Single); cdecl;

  nk_property_double: procedure(p1: Pnk_context; const name: PUTF8Char; min: Double; val: PDouble; max: Double; step: Double; inc_per_pixel: Single); cdecl;

  nk_propertyi: function(p1: Pnk_context; const name: PUTF8Char; min: Integer; val: Integer; max: Integer; step: Integer; inc_per_pixel: Single): Integer; cdecl;

  nk_propertyf: function(p1: Pnk_context; const name: PUTF8Char; min: Single; val: Single; max: Single; step: Single; inc_per_pixel: Single): Single; cdecl;

  nk_propertyd: function(p1: Pnk_context; const name: PUTF8Char; min: Double; val: Double; max: Double; step: Double; inc_per_pixel: Single): Double; cdecl;

  nk_edit_string: function(p1: Pnk_context; p2: nk_flags; buffer: PUTF8Char; len: PInteger; max: Integer; p6: nk_plugin_filter): nk_flags; cdecl;

  nk_edit_string_zero_terminated: function(p1: Pnk_context; p2: nk_flags; buffer: PUTF8Char; max: Integer; p5: nk_plugin_filter): nk_flags; cdecl;

  nk_edit_buffer: function(p1: Pnk_context; p2: nk_flags; p3: Pnk_text_edit; p4: nk_plugin_filter): nk_flags; cdecl;

  nk_edit_focus: procedure(p1: Pnk_context; flags: nk_flags); cdecl;

  nk_edit_unfocus: procedure(p1: Pnk_context); cdecl;

  nk_chart_begin: function(p1: Pnk_context; p2: nk_chart_type; num: Integer; min: Single; max: Single): nk_bool; cdecl;

  nk_chart_begin_colored: function(p1: Pnk_context; p2: nk_chart_type; p3: nk_color; active: nk_color; num: Integer; min: Single; max: Single): nk_bool; cdecl;

  nk_chart_add_slot: procedure(ctx: Pnk_context; const p2: nk_chart_type; count: Integer; min_value: Single; max_value: Single); cdecl;

  nk_chart_add_slot_colored: procedure(ctx: Pnk_context; const p2: nk_chart_type; p3: nk_color; active: nk_color; count: Integer; min_value: Single; max_value: Single); cdecl;

  nk_chart_push: function(p1: Pnk_context; p2: Single): nk_flags; cdecl;

  nk_chart_push_slot: function(p1: Pnk_context; p2: Single; p3: Integer): nk_flags; cdecl;

  nk_chart_end: procedure(p1: Pnk_context); cdecl;

  nk_plot: procedure(p1: Pnk_context; p2: nk_chart_type; const values: PSingle; count: Integer; offset: Integer); cdecl;

type
  nk_plot_function_value_getter = function(user: Pointer; index: Integer): Single; cdecl;

var
  nk_plot_function: procedure(p1: Pnk_context; p2: nk_chart_type; userdata: Pointer; value_getter: nk_plot_function_value_getter; count: Integer; offset: Integer); cdecl;

  nk_popup_begin: function(p1: Pnk_context; p2: nk_popup_type; const p3: PUTF8Char; p4: nk_flags; bounds: nk_rect): nk_bool; cdecl;

  nk_popup_close: procedure(p1: Pnk_context); cdecl;

  nk_popup_end: procedure(p1: Pnk_context); cdecl;

  nk_popup_get_scroll: procedure(p1: Pnk_context; offset_x: Pnk_uint; offset_y: Pnk_uint); cdecl;

  nk_popup_set_scroll: procedure(p1: Pnk_context; offset_x: nk_uint; offset_y: nk_uint); cdecl;

  nk_combo: function(p1: Pnk_context; items: PPUTF8Char; count: Integer; selected: Integer; item_height: Integer; size: nk_vec2): Integer; cdecl;

  nk_combo_separator: function(p1: Pnk_context; const items_separated_by_separator: PUTF8Char; separator: Integer; selected: Integer; count: Integer; item_height: Integer; size: nk_vec2): Integer; cdecl;

  nk_combo_string: function(p1: Pnk_context; const items_separated_by_zeros: PUTF8Char; selected: Integer; count: Integer; item_height: Integer; size: nk_vec2): Integer; cdecl;

type
  nk_combo_callback_item_getter = procedure(p1: Pointer; p2: Integer; p3: PPUTF8Char); cdecl;

var
  nk_combo_callback: function(p1: Pnk_context; item_getter: nk_combo_callback_item_getter; userdata: Pointer; selected: Integer; count: Integer; item_height: Integer; size: nk_vec2): Integer; cdecl;

  nk_combobox: procedure(p1: Pnk_context; items: PPUTF8Char; count: Integer; selected: PInteger; item_height: Integer; size: nk_vec2); cdecl;

  nk_combobox_string: procedure(p1: Pnk_context; const items_separated_by_zeros: PUTF8Char; selected: PInteger; count: Integer; item_height: Integer; size: nk_vec2); cdecl;

  nk_combobox_separator: procedure(p1: Pnk_context; const items_separated_by_separator: PUTF8Char; separator: Integer; selected: PInteger; count: Integer; item_height: Integer; size: nk_vec2); cdecl;

type
  nk_combobox_callback_item_getter = procedure(p1: Pointer; p2: Integer; p3: PPUTF8Char); cdecl;

var
  nk_combobox_callback: procedure(p1: Pnk_context; item_getter: nk_combobox_callback_item_getter; p3: Pointer; selected: PInteger; count: Integer; item_height: Integer; size: nk_vec2); cdecl;

  nk_combo_begin_text: function(p1: Pnk_context; const selected: PUTF8Char; p3: Integer; size: nk_vec2): nk_bool; cdecl;

  nk_combo_begin_label: function(p1: Pnk_context; const selected: PUTF8Char; size: nk_vec2): nk_bool; cdecl;

  nk_combo_begin_color: function(p1: Pnk_context; color: nk_color; size: nk_vec2): nk_bool; cdecl;

  nk_combo_begin_symbol: function(p1: Pnk_context; p2: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;

  nk_combo_begin_symbol_label: function(p1: Pnk_context; const selected: PUTF8Char; p3: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;

  nk_combo_begin_symbol_text: function(p1: Pnk_context; const selected: PUTF8Char; p3: Integer; p4: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;

  nk_combo_begin_image: function(p1: Pnk_context; img: nk_image; size: nk_vec2): nk_bool; cdecl;

  nk_combo_begin_image_label: function(p1: Pnk_context; const selected: PUTF8Char; p3: nk_image; size: nk_vec2): nk_bool; cdecl;

  nk_combo_begin_image_text: function(p1: Pnk_context; const selected: PUTF8Char; p3: Integer; p4: nk_image; size: nk_vec2): nk_bool; cdecl;

  nk_combo_item_label: function(p1: Pnk_context; const p2: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;

  nk_combo_item_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_combo_item_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;

  nk_combo_item_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_combo_item_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;

  nk_combo_item_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_combo_close: procedure(p1: Pnk_context); cdecl;

  nk_combo_end: procedure(p1: Pnk_context); cdecl;

  nk_contextual_begin: function(p1: Pnk_context; p2: nk_flags; p3: nk_vec2; trigger_bounds: nk_rect): nk_bool; cdecl;

  nk_contextual_item_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags): nk_bool; cdecl;

  nk_contextual_item_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags): nk_bool; cdecl;

  nk_contextual_item_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;

  nk_contextual_item_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; len: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_contextual_item_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;

  nk_contextual_item_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_contextual_close: procedure(p1: Pnk_context); cdecl;

  nk_contextual_end: procedure(p1: Pnk_context); cdecl;

  nk_tooltip: procedure(p1: Pnk_context; const p2: PUTF8Char); cdecl;

  nk_tooltipf: procedure(p1: Pnk_context; const p2: PUTF8Char) varargs; cdecl;

  nk_tooltipfv: procedure(p1: Pnk_context; const p2: PUTF8Char; p3: Pointer); cdecl;

  nk_tooltip_begin: function(p1: Pnk_context; width: Single): nk_bool; cdecl;

  nk_tooltip_end: procedure(p1: Pnk_context); cdecl;

  nk_menubar_begin: procedure(p1: Pnk_context); cdecl;

  nk_menubar_end: procedure(p1: Pnk_context); cdecl;

  nk_menu_begin_text: function(p1: Pnk_context; const title: PUTF8Char; title_len: Integer; align: nk_flags; size: nk_vec2): nk_bool; cdecl;

  nk_menu_begin_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; size: nk_vec2): nk_bool; cdecl;

  nk_menu_begin_image: function(p1: Pnk_context; const p2: PUTF8Char; p3: nk_image; size: nk_vec2): nk_bool; cdecl;

  nk_menu_begin_image_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags; p5: nk_image; size: nk_vec2): nk_bool; cdecl;

  nk_menu_begin_image_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; p4: nk_image; size: nk_vec2): nk_bool; cdecl;

  nk_menu_begin_symbol: function(p1: Pnk_context; const p2: PUTF8Char; p3: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;

  nk_menu_begin_symbol_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags; p5: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;

  nk_menu_begin_symbol_label: function(p1: Pnk_context; const p2: PUTF8Char; align: nk_flags; p4: nk_symbol_type; size: nk_vec2): nk_bool; cdecl;

  nk_menu_item_text: function(p1: Pnk_context; const p2: PUTF8Char; p3: Integer; align: nk_flags): nk_bool; cdecl;

  nk_menu_item_label: function(p1: Pnk_context; const p2: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;

  nk_menu_item_image_label: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;

  nk_menu_item_image_text: function(p1: Pnk_context; p2: nk_image; const p3: PUTF8Char; len: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_menu_item_symbol_text: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; p4: Integer; alignment: nk_flags): nk_bool; cdecl;

  nk_menu_item_symbol_label: function(p1: Pnk_context; p2: nk_symbol_type; const p3: PUTF8Char; alignment: nk_flags): nk_bool; cdecl;

  nk_menu_close: procedure(p1: Pnk_context); cdecl;

  nk_menu_end: procedure(p1: Pnk_context); cdecl;

  nk_style_default: procedure(p1: Pnk_context); cdecl;

  nk_style_from_table: procedure(p1: Pnk_context; const p2: Pnk_color); cdecl;

  nk_style_load_cursor: procedure(p1: Pnk_context; p2: nk_style_cursor; const p3: Pnk_cursor); cdecl;

  nk_style_load_all_cursors: procedure(p1: Pnk_context; p2: Pnk_cursor); cdecl;

  nk_style_get_color_by_name: function(p1: nk_style_colors): PUTF8Char; cdecl;

  nk_style_set_font: procedure(p1: Pnk_context; const p2: Pnk_user_font); cdecl;

  nk_style_set_cursor: function(p1: Pnk_context; p2: nk_style_cursor): nk_bool; cdecl;

  nk_style_show_cursor: procedure(p1: Pnk_context); cdecl;

  nk_style_hide_cursor: procedure(p1: Pnk_context); cdecl;

  nk_style_push_font: function(p1: Pnk_context; const p2: Pnk_user_font): nk_bool; cdecl;

  nk_style_push_float: function(p1: Pnk_context; p2: PSingle; p3: Single): nk_bool; cdecl;

  nk_style_push_vec2: function(p1: Pnk_context; p2: Pnk_vec2; p3: nk_vec2): nk_bool; cdecl;

  nk_style_push_style_item: function(p1: Pnk_context; p2: Pnk_style_item; p3: nk_style_item): nk_bool; cdecl;

  nk_style_push_flags: function(p1: Pnk_context; p2: Pnk_flags; p3: nk_flags): nk_bool; cdecl;

  nk_style_push_color: function(p1: Pnk_context; p2: Pnk_color; p3: nk_color): nk_bool; cdecl;

  nk_style_pop_font: function(p1: Pnk_context): nk_bool; cdecl;

  nk_style_pop_float: function(p1: Pnk_context): nk_bool; cdecl;

  nk_style_pop_vec2: function(p1: Pnk_context): nk_bool; cdecl;

  nk_style_pop_style_item: function(p1: Pnk_context): nk_bool; cdecl;

  nk_style_pop_flags: function(p1: Pnk_context): nk_bool; cdecl;

  nk_style_pop_color: function(p1: Pnk_context): nk_bool; cdecl;

  nk_rgb_rtn: function(r: Integer; g: Integer; b: Integer): nk_color; cdecl;

  nk_rgb_iv: function(const rgb: PInteger): nk_color; cdecl;

  nk_rgb_bv: function(const rgb: Pnk_byte): nk_color; cdecl;

  nk_rgb_f: function(r: Single; g: Single; b: Single): nk_color; cdecl;

  nk_rgb_fv: function(const rgb: PSingle): nk_color; cdecl;

  nk_rgb_cf: function(c: nk_colorf): nk_color; cdecl;

  nk_rgb_hex: function(const rgb: PUTF8Char): nk_color; cdecl;

  nk_rgba_rtn: function(r: Integer; g: Integer; b: Integer; a: Integer): nk_color; cdecl;

  nk_rgba_u32: function(p1: nk_uint): nk_color; cdecl;

  nk_rgba_iv: function(const rgba: PInteger): nk_color; cdecl;

  nk_rgba_bv: function(const rgba: Pnk_byte): nk_color; cdecl;

  nk_rgba_f: function(r: Single; g: Single; b: Single; a: Single): nk_color; cdecl;

  nk_rgba_fv: function(const rgba: PSingle): nk_color; cdecl;

  nk_rgba_cf: function(c: nk_colorf): nk_color; cdecl;

  nk_rgba_hex: function(const rgb: PUTF8Char): nk_color; cdecl;

  nk_hsva_colorf: function(h: Single; s: Single; v: Single; a: Single): nk_colorf; cdecl;

  nk_hsva_colorfv: function(c: PSingle): nk_colorf; cdecl;

  nk_colorf_hsva_f: procedure(out_h: PSingle; out_s: PSingle; out_v: PSingle; out_a: PSingle; in_: nk_colorf); cdecl;

  nk_colorf_hsva_fv: procedure(hsva: PSingle; in_: nk_colorf); cdecl;

  nk_hsv: function(h: Integer; s: Integer; v: Integer): nk_color; cdecl;

  nk_hsv_iv: function(const hsv: PInteger): nk_color; cdecl;

  nk_hsv_bv: function(const hsv: Pnk_byte): nk_color; cdecl;

  nk_hsv_f: function(h: Single; s: Single; v: Single): nk_color; cdecl;

  nk_hsv_fv: function(const hsv: PSingle): nk_color; cdecl;

  nk_hsva: function(h: Integer; s: Integer; v: Integer; a: Integer): nk_color; cdecl;

  nk_hsva_iv: function(const hsva: PInteger): nk_color; cdecl;

  nk_hsva_bv: function(const hsva: Pnk_byte): nk_color; cdecl;

  nk_hsva_f: function(h: Single; s: Single; v: Single; a: Single): nk_color; cdecl;

  nk_hsva_fv: function(const hsva: PSingle): nk_color; cdecl;

  nk_color_f: procedure(r: PSingle; g: PSingle; b: PSingle; a: PSingle; p5: nk_color); cdecl;

  nk_color_fv: procedure(rgba_out: PSingle; p2: nk_color); cdecl;

  nk_color_cf: function(p1: nk_color): nk_colorf; cdecl;

  nk_color_d: procedure(r: PDouble; g: PDouble; b: PDouble; a: PDouble; p5: nk_color); cdecl;

  nk_color_dv: procedure(rgba_out: PDouble; p2: nk_color); cdecl;

  nk_color_u32: function(p1: nk_color): nk_uint; cdecl;

  nk_color_hex_rgba: procedure(output: PUTF8Char; p2: nk_color); cdecl;

  nk_color_hex_rgb: procedure(output: PUTF8Char; p2: nk_color); cdecl;

  nk_color_hsv_i: procedure(out_h: PInteger; out_s: PInteger; out_v: PInteger; p4: nk_color); cdecl;

  nk_color_hsv_b: procedure(out_h: Pnk_byte; out_s: Pnk_byte; out_v: Pnk_byte; p4: nk_color); cdecl;

  nk_color_hsv_iv: procedure(hsv_out: PInteger; p2: nk_color); cdecl;

  nk_color_hsv_bv: procedure(hsv_out: Pnk_byte; p2: nk_color); cdecl;

  nk_color_hsv_f: procedure(out_h: PSingle; out_s: PSingle; out_v: PSingle; p4: nk_color); cdecl;

  nk_color_hsv_fv: procedure(hsv_out: PSingle; p2: nk_color); cdecl;

  nk_color_hsva_i: procedure(h: PInteger; s: PInteger; v: PInteger; a: PInteger; p5: nk_color); cdecl;

  nk_color_hsva_b: procedure(h: Pnk_byte; s: Pnk_byte; v: Pnk_byte; a: Pnk_byte; p5: nk_color); cdecl;

  nk_color_hsva_iv: procedure(hsva_out: PInteger; p2: nk_color); cdecl;

  nk_color_hsva_bv: procedure(hsva_out: Pnk_byte; p2: nk_color); cdecl;

  nk_color_hsva_f: procedure(out_h: PSingle; out_s: PSingle; out_v: PSingle; out_a: PSingle; p5: nk_color); cdecl;

  nk_color_hsva_fv: procedure(hsva_out: PSingle; p2: nk_color); cdecl;

  nk_handle_ptr: function(p1: Pointer): nk_handle; cdecl;

  nk_handle_id: function(p1: Integer): nk_handle; cdecl;

  nk_image_handle: function(p1: nk_handle): nk_image; cdecl;

  nk_image_ptr: function(p1: Pointer): nk_image; cdecl;

  nk_image_id: function(p1: Integer): nk_image; cdecl;

  nk_image_is_subimage: function(const img: Pnk_image): nk_bool; cdecl;

  nk_subimage_ptr: function(p1: Pointer; w: nk_ushort; h: nk_ushort; sub_region: nk_rect): nk_image; cdecl;

  nk_subimage_id: function(p1: Integer; w: nk_ushort; h: nk_ushort; sub_region: nk_rect): nk_image; cdecl;

  nk_subimage_handle: function(p1: nk_handle; w: nk_ushort; h: nk_ushort; sub_region: nk_rect): nk_image; cdecl;

  nk_nine_slice_handle: function(p1: nk_handle; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;

  nk_nine_slice_ptr: function(p1: Pointer; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;

  nk_nine_slice_id: function(p1: Integer; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;

  nk_nine_slice_is_sub9slice: function(const img: Pnk_nine_slice): Integer; cdecl;

  nk_sub9slice_ptr: function(p1: Pointer; w: nk_ushort; h: nk_ushort; sub_region: nk_rect; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;

  nk_sub9slice_id: function(p1: Integer; w: nk_ushort; h: nk_ushort; sub_region: nk_rect; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;

  nk_sub9slice_handle: function(p1: nk_handle; w: nk_ushort; h: nk_ushort; sub_region: nk_rect; l: nk_ushort; t: nk_ushort; r: nk_ushort; b: nk_ushort): nk_nine_slice; cdecl;

  nk_murmur_hash: function(const key: Pointer; len: Integer; seed: nk_hash): nk_hash; cdecl;

  nk_triangle_from_direction: procedure(result: Pnk_vec2; r: nk_rect; pad_x: Single; pad_y: Single; p5: nk_heading); cdecl;

  nk_vec2_rtn: function(x: Single; y: Single): nk_vec2; cdecl;

  nk_vec2i_rtn: function(x: Integer; y: Integer): nk_vec2; cdecl;

  nk_vec2v: function(const xy: PSingle): nk_vec2; cdecl;

  nk_vec2iv: function(const xy: PInteger): nk_vec2; cdecl;

  nk_get_null_rect: function(): nk_rect; cdecl;

  nk_rect_rtn: function(x: Single; y: Single; w: Single; h: Single): nk_rect; cdecl;

  nk_recti_rtn: function(x: Integer; y: Integer; w: Integer; h: Integer): nk_rect; cdecl;

  nk_recta: function(pos: nk_vec2; size: nk_vec2): nk_rect; cdecl;

  nk_rectv: function(const xywh: PSingle): nk_rect; cdecl;

  nk_rectiv: function(const xywh: PInteger): nk_rect; cdecl;

  nk_rect_pos: function(p1: nk_rect): nk_vec2; cdecl;

  nk_rect_size: function(p1: nk_rect): nk_vec2; cdecl;

  nk_strlen: function(const str: PUTF8Char): Integer; cdecl;

  nk_stricmp: function(const s1: PUTF8Char; const s2: PUTF8Char): Integer; cdecl;

  nk_stricmpn: function(const s1: PUTF8Char; const s2: PUTF8Char; n: Integer): Integer; cdecl;

  nk_strtoi: function(const str: PUTF8Char; endptr: PPUTF8Char): Integer; cdecl;

  nk_strtof: function(const str: PUTF8Char; endptr: PPUTF8Char): Single; cdecl;

  nk_strtod: function(const str: PUTF8Char; endptr: PPUTF8Char): Double; cdecl;

  nk_strfilter: function(const text: PUTF8Char; const regexp: PUTF8Char): Integer; cdecl;

  nk_strmatch_fuzzy_string: function(const str: PUTF8Char; const pattern: PUTF8Char; out_score: PInteger): Integer; cdecl;

  nk_strmatch_fuzzy_text: function(const txt: PUTF8Char; txt_len: Integer; const pattern: PUTF8Char; out_score: PInteger): Integer; cdecl;

  nk_utf_decode: function(const p1: PUTF8Char; p2: Pnk_rune; p3: Integer): Integer; cdecl;

  nk_utf_encode: function(p1: nk_rune; p2: PUTF8Char; p3: Integer): Integer; cdecl;

  nk_utf_len: function(const p1: PUTF8Char; byte_len: Integer): Integer; cdecl;

  nk_utf_at: function(const buffer: PUTF8Char; length: Integer; index: Integer; unicode: Pnk_rune; len: PInteger): PUTF8Char; cdecl;

  nk_font_default_glyph_ranges: function(): Pnk_rune; cdecl;

  nk_font_chinese_glyph_ranges: function(): Pnk_rune; cdecl;

  nk_font_cyrillic_glyph_ranges: function(): Pnk_rune; cdecl;

  nk_font_korean_glyph_ranges: function(): Pnk_rune; cdecl;

  nk_font_atlas_init_default: procedure(p1: Pnk_font_atlas); cdecl;

  nk_font_atlas_init: procedure(p1: Pnk_font_atlas; p2: Pnk_allocator); cdecl;

  nk_font_atlas_init_custom: procedure(p1: Pnk_font_atlas; persistent: Pnk_allocator; transient: Pnk_allocator); cdecl;

  nk_font_atlas_begin: procedure(p1: Pnk_font_atlas); cdecl;

  nk_font_config_rtn: function(pixel_height: Single): nk_font_config; cdecl;

  nk_font_atlas_add: function(p1: Pnk_font_atlas; const p2: Pnk_font_config): Pnk_font; cdecl;

  nk_font_atlas_add_default: function(p1: Pnk_font_atlas; height: Single; const p3: Pnk_font_config): Pnk_font; cdecl;

  nk_font_atlas_add_from_memory: function(atlas: Pnk_font_atlas; memory: Pointer; size: nk_size; height: Single; const config: Pnk_font_config): Pnk_font; cdecl;

  nk_font_atlas_add_from_file: function(atlas: Pnk_font_atlas; const file_path: PUTF8Char; height: Single; const p4: Pnk_font_config): Pnk_font; cdecl;

  nk_font_atlas_add_compressed: function(p1: Pnk_font_atlas; memory: Pointer; size: nk_size; height: Single; const p5: Pnk_font_config): Pnk_font; cdecl;

  nk_font_atlas_add_compressed_base85: function(p1: Pnk_font_atlas; const data: PUTF8Char; height: Single; const config: Pnk_font_config): Pnk_font; cdecl;

  nk_font_atlas_bake: function(p1: Pnk_font_atlas; width: PInteger; height: PInteger; p4: nk_font_atlas_format): Pointer; cdecl;

  nk_font_atlas_end: procedure(p1: Pnk_font_atlas; tex: nk_handle; p3: Pnk_draw_null_texture); cdecl;

  nk_font_find_glyph: function(p1: Pnk_font; unicode: nk_rune): Pnk_font_glyph; cdecl;

  nk_font_atlas_cleanup: procedure(atlas: Pnk_font_atlas); cdecl;

  nk_font_atlas_clear: procedure(p1: Pnk_font_atlas); cdecl;

  nk_buffer_init_default: procedure(p1: Pnk_buffer); cdecl;

  nk_buffer_init: procedure(p1: Pnk_buffer; const p2: Pnk_allocator; size: nk_size); cdecl;

  nk_buffer_init_fixed: procedure(p1: Pnk_buffer; memory: Pointer; size: nk_size); cdecl;

  nk_buffer_info: procedure(p1: Pnk_memory_status; p2: Pnk_buffer); cdecl;

  nk_buffer_push: procedure(p1: Pnk_buffer; type_: nk_buffer_allocation_type; const memory: Pointer; size: nk_size; align: nk_size); cdecl;

  nk_buffer_mark: procedure(p1: Pnk_buffer; type_: nk_buffer_allocation_type); cdecl;

  nk_buffer_reset: procedure(p1: Pnk_buffer; type_: nk_buffer_allocation_type); cdecl;

  nk_buffer_clear: procedure(p1: Pnk_buffer); cdecl;

  nk_buffer_free: procedure(p1: Pnk_buffer); cdecl;

  nk_buffer_memory: function(p1: Pnk_buffer): Pointer; cdecl;

  nk_buffer_memory_const: function(const p1: Pnk_buffer): Pointer; cdecl;

  nk_buffer_total: function(p1: Pnk_buffer): nk_size; cdecl;

  nk_str_init_default: procedure(p1: Pnk_str); cdecl;

  nk_str_init: procedure(p1: Pnk_str; const p2: Pnk_allocator; size: nk_size); cdecl;

  nk_str_init_fixed: procedure(p1: Pnk_str; memory: Pointer; size: nk_size); cdecl;

  nk_str_clear: procedure(p1: Pnk_str); cdecl;

  nk_str_free: procedure(p1: Pnk_str); cdecl;

  nk_str_append_text_char: function(p1: Pnk_str; const p2: PUTF8Char; p3: Integer): Integer; cdecl;

  nk_str_append_str_char: function(p1: Pnk_str; const p2: PUTF8Char): Integer; cdecl;

  nk_str_append_text_utf8: function(p1: Pnk_str; const p2: PUTF8Char; p3: Integer): Integer; cdecl;

  nk_str_append_str_utf8: function(p1: Pnk_str; const p2: PUTF8Char): Integer; cdecl;

  nk_str_append_text_runes: function(p1: Pnk_str; const p2: Pnk_rune; p3: Integer): Integer; cdecl;

  nk_str_append_str_runes: function(p1: Pnk_str; const p2: Pnk_rune): Integer; cdecl;

  nk_str_insert_at_char: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char; p4: Integer): Integer; cdecl;

  nk_str_insert_at_rune: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char; p4: Integer): Integer; cdecl;

  nk_str_insert_text_char: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char; p4: Integer): Integer; cdecl;

  nk_str_insert_str_char: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char): Integer; cdecl;

  nk_str_insert_text_utf8: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char; p4: Integer): Integer; cdecl;

  nk_str_insert_str_utf8: function(p1: Pnk_str; pos: Integer; const p3: PUTF8Char): Integer; cdecl;

  nk_str_insert_text_runes: function(p1: Pnk_str; pos: Integer; const p3: Pnk_rune; p4: Integer): Integer; cdecl;

  nk_str_insert_str_runes: function(p1: Pnk_str; pos: Integer; const p3: Pnk_rune): Integer; cdecl;

  nk_str_remove_chars: procedure(p1: Pnk_str; len: Integer); cdecl;

  nk_str_remove_runes: procedure(str: Pnk_str; len: Integer); cdecl;

  nk_str_delete_chars: procedure(p1: Pnk_str; pos: Integer; len: Integer); cdecl;

  nk_str_delete_runes: procedure(p1: Pnk_str; pos: Integer; len: Integer); cdecl;

  nk_str_at_char: function(p1: Pnk_str; pos: Integer): PUTF8Char; cdecl;

  nk_str_at_rune: function(p1: Pnk_str; pos: Integer; unicode: Pnk_rune; len: PInteger): PUTF8Char; cdecl;

  nk_str_rune_at: function(const p1: Pnk_str; pos: Integer): nk_rune; cdecl;

  nk_str_at_char_const: function(const p1: Pnk_str; pos: Integer): PUTF8Char; cdecl;

  nk_str_at_const: function(const p1: Pnk_str; pos: Integer; unicode: Pnk_rune; len: PInteger): PUTF8Char; cdecl;

  nk_str_get: function(p1: Pnk_str): PUTF8Char; cdecl;

  nk_str_get_const: function(const p1: Pnk_str): PUTF8Char; cdecl;

  nk_str_len: function(p1: Pnk_str): Integer; cdecl;

  nk_str_len_char: function(p1: Pnk_str): Integer; cdecl;

  nk_filter_default: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  nk_filter_ascii: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  nk_filter_float: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  nk_filter_decimal: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  nk_filter_hex: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  nk_filter_oct: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  nk_filter_binary: function(const p1: Pnk_text_edit; unicode: nk_rune): nk_bool; cdecl;

  nk_textedit_init_default: procedure(p1: Pnk_text_edit); cdecl;

  nk_textedit_init: procedure(p1: Pnk_text_edit; p2: Pnk_allocator; size: nk_size); cdecl;

  nk_textedit_init_fixed: procedure(p1: Pnk_text_edit; memory: Pointer; size: nk_size); cdecl;

  nk_textedit_free: procedure(p1: Pnk_text_edit); cdecl;

  nk_textedit_text: procedure(p1: Pnk_text_edit; const p2: PUTF8Char; total_len: Integer); cdecl;

  nk_textedit_delete: procedure(p1: Pnk_text_edit; where: Integer; len: Integer); cdecl;

  nk_textedit_delete_selection: procedure(p1: Pnk_text_edit); cdecl;

  nk_textedit_select_all: procedure(p1: Pnk_text_edit); cdecl;

  nk_textedit_cut: function(p1: Pnk_text_edit): nk_bool; cdecl;

  nk_textedit_paste: function(p1: Pnk_text_edit; const p2: PUTF8Char; len: Integer): nk_bool; cdecl;

  nk_textedit_undo: procedure(p1: Pnk_text_edit); cdecl;

  nk_textedit_redo: procedure(p1: Pnk_text_edit); cdecl;

  nk_stroke_line: procedure(b: Pnk_command_buffer; x0: Single; y0: Single; x1: Single; y1: Single; line_thickness: Single; p7: nk_color); cdecl;

  nk_stroke_curve: procedure(p1: Pnk_command_buffer; p2: Single; p3: Single; p4: Single; p5: Single; p6: Single; p7: Single; p8: Single; p9: Single; line_thickness: Single; p11: nk_color); cdecl;

  nk_stroke_rect: procedure(p1: Pnk_command_buffer; p2: nk_rect; rounding: Single; line_thickness: Single; p5: nk_color); cdecl;

  nk_stroke_circle: procedure(p1: Pnk_command_buffer; p2: nk_rect; line_thickness: Single; p4: nk_color); cdecl;

  nk_stroke_arc: procedure(p1: Pnk_command_buffer; cx: Single; cy: Single; radius: Single; a_min: Single; a_max: Single; line_thickness: Single; p8: nk_color); cdecl;

  nk_stroke_triangle: procedure(p1: Pnk_command_buffer; p2: Single; p3: Single; p4: Single; p5: Single; p6: Single; p7: Single; line_thichness: Single; p9: nk_color); cdecl;

  nk_stroke_polyline: procedure(p1: Pnk_command_buffer; points: PSingle; point_count: Integer; line_thickness: Single; col: nk_color); cdecl;

  nk_stroke_polygon: procedure(p1: Pnk_command_buffer; p2: PSingle; point_count: Integer; line_thickness: Single; p5: nk_color); cdecl;

  nk_fill_rect: procedure(p1: Pnk_command_buffer; p2: nk_rect; rounding: Single; p4: nk_color); cdecl;

  nk_fill_rect_multi_color: procedure(p1: Pnk_command_buffer; p2: nk_rect; left: nk_color; top: nk_color; right: nk_color; bottom: nk_color); cdecl;

  nk_fill_circle: procedure(p1: Pnk_command_buffer; p2: nk_rect; p3: nk_color); cdecl;

  nk_fill_arc: procedure(p1: Pnk_command_buffer; cx: Single; cy: Single; radius: Single; a_min: Single; a_max: Single; p7: nk_color); cdecl;

  nk_fill_triangle: procedure(p1: Pnk_command_buffer; x0: Single; y0: Single; x1: Single; y1: Single; x2: Single; y2: Single; p8: nk_color); cdecl;

  nk_fill_polygon: procedure(p1: Pnk_command_buffer; p2: PSingle; point_count: Integer; p4: nk_color); cdecl;

  nk_draw_image: procedure(p1: Pnk_command_buffer; p2: nk_rect; const p3: Pnk_image; p4: nk_color); cdecl;

  nk_draw_nine_slice: procedure(p1: Pnk_command_buffer; p2: nk_rect; const p3: Pnk_nine_slice; p4: nk_color); cdecl;

  nk_draw_text: procedure(p1: Pnk_command_buffer; p2: nk_rect; const text: PUTF8Char; len: Integer; const p5: Pnk_user_font; p6: nk_color; p7: nk_color); cdecl;

  nk_push_scissor: procedure(p1: Pnk_command_buffer; p2: nk_rect); cdecl;

  nk_push_custom: procedure(p1: Pnk_command_buffer; p2: nk_rect; p3: nk_command_custom_callback; usr: nk_handle); cdecl;

  nk_input_has_mouse_click: function(const p1: Pnk_input; p2: nk_buttons): nk_bool; cdecl;

  nk_input_has_mouse_click_in_rect: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect): nk_bool; cdecl;

  nk_input_has_mouse_click_in_button_rect: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect): nk_bool; cdecl;

  nk_input_has_mouse_click_down_in_rect: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect; down: nk_bool): nk_bool; cdecl;

  nk_input_is_mouse_click_in_rect: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect): nk_bool; cdecl;

  nk_input_is_mouse_click_down_in_rect: function(const i: Pnk_input; id: nk_buttons; b: nk_rect; down: nk_bool): nk_bool; cdecl;

  nk_input_any_mouse_click_in_rect: function(const p1: Pnk_input; p2: nk_rect): nk_bool; cdecl;

  nk_input_is_mouse_prev_hovering_rect: function(const p1: Pnk_input; p2: nk_rect): nk_bool; cdecl;

  nk_input_is_mouse_hovering_rect: function(const p1: Pnk_input; p2: nk_rect): nk_bool; cdecl;

  nk_input_mouse_clicked: function(const p1: Pnk_input; p2: nk_buttons; p3: nk_rect): nk_bool; cdecl;

  nk_input_is_mouse_down: function(const p1: Pnk_input; p2: nk_buttons): nk_bool; cdecl;

  nk_input_is_mouse_pressed: function(const p1: Pnk_input; p2: nk_buttons): nk_bool; cdecl;

  nk_input_is_mouse_released: function(const p1: Pnk_input; p2: nk_buttons): nk_bool; cdecl;

  nk_input_is_key_pressed: function(const p1: Pnk_input; p2: nk_keys): nk_bool; cdecl;

  nk_input_is_key_released: function(const p1: Pnk_input; p2: nk_keys): nk_bool; cdecl;

  nk_input_is_key_down: function(const p1: Pnk_input; p2: nk_keys): nk_bool; cdecl;

  nk_draw_list_init: procedure(p1: Pnk_draw_list); cdecl;

  nk_draw_list_setup: procedure(p1: Pnk_draw_list; const p2: Pnk_convert_config; cmds: Pnk_buffer; vertices: Pnk_buffer; elements: Pnk_buffer; line_aa: nk_anti_aliasing; shape_aa: nk_anti_aliasing); cdecl;

  nk__draw_list_begin: function(const p1: Pnk_draw_list; const p2: Pnk_buffer): Pnk_draw_command; cdecl;

  nk__draw_list_next: function(const p1: Pnk_draw_command; const p2: Pnk_buffer; const p3: Pnk_draw_list): Pnk_draw_command; cdecl;

  nk__draw_list_end: function(const p1: Pnk_draw_list; const p2: Pnk_buffer): Pnk_draw_command; cdecl;

  nk_draw_list_path_clear: procedure(p1: Pnk_draw_list); cdecl;

  nk_draw_list_path_line_to: procedure(p1: Pnk_draw_list; pos: nk_vec2); cdecl;

  nk_draw_list_path_arc_to_fast: procedure(p1: Pnk_draw_list; center: nk_vec2; radius: Single; a_min: Integer; a_max: Integer); cdecl;

  nk_draw_list_path_arc_to: procedure(p1: Pnk_draw_list; center: nk_vec2; radius: Single; a_min: Single; a_max: Single; segments: Cardinal); cdecl;

  nk_draw_list_path_rect_to: procedure(p1: Pnk_draw_list; a: nk_vec2; b: nk_vec2; rounding: Single); cdecl;

  nk_draw_list_path_curve_to: procedure(p1: Pnk_draw_list; p2: nk_vec2; p3: nk_vec2; p4: nk_vec2; num_segments: Cardinal); cdecl;

  nk_draw_list_path_fill: procedure(p1: Pnk_draw_list; p2: nk_color); cdecl;

  nk_draw_list_path_stroke: procedure(p1: Pnk_draw_list; p2: nk_color; closed: nk_draw_list_stroke; thickness: Single); cdecl;

  nk_draw_list_stroke_line: procedure(p1: Pnk_draw_list; a: nk_vec2; b: nk_vec2; p4: nk_color; thickness: Single); cdecl;

  nk_draw_list_stroke_rect: procedure(p1: Pnk_draw_list; rect: nk_rect; p3: nk_color; rounding: Single; thickness: Single); cdecl;

  nk_draw_list_stroke_triangle: procedure(p1: Pnk_draw_list; a: nk_vec2; b: nk_vec2; c: nk_vec2; p5: nk_color; thickness: Single); cdecl;

  nk_draw_list_stroke_circle: procedure(p1: Pnk_draw_list; center: nk_vec2; radius: Single; p4: nk_color; segs: Cardinal; thickness: Single); cdecl;

  nk_draw_list_stroke_curve: procedure(draw_list: Pnk_draw_list; p0: nk_vec2; cp0: nk_vec2; cp1: nk_vec2; p1: nk_vec2; p6: nk_color; segments: Cardinal; thickness: Single); cdecl;

  nk_draw_list_stroke_poly_line: procedure(p1: Pnk_draw_list; const pnts: Pnk_vec2; const cnt: Cardinal; p4: nk_color; p5: nk_draw_list_stroke; thickness: Single; p7: nk_anti_aliasing); cdecl;

  nk_draw_list_fill_rect: procedure(p1: Pnk_draw_list; rect: nk_rect; p3: nk_color; rounding: Single); cdecl;

  nk_draw_list_fill_rect_multi_color: procedure(p1: Pnk_draw_list; rect: nk_rect; left: nk_color; top: nk_color; right: nk_color; bottom: nk_color); cdecl;

  nk_draw_list_fill_triangle: procedure(p1: Pnk_draw_list; a: nk_vec2; b: nk_vec2; c: nk_vec2; p5: nk_color); cdecl;

  nk_draw_list_fill_circle: procedure(p1: Pnk_draw_list; center: nk_vec2; radius: Single; col: nk_color; segs: Cardinal); cdecl;

  nk_draw_list_fill_poly_convex: procedure(p1: Pnk_draw_list; const points: Pnk_vec2; const count: Cardinal; p4: nk_color; p5: nk_anti_aliasing); cdecl;

  nk_draw_list_add_image: procedure(p1: Pnk_draw_list; texture: nk_image; rect: nk_rect; p4: nk_color); cdecl;

  nk_draw_list_add_text: procedure(p1: Pnk_draw_list; const p2: Pnk_user_font; p3: nk_rect; const text: PUTF8Char; len: Integer; font_height: Single; p7: nk_color); cdecl;

  nk_style_item_color_rtn: function(p1: nk_color): nk_style_item; cdecl;

  nk_style_item_image_rtn: function(img: nk_image): nk_style_item; cdecl;

  nk_style_item_nine_slice_rtn: function(slice: nk_nine_slice): nk_style_item; cdecl;

  nk_style_item_hide: function(): nk_style_item; cdecl;

  plm_create_with_filename: function(const filename: PUTF8Char): Pplm_t; cdecl;

  plm_create_with_file: function(fh: PPointer; close_when_done: Integer): Pplm_t; cdecl;

  plm_create_with_memory: function(bytes: PUInt8; length: NativeUInt; free_when_done: Integer): Pplm_t; cdecl;

  plm_create_with_buffer: function(buffer: Pplm_buffer_t; destroy_when_done: Integer): Pplm_t; cdecl;

  plm_destroy: procedure(self: Pplm_t); cdecl;

  plm_has_headers: function(self: Pplm_t): Integer; cdecl;

  plm_get_video_enabled: function(self: Pplm_t): Integer; cdecl;

  plm_set_video_enabled: procedure(self: Pplm_t; enabled: Integer); cdecl;

  plm_get_num_video_streams: function(self: Pplm_t): Integer; cdecl;

  plm_get_width: function(self: Pplm_t): Integer; cdecl;

  plm_get_height: function(self: Pplm_t): Integer; cdecl;

  plm_get_framerate: function(self: Pplm_t): Double; cdecl;

  plm_get_audio_enabled: function(self: Pplm_t): Integer; cdecl;

  plm_set_audio_enabled: procedure(self: Pplm_t; enabled: Integer); cdecl;

  plm_get_num_audio_streams: function(self: Pplm_t): Integer; cdecl;

  plm_set_audio_stream: procedure(self: Pplm_t; stream_index: Integer); cdecl;

  plm_get_samplerate: function(self: Pplm_t): Integer; cdecl;

  plm_get_audio_lead_time: function(self: Pplm_t): Double; cdecl;

  plm_set_audio_lead_time: procedure(self: Pplm_t; lead_time: Double); cdecl;

  plm_get_time: function(self: Pplm_t): Double; cdecl;

  plm_get_duration: function(self: Pplm_t): Double; cdecl;

  plm_rewind: procedure(self: Pplm_t); cdecl;

  plm_get_loop: function(self: Pplm_t): Integer; cdecl;

  plm_set_loop: procedure(self: Pplm_t; loop: Integer); cdecl;

  plm_has_ended: function(self: Pplm_t): Integer; cdecl;

  plm_set_video_decode_callback: procedure(self: Pplm_t; fp: plm_video_decode_callback; user: Pointer); cdecl;

  plm_set_audio_decode_callback: procedure(self: Pplm_t; fp: plm_audio_decode_callback; user: Pointer); cdecl;

  plm_decode: procedure(self: Pplm_t; seconds: Double); cdecl;

  plm_decode_video: function(self: Pplm_t): Pplm_frame_t; cdecl;

  plm_decode_audio: function(self: Pplm_t): Pplm_samples_t; cdecl;

  plm_seek: function(self: Pplm_t; time: Double; seek_exact: Integer): Integer; cdecl;

  plm_seek_frame: function(self: Pplm_t; time: Double; seek_exact: Integer): Pplm_frame_t; cdecl;

  plm_buffer_create_with_filename: function(const filename: PUTF8Char): Pplm_buffer_t; cdecl;

  plm_buffer_create_with_file: function(fh: PPointer; close_when_done: Integer): Pplm_buffer_t; cdecl;

  plm_buffer_create_with_memory: function(bytes: PUInt8; length: NativeUInt; free_when_done: Integer): Pplm_buffer_t; cdecl;

  plm_buffer_create_with_capacity: function(capacity: NativeUInt): Pplm_buffer_t; cdecl;

  plm_buffer_create_for_appending: function(initial_capacity: NativeUInt): Pplm_buffer_t; cdecl;

  plm_buffer_destroy: procedure(self: Pplm_buffer_t); cdecl;

  plm_buffer_write: function(self: Pplm_buffer_t; bytes: PUInt8; length: NativeUInt): NativeUInt; cdecl;

  plm_buffer_signal_end: procedure(self: Pplm_buffer_t); cdecl;

  plm_buffer_set_load_callback: procedure(self: Pplm_buffer_t; fp: plm_buffer_load_callback; user: Pointer); cdecl;

  plm_buffer_rewind: procedure(self: Pplm_buffer_t); cdecl;

  plm_buffer_get_size: function(self: Pplm_buffer_t): NativeUInt; cdecl;

  plm_buffer_get_remaining: function(self: Pplm_buffer_t): NativeUInt; cdecl;

  plm_buffer_has_ended: function(self: Pplm_buffer_t): Integer; cdecl;

  plm_demux_create: function(buffer: Pplm_buffer_t; destroy_when_done: Integer): Pplm_demux_t; cdecl;

  plm_demux_destroy: procedure(self: Pplm_demux_t); cdecl;

  plm_demux_has_headers: function(self: Pplm_demux_t): Integer; cdecl;

  plm_demux_get_num_video_streams: function(self: Pplm_demux_t): Integer; cdecl;

  plm_demux_get_num_audio_streams: function(self: Pplm_demux_t): Integer; cdecl;

  plm_demux_rewind: procedure(self: Pplm_demux_t); cdecl;

  plm_demux_has_ended: function(self: Pplm_demux_t): Integer; cdecl;

  plm_demux_seek: function(self: Pplm_demux_t; time: Double; type_: Integer; force_intra: Integer): Pplm_packet_t; cdecl;

  plm_demux_get_start_time: function(self: Pplm_demux_t; type_: Integer): Double; cdecl;

  plm_demux_get_duration: function(self: Pplm_demux_t; type_: Integer): Double; cdecl;

  plm_demux_decode: function(self: Pplm_demux_t): Pplm_packet_t; cdecl;

  plm_video_create_with_buffer: function(buffer: Pplm_buffer_t; destroy_when_done: Integer): Pplm_video_t; cdecl;

  plm_video_destroy: procedure(self: Pplm_video_t); cdecl;

  plm_video_has_header: function(self: Pplm_video_t): Integer; cdecl;

  plm_video_get_framerate: function(self: Pplm_video_t): Double; cdecl;

  plm_video_get_width: function(self: Pplm_video_t): Integer; cdecl;

  plm_video_get_height: function(self: Pplm_video_t): Integer; cdecl;

  plm_video_set_no_delay: procedure(self: Pplm_video_t; no_delay: Integer); cdecl;

  plm_video_get_time: function(self: Pplm_video_t): Double; cdecl;

  plm_video_set_time: procedure(self: Pplm_video_t; time: Double); cdecl;

  plm_video_rewind: procedure(self: Pplm_video_t); cdecl;

  plm_video_has_ended: function(self: Pplm_video_t): Integer; cdecl;

  plm_video_decode: function(self: Pplm_video_t): Pplm_frame_t; cdecl;

  plm_frame_to_rgb: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;

  plm_frame_to_bgr: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;

  plm_frame_to_rgba: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;

  plm_frame_to_bgra: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;

  plm_frame_to_argb: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;

  plm_frame_to_abgr: procedure(frame: Pplm_frame_t; dest: PUInt8; stride: Integer); cdecl;

  plm_audio_create_with_buffer: function(buffer: Pplm_buffer_t; destroy_when_done: Integer): Pplm_audio_t; cdecl;

  plm_audio_destroy: procedure(self: Pplm_audio_t); cdecl;

  plm_audio_has_header: function(self: Pplm_audio_t): Integer; cdecl;

  plm_audio_get_samplerate: function(self: Pplm_audio_t): Integer; cdecl;

  plm_audio_get_time: function(self: Pplm_audio_t): Double; cdecl;

  plm_audio_set_time: procedure(self: Pplm_audio_t; time: Double); cdecl;

  plm_audio_rewind: procedure(self: Pplm_audio_t); cdecl;

  plm_audio_has_ended: function(self: Pplm_audio_t): Integer; cdecl;

  plm_audio_decode: function(self: Pplm_audio_t): Pplm_samples_t; cdecl;

  crc32: function(crc: Cardinal; const buf: PByte; len: Cardinal): Cardinal; cdecl;

  zipOpen: function(const pathname: PUTF8Char; append: Integer): zipFile; cdecl;

  zipOpenNewFileInZip3: function(file_: zipFile; const filename: PUTF8Char; const zipfi: Pzip_fileinfo; const extrafield_local: Pointer; size_extrafield_local: uInt; const extrafield_global: Pointer; size_extrafield_global: uInt; const comment: PUTF8Char; method: Integer; level: Integer; raw: Integer; windowBits: Integer; memLevel: Integer; strategy: Integer; const password: PUTF8Char; crcForCrypting: uLong): Integer; cdecl;

  zipWriteInFileInZip: function(file_: zipFile; const buf: Pointer; len: Cardinal): Integer; cdecl;

  zipCloseFileInZip: function(file_: zipFile): Integer; cdecl;

  zipClose: function(file_: zipFile; const global_comment: PUTF8Char): Integer; cdecl;

  nk_sdl_init: function(win: PSDL_Window; renderer: PSDL_Renderer): Pnk_context; cdecl;

  nk_sdl_font_stash_begin: procedure(atlas: PPnk_font_atlas); cdecl;

  nk_sdl_font_stash_end: procedure(); cdecl;

  nk_sdl_handle_event: function(evt: PSDL_Event): Integer; cdecl;

  nk_sdl_render: procedure(p1: nk_anti_aliasing); cdecl;

  nk_sdl_shutdown: procedure(); cdecl;

  pixelColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; color: Uint32): Integer; cdecl;

  pixelRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  hlineColor: function(renderer: PSDL_Renderer; x1: Sint16; x2: Sint16; y: Sint16; color: Uint32): Integer; cdecl;

  hlineRGBA: function(renderer: PSDL_Renderer; x1: Sint16; x2: Sint16; y: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  vlineColor: function(renderer: PSDL_Renderer; x: Sint16; y1: Sint16; y2: Sint16; color: Uint32): Integer; cdecl;

  vlineRGBA: function(renderer: PSDL_Renderer; x: Sint16; y1: Sint16; y2: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  rectangleColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; color: Uint32): Integer; cdecl;

  rectangleRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  roundedRectangleColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; rad: Sint16; color: Uint32): Integer; cdecl;

  roundedRectangleRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; rad: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  boxColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; color: Uint32): Integer; cdecl;

  boxRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  roundedBoxColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; rad: Sint16; color: Uint32): Integer; cdecl;

  roundedBoxRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; rad: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  lineColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; color: Uint32): Integer; cdecl;

  lineRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  aalineColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; color: Uint32): Integer; cdecl;

  aalineRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  thickLineColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; width: Uint8; color: Uint32): Integer; cdecl;

  thickLineRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; width: Uint8; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  circleColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; color: Uint32): Integer; cdecl;

  circleRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  arcColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; start: Sint16; end_: Sint16; color: Uint32): Integer; cdecl;

  arcRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; start: Sint16; end_: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  aacircleColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; color: Uint32): Integer; cdecl;

  aacircleRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  filledCircleColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; r: Sint16; color: Uint32): Integer; cdecl;

  filledCircleRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  ellipseColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rx: Sint16; ry: Sint16; color: Uint32): Integer; cdecl;

  ellipseRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rx: Sint16; ry: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  aaellipseColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rx: Sint16; ry: Sint16; color: Uint32): Integer; cdecl;

  aaellipseRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rx: Sint16; ry: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  filledEllipseColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rx: Sint16; ry: Sint16; color: Uint32): Integer; cdecl;

  filledEllipseRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rx: Sint16; ry: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  pieColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; start: Sint16; end_: Sint16; color: Uint32): Integer; cdecl;

  pieRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; start: Sint16; end_: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  filledPieColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; start: Sint16; end_: Sint16; color: Uint32): Integer; cdecl;

  filledPieRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; rad: Sint16; start: Sint16; end_: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  trigonColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; x3: Sint16; y3: Sint16; color: Uint32): Integer; cdecl;

  trigonRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; x3: Sint16; y3: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  aatrigonColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; x3: Sint16; y3: Sint16; color: Uint32): Integer; cdecl;

  aatrigonRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; x3: Sint16; y3: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  filledTrigonColor: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; x3: Sint16; y3: Sint16; color: Uint32): Integer; cdecl;

  filledTrigonRGBA: function(renderer: PSDL_Renderer; x1: Sint16; y1: Sint16; x2: Sint16; y2: Sint16; x3: Sint16; y3: Sint16; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  polygonColor: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; color: Uint32): Integer; cdecl;

  polygonRGBA: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  aapolygonColor: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; color: Uint32): Integer; cdecl;

  aapolygonRGBA: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  filledPolygonColor: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; color: Uint32): Integer; cdecl;

  filledPolygonRGBA: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  texturedPolygon: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; texture: PSDL_Surface; texture_dx: Integer; texture_dy: Integer): Integer; cdecl;

  bezierColor: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; s: Integer; color: Uint32): Integer; cdecl;

  bezierRGBA: function(renderer: PSDL_Renderer; const vx: PSint16; const vy: PSint16; n: Integer; s: Integer; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  gfxPrimitivesSetFont: procedure(const fontdata: Pointer; cw: Uint32; ch: Uint32); cdecl;

  gfxPrimitivesSetFontRotation: procedure(rotation: Uint32); cdecl;

  characterColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; c: UTF8Char; color: Uint32): Integer; cdecl;

  characterRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; c: UTF8Char; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;

  stringColor: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; const s: PUTF8Char; color: Uint32): Integer; cdecl;

  stringRGBA: function(renderer: PSDL_Renderer; x: Sint16; y: Sint16; const s: PUTF8Char; r: Uint8; g: Uint8; b: Uint8; a: Uint8): Integer; cdecl;


{$REGION 'Common Colors'}
const
  ALICEBLUE           : SDL_Color = (r:$F0; g:$F8; b:$FF; a:$FF);
  ANTIQUEWHITE        : SDL_Color = (r:$FA; g:$EB; b:$D7; a:$FF);
  AQUA                : SDL_Color = (r:$00; g:$FF; b:$FF; a:$FF);
  AQUAMARINE          : SDL_Color = (r:$7F; g:$FF; b:$D4; a:$FF);
  AZURE               : SDL_Color = (r:$F0; g:$FF; b:$FF; a:$FF);
  BEIGE               : SDL_Color = (r:$F5; g:$F5; b:$DC; a:$FF);
  BISQUE              : SDL_Color = (r:$FF; g:$E4; b:$C4; a:$FF);
  BLACK               : SDL_Color = (r:$00; g:$00; b:$00; a:$FF);
  BLANCHEDALMOND      : SDL_Color = (r:$FF; g:$EB; b:$CD; a:$FF);
  BLUE                : SDL_Color = (r:$00; g:$00; b:$FF; a:$FF);
  BLUEVIOLET          : SDL_Color = (r:$8A; g:$2B; b:$E2; a:$FF);
  BROWN               : SDL_Color = (r:$A5; g:$2A; b:$2A; a:$FF);
  BURLYWOOD           : SDL_Color = (r:$DE; g:$B8; b:$87; a:$FF);
  CADETBLUE           : SDL_Color = (r:$5F; g:$9E; b:$A0; a:$FF);
  CHARTREUSE          : SDL_Color = (r:$7F; g:$FF; b:$00; a:$FF);
  CHOCOLATE           : SDL_Color = (r:$D2; g:$69; b:$1E; a:$FF);
  CORAL               : SDL_Color = (r:$FF; g:$7F; b:$50; a:$FF);
  CORNFLOWERBLUE      : SDL_Color = (r:$64; g:$95; b:$ED; a:$FF);
  CORNSILK            : SDL_Color = (r:$FF; g:$F8; b:$DC; a:$FF);
  CRIMSON             : SDL_Color = (r:$DC; g:$14; b:$3C; a:$FF);
  CYAN                : SDL_Color = (r:$00; g:$FF; b:$FF; a:$FF);
  DARKBLUE            : SDL_Color = (r:$00; g:$00; b:$8B; a:$FF);
  DARKCYAN            : SDL_Color = (r:$00; g:$8B; b:$8B; a:$FF);
  DARKGOLDENROD       : SDL_Color = (r:$B8; g:$86; b:$0B; a:$FF);
  DARKGRAY            : SDL_Color = (r:$A9; g:$A9; b:$A9; a:$FF);
  DARKGREEN           : SDL_Color = (r:$00; g:$64; b:$00; a:$FF);
  DARKGREY            : SDL_Color = (r:$A9; g:$A9; b:$A9; a:$FF);
  DARKKHAKI           : SDL_Color = (r:$BD; g:$B7; b:$6B; a:$FF);
  DARKMAGENTA         : SDL_Color = (r:$8B; g:$00; b:$8B; a:$FF);
  DARKOLIVEGREEN      : SDL_Color = (r:$55; g:$6B; b:$2F; a:$FF);
  DARKORANGE          : SDL_Color = (r:$FF; g:$8C; b:$00; a:$FF);
  DARKORCHID          : SDL_Color = (r:$99; g:$32; b:$CC; a:$FF);
  DARKRED             : SDL_Color = (r:$8B; g:$00; b:$00; a:$FF);
  DARKSALMON          : SDL_Color = (r:$E9; g:$96; b:$7A; a:$FF);
  DARKSEAGREEN        : SDL_Color = (r:$8F; g:$BC; b:$8F; a:$FF);
  DARKSLATEBLUE       : SDL_Color = (r:$48; g:$3D; b:$8B; a:$FF);
  DARKSLATEGRAY       : SDL_Color = (r:$2F; g:$4F; b:$4F; a:$FF);
  DARKTURQUOISE       : SDL_Color = (r:$00; g:$CE; b:$D1; a:$FF);
  DARKVIOLET          : SDL_Color = (r:$94; g:$00; b:$D3; a:$FF);
  DEEPPINK            : SDL_Color = (r:$FF; g:$14; b:$93; a:$FF);
  DEEPSKYBLUE         : SDL_Color = (r:$00; g:$BF; b:$FF; a:$FF);
  DIMGRAY             : SDL_Color = (r:$69; g:$69; b:$69; a:$FF);
  DODGERBLUE          : SDL_Color = (r:$1E; g:$90; b:$FF; a:$FF);
  FIREBRICK           : SDL_Color = (r:$B2; g:$22; b:$22; a:$FF);
  FLORALWHITE         : SDL_Color = (r:$FF; g:$FA; b:$F0; a:$FF);
  FORESTGREEN         : SDL_Color = (r:$22; g:$8B; b:$22; a:$FF);
  FUCHSIA             : SDL_Color = (r:$FF; g:$00; b:$FF; a:$FF);
  GAINSBORO           : SDL_Color = (r:$DC; g:$DC; b:$DC; a:$FF);
  GHOSTWHITE          : SDL_Color = (r:$F8; g:$F8; b:$FF; a:$FF);
  GOLD                : SDL_Color = (r:$FF; g:$D7; b:$00; a:$FF);
  GOLDENROD           : SDL_Color = (r:$DA; g:$A5; b:$20; a:$FF);
  GRAY                : SDL_Color = (r:$80; g:$80; b:$80; a:$FF);
  GREEN               : SDL_Color = (r:$00; g:$80; b:$00; a:$FF);
  GREENYELLOW         : SDL_Color = (r:$AD; g:$FF; b:$2F; a:$FF);
  GREY                : SDL_Color = (r:$80; g:$80; b:$80; a:$FF);
  HONEYDEW            : SDL_Color = (r:$F0; g:$FF; b:$F0; a:$FF);
  HOTPINK             : SDL_Color = (r:$FF; g:$69; b:$B4; a:$FF);
  INDIANRED           : SDL_Color = (r:$CD; g:$5C; b:$5C; a:$FF);
  INDIGO              : SDL_Color = (r:$4B; g:$00; b:$82; a:$FF);
  IVORY               : SDL_Color = (r:$FF; g:$FF; b:$F0; a:$FF);
  KHAKI               : SDL_Color = (r:$F0; g:$E6; b:$8C; a:$FF);
  LAVENDER            : SDL_Color = (r:$E6; g:$E6; b:$FA; a:$FF);
  LAVENDERBLUSH       : SDL_Color = (r:$FF; g:$F0; b:$F5; a:$FF);
  LAWNGREEN           : SDL_Color = (r:$7C; g:$FC; b:$00; a:$FF);
  LEMONCHIFFON        : SDL_Color = (r:$FF; g:$FA; b:$CD; a:$FF);
  LIGHTBLUE           : SDL_Color = (r:$AD; g:$D8; b:$E6; a:$FF);
  LIGHTCORAL          : SDL_Color = (r:$F0; g:$80; b:$80; a:$FF);
  LIGHTCYAN           : SDL_Color = (r:$E0; g:$FF; b:$FF; a:$FF);
  LIGHTGOLDENRODYELLOW: SDL_Color = (r:$FA; g:$FA; b:$D2; a:$FF);
  LIGHTGRAY           : SDL_Color = (r:$D3; g:$D3; b:$D3; a:$FF);
  LIGHTGREEN          : SDL_Color = (r:$90; g:$EE; b:$90; a:$FF);
  LIGHTGREY           : SDL_Color = (r:$D3; g:$D3; b:$D3; a:$FF);
  LIGHTPINK           : SDL_Color = (r:$FF; g:$B6; b:$C1; a:$FF);
  LIGHTSALMON         : SDL_Color = (r:$FF; g:$A0; b:$7A; a:$FF);
  LIGHTSEAGREEN       : SDL_Color = (r:$20; g:$B2; b:$AA; a:$FF);
  LIGHTSKYBLUE        : SDL_Color = (r:$87; g:$CE; b:$FA; a:$FF);
  LIGHTSLATEGRAY      : SDL_Color = (r:$77; g:$88; b:$99; a:$FF);
  LIGHTSLATEGREY      : SDL_Color = (r:$77; g:$88; b:$99; a:$FF);
  LIGHTSTEELBLUE      : SDL_Color = (r:$B0; g:$C4; b:$DE; a:$FF);
  LIGHTYELLOW         : SDL_Color = (r:$FF; g:$FF; b:$E0; a:$FF);
  LIME                : SDL_Color = (r:$00; g:$FF; b:$00; a:$FF);
  LIMEGREEN           : SDL_Color = (r:$32; g:$CD; b:$32; a:$FF);
  LINEN               : SDL_Color = (r:$FA; g:$F0; b:$E6; a:$FF);
  MAGENTA             : SDL_Color = (r:$FF; g:$00; b:$FF; a:$FF);
  MAROON              : SDL_Color = (r:$80; g:$00; b:$00; a:$FF);
  MEDIUMAQUAMARINE    : SDL_Color = (r:$66; g:$CD; b:$AA; a:$FF);
  MEDIUMBLUE          : SDL_Color = (r:$00; g:$00; b:$CD; a:$FF);
  MEDIUMORCHID        : SDL_Color = (r:$BA; g:$55; b:$D3; a:$FF);
  MEDIUMPURPLE        : SDL_Color = (r:$93; g:$70; b:$DB; a:$FF);
  MEDIUMSEAGREEN      : SDL_Color = (r:$3C; g:$B3; b:$71; a:$FF);
  MEDIUMSLATEBLUE     : SDL_Color = (r:$7B; g:$68; b:$EE; a:$FF);
  MEDIUMSPRINGGREEN   : SDL_Color = (r:$00; g:$FA; b:$9A; a:$FF);
  MEDIUMTURQUOISE     : SDL_Color = (r:$48; g:$D1; b:$CC; a:$FF);
  MEDIUMVIOLETRED     : SDL_Color = (r:$C7; g:$15; b:$85; a:$FF);
  MIDNIGHTBLUE        : SDL_Color = (r:$19; g:$19; b:$70; a:$FF);
  MINTCREAM           : SDL_Color = (r:$F5; g:$FF; b:$FA; a:$FF);
  MISTYROSE           : SDL_Color = (r:$FF; g:$E4; b:$E1; a:$FF);
  MOCCASIN            : SDL_Color = (r:$FF; g:$E4; b:$B5; a:$FF);
  NAVAJOWHITE         : SDL_Color = (r:$FF; g:$DE; b:$AD; a:$FF);
  NAVY                : SDL_Color = (r:$00; g:$00; b:$80; a:$FF);
  OLDLACE             : SDL_Color = (r:$FD; g:$F5; b:$E6; a:$FF);
  OLIVE               : SDL_Color = (r:$80; g:$80; b:$00; a:$FF);
  OLIVEDRAB           : SDL_Color = (r:$6B; g:$8E; b:$23; a:$FF);
  ORANGE              : SDL_Color = (r:$FF; g:$A5; b:$00; a:$FF);
  ORANGERED           : SDL_Color = (r:$FF; g:$45; b:$00; a:$FF);
  ORCHID              : SDL_Color = (r:$DA; g:$70; b:$D6; a:$FF);
  PALEGOLDENROD       : SDL_Color = (r:$EE; g:$E8; b:$AA; a:$FF);
  PALEGREEN           : SDL_Color = (r:$98; g:$FB; b:$98; a:$FF);
  PALETURQUOISE       : SDL_Color = (r:$AF; g:$EE; b:$EE; a:$FF);
  PALEVIOLETRED       : SDL_Color = (r:$DB; g:$70; b:$93; a:$FF);
  PAPAYAWHIP          : SDL_Color = (r:$FF; g:$EF; b:$D5; a:$FF);
  PEACHPUFF           : SDL_Color = (r:$FF; g:$DA; b:$B9; a:$FF);
  PERU                : SDL_Color = (r:$CD; g:$85; b:$3F; a:$FF);
  PINK                : SDL_Color = (r:$FF; g:$C0; b:$CB; a:$FF);
  PLUM                : SDL_Color = (r:$DD; g:$A0; b:$DD; a:$FF);
  POWDERBLUE          : SDL_Color = (r:$B0; g:$E0; b:$E6; a:$FF);
  PURPLE              : SDL_Color = (r:$80; g:$00; b:$80; a:$FF);
  REBECCAPURPLE       : SDL_Color = (r:$66; g:$33; b:$99; a:$FF);
  RED                 : SDL_Color = (r:$FF; g:$00; b:$00; a:$FF);
  ROSYBROWN           : SDL_Color = (r:$BC; g:$8F; b:$8F; a:$FF);
  ROYALBLUE           : SDL_Color = (r:$41; g:$69; b:$E1; a:$FF);
  SADDLEBROWN         : SDL_Color = (r:$8B; g:$45; b:$13; a:$FF);
  SALMON              : SDL_Color = (r:$FA; g:$80; b:$72; a:$FF);
  SANDYBROWN          : SDL_Color = (r:$F4; g:$A4; b:$60; a:$FF);
  SEAGREEN            : SDL_Color = (r:$2E; g:$8B; b:$57; a:$FF);
  SEASHELL            : SDL_Color = (r:$FF; g:$F5; b:$EE; a:$FF);
  SIENNA              : SDL_Color = (r:$A0; g:$52; b:$2D; a:$FF);
  SILVER              : SDL_Color = (r:$C0; g:$C0; b:$C0; a:$FF);
  SKYBLUE             : SDL_Color = (r:$87; g:$CE; b:$EB; a:$FF);
  SLATEBLUE           : SDL_Color = (r:$6A; g:$5A; b:$CD; a:$FF);
  SLATEGRAY           : SDL_Color = (r:$70; g:$80; b:$90; a:$FF);
  SLATEGREY           : SDL_Color = (r:$70; g:$80; b:$90; a:$FF);
  SNOW                : SDL_Color = (r:$FF; g:$FA; b:$FA; a:$FF);
  SPRINGGREEN         : SDL_Color = (r:$00; g:$FF; b:$7F; a:$FF);
  STEELBLUE           : SDL_Color = (r:$46; g:$82; b:$B4; a:$FF);
  TAN                 : SDL_Color = (r:$D2; g:$B4; b:$8C; a:$FF);
  TEAL                : SDL_Color = (r:$00; g:$80; b:$80; a:$FF);
  THISTLE             : SDL_Color = (r:$D8; g:$BF; b:$D8; a:$FF);
  TOMATO              : SDL_Color = (r:$FF; g:$63; b:$47; a:$FF);
  TURQUOISE           : SDL_Color = (r:$40; g:$E0; b:$D0; a:$FF);
  VIOLET              : SDL_Color = (r:$EE; g:$82; b:$EE; a:$FF);
  WHEAT               : SDL_Color = (r:$F5; g:$DE; b:$B3; a:$FF);
  WHITE               : SDL_Color = (r:$FF; g:$FF; b:$FF; a:$FF);
  WHITESMOKE          : SDL_Color = (r:$F5; g:$F5; b:$F5; a:$FF);
  YELLOW              : SDL_Color = (r:$FF; g:$FF; b:$00; a:$FF);
  YELLOWGREEN         : SDL_Color = (r:$9A; g:$CD; b:$32; a:$FF);
  BLANK               : SDL_Color = (r:$00; g:$00; b:$00; a:$00);
  WHITE2              : SDL_Color = (r:$F5; g:$F5; b:$F5; a:$FF);
  RED2                : SDL_Color = (r:$7E; g:$32; b:$3F; a:255);
  COLORKEY            : SDL_Color = (r:$FF; g:$00; b:$FF; a:$FF);
  OVERLAY1            : SDL_Color = (r:$00; g:$20; b:$29; a:$B4);
  OVERLAY2            : SDL_Color = (r:$01; g:$1B; b:$01; a:255);
  DIMWHITE            : SDL_Color = (r:$10; g:$10; b:$10; a:$10);
  DARKSLATEBROWN      : SDL_Color = (r:30;  g:31;  b:30;  a:1);
{$ENDREGION}

{$ENDREGION}

{$REGION 'Luna.SpeechLib'}
const
  // TypeLibrary Major and minor versions
  SpeechLibMajorVersion = 5;
  SpeechLibMinorVersion = 4;

  LIBID_SpeechLib: TGUID = '{C866CA3A-32F7-11D2-9602-00C04F8EE628}';

  IID_ISpeechDataKey: TGUID = '{CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}';
  IID_ISpeechObjectToken: TGUID = '{C74A3ADC-B727-4500-A84A-B526721C8B8C}';
  IID_ISpeechObjectTokenCategory: TGUID = '{CA7EAC50-2D01-4145-86D4-5AE7D70F4469}';
  IID_ISpeechObjectTokens: TGUID = '{9285B776-2E7B-4BC0-B53E-580EB6FA967F}';
  IID_ISpeechAudioBufferInfo: TGUID = '{11B103D8-1142-4EDF-A093-82FB3915F8CC}';
  IID_ISpeechAudioStatus: TGUID = '{C62D9C91-7458-47F6-862D-1EF86FB0B278}';
  IID_ISpeechAudioFormat: TGUID = '{E6E9C590-3E18-40E3-8299-061F98BDE7C7}';
  IID_ISpeechWaveFormatEx: TGUID = '{7A1EF0D5-1581-4741-88E4-209A49F11A10}';
  IID_ISpeechBaseStream: TGUID = '{6450336F-7D49-4CED-8097-49D6DEE37294}';
  IID_ISpeechFileStream: TGUID = '{AF67F125-AB39-4E93-B4A2-CC2E66E182A7}';
  IID_ISpeechMemoryStream: TGUID = '{EEB14B68-808B-4ABE-A5EA-B51DA7588008}';
  IID_ISpeechCustomStream: TGUID = '{1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}';
  IID_ISpeechAudio: TGUID = '{CFF8E175-019E-11D3-A08E-00C04F8EF9B5}';
  IID_ISpeechMMSysAudio: TGUID = '{3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}';
  IID_ISpeechVoice: TGUID = '{269316D8-57BD-11D2-9EEE-00C04F797396}';
  IID_ISpeechVoiceStatus: TGUID = '{8BE47B07-57F6-11D2-9EEE-00C04F797396}';
  DIID__ISpeechVoiceEvents: TGUID = '{A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}';
  IID_ISpeechRecognizer: TGUID = '{2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}';
  IID_ISpeechRecognizerStatus: TGUID = '{BFF9E781-53EC-484E-BB8A-0E1B5551E35C}';
  IID_ISpeechRecoContext: TGUID = '{580AA49D-7E1E-4809-B8E2-57DA806104B8}';
  IID_ISpeechRecoGrammar: TGUID = '{B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}';
  IID_ISpeechGrammarRules: TGUID = '{6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}';
  IID_ISpeechGrammarRule: TGUID = '{AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}';
  IID_ISpeechGrammarRuleState: TGUID = '{D4286F2C-EE67-45AE-B928-28D695362EDA}';
  IID_ISpeechGrammarRuleStateTransitions: TGUID = '{EABCE657-75BC-44A2-AA7F-C56476742963}';
  IID_ISpeechGrammarRuleStateTransition: TGUID = '{CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}';
  IID_ISpeechTextSelectionInformation: TGUID = '{3B9C7E7A-6EEE-4DED-9092-11657279ADBE}';
  IID_ISpeechRecoResult: TGUID = '{ED2879CF-CED9-4EE6-A534-DE0191D5468D}';
  IID_ISpeechRecoResultTimes: TGUID = '{62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}';
  IID_ISpeechPhraseInfo: TGUID = '{961559CF-4E67-4662-8BF0-D93F1FCD61B3}';
  IID_ISpeechPhraseRule: TGUID = '{A7BFE112-A4A0-48D9-B602-C313843F6964}';
  IID_ISpeechPhraseRules: TGUID = '{9047D593-01DD-4B72-81A3-E4A0CA69F407}';
  IID_ISpeechPhraseProperties: TGUID = '{08166B47-102E-4B23-A599-BDB98DBFD1F4}';
  IID_ISpeechPhraseProperty: TGUID = '{CE563D48-961E-4732-A2E1-378A42B430BE}';
  IID_ISpeechPhraseElements: TGUID = '{0626B328-3478-467D-A0B3-D0853B93DDA3}';
  IID_ISpeechPhraseElement: TGUID = '{E6176F96-E373-4801-B223-3B62C068C0B4}';
  IID_ISpeechPhraseReplacements: TGUID = '{38BC662F-2257-4525-959E-2069D2596C05}';
  IID_ISpeechPhraseReplacement: TGUID = '{2890A410-53A7-4FB5-94EC-06D4998E3D02}';
  IID_ISpeechPhraseAlternates: TGUID = '{B238B6D5-F276-4C3D-A6C1-2974801C3CC2}';
  IID_ISpeechPhraseAlternate: TGUID = '{27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}';
  DIID__ISpeechRecoContextEvents: TGUID = '{7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}';
  IID_ISpeechRecoResult2: TGUID = '{8E0A246D-D3C8-45DE-8657-04290C458C3C}';
  IID_ISpeechLexicon: TGUID = '{3DA7627A-C7AE-4B23-8708-638C50362C25}';
  IID_ISpeechLexiconWords: TGUID = '{8D199862-415E-47D5-AC4F-FAA608B424E6}';
  IID_ISpeechLexiconWord: TGUID = '{4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}';
  IID_ISpeechLexiconPronunciations: TGUID = '{72829128-5682-4704-A0D4-3E2BB6F2EAD3}';
  IID_ISpeechLexiconPronunciation: TGUID = '{95252C5D-9E43-4F4A-9899-48EE73352F9F}';
  IID_ISpeechXMLRecoResult: TGUID = '{AAEC54AF-8F85-4924-944D-B79D39D72E19}';
  IID_ISpeechRecoResultDispatch: TGUID = '{6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}';
  IID_ISpeechPhraseInfoBuilder: TGUID = '{3B151836-DF3A-4E0A-846C-D2ADC9334333}';
  IID_ISpeechPhoneConverter: TGUID = '{C3E4F353-433F-43D6-89A1-6A62A7054C3D}';
  IID_ISpNotifySink: TGUID = '{259684DC-37C3-11D2-9603-00C04F8EE628}';
  IID_ISpNotifyTranslator: TGUID = '{ACA16614-5D3D-11D2-960E-00C04F8EE628}';
  CLASS_SpNotifyTranslator: TGUID = '{E2AE5372-5D40-11D2-960E-00C04F8EE628}';
  IID_ISpDataKey: TGUID = '{14056581-E16C-11D2-BB90-00C04F8EE6C0}';
  IID_ISpObjectTokenCategory: TGUID = '{2D3D3845-39AF-4850-BBF9-40B49780011D}';
  CLASS_SpObjectTokenCategory: TGUID = '{A910187F-0C7A-45AC-92CC-59EDAFB77B53}';
  IID_IEnumSpObjectTokens: TGUID = '{06B64F9E-7FDA-11D2-B4F2-00C04F797396}';
  IID_ISpObjectToken: TGUID = '{14056589-E16C-11D2-BB90-00C04F8EE6C0}';
  CLASS_SpObjectToken: TGUID = '{EF411752-3736-4CB4-9C8C-8EF4CCB58EFE}';
  IID_IServiceProvider: TGUID = '{6D5140C1-7436-11CE-8034-00AA006009FA}';
  IID_ISpResourceManager: TGUID = '{93384E18-5014-43D5-ADBB-A78E055926BD}';
  CLASS_SpResourceManager: TGUID = '{96749373-3391-11D2-9EE3-00C04F797396}';
  IID_ISequentialStream: TGUID = '{0C733A30-2A1C-11CE-ADE5-00AA0044773D}';
  IID_IStream: TGUID = '{0000000C-0000-0000-C000-000000000046}';
  IID_ISpStreamFormat: TGUID = '{BED530BE-2606-4F4D-A1C0-54C5CDA5566F}';
  IID_ISpStreamFormatConverter: TGUID = '{678A932C-EA71-4446-9B41-78FDA6280A29}';
  CLASS_SpStreamFormatConverter: TGUID = '{7013943A-E2EC-11D2-A086-00C04F8EF9B5}';
  CLASS_SpMMAudioEnum: TGUID = '{AB1890A0-E91F-11D2-BB91-00C04F8EE6C0}';
  IID_ISpNotifySource: TGUID = '{5EFF4AEF-8487-11D2-961C-00C04F8EE628}';
  IID_ISpEventSource: TGUID = '{BE7A9CCE-5F9E-11D2-960F-00C04F8EE628}';
  IID_ISpEventSink: TGUID = '{BE7A9CC9-5F9E-11D2-960F-00C04F8EE628}';
  IID_ISpObjectWithToken: TGUID = '{5B559F40-E952-11D2-BB91-00C04F8EE6C0}';
  IID_ISpAudio: TGUID = '{C05C768F-FAE8-4EC2-8E07-338321C12452}';
  IID_ISpMMSysAudio: TGUID = '{15806F6E-1D70-4B48-98E6-3B1A007509AB}';
  CLASS_SpMMAudioIn: TGUID = '{CF3D2E50-53F2-11D2-960C-00C04F8EE628}';
  CLASS_SpMMAudioOut: TGUID = '{A8C680EB-3D32-11D2-9EE7-00C04F797396}';
  IID_ISpStream: TGUID = '{12E3CCA9-7518-44C5-A5E7-BA5A79CB929E}';
  CLASS_SpStream: TGUID = '{715D9C59-4442-11D2-9605-00C04F8EE628}';
  IID_ISpVoice: TGUID = '{6C44DF74-72B9-4992-A1EC-EF996E0422D4}';
  IID_ISpPhoneticAlphabetSelection: TGUID = '{B2745EFD-42CE-48CA-81F1-A96E02538A90}';
  CLASS_SpVoice: TGUID = '{96749377-3391-11D2-9EE3-00C04F797396}';
  IID_ISpRecoContext: TGUID = '{F740A62F-7C15-489E-8234-940A33D9272D}';
  IID_ISpRecoContext2: TGUID = '{BEAD311C-52FF-437F-9464-6B21054CA73D}';
  IID_ISpProperties: TGUID = '{5B4FB971-B115-4DE1-AD97-E482E3BF6EE4}';
  IID_ISpRecognizer: TGUID = '{C2B5F241-DAA0-4507-9E16-5A1EAA2B7A5C}';
  IID_ISpPhrase: TGUID = '{1A5C0354-B621-4B5A-8791-D306ED379E53}';
  IID_ISpGrammarBuilder: TGUID = '{8137828F-591A-4A42-BE58-49EA7EBAAC68}';
  IID_ISpRecoGrammar: TGUID = '{2177DB29-7F45-47D0-8554-067E91C80502}';
  IID_ISpRecoResult: TGUID = '{20B053BE-E235-43CD-9A2A-8D17A48B7842}';
  IID_ISpPhraseAlt: TGUID = '{8FCEBC98-4E49-4067-9C6C-D86A0E092E3D}';
  CLASS_SpSharedRecoContext: TGUID = '{47206204-5ECA-11D2-960F-00C04F8EE628}';
  IID_ISpRecognizer2: TGUID = '{8FC6D974-C81E-4098-93C5-0147F61ED4D3}';
  IID_ISpRecognizer3: TGUID = '{DF1B943C-5838-4AA2-8706-D7CD5B333499}';
  IID_ISpSerializeState: TGUID = '{21B501A0-0EC7-46C9-92C3-A2BC784C54B9}';
  IID_ISpRecoCategory: TGUID = '{DA0CD0F9-14A2-4F09-8C2A-85CC48979345}';
  CLASS_SpInprocRecognizer: TGUID = '{41B89B6B-9399-11D2-9623-00C04F8EE628}';
  CLASS_SpSharedRecognizer: TGUID = '{3BEE4890-4FE9-4A37-8C1E-5E7E12791C1F}';
  IID_ISpLexicon: TGUID = '{DA41A7C2-5383-4DB2-916B-6C1719E3DB58}';
  CLASS_SpLexicon: TGUID = '{0655E396-25D0-11D3-9C26-00C04F8EF87C}';
  CLASS_SpUnCompressedLexicon: TGUID = '{C9E37C15-DF92-4727-85D6-72E5EEB6995A}';
  CLASS_SpCompressedLexicon: TGUID = '{90903716-2F42-11D3-9C26-00C04F8EF87C}';
  IID_ISpShortcut: TGUID = '{3DF681E2-EA56-11D9-8BDE-F66BAD1E3F3A}';
  CLASS_SpShortcut: TGUID = '{0D722F1A-9FCF-4E62-96D8-6DF8F01A26AA}';
  IID_ISpPhoneConverter: TGUID = '{8445C581-0CAC-4A38-ABFE-9B2CE2826455}';
  CLASS_SpPhoneConverter: TGUID = '{9185F743-1143-4C28-86B5-BFF14F20E5C8}';
  IID_ISpPhoneticAlphabetConverter: TGUID = '{133ADCD4-19B4-4020-9FDC-842E78253B17}';
  CLASS_SpPhoneticAlphabetConverter: TGUID = '{4F414126-DFE3-4629-99EE-797978317EAD}';
  CLASS_SpNullPhoneConverter: TGUID = '{455F24E9-7396-4A16-9715-7C0FDBE3EFE3}';
  CLASS_SpTextSelectionInformation: TGUID = '{0F92030A-CBFD-4AB8-A164-FF5985547FF6}';
  CLASS_SpPhraseInfoBuilder: TGUID = '{C23FC28D-C55F-4720-8B32-91F73C2BD5D1}';
  CLASS_SpAudioFormat: TGUID = '{9EF96870-E160-4792-820D-48CF0649E4EC}';
  CLASS_SpWaveFormatEx: TGUID = '{C79A574C-63BE-44B9-801F-283F87F898BE}';
  CLASS_SpInProcRecoContext: TGUID = '{73AD6842-ACE0-45E8-A4DD-8795881A2C2A}';
  CLASS_SpCustomStream: TGUID = '{8DBEF13F-1948-4AA8-8CF0-048EEBED95D8}';
  CLASS_SpFileStream: TGUID = '{947812B3-2AE1-4644-BA86-9E90DED7EC91}';
  CLASS_SpMemoryStream: TGUID = '{5FB7EF7D-DFF4-468A-B6B7-2FCBD188F994}';
  IID_ISpXMLRecoResult: TGUID = '{AE39362B-45A8-4074-9B9E-CCF49AA2D0B6}';
  IID_ISpRecoGrammar2: TGUID = '{4B37BC9E-9ED6-44A3-93D3-18F022B79EC3}';
  IID_ISpeechResourceLoader: TGUID = '{B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}';
  IID_IInternetSecurityManager: TGUID = '{79EAC9EE-BAF9-11CE-8C82-00AA004BA90B}';
  IID_IInternetSecurityMgrSite: TGUID = '{79EAC9ED-BAF9-11CE-8C82-00AA004BA90B}';
  IID_IEnumString: TGUID = '{00000101-0000-0000-C000-000000000046}';

  // *********************************************************************//
  // Declaration of Enumerations defined in Type Library
  // *********************************************************************//
  // Constants for enum SpeechDataKeyLocation
type
  SpeechDataKeyLocation = TOleEnum;

const
  SDKLDefaultLocation = $00000000;
  SDKLCurrentUser = $00000001;
  SDKLLocalMachine = $00000002;
  SDKLCurrentConfig = $00000005;

  // Constants for enum SpeechTokenContext
type
  SpeechTokenContext = TOleEnum;

const
  STCInprocServer = $00000001;
  STCInprocHandler = $00000002;
  STCLocalServer = $00000004;
  STCRemoteServer = $00000010;
  STCAll = $00000017;

  // Constants for enum SpeechTokenShellFolder
type
  SpeechTokenShellFolder = TOleEnum;

const
  STSF_AppData = $0000001A;
  STSF_LocalAppData = $0000001C;
  STSF_CommonAppData = $00000023;
  STSF_FlagCreate = $00008000;

  // Constants for enum SpeechAudioState
type
  SpeechAudioState = TOleEnum;

const
  SASClosed = $00000000;
  SASStop = $00000001;
  SASPause = $00000002;
  SASRun = $00000003;

  // Constants for enum SpeechAudioFormatType
type
  SpeechAudioFormatType = TOleEnum;

const
  SAFTDefault = $FFFFFFFF;
  SAFTNoAssignedFormat = $00000000;
  SAFTText = $00000001;
  SAFTNonStandardFormat = $00000002;
  SAFTExtendedAudioFormat = $00000003;
  SAFT8kHz8BitMono = $00000004;
  SAFT8kHz8BitStereo = $00000005;
  SAFT8kHz16BitMono = $00000006;
  SAFT8kHz16BitStereo = $00000007;
  SAFT11kHz8BitMono = $00000008;
  SAFT11kHz8BitStereo = $00000009;
  SAFT11kHz16BitMono = $0000000A;
  SAFT11kHz16BitStereo = $0000000B;
  SAFT12kHz8BitMono = $0000000C;
  SAFT12kHz8BitStereo = $0000000D;
  SAFT12kHz16BitMono = $0000000E;
  SAFT12kHz16BitStereo = $0000000F;
  SAFT16kHz8BitMono = $00000010;
  SAFT16kHz8BitStereo = $00000011;
  SAFT16kHz16BitMono = $00000012;
  SAFT16kHz16BitStereo = $00000013;
  SAFT22kHz8BitMono = $00000014;
  SAFT22kHz8BitStereo = $00000015;
  SAFT22kHz16BitMono = $00000016;
  SAFT22kHz16BitStereo = $00000017;
  SAFT24kHz8BitMono = $00000018;
  SAFT24kHz8BitStereo = $00000019;
  SAFT24kHz16BitMono = $0000001A;
  SAFT24kHz16BitStereo = $0000001B;
  SAFT32kHz8BitMono = $0000001C;
  SAFT32kHz8BitStereo = $0000001D;
  SAFT32kHz16BitMono = $0000001E;
  SAFT32kHz16BitStereo = $0000001F;
  SAFT44kHz8BitMono = $00000020;
  SAFT44kHz8BitStereo = $00000021;
  SAFT44kHz16BitMono = $00000022;
  SAFT44kHz16BitStereo = $00000023;
  SAFT48kHz8BitMono = $00000024;
  SAFT48kHz8BitStereo = $00000025;
  SAFT48kHz16BitMono = $00000026;
  SAFT48kHz16BitStereo = $00000027;
  SAFTTrueSpeech_8kHz1BitMono = $00000028;
  SAFTCCITT_ALaw_8kHzMono = $00000029;
  SAFTCCITT_ALaw_8kHzStereo = $0000002A;
  SAFTCCITT_ALaw_11kHzMono = $0000002B;
  SAFTCCITT_ALaw_11kHzStereo = $0000002C;
  SAFTCCITT_ALaw_22kHzMono = $0000002D;
  SAFTCCITT_ALaw_22kHzStereo = $0000002E;
  SAFTCCITT_ALaw_44kHzMono = $0000002F;
  SAFTCCITT_ALaw_44kHzStereo = $00000030;
  SAFTCCITT_uLaw_8kHzMono = $00000031;
  SAFTCCITT_uLaw_8kHzStereo = $00000032;
  SAFTCCITT_uLaw_11kHzMono = $00000033;
  SAFTCCITT_uLaw_11kHzStereo = $00000034;
  SAFTCCITT_uLaw_22kHzMono = $00000035;
  SAFTCCITT_uLaw_22kHzStereo = $00000036;
  SAFTCCITT_uLaw_44kHzMono = $00000037;
  SAFTCCITT_uLaw_44kHzStereo = $00000038;
  SAFTADPCM_8kHzMono = $00000039;
  SAFTADPCM_8kHzStereo = $0000003A;
  SAFTADPCM_11kHzMono = $0000003B;
  SAFTADPCM_11kHzStereo = $0000003C;
  SAFTADPCM_22kHzMono = $0000003D;
  SAFTADPCM_22kHzStereo = $0000003E;
  SAFTADPCM_44kHzMono = $0000003F;
  SAFTADPCM_44kHzStereo = $00000040;
  SAFTGSM610_8kHzMono = $00000041;
  SAFTGSM610_11kHzMono = $00000042;
  SAFTGSM610_22kHzMono = $00000043;
  SAFTGSM610_44kHzMono = $00000044;

  // Constants for enum SpeechStreamSeekPositionType
type
  SpeechStreamSeekPositionType = TOleEnum;

const
  SSSPTRelativeToStart = $00000000;
  SSSPTRelativeToCurrentPosition = $00000001;
  SSSPTRelativeToEnd = $00000002;

  // Constants for enum SpeechStreamFileMode
type
  SpeechStreamFileMode = TOleEnum;

const
  SSFMOpenForRead = $00000000;
  SSFMOpenReadWrite = $00000001;
  SSFMCreate = $00000002;
  SSFMCreateForWrite = $00000003;

  // Constants for enum SpeechRunState
type
  SpeechRunState = TOleEnum;

const
  SRSEDone = $00000001;
  SRSEIsSpeaking = $00000002;

  // Constants for enum SpeechVoiceEvents
type
  SpeechVoiceEvents = TOleEnum;

const
  SVEStartInputStream = $00000002;
  SVEEndInputStream = $00000004;
  SVEVoiceChange = $00000008;
  SVEBookmark = $00000010;
  SVEWordBoundary = $00000020;
  SVEPhoneme = $00000040;
  SVESentenceBoundary = $00000080;
  SVEViseme = $00000100;
  SVEAudioLevel = $00000200;
  SVEPrivate = $00008000;
  SVEAllEvents = $000083FE;

  // Constants for enum SpeechVoicePriority
type
  SpeechVoicePriority = TOleEnum;

const
  SVPNormal = $00000000;
  SVPAlert = $00000001;
  SVPOver = $00000002;

  // Constants for enum SpeechVoiceSpeakFlags
type
  SpeechVoiceSpeakFlags = TOleEnum;

const
  SVSFDefault = $00000000;
  SVSFlagsAsync = $00000001;
  SVSFPurgeBeforeSpeak = $00000002;
  SVSFIsFilename = $00000004;
  SVSFIsXML = $00000008;
  SVSFIsNotXML = $00000010;
  SVSFPersistXML = $00000020;
  SVSFNLPSpeakPunc = $00000040;
  SVSFParseSapi = $00000080;
  SVSFParseSsml = $00000100;
  SVSFParseAutodetect = $00000000;
  SVSFNLPMask = $00000040;
  SVSFParseMask = $00000180;
  SVSFVoiceMask = $000001FF;
  SVSFUnusedFlags = $FFFFFE00;

  // Constants for enum SpeechVisemeFeature
type
  SpeechVisemeFeature = TOleEnum;

const
  SVF_None = $00000000;
  SVF_Stressed = $00000001;
  SVF_Emphasis = $00000002;

  // Constants for enum SpeechVisemeType
type
  SpeechVisemeType = TOleEnum;

const
  SVP_0 = $00000000;
  SVP_1 = $00000001;
  SVP_2 = $00000002;
  SVP_3 = $00000003;
  SVP_4 = $00000004;
  SVP_5 = $00000005;
  SVP_6 = $00000006;
  SVP_7 = $00000007;
  SVP_8 = $00000008;
  SVP_9 = $00000009;
  SVP_10 = $0000000A;
  SVP_11 = $0000000B;
  SVP_12 = $0000000C;
  SVP_13 = $0000000D;
  SVP_14 = $0000000E;
  SVP_15 = $0000000F;
  SVP_16 = $00000010;
  SVP_17 = $00000011;
  SVP_18 = $00000012;
  SVP_19 = $00000013;
  SVP_20 = $00000014;
  SVP_21 = $00000015;

  // Constants for enum SpeechRecognizerState
type
  SpeechRecognizerState = TOleEnum;

const
  SRSInactive = $00000000;
  SRSActive = $00000001;
  SRSActiveAlways = $00000002;
  SRSInactiveWithPurge = $00000003;

  // Constants for enum SpeechInterference
type
  SpeechInterference = TOleEnum;

const
  SINone = $00000000;
  SINoise = $00000001;
  SINoSignal = $00000002;
  SITooLoud = $00000003;
  SITooQuiet = $00000004;
  SITooFast = $00000005;
  SITooSlow = $00000006;

  // Constants for enum SpeechRecoEvents
type
  SpeechRecoEvents = TOleEnum;

const
  SREStreamEnd = $00000001;
  SRESoundStart = $00000002;
  SRESoundEnd = $00000004;
  SREPhraseStart = $00000008;
  SRERecognition = $00000010;
  SREHypothesis = $00000020;
  SREBookmark = $00000040;
  SREPropertyNumChange = $00000080;
  SREPropertyStringChange = $00000100;
  SREFalseRecognition = $00000200;
  SREInterference = $00000400;
  SRERequestUI = $00000800;
  SREStateChange = $00001000;
  SREAdaptation = $00002000;
  SREStreamStart = $00004000;
  SRERecoOtherContext = $00008000;
  SREAudioLevel = $00010000;
  SREPrivate = $00040000;
  SREAllEvents = $0005FFFF;

  // Constants for enum SpeechRecoContextState
type
  SpeechRecoContextState = TOleEnum;

const
  SRCS_Disabled = $00000000;
  SRCS_Enabled = $00000001;

  // Constants for enum SpeechRetainedAudioOptions
type
  SpeechRetainedAudioOptions = TOleEnum;

const
  SRAONone = $00000000;
  SRAORetainAudio = $00000001;

  // Constants for enum SpeechGrammarState
type
  SpeechGrammarState = TOleEnum;

const
  SGSEnabled = $00000001;
  SGSDisabled = $00000000;
  SGSExclusive = $00000003;

  // Constants for enum SpeechRuleAttributes
type
  SpeechRuleAttributes = TOleEnum;

const
  SRATopLevel = $00000001;
  SRADefaultToActive = $00000002;
  SRAExport = $00000004;
  SRAImport = $00000008;
  SRAInterpreter = $00000010;
  SRADynamic = $00000020;
  SRARoot = $00000040;

  // Constants for enum SpeechGrammarRuleStateTransitionType
type
  SpeechGrammarRuleStateTransitionType = TOleEnum;

const
  SGRSTTEpsilon = $00000000;
  SGRSTTWord = $00000001;
  SGRSTTRule = $00000002;
  SGRSTTDictation = $00000003;
  SGRSTTWildcard = $00000004;
  SGRSTTTextBuffer = $00000005;

  // Constants for enum SpeechGrammarWordType
type
  SpeechGrammarWordType = TOleEnum;

const
  SGDisplay = $00000000;
  SGLexical = $00000001;
  SGPronounciation = $00000002;
  SGLexicalNoSpecialChars = $00000003;

  // Constants for enum SpeechSpecialTransitionType
type
  SpeechSpecialTransitionType = TOleEnum;

const
  SSTTWildcard = $00000001;
  SSTTDictation = $00000002;
  SSTTTextBuffer = $00000003;

  // Constants for enum SpeechLoadOption
type
  SpeechLoadOption = TOleEnum;

const
  SLOStatic = $00000000;
  SLODynamic = $00000001;

  // Constants for enum SpeechRuleState
type
  SpeechRuleState = TOleEnum;

const
  SGDSInactive = $00000000;
  SGDSActive = $00000001;
  SGDSActiveWithAutoPause = $00000003;
  SGDSActiveUserDelimited = $00000004;

  // Constants for enum SpeechWordPronounceable
type
  SpeechWordPronounceable = TOleEnum;

const
  SWPUnknownWordUnpronounceable = $00000000;
  SWPUnknownWordPronounceable = $00000001;
  SWPKnownWordPronounceable = $00000002;

  // Constants for enum SpeechEngineConfidence
type
  SpeechEngineConfidence = TOleEnum;

const
  SECLowConfidence = $FFFFFFFF;
  SECNormalConfidence = $00000000;
  SECHighConfidence = $00000001;

  // Constants for enum SpeechDisplayAttributes
type
  SpeechDisplayAttributes = TOleEnum;

const
  SDA_No_Trailing_Space = $00000000;
  SDA_One_Trailing_Space = $00000002;
  SDA_Two_Trailing_Spaces = $00000004;
  SDA_Consume_Leading_Spaces = $00000008;

  // Constants for enum SpeechDiscardType
type
  SpeechDiscardType = TOleEnum;

const
  SDTProperty = $00000001;
  SDTReplacement = $00000002;
  SDTRule = $00000004;
  SDTDisplayText = $00000008;
  SDTLexicalForm = $00000010;
  SDTPronunciation = $00000020;
  SDTAudio = $00000040;
  SDTAlternates = $00000080;
  SDTAll = $000000FF;

  // Constants for enum SpeechBookmarkOptions
type
  SpeechBookmarkOptions = TOleEnum;

const
  SBONone = $00000000;
  SBOPause = $00000001;

  // Constants for enum SpeechFormatType
type
  SpeechFormatType = TOleEnum;

const
  SFTInput = $00000000;
  SFTSREngine = $00000001;

  // Constants for enum SpeechRecognitionType
type
  SpeechRecognitionType = TOleEnum;

const
  SRTStandard = $00000000;
  SRTAutopause = $00000001;
  SRTEmulated = $00000002;
  SRTSMLTimeout = $00000004;
  SRTExtendableParse = $00000008;
  SRTReSent = $00000010;

  // Constants for enum SpeechLexiconType
type
  SpeechLexiconType = TOleEnum;

const
  SLTUser = $00000001;
  SLTApp = $00000002;

  // Constants for enum SpeechWordType
type
  SpeechWordType = TOleEnum;

const
  SWTAdded = $00000001;
  SWTDeleted = $00000002;

  // Constants for enum SpeechPartOfSpeech
type
  SpeechPartOfSpeech = TOleEnum;

const
  SPSNotOverriden = $FFFFFFFF;
  SPSUnknown = $00000000;
  SPSNoun = $00001000;
  SPSVerb = $00002000;
  SPSModifier = $00003000;
  SPSFunction = $00004000;
  SPSInterjection = $00005000;
  SPSLMA = $00007000;
  SPSSuppressWord = $0000F000;

  // Constants for enum DISPID_SpeechDataKey
type
  DISPID_SpeechDataKey = TOleEnum;

const
  DISPID_SDKSetBinaryValue = $00000001;
  DISPID_SDKGetBinaryValue = $00000002;
  DISPID_SDKSetStringValue = $00000003;
  DISPID_SDKGetStringValue = $00000004;
  DISPID_SDKSetLongValue = $00000005;
  DISPID_SDKGetlongValue = $00000006;
  DISPID_SDKOpenKey = $00000007;
  DISPID_SDKCreateKey = $00000008;
  DISPID_SDKDeleteKey = $00000009;
  DISPID_SDKDeleteValue = $0000000A;
  DISPID_SDKEnumKeys = $0000000B;
  DISPID_SDKEnumValues = $0000000C;

  // Constants for enum DISPID_SpeechObjectToken
type
  DISPID_SpeechObjectToken = TOleEnum;

const
  DISPID_SOTId = $00000001;
  DISPID_SOTDataKey = $00000002;
  DISPID_SOTCategory = $00000003;
  DISPID_SOTGetDescription = $00000004;
  DISPID_SOTSetId = $00000005;
  DISPID_SOTGetAttribute = $00000006;
  DISPID_SOTCreateInstance = $00000007;
  DISPID_SOTRemove = $00000008;
  DISPID_SOTGetStorageFileName = $00000009;
  DISPID_SOTRemoveStorageFileName = $0000000A;
  DISPID_SOTIsUISupported = $0000000B;
  DISPID_SOTDisplayUI = $0000000C;
  DISPID_SOTMatchesAttributes = $0000000D;

  // Constants for enum DISPID_SpeechObjectTokens
type
  DISPID_SpeechObjectTokens = TOleEnum;

const
  DISPID_SOTsCount = $00000001;
  DISPID_SOTsItem = $00000000;
  DISPID_SOTs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechObjectTokenCategory
type
  DISPID_SpeechObjectTokenCategory = TOleEnum;

const
  DISPID_SOTCId = $00000001;
  DISPID_SOTCDefault = $00000002;
  DISPID_SOTCSetId = $00000003;
  DISPID_SOTCGetDataKey = $00000004;
  DISPID_SOTCEnumerateTokens = $00000005;

  // Constants for enum DISPID_SpeechAudioFormat
type
  DISPID_SpeechAudioFormat = TOleEnum;

const
  DISPID_SAFType = $00000001;
  DISPID_SAFGuid = $00000002;
  DISPID_SAFGetWaveFormatEx = $00000003;
  DISPID_SAFSetWaveFormatEx = $00000004;

  // Constants for enum DISPID_SpeechBaseStream
type
  DISPID_SpeechBaseStream = TOleEnum;

const
  DISPID_SBSFormat = $00000001;
  DISPID_SBSRead = $00000002;
  DISPID_SBSWrite = $00000003;
  DISPID_SBSSeek = $00000004;

  // Constants for enum DISPID_SpeechAudio
type
  DISPID_SpeechAudio = TOleEnum;

const
  DISPID_SAStatus = $000000C8;
  DISPID_SABufferInfo = $000000C9;
  DISPID_SADefaultFormat = $000000CA;
  DISPID_SAVolume = $000000CB;
  DISPID_SABufferNotifySize = $000000CC;
  DISPID_SAEventHandle = $000000CD;
  DISPID_SASetState = $000000CE;

  // Constants for enum DISPID_SpeechMMSysAudio
type
  DISPID_SpeechMMSysAudio = TOleEnum;

const
  DISPID_SMSADeviceId = $0000012C;
  DISPID_SMSALineId = $0000012D;
  DISPID_SMSAMMHandle = $0000012E;

  // Constants for enum DISPID_SpeechFileStream
type
  DISPID_SpeechFileStream = TOleEnum;

const
  DISPID_SFSOpen = $00000064;
  DISPID_SFSClose = $00000065;

  // Constants for enum DISPID_SpeechCustomStream
type
  DISPID_SpeechCustomStream = TOleEnum;

const
  DISPID_SCSBaseStream = $00000064;

  // Constants for enum DISPID_SpeechMemoryStream
type
  DISPID_SpeechMemoryStream = TOleEnum;

const
  DISPID_SMSSetData = $00000064;
  DISPID_SMSGetData = $00000065;

  // Constants for enum DISPID_SpeechAudioStatus
type
  DISPID_SpeechAudioStatus = TOleEnum;

const
  DISPID_SASFreeBufferSpace = $00000001;
  DISPID_SASNonBlockingIO = $00000002;
  DISPID_SASState = $00000003;
  DISPID_SASCurrentSeekPosition = $00000004;
  DISPID_SASCurrentDevicePosition = $00000005;

  // Constants for enum DISPID_SpeechAudioBufferInfo
type
  DISPID_SpeechAudioBufferInfo = TOleEnum;

const
  DISPID_SABIMinNotification = $00000001;
  DISPID_SABIBufferSize = $00000002;
  DISPID_SABIEventBias = $00000003;

  // Constants for enum DISPID_SpeechWaveFormatEx
type
  DISPID_SpeechWaveFormatEx = TOleEnum;

const
  DISPID_SWFEFormatTag = $00000001;
  DISPID_SWFEChannels = $00000002;
  DISPID_SWFESamplesPerSec = $00000003;
  DISPID_SWFEAvgBytesPerSec = $00000004;
  DISPID_SWFEBlockAlign = $00000005;
  DISPID_SWFEBitsPerSample = $00000006;
  DISPID_SWFEExtraData = $00000007;

  // Constants for enum DISPID_SpeechVoice
type
  DISPID_SpeechVoice = TOleEnum;

const
  DISPID_SVStatus = $00000001;
  DISPID_SVVoice = $00000002;
  DISPID_SVAudioOutput = $00000003;
  DISPID_SVAudioOutputStream = $00000004;
  DISPID_SVRate = $00000005;
  DISPID_SVVolume = $00000006;
  DISPID_SVAllowAudioOuputFormatChangesOnNextSet = $00000007;
  DISPID_SVEventInterests = $00000008;
  DISPID_SVPriority = $00000009;
  DISPID_SVAlertBoundary = $0000000A;
  DISPID_SVSyncronousSpeakTimeout = $0000000B;
  DISPID_SVSpeak = $0000000C;
  DISPID_SVSpeakStream = $0000000D;
  DISPID_SVPause = $0000000E;
  DISPID_SVResume = $0000000F;
  DISPID_SVSkip = $00000010;
  DISPID_SVGetVoices = $00000011;
  DISPID_SVGetAudioOutputs = $00000012;
  DISPID_SVWaitUntilDone = $00000013;
  DISPID_SVSpeakCompleteEvent = $00000014;
  DISPID_SVIsUISupported = $00000015;
  DISPID_SVDisplayUI = $00000016;

  // Constants for enum DISPID_SpeechVoiceStatus
type
  DISPID_SpeechVoiceStatus = TOleEnum;

const
  DISPID_SVSCurrentStreamNumber = $00000001;
  DISPID_SVSLastStreamNumberQueued = $00000002;
  DISPID_SVSLastResult = $00000003;
  DISPID_SVSRunningState = $00000004;
  DISPID_SVSInputWordPosition = $00000005;
  DISPID_SVSInputWordLength = $00000006;
  DISPID_SVSInputSentencePosition = $00000007;
  DISPID_SVSInputSentenceLength = $00000008;
  DISPID_SVSLastBookmark = $00000009;
  DISPID_SVSLastBookmarkId = $0000000A;
  DISPID_SVSPhonemeId = $0000000B;
  DISPID_SVSVisemeId = $0000000C;

  // Constants for enum DISPID_SpeechVoiceEvent
type
  DISPID_SpeechVoiceEvent = TOleEnum;

const
  DISPID_SVEStreamStart = $00000001;
  DISPID_SVEStreamEnd = $00000002;
  DISPID_SVEVoiceChange = $00000003;
  DISPID_SVEBookmark = $00000004;
  DISPID_SVEWord = $00000005;
  DISPID_SVEPhoneme = $00000006;
  DISPID_SVESentenceBoundary = $00000007;
  DISPID_SVEViseme = $00000008;
  DISPID_SVEAudioLevel = $00000009;
  DISPID_SVEEnginePrivate = $0000000A;

  // Constants for enum DISPID_SpeechRecognizer
type
  DISPID_SpeechRecognizer = TOleEnum;

const
  DISPID_SRRecognizer = $00000001;
  DISPID_SRAllowAudioInputFormatChangesOnNextSet = $00000002;
  DISPID_SRAudioInput = $00000003;
  DISPID_SRAudioInputStream = $00000004;
  DISPID_SRIsShared = $00000005;
  DISPID_SRState = $00000006;
  DISPID_SRStatus = $00000007;
  DISPID_SRProfile = $00000008;
  DISPID_SREmulateRecognition = $00000009;
  DISPID_SRCreateRecoContext = $0000000A;
  DISPID_SRGetFormat = $0000000B;
  DISPID_SRSetPropertyNumber = $0000000C;
  DISPID_SRGetPropertyNumber = $0000000D;
  DISPID_SRSetPropertyString = $0000000E;
  DISPID_SRGetPropertyString = $0000000F;
  DISPID_SRIsUISupported = $00000010;
  DISPID_SRDisplayUI = $00000011;
  DISPID_SRGetRecognizers = $00000012;
  DISPID_SVGetAudioInputs = $00000013;
  DISPID_SVGetProfiles = $00000014;

  // Constants for enum SpeechEmulationCompareFlags
type
  SpeechEmulationCompareFlags = TOleEnum;

const
  SECFIgnoreCase = $00000001;
  SECFIgnoreKanaType = $00010000;
  SECFIgnoreWidth = $00020000;
  SECFNoSpecialChars = $20000000;
  SECFEmulateResult = $40000000;
  SECFDefault = $00030001;

  // Constants for enum DISPID_SpeechRecognizerStatus
type
  DISPID_SpeechRecognizerStatus = TOleEnum;

const
  DISPID_SRSAudioStatus = $00000001;
  DISPID_SRSCurrentStreamPosition = $00000002;
  DISPID_SRSCurrentStreamNumber = $00000003;
  DISPID_SRSNumberOfActiveRules = $00000004;
  DISPID_SRSClsidEngine = $00000005;
  DISPID_SRSSupportedLanguages = $00000006;

  // Constants for enum DISPID_SpeechRecoContext
type
  DISPID_SpeechRecoContext = TOleEnum;

const
  DISPID_SRCRecognizer = $00000001;
  DISPID_SRCAudioInInterferenceStatus = $00000002;
  DISPID_SRCRequestedUIType = $00000003;
  DISPID_SRCVoice = $00000004;
  DISPID_SRAllowVoiceFormatMatchingOnNextSet = $00000005;
  DISPID_SRCVoicePurgeEvent = $00000006;
  DISPID_SRCEventInterests = $00000007;
  DISPID_SRCCmdMaxAlternates = $00000008;
  DISPID_SRCState = $00000009;
  DISPID_SRCRetainedAudio = $0000000A;
  DISPID_SRCRetainedAudioFormat = $0000000B;
  DISPID_SRCPause = $0000000C;
  DISPID_SRCResume = $0000000D;
  DISPID_SRCCreateGrammar = $0000000E;
  DISPID_SRCCreateResultFromMemory = $0000000F;
  DISPID_SRCBookmark = $00000010;
  DISPID_SRCSetAdaptationData = $00000011;

  // Constants for enum DISPIDSPRG
type
  DISPIDSPRG = TOleEnum;

const
  DISPID_SRGId = $00000001;
  DISPID_SRGRecoContext = $00000002;
  DISPID_SRGState = $00000003;
  DISPID_SRGRules = $00000004;
  DISPID_SRGReset = $00000005;
  DISPID_SRGCommit = $00000006;
  DISPID_SRGCmdLoadFromFile = $00000007;
  DISPID_SRGCmdLoadFromObject = $00000008;
  DISPID_SRGCmdLoadFromResource = $00000009;
  DISPID_SRGCmdLoadFromMemory = $0000000A;
  DISPID_SRGCmdLoadFromProprietaryGrammar = $0000000B;
  DISPID_SRGCmdSetRuleState = $0000000C;
  DISPID_SRGCmdSetRuleIdState = $0000000D;
  DISPID_SRGDictationLoad = $0000000E;
  DISPID_SRGDictationUnload = $0000000F;
  DISPID_SRGDictationSetState = $00000010;
  DISPID_SRGSetWordSequenceData = $00000011;
  DISPID_SRGSetTextSelection = $00000012;
  DISPID_SRGIsPronounceable = $00000013;

  // Constants for enum DISPID_SpeechRecoContextEvents
type
  DISPID_SpeechRecoContextEvents = TOleEnum;

const
  DISPID_SRCEStartStream = $00000001;
  DISPID_SRCEEndStream = $00000002;
  DISPID_SRCEBookmark = $00000003;
  DISPID_SRCESoundStart = $00000004;
  DISPID_SRCESoundEnd = $00000005;
  DISPID_SRCEPhraseStart = $00000006;
  DISPID_SRCERecognition = $00000007;
  DISPID_SRCEHypothesis = $00000008;
  DISPID_SRCEPropertyNumberChange = $00000009;
  DISPID_SRCEPropertyStringChange = $0000000A;
  DISPID_SRCEFalseRecognition = $0000000B;
  DISPID_SRCEInterference = $0000000C;
  DISPID_SRCERequestUI = $0000000D;
  DISPID_SRCERecognizerStateChange = $0000000E;
  DISPID_SRCEAdaptation = $0000000F;
  DISPID_SRCERecognitionForOtherContext = $00000010;
  DISPID_SRCEAudioLevel = $00000011;
  DISPID_SRCEEnginePrivate = $00000012;

  // Constants for enum DISPID_SpeechGrammarRule
type
  DISPID_SpeechGrammarRule = TOleEnum;

const
  DISPID_SGRAttributes = $00000001;
  DISPID_SGRInitialState = $00000002;
  DISPID_SGRName = $00000003;
  DISPID_SGRId = $00000004;
  DISPID_SGRClear = $00000005;
  DISPID_SGRAddResource = $00000006;
  DISPID_SGRAddState = $00000007;

  // Constants for enum DISPID_SpeechGrammarRules
type
  DISPID_SpeechGrammarRules = TOleEnum;

const
  DISPID_SGRsCount = $00000001;
  DISPID_SGRsDynamic = $00000002;
  DISPID_SGRsAdd = $00000003;
  DISPID_SGRsCommit = $00000004;
  DISPID_SGRsCommitAndSave = $00000005;
  DISPID_SGRsFindRule = $00000006;
  DISPID_SGRsItem = $00000000;
  DISPID_SGRs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechGrammarRuleState
type
  DISPID_SpeechGrammarRuleState = TOleEnum;

const
  DISPID_SGRSRule = $00000001;
  DISPID_SGRSTransitions = $00000002;
  DISPID_SGRSAddWordTransition = $00000003;
  DISPID_SGRSAddRuleTransition = $00000004;
  DISPID_SGRSAddSpecialTransition = $00000005;

  // Constants for enum DISPID_SpeechGrammarRuleStateTransitions
type
  DISPID_SpeechGrammarRuleStateTransitions = TOleEnum;

const
  DISPID_SGRSTsCount = $00000001;
  DISPID_SGRSTsItem = $00000000;
  DISPID_SGRSTs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechGrammarRuleStateTransition
type
  DISPID_SpeechGrammarRuleStateTransition = TOleEnum;

const
  DISPID_SGRSTType = $00000001;
  DISPID_SGRSTText = $00000002;
  DISPID_SGRSTRule = $00000003;
  DISPID_SGRSTWeight = $00000004;
  DISPID_SGRSTPropertyName = $00000005;
  DISPID_SGRSTPropertyId = $00000006;
  DISPID_SGRSTPropertyValue = $00000007;
  DISPID_SGRSTNextState = $00000008;

  // Constants for enum DISPIDSPTSI
type
  DISPIDSPTSI = TOleEnum;

const
  DISPIDSPTSI_ActiveOffset = $00000001;
  DISPIDSPTSI_ActiveLength = $00000002;
  DISPIDSPTSI_SelectionOffset = $00000003;
  DISPIDSPTSI_SelectionLength = $00000004;

  // Constants for enum DISPID_SpeechRecoResult
type
  DISPID_SpeechRecoResult = TOleEnum;

const
  DISPID_SRRRecoContext = $00000001;
  DISPID_SRRTimes = $00000002;
  DISPID_SRRAudioFormat = $00000003;
  DISPID_SRRPhraseInfo = $00000004;
  DISPID_SRRAlternates = $00000005;
  DISPID_SRRAudio = $00000006;
  DISPID_SRRSpeakAudio = $00000007;
  DISPID_SRRSaveToMemory = $00000008;
  DISPID_SRRDiscardResultInfo = $00000009;

  // Constants for enum DISPID_SpeechXMLRecoResult
type
  DISPID_SpeechXMLRecoResult = TOleEnum;

const
  DISPID_SRRGetXMLResult = $0000000A;
  DISPID_SRRGetXMLErrorInfo = $0000000B;

  // Constants for enum SPXMLRESULTOPTIONS
type
  SPXMLRESULTOPTIONS = TOleEnum;

const
  SPXRO_SML = $00000000;
  SPXRO_Alternates_SML = $00000001;

  // Constants for enum DISPID_SpeechRecoResult2
type
  DISPID_SpeechRecoResult2 = TOleEnum;

const
  DISPID_SRRSetTextFeedback = $0000000C;

  // Constants for enum DISPID_SpeechPhraseBuilder
type
  DISPID_SpeechPhraseBuilder = TOleEnum;

const
  DISPID_SPPBRestorePhraseFromMemory = $00000001;

  // Constants for enum DISPID_SpeechRecoResultTimes
type
  DISPID_SpeechRecoResultTimes = TOleEnum;

const
  DISPID_SRRTStreamTime = $00000001;
  DISPID_SRRTLength = $00000002;
  DISPID_SRRTTickCount = $00000003;
  DISPID_SRRTOffsetFromStart = $00000004;

  // Constants for enum DISPID_SpeechPhraseAlternate
type
  DISPID_SpeechPhraseAlternate = TOleEnum;

const
  DISPID_SPARecoResult = $00000001;
  DISPID_SPAStartElementInResult = $00000002;
  DISPID_SPANumberOfElementsInResult = $00000003;
  DISPID_SPAPhraseInfo = $00000004;
  DISPID_SPACommit = $00000005;

  // Constants for enum DISPID_SpeechPhraseAlternates
type
  DISPID_SpeechPhraseAlternates = TOleEnum;

const
  DISPID_SPAsCount = $00000001;
  DISPID_SPAsItem = $00000000;
  DISPID_SPAs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechPhraseInfo
type
  DISPID_SpeechPhraseInfo = TOleEnum;

const
  DISPID_SPILanguageId = $00000001;
  DISPID_SPIGrammarId = $00000002;
  DISPID_SPIStartTime = $00000003;
  DISPID_SPIAudioStreamPosition = $00000004;
  DISPID_SPIAudioSizeBytes = $00000005;
  DISPID_SPIRetainedSizeBytes = $00000006;
  DISPID_SPIAudioSizeTime = $00000007;
  DISPID_SPIRule = $00000008;
  DISPID_SPIProperties = $00000009;
  DISPID_SPIElements = $0000000A;
  DISPID_SPIReplacements = $0000000B;
  DISPID_SPIEngineId = $0000000C;
  DISPID_SPIEnginePrivateData = $0000000D;
  DISPID_SPISaveToMemory = $0000000E;
  DISPID_SPIGetText = $0000000F;
  DISPID_SPIGetDisplayAttributes = $00000010;

  // Constants for enum DISPID_SpeechPhraseElement
type
  DISPID_SpeechPhraseElement = TOleEnum;

const
  DISPID_SPEAudioTimeOffset = $00000001;
  DISPID_SPEAudioSizeTime = $00000002;
  DISPID_SPEAudioStreamOffset = $00000003;
  DISPID_SPEAudioSizeBytes = $00000004;
  DISPID_SPERetainedStreamOffset = $00000005;
  DISPID_SPERetainedSizeBytes = $00000006;
  DISPID_SPEDisplayText = $00000007;
  DISPID_SPELexicalForm = $00000008;
  DISPID_SPEPronunciation = $00000009;
  DISPID_SPEDisplayAttributes = $0000000A;
  DISPID_SPERequiredConfidence = $0000000B;
  DISPID_SPEActualConfidence = $0000000C;
  DISPID_SPEEngineConfidence = $0000000D;

  // Constants for enum DISPID_SpeechPhraseElements
type
  DISPID_SpeechPhraseElements = TOleEnum;

const
  DISPID_SPEsCount = $00000001;
  DISPID_SPEsItem = $00000000;
  DISPID_SPEs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechPhraseReplacement
type
  DISPID_SpeechPhraseReplacement = TOleEnum;

const
  DISPID_SPRDisplayAttributes = $00000001;
  DISPID_SPRText = $00000002;
  DISPID_SPRFirstElement = $00000003;
  DISPID_SPRNumberOfElements = $00000004;

  // Constants for enum DISPID_SpeechPhraseReplacements
type
  DISPID_SpeechPhraseReplacements = TOleEnum;

const
  DISPID_SPRsCount = $00000001;
  DISPID_SPRsItem = $00000000;
  DISPID_SPRs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechPhraseProperty
type
  DISPID_SpeechPhraseProperty = TOleEnum;

const
  DISPID_SPPName = $00000001;
  DISPID_SPPId = $00000002;
  DISPID_SPPValue = $00000003;
  DISPID_SPPFirstElement = $00000004;
  DISPID_SPPNumberOfElements = $00000005;
  DISPID_SPPEngineConfidence = $00000006;
  DISPID_SPPConfidence = $00000007;
  DISPID_SPPParent = $00000008;
  DISPID_SPPChildren = $00000009;

  // Constants for enum DISPID_SpeechPhraseProperties
type
  DISPID_SpeechPhraseProperties = TOleEnum;

const
  DISPID_SPPsCount = $00000001;
  DISPID_SPPsItem = $00000000;
  DISPID_SPPs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechPhraseRule
type
  DISPID_SpeechPhraseRule = TOleEnum;

const
  DISPID_SPRuleName = $00000001;
  DISPID_SPRuleId = $00000002;
  DISPID_SPRuleFirstElement = $00000003;
  DISPID_SPRuleNumberOfElements = $00000004;
  DISPID_SPRuleParent = $00000005;
  DISPID_SPRuleChildren = $00000006;
  DISPID_SPRuleConfidence = $00000007;
  DISPID_SPRuleEngineConfidence = $00000008;

  // Constants for enum DISPID_SpeechPhraseRules
type
  DISPID_SpeechPhraseRules = TOleEnum;

const
  DISPID_SPRulesCount = $00000001;
  DISPID_SPRulesItem = $00000000;
  DISPID_SPRules_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechLexicon
type
  DISPID_SpeechLexicon = TOleEnum;

const
  DISPID_SLGenerationId = $00000001;
  DISPID_SLGetWords = $00000002;
  DISPID_SLAddPronunciation = $00000003;
  DISPID_SLAddPronunciationByPhoneIds = $00000004;
  DISPID_SLRemovePronunciation = $00000005;
  DISPID_SLRemovePronunciationByPhoneIds = $00000006;
  DISPID_SLGetPronunciations = $00000007;
  DISPID_SLGetGenerationChange = $00000008;

  // Constants for enum DISPID_SpeechLexiconWords
type
  DISPID_SpeechLexiconWords = TOleEnum;

const
  DISPID_SLWsCount = $00000001;
  DISPID_SLWsItem = $00000000;
  DISPID_SLWs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechLexiconWord
type
  DISPID_SpeechLexiconWord = TOleEnum;

const
  DISPID_SLWLangId = $00000001;
  DISPID_SLWType = $00000002;
  DISPID_SLWWord = $00000003;
  DISPID_SLWPronunciations = $00000004;

  // Constants for enum DISPID_SpeechLexiconProns
type
  DISPID_SpeechLexiconProns = TOleEnum;

const
  DISPID_SLPsCount = $00000001;
  DISPID_SLPsItem = $00000000;
  DISPID_SLPs_NewEnum = $FFFFFFFC;

  // Constants for enum DISPID_SpeechLexiconPronunciation
type
  DISPID_SpeechLexiconPronunciation = TOleEnum;

const
  DISPID_SLPType = $00000001;
  DISPID_SLPLangId = $00000002;
  DISPID_SLPPartOfSpeech = $00000003;
  DISPID_SLPPhoneIds = $00000004;
  DISPID_SLPSymbolic = $00000005;

  // Constants for enum DISPID_SpeechPhoneConverter
type
  DISPID_SpeechPhoneConverter = TOleEnum;

const
  DISPID_SPCLangId = $00000001;
  DISPID_SPCPhoneToId = $00000002;
  DISPID_SPCIdToPhone = $00000003;

  // Constants for enum SPDATAKEYLOCATION
type
  SPDATAKEYLOCATION = TOleEnum;

const
  SPDKL_DefaultLocation = $00000000;
  SPDKL_CurrentUser = $00000001;
  SPDKL_LocalMachine = $00000002;
  SPDKL_CurrentConfig = $00000005;

  // Constants for enum _SPAUDIOSTATE
type
  _SPAUDIOSTATE = TOleEnum;

const
  SPAS_CLOSED = $00000000;
  SPAS_STOP = $00000001;
  SPAS_PAUSE = $00000002;
  SPAS_RUN = $00000003;

  // Constants for enum SPFILEMODE
type
  SPFILEMODE = TOleEnum;

const
  SPFM_OPEN_READONLY = $00000000;
  SPFM_OPEN_READWRITE = $00000001;
  SPFM_CREATE = $00000002;
  SPFM_CREATE_ALWAYS = $00000003;
  SPFM_NUM_MODES = $00000004;

  // Constants for enum SPVISEMES
type
  SPVISEMES = TOleEnum;

const
  SP_VISEME_0 = $00000000;
  SP_VISEME_1 = $00000001;
  SP_VISEME_2 = $00000002;
  SP_VISEME_3 = $00000003;
  SP_VISEME_4 = $00000004;
  SP_VISEME_5 = $00000005;
  SP_VISEME_6 = $00000006;
  SP_VISEME_7 = $00000007;
  SP_VISEME_8 = $00000008;
  SP_VISEME_9 = $00000009;
  SP_VISEME_10 = $0000000A;
  SP_VISEME_11 = $0000000B;
  SP_VISEME_12 = $0000000C;
  SP_VISEME_13 = $0000000D;
  SP_VISEME_14 = $0000000E;
  SP_VISEME_15 = $0000000F;
  SP_VISEME_16 = $00000010;
  SP_VISEME_17 = $00000011;
  SP_VISEME_18 = $00000012;
  SP_VISEME_19 = $00000013;
  SP_VISEME_20 = $00000014;
  SP_VISEME_21 = $00000015;

  // Constants for enum SPVPRIORITY
type
  SPVPRIORITY = TOleEnum;

const
  SPVPRI_NORMAL = $00000000;
  SPVPRI_ALERT = $00000001;
  SPVPRI_OVER = $00000002;

  // Constants for enum SPEVENTENUM
type
  SPEVENTENUM = TOleEnum;

const
  SPEI_UNDEFINED = $00000000;
  SPEI_START_INPUT_STREAM = $00000001;
  SPEI_END_INPUT_STREAM = $00000002;
  SPEI_VOICE_CHANGE = $00000003;
  SPEI_TTS_BOOKMARK = $00000004;
  SPEI_WORD_BOUNDARY = $00000005;
  SPEI_PHONEME = $00000006;
  SPEI_SENTENCE_BOUNDARY = $00000007;
  SPEI_VISEME = $00000008;
  SPEI_TTS_AUDIO_LEVEL = $00000009;
  SPEI_TTS_PRIVATE = $0000000F;
  SPEI_MIN_TTS = $00000001;
  SPEI_MAX_TTS = $0000000F;
  SPEI_END_SR_STREAM = $00000022;
  SPEI_SOUND_START = $00000023;
  SPEI_SOUND_END = $00000024;
  SPEI_PHRASE_START = $00000025;
  SPEI_RECOGNITION = $00000026;
  SPEI_HYPOTHESIS = $00000027;
  SPEI_SR_BOOKMARK = $00000028;
  SPEI_PROPERTY_NUM_CHANGE = $00000029;
  SPEI_PROPERTY_STRING_CHANGE = $0000002A;
  SPEI_FALSE_RECOGNITION = $0000002B;
  SPEI_INTERFERENCE = $0000002C;
  SPEI_REQUEST_UI = $0000002D;
  SPEI_RECO_STATE_CHANGE = $0000002E;
  SPEI_ADAPTATION = $0000002F;
  SPEI_START_SR_STREAM = $00000030;
  SPEI_RECO_OTHER_CONTEXT = $00000031;
  SPEI_SR_AUDIO_LEVEL = $00000032;
  SPEI_SR_RETAINEDAUDIO = $00000033;
  SPEI_SR_PRIVATE = $00000034;
  SPEI_ACTIVE_CATEGORY_CHANGED = $00000035;
  SPEI_RESERVED5 = $00000036;
  SPEI_RESERVED6 = $00000037;
  SPEI_MIN_SR = $00000022;
  SPEI_MAX_SR = $00000037;
  SPEI_RESERVED1 = $0000001E;
  SPEI_RESERVED2 = $00000021;
  SPEI_RESERVED3 = $0000003F;

  // Constants for enum SPRECOSTATE
type
  SPRECOSTATE = TOleEnum;

const
  SPRST_INACTIVE = $00000000;
  SPRST_ACTIVE = $00000001;
  SPRST_ACTIVE_ALWAYS = $00000002;
  SPRST_INACTIVE_WITH_PURGE = $00000003;
  SPRST_NUM_STATES = $00000004;

  // Constants for enum SPWAVEFORMATTYPE
type
  SPWAVEFORMATTYPE = TOleEnum;

const
  SPWF_INPUT = $00000000;
  SPWF_SRENGINE = $00000001;

  // Constants for enum SPSEMANTICFORMAT
type
  SPSEMANTICFORMAT = TOleEnum;

const
  SPSMF_SAPI_PROPERTIES = $00000000;
  SPSMF_SRGS_SEMANTICINTERPRETATION_MS = $00000001;
  SPSMF_SRGS_SAPIPROPERTIES = $00000002;
  SPSMF_UPS = $00000004;
  SPSMF_SRGS_SEMANTICINTERPRETATION_W3C = $00000008;

  // Constants for enum SPGRAMMARWORDTYPE
type
  SPGRAMMARWORDTYPE = TOleEnum;

const
  SPWT_DISPLAY = $00000000;
  SPWT_LEXICAL = $00000001;
  SPWT_PRONUNCIATION = $00000002;
  SPWT_LEXICAL_NO_SPECIAL_CHARS = $00000003;

  // Constants for enum SPLOADOPTIONS
type
  SPLOADOPTIONS = TOleEnum;

const
  SPLO_STATIC = $00000000;
  SPLO_DYNAMIC = $00000001;

  // Constants for enum SPRULESTATE
type
  SPRULESTATE = TOleEnum;

const
  SPRS_INACTIVE = $00000000;
  SPRS_ACTIVE = $00000001;
  SPRS_ACTIVE_WITH_AUTO_PAUSE = $00000003;
  SPRS_ACTIVE_USER_DELIMITED = $00000004;

  // Constants for enum SPWORDPRONOUNCEABLE
type
  SPWORDPRONOUNCEABLE = TOleEnum;

const
  SPWP_UNKNOWN_WORD_UNPRONOUNCEABLE = $00000000;
  SPWP_UNKNOWN_WORD_PRONOUNCEABLE = $00000001;
  SPWP_KNOWN_WORD_PRONOUNCEABLE = $00000002;

  // Constants for enum SPGRAMMARSTATE
type
  SPGRAMMARSTATE = TOleEnum;

const
  SPGS_DISABLED = $00000000;
  SPGS_ENABLED = $00000001;
  SPGS_EXCLUSIVE = $00000003;

  // Constants for enum SPINTERFERENCE
type
  SPINTERFERENCE = TOleEnum;

const
  SPINTERFERENCE_NONE = $00000000;
  SPINTERFERENCE_NOISE = $00000001;
  SPINTERFERENCE_NOSIGNAL = $00000002;
  SPINTERFERENCE_TOOLOUD = $00000003;
  SPINTERFERENCE_TOOQUIET = $00000004;
  SPINTERFERENCE_TOOFAST = $00000005;
  SPINTERFERENCE_TOOSLOW = $00000006;
  SPINTERFERENCE_LATENCY_WARNING = $00000007;
  SPINTERFERENCE_LATENCY_TRUNCATE_BEGIN = $00000008;
  SPINTERFERENCE_LATENCY_TRUNCATE_END = $00000009;

  // Constants for enum SPAUDIOOPTIONS
type
  SPAUDIOOPTIONS = TOleEnum;

const
  SPAO_NONE = $00000000;
  SPAO_RETAIN_AUDIO = $00000001;

  // Constants for enum SPBOOKMARKOPTIONS
type
  SPBOOKMARKOPTIONS = TOleEnum;

const
  SPBO_NONE = $00000000;
  SPBO_PAUSE = $00000001;
  SPBO_AHEAD = $00000002;
  SPBO_TIME_UNITS = $00000004;

  // Constants for enum SPCONTEXTSTATE
type
  SPCONTEXTSTATE = TOleEnum;

const
  SPCS_DISABLED = $00000000;
  SPCS_ENABLED = $00000001;

  // Constants for enum SPADAPTATIONRELEVANCE
type
  SPADAPTATIONRELEVANCE = TOleEnum;

const
  SPAR_Unknown = $00000000;
  SPAR_Low = $00000001;
  SPAR_Medium = $00000002;
  SPAR_High = $00000003;

  // Constants for enum SPCATEGORYTYPE
type
  SPCATEGORYTYPE = TOleEnum;

const
  SPCT_COMMAND = $00000000;
  SPCT_DICTATION = $00000001;
  SPCT_SLEEP = $00000002;
  SPCT_SUB_COMMAND = $00000003;
  SPCT_SUB_DICTATION = $00000004;

  // Constants for enum SPLEXICONTYPE
type
  SPLEXICONTYPE = TOleEnum;

const
  eLEXTYPE_USER = $00000001;
  eLEXTYPE_APP = $00000002;
  eLEXTYPE_VENDORLEXICON = $00000004;
  eLEXTYPE_LETTERTOSOUND = $00000008;
  eLEXTYPE_MORPHOLOGY = $00000010;
  eLEXTYPE_RESERVED4 = $00000020;
  eLEXTYPE_USER_SHORTCUT = $00000040;
  eLEXTYPE_RESERVED6 = $00000080;
  eLEXTYPE_RESERVED7 = $00000100;
  eLEXTYPE_RESERVED8 = $00000200;
  eLEXTYPE_RESERVED9 = $00000400;
  eLEXTYPE_RESERVED10 = $00000800;
  eLEXTYPE_PRIVATE1 = $00001000;
  eLEXTYPE_PRIVATE2 = $00002000;
  eLEXTYPE_PRIVATE3 = $00004000;
  eLEXTYPE_PRIVATE4 = $00008000;
  eLEXTYPE_PRIVATE5 = $00010000;
  eLEXTYPE_PRIVATE6 = $00020000;
  eLEXTYPE_PRIVATE7 = $00040000;
  eLEXTYPE_PRIVATE8 = $00080000;
  eLEXTYPE_PRIVATE9 = $00100000;
  eLEXTYPE_PRIVATE10 = $00200000;
  eLEXTYPE_PRIVATE11 = $00400000;
  eLEXTYPE_PRIVATE12 = $00800000;
  eLEXTYPE_PRIVATE13 = $01000000;
  eLEXTYPE_PRIVATE14 = $02000000;
  eLEXTYPE_PRIVATE15 = $04000000;
  eLEXTYPE_PRIVATE16 = $08000000;
  eLEXTYPE_PRIVATE17 = $10000000;
  eLEXTYPE_PRIVATE18 = $20000000;
  eLEXTYPE_PRIVATE19 = $40000000;
  eLEXTYPE_PRIVATE20 = $80000000;

  // Constants for enum SPPARTOFSPEECH
type
  SPPARTOFSPEECH = TOleEnum;

const
  SPPS_NotOverriden = $FFFFFFFF;
  SPPS_Unknown = $00000000;
  SPPS_Noun = $00001000;
  SPPS_Verb = $00002000;
  SPPS_Modifier = $00003000;
  SPPS_Function = $00004000;
  SPPS_Interjection = $00005000;
  SPPS_Noncontent = $00006000;
  SPPS_LMA = $00007000;
  SPPS_SuppressWord = $0000F000;

  // Constants for enum SPWORDTYPE
type
  SPWORDTYPE = TOleEnum;

const
  eWORDTYPE_ADDED = $00000001;
  eWORDTYPE_DELETED = $00000002;

  // Constants for enum SPSHORTCUTTYPE
type
  SPSHORTCUTTYPE = TOleEnum;

const
  SPSHT_NotOverriden = $FFFFFFFF;
  SPSHT_Unknown = $00000000;
  SPSHT_EMAIL = $00001000;
  SPSHT_OTHER = $00002000;
  SPPS_RESERVED1 = $00003000;
  SPPS_RESERVED2 = $00004000;
  SPPS_RESERVED3 = $00005000;
  SPPS_RESERVED4 = $0000F000;

type

  // *********************************************************************//
  // Forward declaration of types defined in TypeLibrary
  // *********************************************************************//
  ISpeechDataKey = interface;
  ISpeechDataKeyDisp = dispinterface;
  ISpeechObjectToken = interface;
  ISpeechObjectTokenDisp = dispinterface;
  ISpeechObjectTokenCategory = interface;
  ISpeechObjectTokenCategoryDisp = dispinterface;
  ISpeechObjectTokens = interface;
  ISpeechObjectTokensDisp = dispinterface;
  ISpeechAudioBufferInfo = interface;
  ISpeechAudioBufferInfoDisp = dispinterface;
  ISpeechAudioStatus = interface;
  ISpeechAudioStatusDisp = dispinterface;
  ISpeechAudioFormat = interface;
  ISpeechAudioFormatDisp = dispinterface;
  ISpeechWaveFormatEx = interface;
  ISpeechWaveFormatExDisp = dispinterface;
  ISpeechBaseStream = interface;
  ISpeechBaseStreamDisp = dispinterface;
  ISpeechFileStream = interface;
  ISpeechFileStreamDisp = dispinterface;
  ISpeechMemoryStream = interface;
  ISpeechMemoryStreamDisp = dispinterface;
  ISpeechCustomStream = interface;
  ISpeechCustomStreamDisp = dispinterface;
  ISpeechAudio = interface;
  ISpeechAudioDisp = dispinterface;
  ISpeechMMSysAudio = interface;
  ISpeechMMSysAudioDisp = dispinterface;
  ISpeechVoice = interface;
  ISpeechVoiceDisp = dispinterface;
  ISpeechVoiceStatus = interface;
  ISpeechVoiceStatusDisp = dispinterface;
  _ISpeechVoiceEvents = dispinterface;
  ISpeechRecognizer = interface;
  ISpeechRecognizerDisp = dispinterface;
  ISpeechRecognizerStatus = interface;
  ISpeechRecognizerStatusDisp = dispinterface;
  ISpeechRecoContext = interface;
  ISpeechRecoContextDisp = dispinterface;
  ISpeechRecoGrammar = interface;
  ISpeechRecoGrammarDisp = dispinterface;
  ISpeechGrammarRules = interface;
  ISpeechGrammarRulesDisp = dispinterface;
  ISpeechGrammarRule = interface;
  ISpeechGrammarRuleDisp = dispinterface;
  ISpeechGrammarRuleState = interface;
  ISpeechGrammarRuleStateDisp = dispinterface;
  ISpeechGrammarRuleStateTransitions = interface;
  ISpeechGrammarRuleStateTransitionsDisp = dispinterface;
  ISpeechGrammarRuleStateTransition = interface;
  ISpeechGrammarRuleStateTransitionDisp = dispinterface;
  ISpeechTextSelectionInformation = interface;
  ISpeechTextSelectionInformationDisp = dispinterface;
  ISpeechRecoResult = interface;
  ISpeechRecoResultDisp = dispinterface;
  ISpeechRecoResultTimes = interface;
  ISpeechRecoResultTimesDisp = dispinterface;
  ISpeechPhraseInfo = interface;
  ISpeechPhraseInfoDisp = dispinterface;
  ISpeechPhraseRule = interface;
  ISpeechPhraseRuleDisp = dispinterface;
  ISpeechPhraseRules = interface;
  ISpeechPhraseRulesDisp = dispinterface;
  ISpeechPhraseProperties = interface;
  ISpeechPhrasePropertiesDisp = dispinterface;
  ISpeechPhraseProperty = interface;
  ISpeechPhrasePropertyDisp = dispinterface;
  ISpeechPhraseElements = interface;
  ISpeechPhraseElementsDisp = dispinterface;
  ISpeechPhraseElement = interface;
  ISpeechPhraseElementDisp = dispinterface;
  ISpeechPhraseReplacements = interface;
  ISpeechPhraseReplacementsDisp = dispinterface;
  ISpeechPhraseReplacement = interface;
  ISpeechPhraseReplacementDisp = dispinterface;
  ISpeechPhraseAlternates = interface;
  ISpeechPhraseAlternatesDisp = dispinterface;
  ISpeechPhraseAlternate = interface;
  ISpeechPhraseAlternateDisp = dispinterface;
  _ISpeechRecoContextEvents = dispinterface;
  ISpeechRecoResult2 = interface;
  ISpeechRecoResult2Disp = dispinterface;
  ISpeechLexicon = interface;
  ISpeechLexiconDisp = dispinterface;
  ISpeechLexiconWords = interface;
  ISpeechLexiconWordsDisp = dispinterface;
  ISpeechLexiconWord = interface;
  ISpeechLexiconWordDisp = dispinterface;
  ISpeechLexiconPronunciations = interface;
  ISpeechLexiconPronunciationsDisp = dispinterface;
  ISpeechLexiconPronunciation = interface;
  ISpeechLexiconPronunciationDisp = dispinterface;
  ISpeechXMLRecoResult = interface;
  ISpeechXMLRecoResultDisp = dispinterface;
  ISpeechRecoResultDispatch = interface;
  ISpeechRecoResultDispatchDisp = dispinterface;
  ISpeechPhraseInfoBuilder = interface;
  ISpeechPhraseInfoBuilderDisp = dispinterface;
  ISpeechPhoneConverter = interface;
  ISpeechPhoneConverterDisp = dispinterface;
  ISpNotifySink = interface;
  ISpNotifyTranslator = interface;
  ISpDataKey = interface;
  ISpObjectTokenCategory = interface;
  IEnumSpObjectTokens = interface;
  ISpObjectToken = interface;
  IServiceProvider = interface;
  ISpResourceManager = interface;
  ISequentialStream = interface;
  IStream = interface;
  ISpStreamFormat = interface;
  ISpStreamFormatConverter = interface;
  ISpNotifySource = interface;
  ISpEventSource = interface;
  ISpEventSink = interface;
  ISpObjectWithToken = interface;
  ISpAudio = interface;
  ISpMMSysAudio = interface;
  ISpStream = interface;
  ISpVoice = interface;
  ISpPhoneticAlphabetSelection = interface;
  ISpRecoContext = interface;
  ISpRecoContext2 = interface;
  ISpProperties = interface;
  ISpRecognizer = interface;
  ISpPhrase = interface;
  ISpGrammarBuilder = interface;
  ISpRecoGrammar = interface;
  ISpRecoResult = interface;
  ISpPhraseAlt = interface;
  ISpRecognizer2 = interface;
  ISpRecognizer3 = interface;
  ISpSerializeState = interface;
  ISpRecoCategory = interface;
  ISpLexicon = interface;
  ISpShortcut = interface;
  ISpPhoneConverter = interface;
  ISpPhoneticAlphabetConverter = interface;
  ISpXMLRecoResult = interface;
  ISpRecoGrammar2 = interface;
  ISpeechResourceLoader = interface;
  ISpeechResourceLoaderDisp = dispinterface;
  IInternetSecurityManager = interface;
  IInternetSecurityMgrSite = interface;
  IEnumString = interface;

  // *********************************************************************//
  // Declaration of CoClasses defined in Type Library
  // (NOTE: Here we map each CoClass to its Default Interface)
  // *********************************************************************//
  SpNotifyTranslator = ISpNotifyTranslator;
  SpObjectTokenCategory = ISpeechObjectTokenCategory;
  SpObjectToken = ISpeechObjectToken;
  SpResourceManager = ISpResourceManager;
  SpStreamFormatConverter = ISpStreamFormatConverter;
  SpMMAudioEnum = IEnumSpObjectTokens;
  SpMMAudioIn = ISpeechMMSysAudio;
  SpMMAudioOut = ISpeechMMSysAudio;
  SpStream = ISpStream;
  SpVoice = ISpeechVoice;
  SpSharedRecoContext = ISpeechRecoContext;
  SpInprocRecognizer = ISpeechRecognizer;
  SpSharedRecognizer = ISpeechRecognizer;
  SpLexicon = ISpeechLexicon;
  SpUnCompressedLexicon = ISpeechLexicon;
  SpCompressedLexicon = ISpLexicon;
  SpShortcut = ISpShortcut;
  SpPhoneConverter = ISpeechPhoneConverter;
  SpPhoneticAlphabetConverter = ISpPhoneticAlphabetConverter;
  SpNullPhoneConverter = ISpPhoneConverter;
  SpTextSelectionInformation = ISpeechTextSelectionInformation;
  SpPhraseInfoBuilder = ISpeechPhraseInfoBuilder;
  SpAudioFormat = ISpeechAudioFormat;
  SpWaveFormatEx = ISpeechWaveFormatEx;
  SpInProcRecoContext = ISpeechRecoContext;
  SpCustomStream = ISpeechCustomStream;
  SpFileStream = ISpeechFileStream;
  SpMemoryStream = ISpeechMemoryStream;

  // *********************************************************************//
  // Declaration of structures, unions and aliases.
  // *********************************************************************//
  wireHWND = ^_RemotableHandle;
  PUserType9 = ^SPPHRASERULE; { * }
  PUserType10 = ^SPPHRASEPROPERTY; { * }
  PUserType14 = ^SPWORDPRONUNCIATION; { * }
  PUserType15 = ^SPWORD; { * }
  PUserType16 = ^SPSHORTCUTPAIR; { * }
  POleVariant1 = ^OleVariant; { * }
  PPPrivateAlias1 = ^Pointer; { * }
  PByte1 = ^Byte; { * }
  PUINT1 = ^LongWord; { * }
  PUserType1 = ^TGUID; { * }
  PUserType2 = ^WAVEFORMATEX; { * }
  PUserType3 = ^SPEVENT; { * }
  PUserType4 = ^SPAUDIOBUFFERINFO; { * }
  PUserType5 = ^SPAUDIOOPTIONS; { * }
  PUserType6 = ^SPSERIALIZEDRESULT; { * }
  PUserType7 = ^SPPHRASE; { * }
  PUserType8 = ^SPSERIALIZEDPHRASE; { * }
  PUserType11 = ^SPBINARYGRAMMAR; { * }
  PWord1 = ^Word; { * }
  PUserType12 = ^SPTEXTSELECTIONINFO; { * }
  PUserType13 = ^SPPROPERTYINFO; { * }
  PUserType17 = ^SPRULE; { * }

  __MIDL_IWinTypes_0009 = record
    case Integer of
      0:
        (hInproc: Integer);
      1:
        (hRemote: Integer);
  end;

  _RemotableHandle = record
    fContext: Integer;
    u: __MIDL_IWinTypes_0009;
  end;

  UINT_PTR = LongWord;
  LONG_PTR = Integer;

{$ALIGN 8}

  _LARGE_INTEGER = record
    QuadPart: Int64;
  end;

  _ULARGE_INTEGER = record
    QuadPart: Largeuint;
  end;

{$ALIGN 4}

  _FILETIME = record
    dwLowDateTime: LongWord;
    dwHighDateTime: LongWord;
  end;

{$ALIGN 8}

  tagSTATSTG = record
    pwcsName: PWideChar;
    type_: LongWord;
    cbSize: _ULARGE_INTEGER;
    mtime: _FILETIME;
    ctime: _FILETIME;
    atime: _FILETIME;
    grfMode: LongWord;
    grfLocksSupported: LongWord;
    clsid: TGUID;
    grfStateBits: LongWord;
    reserved: LongWord;
  end;

{$ALIGN 4}

  WAVEFORMATEX = record
    wFormatTag: Word;
    nChannels: Word;
    nSamplesPerSec: LongWord;
    nAvgBytesPerSec: LongWord;
    nBlockAlign: Word;
    wBitsPerSample: Word;
    cbSize: Word;
  end;

{$ALIGN 8}

  SPEVENT = record
    eEventId: Word;
    elParamType: Word;
    ulStreamNum: LongWord;
    ullAudioStreamOffset: Largeuint;
    wParam: UINT_PTR;
    lParam: LONG_PTR;
  end;

  SPEVENTSOURCEINFO = record
    ullEventInterest: Largeuint;
    ullQueuedInterest: Largeuint;
    ulCount: LongWord;
  end;

  SPAUDIOSTATE = _SPAUDIOSTATE;

  SPAUDIOSTATUS = record
    cbFreeBuffSpace: Integer;
    cbNonBlockingIO: LongWord;
    State: SPAUDIOSTATE;
    CurSeekPos: Largeuint;
    CurDevicePos: Largeuint;
    dwAudioLevel: LongWord;
    dwReserved2: LongWord;
  end;

{$ALIGN 4}

  SPAUDIOBUFFERINFO = record
    ulMsMinNotification: LongWord;
    ulMsBufferSize: LongWord;
    ulMsEventBias: LongWord;
  end;

  SPVOICESTATUS = record
    ulCurrentStream: LongWord;
    ulLastStreamQueued: LongWord;
    hrLastResult: HResult;
    dwRunningState: LongWord;
    ulInputWordPos: LongWord;
    ulInputWordLen: LongWord;
    ulInputSentPos: LongWord;
    ulInputSentLen: LongWord;
    lBookmarkId: Integer;
    PhonemeId: Word;
    VisemeId: SPVISEMES;
    dwReserved1: LongWord;
    dwReserved2: LongWord;
  end;

{$ALIGN 8}

  SPRECOGNIZERSTATUS = record
    AudioStatus: SPAUDIOSTATUS;
    ullRecognitionStreamPos: Largeuint;
    ulStreamNumber: LongWord;
    ulNumActive: LongWord;
    ClsidEngine: TGUID;
    cLangIDs: LongWord;
    aLangID: array [0 .. 19] of Word;
    ullRecognitionStreamTime: Largeuint;
  end;

  SPSTREAMFORMATTYPE = SPWAVEFORMATTYPE;

{$ALIGN 4}

  SPPHRASERULE = record
    pszName: PWideChar;
    ulId: LongWord;
    ulFirstElement: LongWord;
    ulCountOfElements: LongWord;
    pNextSibling: PUserType9;
    pFirstChild: PUserType9;
    SREngineConfidence: Single;
    Confidence: Shortint;
  end;

{$ALIGN 2}

  __MIDL___MIDL_itf_sapi_0000_0020_0002 = record
    bType: Byte;
    bReserved: Byte;
    usArrayIndex: Word;
  end;

{$ALIGN 4}

  __MIDL___MIDL_itf_sapi_0000_0020_0001 = record
    case Integer of
      0:
        (ulId: LongWord);
      1:
        (__MIDL____MIDL_itf_sapi_0000_00200000
          : __MIDL___MIDL_itf_sapi_0000_0020_0002);
  end;

  SPPHRASEELEMENT = record
    ulAudioTimeOffset: LongWord;
    ulAudioSizeTime: LongWord;
    ulAudioStreamOffset: LongWord;
    ulAudioSizeBytes: LongWord;
    ulRetainedStreamOffset: LongWord;
    ulRetainedSizeBytes: LongWord;
    pszDisplayText: PWideChar;
    pszLexicalForm: PWideChar;
    pszPronunciation: ^Word;
    bDisplayAttributes: Byte;
    RequiredConfidence: Shortint;
    ActualConfidence: Shortint;
    reserved: Byte;
    SREngineConfidence: Single;
  end;

  SPPHRASEREPLACEMENT = record
    bDisplayAttributes: Byte;
    pszReplacementText: PWideChar;
    ulFirstElement: LongWord;
    ulCountOfElements: LongWord;
  end;

  SPSEMANTICERRORINFO = record
    ulLineNumber: LongWord;
    pszScriptLine: PWideChar;
    pszSource: PWideChar;
    pszDescription: PWideChar;
    hrResultCode: HResult;
  end;

  SPSERIALIZEDPHRASE = record
    ulSerializedSize: LongWord;
  end;

{$ALIGN 8}

  tagSPPROPERTYINFO = record
    pszName: PWideChar;
    ulId: LongWord;
    pszValue: PWideChar;
    vValue: OleVariant;
  end;

  SPPROPERTYINFO = tagSPPROPERTYINFO;

{$ALIGN 4}

  SPBINARYGRAMMAR = record
    ulTotalSerializedSize: LongWord;
  end;

  tagSPTEXTSELECTIONINFO = record
    ulStartActiveOffset: LongWord;
    cchActiveChars: LongWord;
    ulStartSelection: LongWord;
    cchSelection: LongWord;
  end;

  SPTEXTSELECTIONINFO = tagSPTEXTSELECTIONINFO;

  SPRECOCONTEXTSTATUS = record
    eInterference: SPINTERFERENCE;
    szRequestTypeOfUI: array [0 .. 254] of Word;
    dwReserved1: LongWord;
    dwReserved2: LongWord;
  end;

  SPSERIALIZEDRESULT = record
    ulSerializedSize: LongWord;
  end;

{$ALIGN 8}

  SPRECORESULTTIMES = record
    ftStreamTime: _FILETIME;
    ullLength: Largeuint;
    dwTickCount: LongWord;
    ullStart: Largeuint;
  end;

{$ALIGN 4}

  SPWORDPRONUNCIATION = record
    pNextWordPronunciation: PUserType14;
    eLexiconType: SPLEXICONTYPE;
    LangId: Word;
    wPronunciationFlags: Word;
    ePartOfSpeech: SPPARTOFSPEECH;
    szPronunciation: array [0 .. 0] of Word;
  end;

  SPWORD = record
    pNextWord: PUserType15;
    LangId: Word;
    wReserved: Word;
    eWordType: SPWORDTYPE;
    pszWord: PWideChar;
    pFirstWordPronunciation: ^SPWORDPRONUNCIATION;
  end;

  SPSHORTCUTPAIR = record
    pNextSHORTCUTPAIR: PUserType16;
    LangId: Word;
    shType: SPSHORTCUTTYPE;
    pszDisplay: PWideChar;
    pszSpoken: PWideChar;
  end;

  SPRULE = record
    pszRuleName: PWideChar;
    ulRuleId: LongWord;
    dwAttributes: LongWord;
  end;

  ULONG_PTR = LongWord;

{$ALIGN 8}

  SPPHRASEPROPERTY = record
    pszName: PWideChar;
    __MIDL____MIDL_itf_sapi_0000_00200001
      : __MIDL___MIDL_itf_sapi_0000_0020_0001;
    pszValue: PWideChar;
    vValue: OleVariant;
    ulFirstElement: LongWord;
    ulCountOfElements: LongWord;
    pNextSibling: PUserType10;
    pFirstChild: PUserType10;
    SREngineConfidence: Single;
    Confidence: Shortint;
  end;

  SPPHRASE = record
    cbSize: LongWord;
    LangId: Word;
    wHomophoneGroupId: Word;
    ullGrammarID: Largeuint;
    ftStartTime: Largeuint;
    ullAudioStreamPosition: Largeuint;
    ulAudioSizeBytes: LongWord;
    ulRetainedSizeBytes: LongWord;
    ulAudioSizeTime: LongWord;
    Rule: SPPHRASERULE;
    pProperties: ^SPPHRASEPROPERTY;
    pElements: ^SPPHRASEELEMENT;
    cReplacements: LongWord;
    pReplacements: ^SPPHRASEREPLACEMENT;
    SREngineID: TGUID;
    ulSREnginePrivateDataSize: LongWord;
    pSREnginePrivateData: ^Byte;
    pSML: PWideChar;
    pSemanticErrorInfo: ^SPSEMANTICERRORINFO;
    SemanticTagFormat: SPSEMANTICFORMAT;
  end;

{$ALIGN 4}

  SPWORDPRONUNCIATIONLIST = record
    ulSize: LongWord;
    pvBuffer: ^Byte;
    pFirstWordPronunciation: ^SPWORDPRONUNCIATION;
  end;

  SPWORDLIST = record
    ulSize: LongWord;
    pvBuffer: ^Byte;
    pFirstWord: ^SPWORD;
  end;

  SPSHORTCUTPAIRLIST = record
    ulSize: LongWord;
    pvBuffer: ^Byte;
    pFirstShortcutPair: ^SPSHORTCUTPAIR;
  end;

  // *********************************************************************//
  // Interface: ISpeechDataKey
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}
  // *********************************************************************//
  ISpeechDataKey = interface(IDispatch)
    ['{CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}']
    procedure SetBinaryValue(const ValueName: WideString;
      Value: OleVariant); safecall;
    function GetBinaryValue(const ValueName: WideString): OleVariant; safecall;
    procedure SetStringValue(const ValueName: WideString;
      const Value: WideString); safecall;
    function GetStringValue(const ValueName: WideString): WideString; safecall;
    procedure SetLongValue(const ValueName: WideString;
      Value: Integer); safecall;
    function GetLongValue(const ValueName: WideString): Integer; safecall;
    function OpenKey(const SubKeyName: WideString): ISpeechDataKey; safecall;
    function CreateKey(const SubKeyName: WideString): ISpeechDataKey; safecall;
    procedure DeleteKey(const SubKeyName: WideString); safecall;
    procedure DeleteValue(const ValueName: WideString); safecall;
    function EnumKeys(Index: Integer): WideString; safecall;
    function EnumValues(Index: Integer): WideString; safecall;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechDataKeyDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}
  // *********************************************************************//
  ISpeechDataKeyDisp = dispinterface
    ['{CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}']
    procedure SetBinaryValue(const ValueName: WideString;
      Value: OleVariant); dispid 1;
    function GetBinaryValue(const ValueName: WideString): OleVariant; dispid 2;
    procedure SetStringValue(const ValueName: WideString;
      const Value: WideString); dispid 3;
    function GetStringValue(const ValueName: WideString): WideString; dispid 4;
    procedure SetLongValue(const ValueName: WideString;
      Value: Integer); dispid 5;
    function GetLongValue(const ValueName: WideString): Integer; dispid 6;
    function OpenKey(const SubKeyName: WideString): ISpeechDataKey; dispid 7;
    function CreateKey(const SubKeyName: WideString): ISpeechDataKey; dispid 8;
    procedure DeleteKey(const SubKeyName: WideString); dispid 9;
    procedure DeleteValue(const ValueName: WideString); dispid 10;
    function EnumKeys(Index: Integer): WideString; dispid 11;
    function EnumValues(Index: Integer): WideString; dispid 12;
  end;

  // *********************************************************************//
  // Interface: ISpeechObjectToken
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {C74A3ADC-B727-4500-A84A-B526721C8B8C}
  // *********************************************************************//
  ISpeechObjectToken = interface(IDispatch)
    ['{C74A3ADC-B727-4500-A84A-B526721C8B8C}']
    function Get_Id: WideString; safecall;
    function Get_DataKey: ISpeechDataKey; safecall;
    function Get_Category: ISpeechObjectTokenCategory; safecall;
    function GetDescription(Locale: Integer): WideString; safecall;
    procedure SetId(const Id: WideString; const CategoryID: WideString;
      CreateIfNotExist: WordBool); safecall;
    function GetAttribute(const AttributeName: WideString): WideString;
      safecall;
    function CreateInstance(const pUnkOuter: IUnknown;
      ClsContext: SpeechTokenContext): IUnknown; safecall;
    procedure Remove(const ObjectStorageCLSID: WideString); safecall;
    function GetStorageFileName(const ObjectStorageCLSID: WideString;
      const KeyName: WideString; const FileName: WideString;
      Folder: SpeechTokenShellFolder): WideString; safecall;
    procedure RemoveStorageFileName(const ObjectStorageCLSID: WideString;
      const KeyName: WideString; DeleteFile: WordBool); safecall;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant; const Object_: IUnknown): WordBool; safecall;
    procedure DisplayUI(hWnd: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant;
      const Object_: IUnknown); safecall;
    function MatchesAttributes(const Attributes: WideString): WordBool;
      safecall;
    property Id: WideString read Get_Id;
    property DataKey: ISpeechDataKey read Get_DataKey;
    property Category: ISpeechObjectTokenCategory read Get_Category;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechObjectTokenDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {C74A3ADC-B727-4500-A84A-B526721C8B8C}
  // *********************************************************************//
  ISpeechObjectTokenDisp = dispinterface
    ['{C74A3ADC-B727-4500-A84A-B526721C8B8C}']
    property Id: WideString readonly dispid 1;
    property DataKey: ISpeechDataKey readonly dispid 2;
    property Category: ISpeechObjectTokenCategory readonly dispid 3;
    function GetDescription(Locale: Integer): WideString; dispid 4;
    procedure SetId(const Id: WideString; const CategoryID: WideString;
      CreateIfNotExist: WordBool); dispid 5;
    function GetAttribute(const AttributeName: WideString): WideString;
      dispid 6;
    function CreateInstance(const pUnkOuter: IUnknown;
      ClsContext: SpeechTokenContext): IUnknown; dispid 7;
    procedure Remove(const ObjectStorageCLSID: WideString); dispid 8;
    function GetStorageFileName(const ObjectStorageCLSID: WideString;
      const KeyName: WideString; const FileName: WideString;
      Folder: SpeechTokenShellFolder): WideString; dispid 9;
    procedure RemoveStorageFileName(const ObjectStorageCLSID: WideString;
      const KeyName: WideString; DeleteFile: WordBool); dispid 10;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant; const Object_: IUnknown): WordBool;
      dispid 11;
    procedure DisplayUI(hWnd: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant;
      const Object_: IUnknown); dispid 12;
    function MatchesAttributes(const Attributes: WideString): WordBool;
      dispid 13;
  end;

  // *********************************************************************//
  // Interface: ISpeechObjectTokenCategory
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CA7EAC50-2D01-4145-86D4-5AE7D70F4469}
  // *********************************************************************//
  ISpeechObjectTokenCategory = interface(IDispatch)
    ['{CA7EAC50-2D01-4145-86D4-5AE7D70F4469}']
    function Get_Id: WideString; safecall;
    procedure Set_Default(const TokenId: WideString); safecall;
    function Get_Default: WideString; safecall;
    procedure SetId(const Id: WideString; CreateIfNotExist: WordBool); safecall;
    function GetDataKey(Location: SpeechDataKeyLocation)
      : ISpeechDataKey; safecall;
    function EnumerateTokens(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    property Id: WideString read Get_Id;
    property Default: WideString read Get_Default write Set_Default;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechObjectTokenCategoryDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CA7EAC50-2D01-4145-86D4-5AE7D70F4469}
  // *********************************************************************//
  ISpeechObjectTokenCategoryDisp = dispinterface
    ['{CA7EAC50-2D01-4145-86D4-5AE7D70F4469}']
    property Id: WideString readonly dispid 1;
    property Default: WideString dispid 2;
    procedure SetId(const Id: WideString; CreateIfNotExist: WordBool); dispid 3;
    function GetDataKey(Location: SpeechDataKeyLocation)
      : ISpeechDataKey; dispid 4;
    function EnumerateTokens(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; dispid 5;
  end;

  // *********************************************************************//
  // Interface: ISpeechObjectTokens
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {9285B776-2E7B-4BC0-B53E-580EB6FA967F}
  // *********************************************************************//
  ISpeechObjectTokens = interface(IDispatch)
    ['{9285B776-2E7B-4BC0-B53E-580EB6FA967F}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechObjectToken; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechObjectTokensDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {9285B776-2E7B-4BC0-B53E-580EB6FA967F}
  // *********************************************************************//
  ISpeechObjectTokensDisp = dispinterface
    ['{9285B776-2E7B-4BC0-B53E-580EB6FA967F}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechObjectToken; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechAudioBufferInfo
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {11B103D8-1142-4EDF-A093-82FB3915F8CC}
  // *********************************************************************//
  ISpeechAudioBufferInfo = interface(IDispatch)
    ['{11B103D8-1142-4EDF-A093-82FB3915F8CC}']
    function Get_MinNotification: Integer; safecall;
    procedure Set_MinNotification(MinNotification: Integer); safecall;
    function Get_BufferSize: Integer; safecall;
    procedure Set_BufferSize(BufferSize: Integer); safecall;
    function Get_EventBias: Integer; safecall;
    procedure Set_EventBias(EventBias: Integer); safecall;
    property MinNotification: Integer read Get_MinNotification
      write Set_MinNotification;
    property BufferSize: Integer read Get_BufferSize write Set_BufferSize;
    property EventBias: Integer read Get_EventBias write Set_EventBias;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechAudioBufferInfoDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {11B103D8-1142-4EDF-A093-82FB3915F8CC}
  // *********************************************************************//
  ISpeechAudioBufferInfoDisp = dispinterface
    ['{11B103D8-1142-4EDF-A093-82FB3915F8CC}']
    property MinNotification: Integer dispid 1;
    property BufferSize: Integer dispid 2;
    property EventBias: Integer dispid 3;
  end;

  // *********************************************************************//
  // Interface: ISpeechAudioStatus
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {C62D9C91-7458-47F6-862D-1EF86FB0B278}
  // *********************************************************************//
  ISpeechAudioStatus = interface(IDispatch)
    ['{C62D9C91-7458-47F6-862D-1EF86FB0B278}']
    function Get_FreeBufferSpace: Integer; safecall;
    function Get_NonBlockingIO: Integer; safecall;
    function Get_State: SpeechAudioState; safecall;
    function Get_CurrentSeekPosition: OleVariant; safecall;
    function Get_CurrentDevicePosition: OleVariant; safecall;
    property FreeBufferSpace: Integer read Get_FreeBufferSpace;
    property NonBlockingIO: Integer read Get_NonBlockingIO;
    property State: SpeechAudioState read Get_State;
    property CurrentSeekPosition: OleVariant read Get_CurrentSeekPosition;
    property CurrentDevicePosition: OleVariant read Get_CurrentDevicePosition;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechAudioStatusDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {C62D9C91-7458-47F6-862D-1EF86FB0B278}
  // *********************************************************************//
  ISpeechAudioStatusDisp = dispinterface
    ['{C62D9C91-7458-47F6-862D-1EF86FB0B278}']
    property FreeBufferSpace: Integer readonly dispid 1;
    property NonBlockingIO: Integer readonly dispid 2;
    property State: SpeechAudioState readonly dispid 3;
    property CurrentSeekPosition: OleVariant readonly dispid 4;
    property CurrentDevicePosition: OleVariant readonly dispid 5;
  end;

  // *********************************************************************//
  // Interface: ISpeechAudioFormat
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {E6E9C590-3E18-40E3-8299-061F98BDE7C7}
  // *********************************************************************//
  ISpeechAudioFormat = interface(IDispatch)
    ['{E6E9C590-3E18-40E3-8299-061F98BDE7C7}']
    function Get_type_: SpeechAudioFormatType; safecall;
    procedure Set_type_(AudioFormat: SpeechAudioFormatType); safecall;
    function Get_Guid: WideString; safecall;
    procedure Set_Guid(const Guid: WideString); safecall;
    function GetWaveFormatEx: ISpeechWaveFormatEx; safecall;
    procedure SetWaveFormatEx(const SpeechWaveFormatEx
      : ISpeechWaveFormatEx); safecall;
    property type_: SpeechAudioFormatType read Get_type_ write Set_type_;
    property Guid: WideString read Get_Guid write Set_Guid;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechAudioFormatDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {E6E9C590-3E18-40E3-8299-061F98BDE7C7}
  // *********************************************************************//
  ISpeechAudioFormatDisp = dispinterface
    ['{E6E9C590-3E18-40E3-8299-061F98BDE7C7}']
    property type_: SpeechAudioFormatType dispid 1;
    property Guid: WideString dispid 2;
    function GetWaveFormatEx: ISpeechWaveFormatEx; dispid 3;
    procedure SetWaveFormatEx(const SpeechWaveFormatEx
      : ISpeechWaveFormatEx); dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechWaveFormatEx
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {7A1EF0D5-1581-4741-88E4-209A49F11A10}
  // *********************************************************************//
  ISpeechWaveFormatEx = interface(IDispatch)
    ['{7A1EF0D5-1581-4741-88E4-209A49F11A10}']
    function Get_FormatTag: Smallint; safecall;
    procedure Set_FormatTag(FormatTag: Smallint); safecall;
    function Get_Channels: Smallint; safecall;
    procedure Set_Channels(Channels: Smallint); safecall;
    function Get_SamplesPerSec: Integer; safecall;
    procedure Set_SamplesPerSec(SamplesPerSec: Integer); safecall;
    function Get_AvgBytesPerSec: Integer; safecall;
    procedure Set_AvgBytesPerSec(AvgBytesPerSec: Integer); safecall;
    function Get_BlockAlign: Smallint; safecall;
    procedure Set_BlockAlign(BlockAlign: Smallint); safecall;
    function Get_BitsPerSample: Smallint; safecall;
    procedure Set_BitsPerSample(BitsPerSample: Smallint); safecall;
    function Get_ExtraData: OleVariant; safecall;
    procedure Set_ExtraData(ExtraData: OleVariant); safecall;
    property FormatTag: Smallint read Get_FormatTag write Set_FormatTag;
    property Channels: Smallint read Get_Channels write Set_Channels;
    property SamplesPerSec: Integer read Get_SamplesPerSec
      write Set_SamplesPerSec;
    property AvgBytesPerSec: Integer read Get_AvgBytesPerSec
      write Set_AvgBytesPerSec;
    property BlockAlign: Smallint read Get_BlockAlign write Set_BlockAlign;
    property BitsPerSample: Smallint read Get_BitsPerSample
      write Set_BitsPerSample;
    property ExtraData: OleVariant read Get_ExtraData write Set_ExtraData;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechWaveFormatExDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {7A1EF0D5-1581-4741-88E4-209A49F11A10}
  // *********************************************************************//
  ISpeechWaveFormatExDisp = dispinterface
    ['{7A1EF0D5-1581-4741-88E4-209A49F11A10}']
    property FormatTag: Smallint dispid 1;
    property Channels: Smallint dispid 2;
    property SamplesPerSec: Integer dispid 3;
    property AvgBytesPerSec: Integer dispid 4;
    property BlockAlign: Smallint dispid 5;
    property BitsPerSample: Smallint dispid 6;
    property ExtraData: OleVariant dispid 7;
  end;

  // *********************************************************************//
  // Interface: ISpeechBaseStream
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {6450336F-7D49-4CED-8097-49D6DEE37294}
  // *********************************************************************//
  ISpeechBaseStream = interface(IDispatch)
    ['{6450336F-7D49-4CED-8097-49D6DEE37294}']
    function Get_Format: ISpeechAudioFormat; safecall;
    procedure _Set_Format(const AudioFormat: ISpeechAudioFormat); safecall;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer)
      : Integer; safecall;
    function Write(Buffer: OleVariant): Integer; safecall;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant; safecall;
    property Format: ISpeechAudioFormat read Get_Format write _Set_Format;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechBaseStreamDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {6450336F-7D49-4CED-8097-49D6DEE37294}
  // *********************************************************************//
  ISpeechBaseStreamDisp = dispinterface
    ['{6450336F-7D49-4CED-8097-49D6DEE37294}']
    property Format: ISpeechAudioFormat dispid 1;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer)
      : Integer; dispid 2;
    function Write(Buffer: OleVariant): Integer; dispid 3;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant; dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechFileStream
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {AF67F125-AB39-4E93-B4A2-CC2E66E182A7}
  // *********************************************************************//
  ISpeechFileStream = interface(ISpeechBaseStream)
    ['{AF67F125-AB39-4E93-B4A2-CC2E66E182A7}']
    procedure Open(const FileName: WideString; FileMode: SpeechStreamFileMode;
      DoEvents: WordBool); safecall;
    procedure Close; safecall;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechFileStreamDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {AF67F125-AB39-4E93-B4A2-CC2E66E182A7}
  // *********************************************************************//
  ISpeechFileStreamDisp = dispinterface
    ['{AF67F125-AB39-4E93-B4A2-CC2E66E182A7}']
    procedure Open(const FileName: WideString; FileMode: SpeechStreamFileMode;
      DoEvents: WordBool); dispid 100;
    procedure Close; dispid 101;
    property Format: ISpeechAudioFormat dispid 1;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer)
      : Integer; dispid 2;
    function Write(Buffer: OleVariant): Integer; dispid 3;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant; dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechMemoryStream
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {EEB14B68-808B-4ABE-A5EA-B51DA7588008}
  // *********************************************************************//
  ISpeechMemoryStream = interface(ISpeechBaseStream)
    ['{EEB14B68-808B-4ABE-A5EA-B51DA7588008}']
    procedure SetData(Data: OleVariant); safecall;
    function GetData: OleVariant; safecall;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechMemoryStreamDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {EEB14B68-808B-4ABE-A5EA-B51DA7588008}
  // *********************************************************************//
  ISpeechMemoryStreamDisp = dispinterface
    ['{EEB14B68-808B-4ABE-A5EA-B51DA7588008}']
    procedure SetData(Data: OleVariant); dispid 100;
    function GetData: OleVariant; dispid 101;
    property Format: ISpeechAudioFormat dispid 1;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer)
      : Integer; dispid 2;
    function Write(Buffer: OleVariant): Integer; dispid 3;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant; dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechCustomStream
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}
  // *********************************************************************//
  ISpeechCustomStream = interface(ISpeechBaseStream)
    ['{1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}']
    function Get_BaseStream: IUnknown; safecall;
    procedure _Set_BaseStream(const ppUnkStream: IUnknown); safecall;
    property BaseStream: IUnknown read Get_BaseStream write _Set_BaseStream;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechCustomStreamDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}
  // *********************************************************************//
  ISpeechCustomStreamDisp = dispinterface
    ['{1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}']
    property BaseStream: IUnknown dispid 100;
    property Format: ISpeechAudioFormat dispid 1;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer)
      : Integer; dispid 2;
    function Write(Buffer: OleVariant): Integer; dispid 3;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant; dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechAudio
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CFF8E175-019E-11D3-A08E-00C04F8EF9B5}
  // *********************************************************************//
  ISpeechAudio = interface(ISpeechBaseStream)
    ['{CFF8E175-019E-11D3-A08E-00C04F8EF9B5}']
    function Get_Status: ISpeechAudioStatus; safecall;
    function Get_BufferInfo: ISpeechAudioBufferInfo; safecall;
    function Get_DefaultFormat: ISpeechAudioFormat; safecall;
    function Get_Volume: Integer; safecall;
    procedure Set_Volume(Volume: Integer); safecall;
    function Get_BufferNotifySize: Integer; safecall;
    procedure Set_BufferNotifySize(BufferNotifySize: Integer); safecall;
    function Get_EventHandle: Integer; safecall;
    procedure SetState(State: SpeechAudioState); safecall;
    property Status: ISpeechAudioStatus read Get_Status;
    property BufferInfo: ISpeechAudioBufferInfo read Get_BufferInfo;
    property DefaultFormat: ISpeechAudioFormat read Get_DefaultFormat;
    property Volume: Integer read Get_Volume write Set_Volume;
    property BufferNotifySize: Integer read Get_BufferNotifySize
      write Set_BufferNotifySize;
    property EventHandle: Integer read Get_EventHandle;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechAudioDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CFF8E175-019E-11D3-A08E-00C04F8EF9B5}
  // *********************************************************************//
  ISpeechAudioDisp = dispinterface
    ['{CFF8E175-019E-11D3-A08E-00C04F8EF9B5}']
    property Status: ISpeechAudioStatus readonly dispid 200;
    property BufferInfo: ISpeechAudioBufferInfo readonly dispid 201;
    property DefaultFormat: ISpeechAudioFormat readonly dispid 202;
    property Volume: Integer dispid 203;
    property BufferNotifySize: Integer dispid 204;
    property EventHandle: Integer readonly dispid 205;
    procedure SetState(State: SpeechAudioState); dispid 206;
    property Format: ISpeechAudioFormat dispid 1;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer)
      : Integer; dispid 2;
    function Write(Buffer: OleVariant): Integer; dispid 3;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant; dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechMMSysAudio
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}
  // *********************************************************************//
  ISpeechMMSysAudio = interface(ISpeechAudio)
    ['{3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}']
    function Get_DeviceId: Integer; safecall;
    procedure Set_DeviceId(DeviceId: Integer); safecall;
    function Get_LineId: Integer; safecall;
    procedure Set_LineId(LineId: Integer); safecall;
    function Get_MMHandle: Integer; safecall;
    property DeviceId: Integer read Get_DeviceId write Set_DeviceId;
    property LineId: Integer read Get_LineId write Set_LineId;
    property MMHandle: Integer read Get_MMHandle;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechMMSysAudioDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}
  // *********************************************************************//
  ISpeechMMSysAudioDisp = dispinterface
    ['{3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}']
    property DeviceId: Integer dispid 300;
    property LineId: Integer dispid 301;
    property MMHandle: Integer readonly dispid 302;
    property Status: ISpeechAudioStatus readonly dispid 200;
    property BufferInfo: ISpeechAudioBufferInfo readonly dispid 201;
    property DefaultFormat: ISpeechAudioFormat readonly dispid 202;
    property Volume: Integer dispid 203;
    property BufferNotifySize: Integer dispid 204;
    property EventHandle: Integer readonly dispid 205;
    procedure SetState(State: SpeechAudioState); dispid 206;
    property Format: ISpeechAudioFormat dispid 1;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer)
      : Integer; dispid 2;
    function Write(Buffer: OleVariant): Integer; dispid 3;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant; dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechVoice
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {269316D8-57BD-11D2-9EEE-00C04F797396}
  // *********************************************************************//
  ISpeechVoice = interface(IDispatch)
    ['{269316D8-57BD-11D2-9EEE-00C04F797396}']
    function Get_Status: ISpeechVoiceStatus; safecall;
    function Get_Voice: ISpeechObjectToken; safecall;
    procedure _Set_Voice(const Voice: ISpeechObjectToken); safecall;
    function Get_AudioOutput: ISpeechObjectToken; safecall;
    procedure _Set_AudioOutput(const AudioOutput: ISpeechObjectToken); safecall;
    function Get_AudioOutputStream: ISpeechBaseStream; safecall;
    procedure _Set_AudioOutputStream(const AudioOutputStream
      : ISpeechBaseStream); safecall;
    function Get_Rate: Integer; safecall;
    procedure Set_Rate(Rate: Integer); safecall;
    function Get_Volume: Integer; safecall;
    procedure Set_Volume(Volume: Integer); safecall;
    procedure Set_AllowAudioOutputFormatChangesOnNextSet
      (Allow: WordBool); safecall;
    function Get_AllowAudioOutputFormatChangesOnNextSet: WordBool; safecall;
    function Get_EventInterests: SpeechVoiceEvents; safecall;
    procedure Set_EventInterests(EventInterestFlags
      : SpeechVoiceEvents); safecall;
    procedure Set_Priority(Priority: SpeechVoicePriority); safecall;
    function Get_Priority: SpeechVoicePriority; safecall;
    procedure Set_AlertBoundary(Boundary: SpeechVoiceEvents); safecall;
    function Get_AlertBoundary: SpeechVoiceEvents; safecall;
    procedure Set_SynchronousSpeakTimeout(msTimeout: Integer); safecall;
    function Get_SynchronousSpeakTimeout: Integer; safecall;
    function Speak(const Text: WideString; Flags: SpeechVoiceSpeakFlags)
      : Integer; safecall;
    function SpeakStream(const Stream: ISpeechBaseStream;
      Flags: SpeechVoiceSpeakFlags): Integer; safecall;
    procedure Pause; safecall;
    procedure Resume; safecall;
    function Skip(const type_: WideString; NumItems: Integer): Integer;
      safecall;
    function GetVoices(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    function GetAudioOutputs(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    function WaitUntilDone(msTimeout: Integer): WordBool; safecall;
    function SpeakCompleteEvent: Integer; safecall;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant): WordBool; safecall;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant); safecall;
    property Status: ISpeechVoiceStatus read Get_Status;
    property Voice: ISpeechObjectToken read Get_Voice write _Set_Voice;
    property AudioOutput: ISpeechObjectToken read Get_AudioOutput
      write _Set_AudioOutput;
    property AudioOutputStream: ISpeechBaseStream read Get_AudioOutputStream
      write _Set_AudioOutputStream;
    property Rate: Integer read Get_Rate write Set_Rate;
    property Volume: Integer read Get_Volume write Set_Volume;
    property AllowAudioOutputFormatChangesOnNextSet: WordBool
      read Get_AllowAudioOutputFormatChangesOnNextSet
      write Set_AllowAudioOutputFormatChangesOnNextSet;
    property EventInterests: SpeechVoiceEvents read Get_EventInterests
      write Set_EventInterests;
    property Priority: SpeechVoicePriority read Get_Priority write Set_Priority;
    property AlertBoundary: SpeechVoiceEvents read Get_AlertBoundary
      write Set_AlertBoundary;
    property SynchronousSpeakTimeout: Integer read Get_SynchronousSpeakTimeout
      write Set_SynchronousSpeakTimeout;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechVoiceDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {269316D8-57BD-11D2-9EEE-00C04F797396}
  // *********************************************************************//
  ISpeechVoiceDisp = dispinterface
    ['{269316D8-57BD-11D2-9EEE-00C04F797396}']
    property Status: ISpeechVoiceStatus readonly dispid 1;
    property Voice: ISpeechObjectToken dispid 2;
    property AudioOutput: ISpeechObjectToken dispid 3;
    property AudioOutputStream: ISpeechBaseStream dispid 4;
    property Rate: Integer dispid 5;
    property Volume: Integer dispid 6;
    property AllowAudioOutputFormatChangesOnNextSet: WordBool dispid 7;
    property EventInterests: SpeechVoiceEvents dispid 8;
    property Priority: SpeechVoicePriority dispid 9;
    property AlertBoundary: SpeechVoiceEvents dispid 10;
    property SynchronousSpeakTimeout: Integer dispid 11;
    function Speak(const Text: WideString; Flags: SpeechVoiceSpeakFlags)
      : Integer; dispid 12;
    function SpeakStream(const Stream: ISpeechBaseStream;
      Flags: SpeechVoiceSpeakFlags): Integer; dispid 13;
    procedure Pause; dispid 14;
    procedure Resume; dispid 15;
    function Skip(const type_: WideString; NumItems: Integer): Integer;
      dispid 16;
    function GetVoices(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; dispid 17;
    function GetAudioOutputs(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; dispid 18;
    function WaitUntilDone(msTimeout: Integer): WordBool; dispid 19;
    function SpeakCompleteEvent: Integer; dispid 20;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant): WordBool; dispid 21;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant); dispid 22;
  end;

  // *********************************************************************//
  // Interface: ISpeechVoiceStatus
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {8BE47B07-57F6-11D2-9EEE-00C04F797396}
  // *********************************************************************//
  ISpeechVoiceStatus = interface(IDispatch)
    ['{8BE47B07-57F6-11D2-9EEE-00C04F797396}']
    function Get_CurrentStreamNumber: Integer; safecall;
    function Get_LastStreamNumberQueued: Integer; safecall;
    function Get_LastHResult: Integer; safecall;
    function Get_RunningState: SpeechRunState; safecall;
    function Get_InputWordPosition: Integer; safecall;
    function Get_InputWordLength: Integer; safecall;
    function Get_InputSentencePosition: Integer; safecall;
    function Get_InputSentenceLength: Integer; safecall;
    function Get_LastBookmark: WideString; safecall;
    function Get_LastBookmarkId: Integer; safecall;
    function Get_PhonemeId: Smallint; safecall;
    function Get_VisemeId: Smallint; safecall;
    property CurrentStreamNumber: Integer read Get_CurrentStreamNumber;
    property LastStreamNumberQueued: Integer read Get_LastStreamNumberQueued;
    property LastHResult: Integer read Get_LastHResult;
    property RunningState: SpeechRunState read Get_RunningState;
    property InputWordPosition: Integer read Get_InputWordPosition;
    property InputWordLength: Integer read Get_InputWordLength;
    property InputSentencePosition: Integer read Get_InputSentencePosition;
    property InputSentenceLength: Integer read Get_InputSentenceLength;
    property LastBookmark: WideString read Get_LastBookmark;
    property LastBookmarkId: Integer read Get_LastBookmarkId;
    property PhonemeId: Smallint read Get_PhonemeId;
    property VisemeId: Smallint read Get_VisemeId;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechVoiceStatusDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {8BE47B07-57F6-11D2-9EEE-00C04F797396}
  // *********************************************************************//
  ISpeechVoiceStatusDisp = dispinterface
    ['{8BE47B07-57F6-11D2-9EEE-00C04F797396}']
    property CurrentStreamNumber: Integer readonly dispid 1;
    property LastStreamNumberQueued: Integer readonly dispid 2;
    property LastHResult: Integer readonly dispid 3;
    property RunningState: SpeechRunState readonly dispid 4;
    property InputWordPosition: Integer readonly dispid 5;
    property InputWordLength: Integer readonly dispid 6;
    property InputSentencePosition: Integer readonly dispid 7;
    property InputSentenceLength: Integer readonly dispid 8;
    property LastBookmark: WideString readonly dispid 9;
    property LastBookmarkId: Integer readonly dispid 10;
    property PhonemeId: Smallint readonly dispid 11;
    property VisemeId: Smallint readonly dispid 12;
  end;

  // *********************************************************************//
  // DispIntf:  _ISpeechVoiceEvents
  // Flags:     (4096) Dispatchable
  // GUID:      {A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}
  // *********************************************************************//
  _ISpeechVoiceEvents = dispinterface
    ['{A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}']
    procedure StartStream(StreamNumber: Integer;
      StreamPosition: OleVariant); dispid 1;
    procedure EndStream(StreamNumber: Integer;
      StreamPosition: OleVariant); dispid 2;
    procedure VoiceChange(StreamNumber: Integer; StreamPosition: OleVariant;
      const VoiceObjectToken: ISpeechObjectToken); dispid 3;
    procedure Bookmark(StreamNumber: Integer; StreamPosition: OleVariant;
      const Bookmark: WideString; BookmarkId: Integer); dispid 4;
    procedure Word(StreamNumber: Integer; StreamPosition: OleVariant;
      CharacterPosition: Integer; Length: Integer); dispid 5;
    procedure Sentence(StreamNumber: Integer; StreamPosition: OleVariant;
      CharacterPosition: Integer; Length: Integer); dispid 7;
    procedure Phoneme(StreamNumber: Integer; StreamPosition: OleVariant;
      Duration: Integer; NextPhoneId: Smallint; Feature: SpeechVisemeFeature;
      CurrentPhoneId: Smallint); dispid 6;
    procedure Viseme(StreamNumber: Integer; StreamPosition: OleVariant;
      Duration: Integer; NextVisemeId: SpeechVisemeType;
      Feature: SpeechVisemeFeature; CurrentVisemeId: SpeechVisemeType);
      dispid 8;
    procedure AudioLevel(StreamNumber: Integer; StreamPosition: OleVariant;
      AudioLevel: Integer); dispid 9;
    procedure EnginePrivate(StreamNumber: Integer; StreamPosition: Integer;
      EngineData: OleVariant); dispid 10;
  end;

  // *********************************************************************//
  // Interface: ISpeechRecognizer
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}
  // *********************************************************************//
  ISpeechRecognizer = interface(IDispatch)
    ['{2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}']
    procedure _Set_Recognizer(const Recognizer: ISpeechObjectToken); safecall;
    function Get_Recognizer: ISpeechObjectToken; safecall;
    procedure Set_AllowAudioInputFormatChangesOnNextSet
      (Allow: WordBool); safecall;
    function Get_AllowAudioInputFormatChangesOnNextSet: WordBool; safecall;
    procedure _Set_AudioInput(const AudioInput: ISpeechObjectToken); safecall;
    function Get_AudioInput: ISpeechObjectToken; safecall;
    procedure _Set_AudioInputStream(const AudioInputStream
      : ISpeechBaseStream); safecall;
    function Get_AudioInputStream: ISpeechBaseStream; safecall;
    function Get_IsShared: WordBool; safecall;
    procedure Set_State(State: SpeechRecognizerState); safecall;
    function Get_State: SpeechRecognizerState; safecall;
    function Get_Status: ISpeechRecognizerStatus; safecall;
    procedure _Set_Profile(const Profile: ISpeechObjectToken); safecall;
    function Get_Profile: ISpeechObjectToken; safecall;
    procedure EmulateRecognition(TextElements: OleVariant;
      const ElementDisplayAttributes: OleVariant; LanguageId: Integer);
      safecall;
    function CreateRecoContext: ISpeechRecoContext; safecall;
    function GetFormat(type_: SpeechFormatType): ISpeechAudioFormat; safecall;
    function SetPropertyNumber(const Name: WideString; Value: Integer)
      : WordBool; safecall;
    function GetPropertyNumber(const Name: WideString; var Value: Integer)
      : WordBool; safecall;
    function SetPropertyString(const Name: WideString; const Value: WideString)
      : WordBool; safecall;
    function GetPropertyString(const Name: WideString; var Value: WideString)
      : WordBool; safecall;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant): WordBool; safecall;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant); safecall;
    function GetRecognizers(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    function GetAudioInputs(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    function GetProfiles(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; safecall;
    property Recognizer: ISpeechObjectToken read Get_Recognizer
      write _Set_Recognizer;
    property AllowAudioInputFormatChangesOnNextSet: WordBool
      read Get_AllowAudioInputFormatChangesOnNextSet
      write Set_AllowAudioInputFormatChangesOnNextSet;
    property AudioInput: ISpeechObjectToken read Get_AudioInput
      write _Set_AudioInput;
    property AudioInputStream: ISpeechBaseStream read Get_AudioInputStream
      write _Set_AudioInputStream;
    property IsShared: WordBool read Get_IsShared;
    property State: SpeechRecognizerState read Get_State write Set_State;
    property Status: ISpeechRecognizerStatus read Get_Status;
    property Profile: ISpeechObjectToken read Get_Profile write _Set_Profile;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechRecognizerDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}
  // *********************************************************************//
  ISpeechRecognizerDisp = dispinterface
    ['{2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}']
    property Recognizer: ISpeechObjectToken dispid 1;
    property AllowAudioInputFormatChangesOnNextSet: WordBool dispid 2;
    property AudioInput: ISpeechObjectToken dispid 3;
    property AudioInputStream: ISpeechBaseStream dispid 4;
    property IsShared: WordBool readonly dispid 5;
    property State: SpeechRecognizerState dispid 6;
    property Status: ISpeechRecognizerStatus readonly dispid 7;
    property Profile: ISpeechObjectToken dispid 8;
    procedure EmulateRecognition(TextElements: OleVariant;
      const ElementDisplayAttributes: OleVariant; LanguageId: Integer);
      dispid 9;
    function CreateRecoContext: ISpeechRecoContext; dispid 10;
    function GetFormat(type_: SpeechFormatType): ISpeechAudioFormat; dispid 11;
    function SetPropertyNumber(const Name: WideString; Value: Integer)
      : WordBool; dispid 12;
    function GetPropertyNumber(const Name: WideString; var Value: Integer)
      : WordBool; dispid 13;
    function SetPropertyString(const Name: WideString; const Value: WideString)
      : WordBool; dispid 14;
    function GetPropertyString(const Name: WideString; var Value: WideString)
      : WordBool; dispid 15;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant): WordBool; dispid 16;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant); dispid 17;
    function GetRecognizers(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; dispid 18;
    function GetAudioInputs(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; dispid 19;
    function GetProfiles(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens; dispid 20;
  end;

  // *********************************************************************//
  // Interface: ISpeechRecognizerStatus
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {BFF9E781-53EC-484E-BB8A-0E1B5551E35C}
  // *********************************************************************//
  ISpeechRecognizerStatus = interface(IDispatch)
    ['{BFF9E781-53EC-484E-BB8A-0E1B5551E35C}']
    function Get_AudioStatus: ISpeechAudioStatus; safecall;
    function Get_CurrentStreamPosition: OleVariant; safecall;
    function Get_CurrentStreamNumber: Integer; safecall;
    function Get_NumberOfActiveRules: Integer; safecall;
    function Get_ClsidEngine: WideString; safecall;
    function Get_SupportedLanguages: OleVariant; safecall;
    property AudioStatus: ISpeechAudioStatus read Get_AudioStatus;
    property CurrentStreamPosition: OleVariant read Get_CurrentStreamPosition;
    property CurrentStreamNumber: Integer read Get_CurrentStreamNumber;
    property NumberOfActiveRules: Integer read Get_NumberOfActiveRules;
    property ClsidEngine: WideString read Get_ClsidEngine;
    property SupportedLanguages: OleVariant read Get_SupportedLanguages;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechRecognizerStatusDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {BFF9E781-53EC-484E-BB8A-0E1B5551E35C}
  // *********************************************************************//
  ISpeechRecognizerStatusDisp = dispinterface
    ['{BFF9E781-53EC-484E-BB8A-0E1B5551E35C}']
    property AudioStatus: ISpeechAudioStatus readonly dispid 1;
    property CurrentStreamPosition: OleVariant readonly dispid 2;
    property CurrentStreamNumber: Integer readonly dispid 3;
    property NumberOfActiveRules: Integer readonly dispid 4;
    property ClsidEngine: WideString readonly dispid 5;
    property SupportedLanguages: OleVariant readonly dispid 6;
  end;

  // *********************************************************************//
  // Interface: ISpeechRecoContext
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {580AA49D-7E1E-4809-B8E2-57DA806104B8}
  // *********************************************************************//
  ISpeechRecoContext = interface(IDispatch)
    ['{580AA49D-7E1E-4809-B8E2-57DA806104B8}']
    function Get_Recognizer: ISpeechRecognizer; safecall;
    function Get_AudioInputInterferenceStatus: SpeechInterference; safecall;
    function Get_RequestedUIType: WideString; safecall;
    procedure _Set_Voice(const Voice: ISpeechVoice); safecall;
    function Get_Voice: ISpeechVoice; safecall;
    procedure Set_AllowVoiceFormatMatchingOnNextSet(pAllow: WordBool); safecall;
    function Get_AllowVoiceFormatMatchingOnNextSet: WordBool; safecall;
    procedure Set_VoicePurgeEvent(EventInterest: SpeechRecoEvents); safecall;
    function Get_VoicePurgeEvent: SpeechRecoEvents; safecall;
    procedure Set_EventInterests(EventInterest: SpeechRecoEvents); safecall;
    function Get_EventInterests: SpeechRecoEvents; safecall;
    procedure Set_CmdMaxAlternates(MaxAlternates: Integer); safecall;
    function Get_CmdMaxAlternates: Integer; safecall;
    procedure Set_State(State: SpeechRecoContextState); safecall;
    function Get_State: SpeechRecoContextState; safecall;
    procedure Set_RetainedAudio(Option: SpeechRetainedAudioOptions); safecall;
    function Get_RetainedAudio: SpeechRetainedAudioOptions; safecall;
    procedure _Set_RetainedAudioFormat(const Format
      : ISpeechAudioFormat); safecall;
    function Get_RetainedAudioFormat: ISpeechAudioFormat; safecall;
    procedure Pause; safecall;
    procedure Resume; safecall;
    function CreateGrammar(GrammarId: OleVariant): ISpeechRecoGrammar; safecall;
    function CreateResultFromMemory(const ResultBlock: OleVariant)
      : ISpeechRecoResult; safecall;
    procedure Bookmark(Options: SpeechBookmarkOptions; StreamPos: OleVariant;
      BookmarkId: OleVariant); safecall;
    procedure SetAdaptationData(const AdaptationString: WideString); safecall;
    property Recognizer: ISpeechRecognizer read Get_Recognizer;
    property AudioInputInterferenceStatus: SpeechInterference
      read Get_AudioInputInterferenceStatus;
    property RequestedUIType: WideString read Get_RequestedUIType;
    property Voice: ISpeechVoice read Get_Voice write _Set_Voice;
    property AllowVoiceFormatMatchingOnNextSet: WordBool
      read Get_AllowVoiceFormatMatchingOnNextSet
      write Set_AllowVoiceFormatMatchingOnNextSet;
    property VoicePurgeEvent: SpeechRecoEvents read Get_VoicePurgeEvent
      write Set_VoicePurgeEvent;
    property EventInterests: SpeechRecoEvents read Get_EventInterests
      write Set_EventInterests;
    property CmdMaxAlternates: Integer read Get_CmdMaxAlternates
      write Set_CmdMaxAlternates;
    property State: SpeechRecoContextState read Get_State write Set_State;
    property RetainedAudio: SpeechRetainedAudioOptions read Get_RetainedAudio
      write Set_RetainedAudio;
    property RetainedAudioFormat: ISpeechAudioFormat
      read Get_RetainedAudioFormat write _Set_RetainedAudioFormat;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechRecoContextDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {580AA49D-7E1E-4809-B8E2-57DA806104B8}
  // *********************************************************************//
  ISpeechRecoContextDisp = dispinterface
    ['{580AA49D-7E1E-4809-B8E2-57DA806104B8}']
    property Recognizer: ISpeechRecognizer readonly dispid 1;
    property AudioInputInterferenceStatus: SpeechInterference readonly dispid 2;
    property RequestedUIType: WideString readonly dispid 3;
    property Voice: ISpeechVoice dispid 4;
    property AllowVoiceFormatMatchingOnNextSet: WordBool dispid 5;
    property VoicePurgeEvent: SpeechRecoEvents dispid 6;
    property EventInterests: SpeechRecoEvents dispid 7;
    property CmdMaxAlternates: Integer dispid 8;
    property State: SpeechRecoContextState dispid 9;
    property RetainedAudio: SpeechRetainedAudioOptions dispid 10;
    property RetainedAudioFormat: ISpeechAudioFormat dispid 11;
    procedure Pause; dispid 12;
    procedure Resume; dispid 13;
    function CreateGrammar(GrammarId: OleVariant): ISpeechRecoGrammar;
      dispid 14;
    function CreateResultFromMemory(const ResultBlock: OleVariant)
      : ISpeechRecoResult; dispid 15;
    procedure Bookmark(Options: SpeechBookmarkOptions; StreamPos: OleVariant;
      BookmarkId: OleVariant); dispid 16;
    procedure SetAdaptationData(const AdaptationString: WideString); dispid 17;
  end;

  // *********************************************************************//
  // Interface: ISpeechRecoGrammar
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}
  // *********************************************************************//
  ISpeechRecoGrammar = interface(IDispatch)
    ['{B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}']
    function Get_Id: OleVariant; safecall;
    function Get_RecoContext: ISpeechRecoContext; safecall;
    procedure Set_State(State: SpeechGrammarState); safecall;
    function Get_State: SpeechGrammarState; safecall;
    function Get_Rules: ISpeechGrammarRules; safecall;
    procedure Reset(NewLanguage: Integer); safecall;
    procedure CmdLoadFromFile(const FileName: WideString;
      LoadOption: SpeechLoadOption); safecall;
    procedure CmdLoadFromObject(const ClassId: WideString;
      const GrammarName: WideString; LoadOption: SpeechLoadOption); safecall;
    procedure CmdLoadFromResource(hModule: Integer; ResourceName: OleVariant;
      ResourceType: OleVariant; LanguageId: Integer;
      LoadOption: SpeechLoadOption); safecall;
    procedure CmdLoadFromMemory(GrammarData: OleVariant;
      LoadOption: SpeechLoadOption); safecall;
    procedure CmdLoadFromProprietaryGrammar(const ProprietaryGuid: WideString;
      const ProprietaryString: WideString; ProprietaryData: OleVariant;
      LoadOption: SpeechLoadOption); safecall;
    procedure CmdSetRuleState(const Name: WideString;
      State: SpeechRuleState); safecall;
    procedure CmdSetRuleIdState(RuleId: Integer;
      State: SpeechRuleState); safecall;
    procedure DictationLoad(const TopicName: WideString;
      LoadOption: SpeechLoadOption); safecall;
    procedure DictationUnload; safecall;
    procedure DictationSetState(State: SpeechRuleState); safecall;
    procedure SetWordSequenceData(const Text: WideString; TextLength: Integer;
      const Info: ISpeechTextSelectionInformation); safecall;
    procedure SetTextSelection(const Info
      : ISpeechTextSelectionInformation); safecall;
    function IsPronounceable(const Word: WideString)
      : SpeechWordPronounceable; safecall;
    property Id: OleVariant read Get_Id;
    property RecoContext: ISpeechRecoContext read Get_RecoContext;
    property State: SpeechGrammarState read Get_State write Set_State;
    property Rules: ISpeechGrammarRules read Get_Rules;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechRecoGrammarDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}
  // *********************************************************************//
  ISpeechRecoGrammarDisp = dispinterface
    ['{B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}']
    property Id: OleVariant readonly dispid 1;
    property RecoContext: ISpeechRecoContext readonly dispid 2;
    property State: SpeechGrammarState dispid 3;
    property Rules: ISpeechGrammarRules readonly dispid 4;
    procedure Reset(NewLanguage: Integer); dispid 5;
    procedure CmdLoadFromFile(const FileName: WideString;
      LoadOption: SpeechLoadOption); dispid 7;
    procedure CmdLoadFromObject(const ClassId: WideString;
      const GrammarName: WideString; LoadOption: SpeechLoadOption); dispid 8;
    procedure CmdLoadFromResource(hModule: Integer; ResourceName: OleVariant;
      ResourceType: OleVariant; LanguageId: Integer;
      LoadOption: SpeechLoadOption); dispid 9;
    procedure CmdLoadFromMemory(GrammarData: OleVariant;
      LoadOption: SpeechLoadOption); dispid 10;
    procedure CmdLoadFromProprietaryGrammar(const ProprietaryGuid: WideString;
      const ProprietaryString: WideString; ProprietaryData: OleVariant;
      LoadOption: SpeechLoadOption); dispid 11;
    procedure CmdSetRuleState(const Name: WideString; State: SpeechRuleState);
      dispid 12;
    procedure CmdSetRuleIdState(RuleId: Integer; State: SpeechRuleState);
      dispid 13;
    procedure DictationLoad(const TopicName: WideString;
      LoadOption: SpeechLoadOption); dispid 14;
    procedure DictationUnload; dispid 15;
    procedure DictationSetState(State: SpeechRuleState); dispid 16;
    procedure SetWordSequenceData(const Text: WideString; TextLength: Integer;
      const Info: ISpeechTextSelectionInformation); dispid 17;
    procedure SetTextSelection(const Info: ISpeechTextSelectionInformation);
      dispid 18;
    function IsPronounceable(const Word: WideString): SpeechWordPronounceable;
      dispid 19;
  end;

  // *********************************************************************//
  // Interface: ISpeechGrammarRules
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}
  // *********************************************************************//
  ISpeechGrammarRules = interface(IDispatch)
    ['{6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}']
    function Get_Count: Integer; safecall;
    function FindRule(RuleNameOrId: OleVariant): ISpeechGrammarRule; safecall;
    function Item(Index: Integer): ISpeechGrammarRule; safecall;
    function Get__NewEnum: IUnknown; safecall;
    function Get_Dynamic: WordBool; safecall;
    function Add(const RuleName: WideString; Attributes: SpeechRuleAttributes;
      RuleId: Integer): ISpeechGrammarRule; safecall;
    procedure Commit; safecall;
    function CommitAndSave(out ErrorText: WideString): OleVariant; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
    property Dynamic: WordBool read Get_Dynamic;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechGrammarRulesDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}
  // *********************************************************************//
  ISpeechGrammarRulesDisp = dispinterface
    ['{6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}']
    property Count: Integer readonly dispid 1;
    function FindRule(RuleNameOrId: OleVariant): ISpeechGrammarRule; dispid 6;
    function Item(Index: Integer): ISpeechGrammarRule; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
    property Dynamic: WordBool readonly dispid 2;
    function Add(const RuleName: WideString; Attributes: SpeechRuleAttributes;
      RuleId: Integer): ISpeechGrammarRule; dispid 3;
    procedure Commit; dispid 4;
    function CommitAndSave(out ErrorText: WideString): OleVariant; dispid 5;
  end;

  // *********************************************************************//
  // Interface: ISpeechGrammarRule
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}
  // *********************************************************************//
  ISpeechGrammarRule = interface(IDispatch)
    ['{AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}']
    function Get_Attributes: SpeechRuleAttributes; safecall;
    function Get_InitialState: ISpeechGrammarRuleState; safecall;
    function Get_Name: WideString; safecall;
    function Get_Id: Integer; safecall;
    procedure Clear; safecall;
    procedure AddResource(const ResourceName: WideString;
      const ResourceValue: WideString); safecall;
    function AddState: ISpeechGrammarRuleState; safecall;
    property Attributes: SpeechRuleAttributes read Get_Attributes;
    property InitialState: ISpeechGrammarRuleState read Get_InitialState;
    property Name: WideString read Get_Name;
    property Id: Integer read Get_Id;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechGrammarRuleDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}
  // *********************************************************************//
  ISpeechGrammarRuleDisp = dispinterface
    ['{AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}']
    property Attributes: SpeechRuleAttributes readonly dispid 1;
    property InitialState: ISpeechGrammarRuleState readonly dispid 2;
    property Name: WideString readonly dispid 3;
    property Id: Integer readonly dispid 4;
    procedure Clear; dispid 5;
    procedure AddResource(const ResourceName: WideString;
      const ResourceValue: WideString); dispid 6;
    function AddState: ISpeechGrammarRuleState; dispid 7;
  end;

  // *********************************************************************//
  // Interface: ISpeechGrammarRuleState
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {D4286F2C-EE67-45AE-B928-28D695362EDA}
  // *********************************************************************//
  ISpeechGrammarRuleState = interface(IDispatch)
    ['{D4286F2C-EE67-45AE-B928-28D695362EDA}']
    function Get_Rule: ISpeechGrammarRule; safecall;
    function Get_Transitions: ISpeechGrammarRuleStateTransitions; safecall;
    procedure AddWordTransition(const DestState: ISpeechGrammarRuleState;
      const Words: WideString; const Separators: WideString;
      type_: SpeechGrammarWordType; const PropertyName: WideString;
      PropertyId: Integer; const PropertyValue: OleVariant;
      Weight: Single); safecall;
    procedure AddRuleTransition(const DestinationState: ISpeechGrammarRuleState;
      const Rule: ISpeechGrammarRule; const PropertyName: WideString;
      PropertyId: Integer; const PropertyValue: OleVariant;
      Weight: Single); safecall;
    procedure AddSpecialTransition(const DestinationState
      : ISpeechGrammarRuleState; type_: SpeechSpecialTransitionType;
      const PropertyName: WideString; PropertyId: Integer;
      const PropertyValue: OleVariant; Weight: Single); safecall;
    property Rule: ISpeechGrammarRule read Get_Rule;
    property Transitions: ISpeechGrammarRuleStateTransitions
      read Get_Transitions;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechGrammarRuleStateDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {D4286F2C-EE67-45AE-B928-28D695362EDA}
  // *********************************************************************//
  ISpeechGrammarRuleStateDisp = dispinterface
    ['{D4286F2C-EE67-45AE-B928-28D695362EDA}']
    property Rule: ISpeechGrammarRule readonly dispid 1;
    property Transitions: ISpeechGrammarRuleStateTransitions readonly dispid 2;
    procedure AddWordTransition(const DestState: ISpeechGrammarRuleState;
      const Words: WideString; const Separators: WideString;
      type_: SpeechGrammarWordType; const PropertyName: WideString;
      PropertyId: Integer; const PropertyValue: OleVariant;
      Weight: Single); dispid 3;
    procedure AddRuleTransition(const DestinationState: ISpeechGrammarRuleState;
      const Rule: ISpeechGrammarRule; const PropertyName: WideString;
      PropertyId: Integer; const PropertyValue: OleVariant;
      Weight: Single); dispid 4;
    procedure AddSpecialTransition(const DestinationState
      : ISpeechGrammarRuleState; type_: SpeechSpecialTransitionType;
      const PropertyName: WideString; PropertyId: Integer;
      const PropertyValue: OleVariant; Weight: Single); dispid 5;
  end;

  // *********************************************************************//
  // Interface: ISpeechGrammarRuleStateTransitions
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {EABCE657-75BC-44A2-AA7F-C56476742963}
  // *********************************************************************//
  ISpeechGrammarRuleStateTransitions = interface(IDispatch)
    ['{EABCE657-75BC-44A2-AA7F-C56476742963}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechGrammarRuleStateTransition; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechGrammarRuleStateTransitionsDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {EABCE657-75BC-44A2-AA7F-C56476742963}
  // *********************************************************************//
  ISpeechGrammarRuleStateTransitionsDisp = dispinterface
    ['{EABCE657-75BC-44A2-AA7F-C56476742963}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechGrammarRuleStateTransition; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechGrammarRuleStateTransition
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}
  // *********************************************************************//
  ISpeechGrammarRuleStateTransition = interface(IDispatch)
    ['{CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}']
    function Get_type_: SpeechGrammarRuleStateTransitionType; safecall;
    function Get_Text: WideString; safecall;
    function Get_Rule: ISpeechGrammarRule; safecall;
    function Get_Weight: OleVariant; safecall;
    function Get_PropertyName: WideString; safecall;
    function Get_PropertyId: Integer; safecall;
    function Get_PropertyValue: OleVariant; safecall;
    function Get_NextState: ISpeechGrammarRuleState; safecall;
    property type_: SpeechGrammarRuleStateTransitionType read Get_type_;
    property Text: WideString read Get_Text;
    property Rule: ISpeechGrammarRule read Get_Rule;
    property Weight: OleVariant read Get_Weight;
    property PropertyName: WideString read Get_PropertyName;
    property PropertyId: Integer read Get_PropertyId;
    property PropertyValue: OleVariant read Get_PropertyValue;
    property NextState: ISpeechGrammarRuleState read Get_NextState;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechGrammarRuleStateTransitionDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}
  // *********************************************************************//
  ISpeechGrammarRuleStateTransitionDisp = dispinterface
    ['{CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}']
    property type_: SpeechGrammarRuleStateTransitionType readonly dispid 1;
    property Text: WideString readonly dispid 2;
    property Rule: ISpeechGrammarRule readonly dispid 3;
    property Weight: OleVariant readonly dispid 4;
    property PropertyName: WideString readonly dispid 5;
    property PropertyId: Integer readonly dispid 6;
    property PropertyValue: OleVariant readonly dispid 7;
    property NextState: ISpeechGrammarRuleState readonly dispid 8;
  end;

  // *********************************************************************//
  // Interface: ISpeechTextSelectionInformation
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {3B9C7E7A-6EEE-4DED-9092-11657279ADBE}
  // *********************************************************************//
  ISpeechTextSelectionInformation = interface(IDispatch)
    ['{3B9C7E7A-6EEE-4DED-9092-11657279ADBE}']
    procedure Set_ActiveOffset(ActiveOffset: Integer); safecall;
    function Get_ActiveOffset: Integer; safecall;
    procedure Set_ActiveLength(ActiveLength: Integer); safecall;
    function Get_ActiveLength: Integer; safecall;
    procedure Set_SelectionOffset(SelectionOffset: Integer); safecall;
    function Get_SelectionOffset: Integer; safecall;
    procedure Set_SelectionLength(SelectionLength: Integer); safecall;
    function Get_SelectionLength: Integer; safecall;
    property ActiveOffset: Integer read Get_ActiveOffset write Set_ActiveOffset;
    property ActiveLength: Integer read Get_ActiveLength write Set_ActiveLength;
    property SelectionOffset: Integer read Get_SelectionOffset
      write Set_SelectionOffset;
    property SelectionLength: Integer read Get_SelectionLength
      write Set_SelectionLength;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechTextSelectionInformationDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {3B9C7E7A-6EEE-4DED-9092-11657279ADBE}
  // *********************************************************************//
  ISpeechTextSelectionInformationDisp = dispinterface
    ['{3B9C7E7A-6EEE-4DED-9092-11657279ADBE}']
    property ActiveOffset: Integer dispid 1;
    property ActiveLength: Integer dispid 2;
    property SelectionOffset: Integer dispid 3;
    property SelectionLength: Integer dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechRecoResult
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {ED2879CF-CED9-4EE6-A534-DE0191D5468D}
  // *********************************************************************//
  ISpeechRecoResult = interface(IDispatch)
    ['{ED2879CF-CED9-4EE6-A534-DE0191D5468D}']
    function Get_RecoContext: ISpeechRecoContext; safecall;
    function Get_Times: ISpeechRecoResultTimes; safecall;
    procedure _Set_AudioFormat(const Format: ISpeechAudioFormat); safecall;
    function Get_AudioFormat: ISpeechAudioFormat; safecall;
    function Get_PhraseInfo: ISpeechPhraseInfo; safecall;
    function Alternates(RequestCount: Integer; StartElement: Integer;
      Elements: Integer): ISpeechPhraseAlternates; safecall;
    function Audio(StartElement: Integer; Elements: Integer)
      : ISpeechMemoryStream; safecall;
    function SpeakAudio(StartElement: Integer; Elements: Integer;
      Flags: SpeechVoiceSpeakFlags): Integer; safecall;
    function SaveToMemory: OleVariant; safecall;
    procedure DiscardResultInfo(ValueTypes: SpeechDiscardType); safecall;
    property RecoContext: ISpeechRecoContext read Get_RecoContext;
    property Times: ISpeechRecoResultTimes read Get_Times;
    property AudioFormat: ISpeechAudioFormat read Get_AudioFormat
      write _Set_AudioFormat;
    property PhraseInfo: ISpeechPhraseInfo read Get_PhraseInfo;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechRecoResultDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {ED2879CF-CED9-4EE6-A534-DE0191D5468D}
  // *********************************************************************//
  ISpeechRecoResultDisp = dispinterface
    ['{ED2879CF-CED9-4EE6-A534-DE0191D5468D}']
    property RecoContext: ISpeechRecoContext readonly dispid 1;
    property Times: ISpeechRecoResultTimes readonly dispid 2;
    property AudioFormat: ISpeechAudioFormat dispid 3;
    property PhraseInfo: ISpeechPhraseInfo readonly dispid 4;
    function Alternates(RequestCount: Integer; StartElement: Integer;
      Elements: Integer): ISpeechPhraseAlternates; dispid 5;
    function Audio(StartElement: Integer; Elements: Integer)
      : ISpeechMemoryStream; dispid 6;
    function SpeakAudio(StartElement: Integer; Elements: Integer;
      Flags: SpeechVoiceSpeakFlags): Integer; dispid 7;
    function SaveToMemory: OleVariant; dispid 8;
    procedure DiscardResultInfo(ValueTypes: SpeechDiscardType); dispid 9;
  end;

  // *********************************************************************//
  // Interface: ISpeechRecoResultTimes
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}
  // *********************************************************************//
  ISpeechRecoResultTimes = interface(IDispatch)
    ['{62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}']
    function Get_StreamTime: OleVariant; safecall;
    function Get_Length: OleVariant; safecall;
    function Get_TickCount: Integer; safecall;
    function Get_OffsetFromStart: OleVariant; safecall;
    property StreamTime: OleVariant read Get_StreamTime;
    property Length: OleVariant read Get_Length;
    property TickCount: Integer read Get_TickCount;
    property OffsetFromStart: OleVariant read Get_OffsetFromStart;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechRecoResultTimesDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}
  // *********************************************************************//
  ISpeechRecoResultTimesDisp = dispinterface
    ['{62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}']
    property StreamTime: OleVariant readonly dispid 1;
    property Length: OleVariant readonly dispid 2;
    property TickCount: Integer readonly dispid 3;
    property OffsetFromStart: OleVariant readonly dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseInfo
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {961559CF-4E67-4662-8BF0-D93F1FCD61B3}
  // *********************************************************************//
  ISpeechPhraseInfo = interface(IDispatch)
    ['{961559CF-4E67-4662-8BF0-D93F1FCD61B3}']
    function Get_LanguageId: Integer; safecall;
    function Get_GrammarId: OleVariant; safecall;
    function Get_StartTime: OleVariant; safecall;
    function Get_AudioStreamPosition: OleVariant; safecall;
    function Get_AudioSizeBytes: Integer; safecall;
    function Get_RetainedSizeBytes: Integer; safecall;
    function Get_AudioSizeTime: Integer; safecall;
    function Get_Rule: ISpeechPhraseRule; safecall;
    function Get_Properties: ISpeechPhraseProperties; safecall;
    function Get_Elements: ISpeechPhraseElements; safecall;
    function Get_Replacements: ISpeechPhraseReplacements; safecall;
    function Get_EngineId: WideString; safecall;
    function Get_EnginePrivateData: OleVariant; safecall;
    function SaveToMemory: OleVariant; safecall;
    function GetText(StartElement: Integer; Elements: Integer;
      UseReplacements: WordBool): WideString; safecall;
    function GetDisplayAttributes(StartElement: Integer; Elements: Integer;
      UseReplacements: WordBool): SpeechDisplayAttributes; safecall;
    property LanguageId: Integer read Get_LanguageId;
    property GrammarId: OleVariant read Get_GrammarId;
    property StartTime: OleVariant read Get_StartTime;
    property AudioStreamPosition: OleVariant read Get_AudioStreamPosition;
    property AudioSizeBytes: Integer read Get_AudioSizeBytes;
    property RetainedSizeBytes: Integer read Get_RetainedSizeBytes;
    property AudioSizeTime: Integer read Get_AudioSizeTime;
    property Rule: ISpeechPhraseRule read Get_Rule;
    property Properties: ISpeechPhraseProperties read Get_Properties;
    property Elements: ISpeechPhraseElements read Get_Elements;
    property Replacements: ISpeechPhraseReplacements read Get_Replacements;
    property EngineId: WideString read Get_EngineId;
    property EnginePrivateData: OleVariant read Get_EnginePrivateData;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseInfoDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {961559CF-4E67-4662-8BF0-D93F1FCD61B3}
  // *********************************************************************//
  ISpeechPhraseInfoDisp = dispinterface
    ['{961559CF-4E67-4662-8BF0-D93F1FCD61B3}']
    property LanguageId: Integer readonly dispid 1;
    property GrammarId: OleVariant readonly dispid 2;
    property StartTime: OleVariant readonly dispid 3;
    property AudioStreamPosition: OleVariant readonly dispid 4;
    property AudioSizeBytes: Integer readonly dispid 5;
    property RetainedSizeBytes: Integer readonly dispid 6;
    property AudioSizeTime: Integer readonly dispid 7;
    property Rule: ISpeechPhraseRule readonly dispid 8;
    property Properties: ISpeechPhraseProperties readonly dispid 9;
    property Elements: ISpeechPhraseElements readonly dispid 10;
    property Replacements: ISpeechPhraseReplacements readonly dispid 11;
    property EngineId: WideString readonly dispid 12;
    property EnginePrivateData: OleVariant readonly dispid 13;
    function SaveToMemory: OleVariant; dispid 14;
    function GetText(StartElement: Integer; Elements: Integer;
      UseReplacements: WordBool): WideString; dispid 15;
    function GetDisplayAttributes(StartElement: Integer; Elements: Integer;
      UseReplacements: WordBool): SpeechDisplayAttributes; dispid 16;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseRule
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {A7BFE112-A4A0-48D9-B602-C313843F6964}
  // *********************************************************************//
  ISpeechPhraseRule = interface(IDispatch)
    ['{A7BFE112-A4A0-48D9-B602-C313843F6964}']
    function Get_Name: WideString; safecall;
    function Get_Id: Integer; safecall;
    function Get_FirstElement: Integer; safecall;
    function Get_NumberOfElements: Integer; safecall;
    function Get_Parent: ISpeechPhraseRule; safecall;
    function Get_Children: ISpeechPhraseRules; safecall;
    function Get_Confidence: SpeechEngineConfidence; safecall;
    function Get_EngineConfidence: Single; safecall;
    property Name: WideString read Get_Name;
    property Id: Integer read Get_Id;
    property FirstElement: Integer read Get_FirstElement;
    property NumberOfElements: Integer read Get_NumberOfElements;
    property Parent: ISpeechPhraseRule read Get_Parent;
    property Children: ISpeechPhraseRules read Get_Children;
    property Confidence: SpeechEngineConfidence read Get_Confidence;
    property EngineConfidence: Single read Get_EngineConfidence;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseRuleDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {A7BFE112-A4A0-48D9-B602-C313843F6964}
  // *********************************************************************//
  ISpeechPhraseRuleDisp = dispinterface
    ['{A7BFE112-A4A0-48D9-B602-C313843F6964}']
    property Name: WideString readonly dispid 1;
    property Id: Integer readonly dispid 2;
    property FirstElement: Integer readonly dispid 3;
    property NumberOfElements: Integer readonly dispid 4;
    property Parent: ISpeechPhraseRule readonly dispid 5;
    property Children: ISpeechPhraseRules readonly dispid 6;
    property Confidence: SpeechEngineConfidence readonly dispid 7;
    property EngineConfidence: Single readonly dispid 8;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseRules
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {9047D593-01DD-4B72-81A3-E4A0CA69F407}
  // *********************************************************************//
  ISpeechPhraseRules = interface(IDispatch)
    ['{9047D593-01DD-4B72-81A3-E4A0CA69F407}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechPhraseRule; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseRulesDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {9047D593-01DD-4B72-81A3-E4A0CA69F407}
  // *********************************************************************//
  ISpeechPhraseRulesDisp = dispinterface
    ['{9047D593-01DD-4B72-81A3-E4A0CA69F407}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechPhraseRule; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseProperties
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {08166B47-102E-4B23-A599-BDB98DBFD1F4}
  // *********************************************************************//
  ISpeechPhraseProperties = interface(IDispatch)
    ['{08166B47-102E-4B23-A599-BDB98DBFD1F4}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechPhraseProperty; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhrasePropertiesDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {08166B47-102E-4B23-A599-BDB98DBFD1F4}
  // *********************************************************************//
  ISpeechPhrasePropertiesDisp = dispinterface
    ['{08166B47-102E-4B23-A599-BDB98DBFD1F4}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechPhraseProperty; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseProperty
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CE563D48-961E-4732-A2E1-378A42B430BE}
  // *********************************************************************//
  ISpeechPhraseProperty = interface(IDispatch)
    ['{CE563D48-961E-4732-A2E1-378A42B430BE}']
    function Get_Name: WideString; safecall;
    function Get_Id: Integer; safecall;
    function Get_Value: OleVariant; safecall;
    function Get_FirstElement: Integer; safecall;
    function Get_NumberOfElements: Integer; safecall;
    function Get_EngineConfidence: Single; safecall;
    function Get_Confidence: SpeechEngineConfidence; safecall;
    function Get_Parent: ISpeechPhraseProperty; safecall;
    function Get_Children: ISpeechPhraseProperties; safecall;
    property Name: WideString read Get_Name;
    property Id: Integer read Get_Id;
    property Value: OleVariant read Get_Value;
    property FirstElement: Integer read Get_FirstElement;
    property NumberOfElements: Integer read Get_NumberOfElements;
    property EngineConfidence: Single read Get_EngineConfidence;
    property Confidence: SpeechEngineConfidence read Get_Confidence;
    property Parent: ISpeechPhraseProperty read Get_Parent;
    property Children: ISpeechPhraseProperties read Get_Children;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhrasePropertyDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {CE563D48-961E-4732-A2E1-378A42B430BE}
  // *********************************************************************//
  ISpeechPhrasePropertyDisp = dispinterface
    ['{CE563D48-961E-4732-A2E1-378A42B430BE}']
    property Name: WideString readonly dispid 1;
    property Id: Integer readonly dispid 2;
    property Value: OleVariant readonly dispid 3;
    property FirstElement: Integer readonly dispid 4;
    property NumberOfElements: Integer readonly dispid 5;
    property EngineConfidence: Single readonly dispid 6;
    property Confidence: SpeechEngineConfidence readonly dispid 7;
    property Parent: ISpeechPhraseProperty readonly dispid 8;
    property Children: ISpeechPhraseProperties readonly dispid 9;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseElements
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {0626B328-3478-467D-A0B3-D0853B93DDA3}
  // *********************************************************************//
  ISpeechPhraseElements = interface(IDispatch)
    ['{0626B328-3478-467D-A0B3-D0853B93DDA3}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechPhraseElement; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseElementsDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {0626B328-3478-467D-A0B3-D0853B93DDA3}
  // *********************************************************************//
  ISpeechPhraseElementsDisp = dispinterface
    ['{0626B328-3478-467D-A0B3-D0853B93DDA3}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechPhraseElement; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseElement
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {E6176F96-E373-4801-B223-3B62C068C0B4}
  // *********************************************************************//
  ISpeechPhraseElement = interface(IDispatch)
    ['{E6176F96-E373-4801-B223-3B62C068C0B4}']
    function Get_AudioTimeOffset: Integer; safecall;
    function Get_AudioSizeTime: Integer; safecall;
    function Get_AudioStreamOffset: Integer; safecall;
    function Get_AudioSizeBytes: Integer; safecall;
    function Get_RetainedStreamOffset: Integer; safecall;
    function Get_RetainedSizeBytes: Integer; safecall;
    function Get_DisplayText: WideString; safecall;
    function Get_LexicalForm: WideString; safecall;
    function Get_Pronunciation: OleVariant; safecall;
    function Get_DisplayAttributes: SpeechDisplayAttributes; safecall;
    function Get_RequiredConfidence: SpeechEngineConfidence; safecall;
    function Get_ActualConfidence: SpeechEngineConfidence; safecall;
    function Get_EngineConfidence: Single; safecall;
    property AudioTimeOffset: Integer read Get_AudioTimeOffset;
    property AudioSizeTime: Integer read Get_AudioSizeTime;
    property AudioStreamOffset: Integer read Get_AudioStreamOffset;
    property AudioSizeBytes: Integer read Get_AudioSizeBytes;
    property RetainedStreamOffset: Integer read Get_RetainedStreamOffset;
    property RetainedSizeBytes: Integer read Get_RetainedSizeBytes;
    property DisplayText: WideString read Get_DisplayText;
    property LexicalForm: WideString read Get_LexicalForm;
    property Pronunciation: OleVariant read Get_Pronunciation;
    property DisplayAttributes: SpeechDisplayAttributes
      read Get_DisplayAttributes;
    property RequiredConfidence: SpeechEngineConfidence
      read Get_RequiredConfidence;
    property ActualConfidence: SpeechEngineConfidence read Get_ActualConfidence;
    property EngineConfidence: Single read Get_EngineConfidence;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseElementDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {E6176F96-E373-4801-B223-3B62C068C0B4}
  // *********************************************************************//
  ISpeechPhraseElementDisp = dispinterface
    ['{E6176F96-E373-4801-B223-3B62C068C0B4}']
    property AudioTimeOffset: Integer readonly dispid 1;
    property AudioSizeTime: Integer readonly dispid 2;
    property AudioStreamOffset: Integer readonly dispid 3;
    property AudioSizeBytes: Integer readonly dispid 4;
    property RetainedStreamOffset: Integer readonly dispid 5;
    property RetainedSizeBytes: Integer readonly dispid 6;
    property DisplayText: WideString readonly dispid 7;
    property LexicalForm: WideString readonly dispid 8;
    property Pronunciation: OleVariant readonly dispid 9;
    property DisplayAttributes: SpeechDisplayAttributes readonly dispid 10;
    property RequiredConfidence: SpeechEngineConfidence readonly dispid 11;
    property ActualConfidence: SpeechEngineConfidence readonly dispid 12;
    property EngineConfidence: Single readonly dispid 13;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseReplacements
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {38BC662F-2257-4525-959E-2069D2596C05}
  // *********************************************************************//
  ISpeechPhraseReplacements = interface(IDispatch)
    ['{38BC662F-2257-4525-959E-2069D2596C05}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechPhraseReplacement; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseReplacementsDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {38BC662F-2257-4525-959E-2069D2596C05}
  // *********************************************************************//
  ISpeechPhraseReplacementsDisp = dispinterface
    ['{38BC662F-2257-4525-959E-2069D2596C05}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechPhraseReplacement; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseReplacement
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {2890A410-53A7-4FB5-94EC-06D4998E3D02}
  // *********************************************************************//
  ISpeechPhraseReplacement = interface(IDispatch)
    ['{2890A410-53A7-4FB5-94EC-06D4998E3D02}']
    function Get_DisplayAttributes: SpeechDisplayAttributes; safecall;
    function Get_Text: WideString; safecall;
    function Get_FirstElement: Integer; safecall;
    function Get_NumberOfElements: Integer; safecall;
    property DisplayAttributes: SpeechDisplayAttributes
      read Get_DisplayAttributes;
    property Text: WideString read Get_Text;
    property FirstElement: Integer read Get_FirstElement;
    property NumberOfElements: Integer read Get_NumberOfElements;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseReplacementDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {2890A410-53A7-4FB5-94EC-06D4998E3D02}
  // *********************************************************************//
  ISpeechPhraseReplacementDisp = dispinterface
    ['{2890A410-53A7-4FB5-94EC-06D4998E3D02}']
    property DisplayAttributes: SpeechDisplayAttributes readonly dispid 1;
    property Text: WideString readonly dispid 2;
    property FirstElement: Integer readonly dispid 3;
    property NumberOfElements: Integer readonly dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseAlternates
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {B238B6D5-F276-4C3D-A6C1-2974801C3CC2}
  // *********************************************************************//
  ISpeechPhraseAlternates = interface(IDispatch)
    ['{B238B6D5-F276-4C3D-A6C1-2974801C3CC2}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechPhraseAlternate; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseAlternatesDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {B238B6D5-F276-4C3D-A6C1-2974801C3CC2}
  // *********************************************************************//
  ISpeechPhraseAlternatesDisp = dispinterface
    ['{B238B6D5-F276-4C3D-A6C1-2974801C3CC2}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechPhraseAlternate; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseAlternate
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}
  // *********************************************************************//
  ISpeechPhraseAlternate = interface(IDispatch)
    ['{27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}']
    function Get_RecoResult: ISpeechRecoResult; safecall;
    function Get_StartElementInResult: Integer; safecall;
    function Get_NumberOfElementsInResult: Integer; safecall;
    function Get_PhraseInfo: ISpeechPhraseInfo; safecall;
    procedure Commit; safecall;
    property RecoResult: ISpeechRecoResult read Get_RecoResult;
    property StartElementInResult: Integer read Get_StartElementInResult;
    property NumberOfElementsInResult: Integer
      read Get_NumberOfElementsInResult;
    property PhraseInfo: ISpeechPhraseInfo read Get_PhraseInfo;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseAlternateDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}
  // *********************************************************************//
  ISpeechPhraseAlternateDisp = dispinterface
    ['{27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}']
    property RecoResult: ISpeechRecoResult readonly dispid 1;
    property StartElementInResult: Integer readonly dispid 2;
    property NumberOfElementsInResult: Integer readonly dispid 3;
    property PhraseInfo: ISpeechPhraseInfo readonly dispid 4;
    procedure Commit; dispid 5;
  end;

  // *********************************************************************//
  // DispIntf:  _ISpeechRecoContextEvents
  // Flags:     (4096) Dispatchable
  // GUID:      {7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}
  // *********************************************************************//
  _ISpeechRecoContextEvents = dispinterface
    ['{7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}']
    procedure StartStream(StreamNumber: Integer;
      StreamPosition: OleVariant); dispid 1;
    procedure EndStream(StreamNumber: Integer; StreamPosition: OleVariant;
      StreamReleased: WordBool); dispid 2;
    procedure Bookmark(StreamNumber: Integer; StreamPosition: OleVariant;
      BookmarkId: OleVariant; Options: SpeechBookmarkOptions); dispid 3;
    procedure SoundStart(StreamNumber: Integer;
      StreamPosition: OleVariant); dispid 4;
    procedure SoundEnd(StreamNumber: Integer;
      StreamPosition: OleVariant); dispid 5;
    procedure PhraseStart(StreamNumber: Integer;
      StreamPosition: OleVariant); dispid 6;
    procedure Recognition(StreamNumber: Integer; StreamPosition: OleVariant;
      RecognitionType: SpeechRecognitionType;
      const Result: ISpeechRecoResult); dispid 7;
    procedure Hypothesis(StreamNumber: Integer; StreamPosition: OleVariant;
      const Result: ISpeechRecoResult); dispid 8;
    procedure PropertyNumberChange(StreamNumber: Integer;
      StreamPosition: OleVariant; const PropertyName: WideString;
      NewNumberValue: Integer); dispid 9;
    procedure PropertyStringChange(StreamNumber: Integer;
      StreamPosition: OleVariant; const PropertyName: WideString;
      const NewStringValue: WideString); dispid 10;
    procedure FalseRecognition(StreamNumber: Integer;
      StreamPosition: OleVariant; const Result: ISpeechRecoResult); dispid 11;
    procedure Interference(StreamNumber: Integer; StreamPosition: OleVariant;
      Interference: SpeechInterference); dispid 12;
    procedure RequestUI(StreamNumber: Integer; StreamPosition: OleVariant;
      const UIType: WideString); dispid 13;
    procedure RecognizerStateChange(StreamNumber: Integer;
      StreamPosition: OleVariant; NewState: SpeechRecognizerState); dispid 14;
    procedure Adaptation(StreamNumber: Integer; StreamPosition: OleVariant);
      dispid 15;
    procedure RecognitionForOtherContext(StreamNumber: Integer;
      StreamPosition: OleVariant); dispid 16;
    procedure AudioLevel(StreamNumber: Integer; StreamPosition: OleVariant;
      AudioLevel: Integer); dispid 17;
    procedure EnginePrivate(StreamNumber: Integer; StreamPosition: OleVariant;
      EngineData: OleVariant); dispid 18;
  end;

  // *********************************************************************//
  // Interface: ISpeechRecoResult2
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {8E0A246D-D3C8-45DE-8657-04290C458C3C}
  // *********************************************************************//
  ISpeechRecoResult2 = interface(ISpeechRecoResult)
    ['{8E0A246D-D3C8-45DE-8657-04290C458C3C}']
    procedure SetTextFeedback(const Feedback: WideString;
      WasSuccessful: WordBool); safecall;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechRecoResult2Disp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {8E0A246D-D3C8-45DE-8657-04290C458C3C}
  // *********************************************************************//
  ISpeechRecoResult2Disp = dispinterface
    ['{8E0A246D-D3C8-45DE-8657-04290C458C3C}']
    procedure SetTextFeedback(const Feedback: WideString;
      WasSuccessful: WordBool); dispid 12;
    property RecoContext: ISpeechRecoContext readonly dispid 1;
    property Times: ISpeechRecoResultTimes readonly dispid 2;
    property AudioFormat: ISpeechAudioFormat dispid 3;
    property PhraseInfo: ISpeechPhraseInfo readonly dispid 4;
    function Alternates(RequestCount: Integer; StartElement: Integer;
      Elements: Integer): ISpeechPhraseAlternates; dispid 5;
    function Audio(StartElement: Integer; Elements: Integer)
      : ISpeechMemoryStream; dispid 6;
    function SpeakAudio(StartElement: Integer; Elements: Integer;
      Flags: SpeechVoiceSpeakFlags): Integer; dispid 7;
    function SaveToMemory: OleVariant; dispid 8;
    procedure DiscardResultInfo(ValueTypes: SpeechDiscardType); dispid 9;
  end;

  // *********************************************************************//
  // Interface: ISpeechLexicon
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {3DA7627A-C7AE-4B23-8708-638C50362C25}
  // *********************************************************************//
  ISpeechLexicon = interface(IDispatch)
    ['{3DA7627A-C7AE-4B23-8708-638C50362C25}']
    function Get_GenerationId: Integer; safecall;
    function GetWords(Flags: SpeechLexiconType; out GenerationId: Integer)
      : ISpeechLexiconWords; safecall;
    procedure AddPronunciation(const bstrWord: WideString; LangId: Integer;
      PartOfSpeech: SpeechPartOfSpeech;
      const bstrPronunciation: WideString); safecall;
    procedure AddPronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
      const PhoneIds: OleVariant); safecall;
    procedure RemovePronunciation(const bstrWord: WideString; LangId: Integer;
      PartOfSpeech: SpeechPartOfSpeech;
      const bstrPronunciation: WideString); safecall;
    procedure RemovePronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
      const PhoneIds: OleVariant); safecall;
    function GetPronunciations(const bstrWord: WideString; LangId: Integer;
      TypeFlags: SpeechLexiconType): ISpeechLexiconPronunciations; safecall;
    function GetGenerationChange(var GenerationId: Integer)
      : ISpeechLexiconWords; safecall;
    property GenerationId: Integer read Get_GenerationId;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechLexiconDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {3DA7627A-C7AE-4B23-8708-638C50362C25}
  // *********************************************************************//
  ISpeechLexiconDisp = dispinterface
    ['{3DA7627A-C7AE-4B23-8708-638C50362C25}']
    property GenerationId: Integer readonly dispid 1;
    function GetWords(Flags: SpeechLexiconType; out GenerationId: Integer)
      : ISpeechLexiconWords; dispid 2;
    procedure AddPronunciation(const bstrWord: WideString; LangId: Integer;
      PartOfSpeech: SpeechPartOfSpeech;
      const bstrPronunciation: WideString); dispid 3;
    procedure AddPronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
      const PhoneIds: OleVariant); dispid 4;
    procedure RemovePronunciation(const bstrWord: WideString; LangId: Integer;
      PartOfSpeech: SpeechPartOfSpeech;
      const bstrPronunciation: WideString); dispid 5;
    procedure RemovePronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
      const PhoneIds: OleVariant); dispid 6;
    function GetPronunciations(const bstrWord: WideString; LangId: Integer;
      TypeFlags: SpeechLexiconType): ISpeechLexiconPronunciations; dispid 7;
    function GetGenerationChange(var GenerationId: Integer)
      : ISpeechLexiconWords; dispid 8;
  end;

  // *********************************************************************//
  // Interface: ISpeechLexiconWords
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {8D199862-415E-47D5-AC4F-FAA608B424E6}
  // *********************************************************************//
  ISpeechLexiconWords = interface(IDispatch)
    ['{8D199862-415E-47D5-AC4F-FAA608B424E6}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechLexiconWord; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechLexiconWordsDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {8D199862-415E-47D5-AC4F-FAA608B424E6}
  // *********************************************************************//
  ISpeechLexiconWordsDisp = dispinterface
    ['{8D199862-415E-47D5-AC4F-FAA608B424E6}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechLexiconWord; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechLexiconWord
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}
  // *********************************************************************//
  ISpeechLexiconWord = interface(IDispatch)
    ['{4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}']
    function Get_LangId: Integer; safecall;
    function Get_type_: SpeechWordType; safecall;
    function Get_Word: WideString; safecall;
    function Get_Pronunciations: ISpeechLexiconPronunciations; safecall;
    property LangId: Integer read Get_LangId;
    property type_: SpeechWordType read Get_type_;
    property Word: WideString read Get_Word;
    property Pronunciations: ISpeechLexiconPronunciations
      read Get_Pronunciations;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechLexiconWordDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}
  // *********************************************************************//
  ISpeechLexiconWordDisp = dispinterface
    ['{4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}']
    property LangId: Integer readonly dispid 1;
    property type_: SpeechWordType readonly dispid 2;
    property Word: WideString readonly dispid 3;
    property Pronunciations: ISpeechLexiconPronunciations readonly dispid 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechLexiconPronunciations
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {72829128-5682-4704-A0D4-3E2BB6F2EAD3}
  // *********************************************************************//
  ISpeechLexiconPronunciations = interface(IDispatch)
    ['{72829128-5682-4704-A0D4-3E2BB6F2EAD3}']
    function Get_Count: Integer; safecall;
    function Item(Index: Integer): ISpeechLexiconPronunciation; safecall;
    function Get__NewEnum: IUnknown; safecall;
    property Count: Integer read Get_Count;
    property _NewEnum: IUnknown read Get__NewEnum;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechLexiconPronunciationsDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {72829128-5682-4704-A0D4-3E2BB6F2EAD3}
  // *********************************************************************//
  ISpeechLexiconPronunciationsDisp = dispinterface
    ['{72829128-5682-4704-A0D4-3E2BB6F2EAD3}']
    property Count: Integer readonly dispid 1;
    function Item(Index: Integer): ISpeechLexiconPronunciation; dispid 0;
    property _NewEnum: IUnknown readonly dispid - 4;
  end;

  // *********************************************************************//
  // Interface: ISpeechLexiconPronunciation
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {95252C5D-9E43-4F4A-9899-48EE73352F9F}
  // *********************************************************************//
  ISpeechLexiconPronunciation = interface(IDispatch)
    ['{95252C5D-9E43-4F4A-9899-48EE73352F9F}']
    function Get_type_: SpeechLexiconType; safecall;
    function Get_LangId: Integer; safecall;
    function Get_PartOfSpeech: SpeechPartOfSpeech; safecall;
    function Get_PhoneIds: OleVariant; safecall;
    function Get_Symbolic: WideString; safecall;
    property type_: SpeechLexiconType read Get_type_;
    property LangId: Integer read Get_LangId;
    property PartOfSpeech: SpeechPartOfSpeech read Get_PartOfSpeech;
    property PhoneIds: OleVariant read Get_PhoneIds;
    property Symbolic: WideString read Get_Symbolic;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechLexiconPronunciationDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {95252C5D-9E43-4F4A-9899-48EE73352F9F}
  // *********************************************************************//
  ISpeechLexiconPronunciationDisp = dispinterface
    ['{95252C5D-9E43-4F4A-9899-48EE73352F9F}']
    property type_: SpeechLexiconType readonly dispid 1;
    property LangId: Integer readonly dispid 2;
    property PartOfSpeech: SpeechPartOfSpeech readonly dispid 3;
    property PhoneIds: OleVariant readonly dispid 4;
    property Symbolic: WideString readonly dispid 5;
  end;

  // *********************************************************************//
  // Interface: ISpeechXMLRecoResult
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {AAEC54AF-8F85-4924-944D-B79D39D72E19}
  // *********************************************************************//
  ISpeechXMLRecoResult = interface(ISpeechRecoResult)
    ['{AAEC54AF-8F85-4924-944D-B79D39D72E19}']
    function GetXMLResult(Options: SPXMLRESULTOPTIONS): WideString; safecall;
    function GetXMLErrorInfo(out LineNumber: Integer;
      out ScriptLine: WideString; out Source: WideString;
      out Description: WideString; out ResultCode: Integer): WordBool; safecall;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechXMLRecoResultDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {AAEC54AF-8F85-4924-944D-B79D39D72E19}
  // *********************************************************************//
  ISpeechXMLRecoResultDisp = dispinterface
    ['{AAEC54AF-8F85-4924-944D-B79D39D72E19}']
    function GetXMLResult(Options: SPXMLRESULTOPTIONS): WideString; dispid 10;
    function GetXMLErrorInfo(out LineNumber: Integer;
      out ScriptLine: WideString; out Source: WideString;
      out Description: WideString; out ResultCode: Integer): WordBool;
      dispid 11;
    property RecoContext: ISpeechRecoContext readonly dispid 1;
    property Times: ISpeechRecoResultTimes readonly dispid 2;
    property AudioFormat: ISpeechAudioFormat dispid 3;
    property PhraseInfo: ISpeechPhraseInfo readonly dispid 4;
    function Alternates(RequestCount: Integer; StartElement: Integer;
      Elements: Integer): ISpeechPhraseAlternates; dispid 5;
    function Audio(StartElement: Integer; Elements: Integer)
      : ISpeechMemoryStream; dispid 6;
    function SpeakAudio(StartElement: Integer; Elements: Integer;
      Flags: SpeechVoiceSpeakFlags): Integer; dispid 7;
    function SaveToMemory: OleVariant; dispid 8;
    procedure DiscardResultInfo(ValueTypes: SpeechDiscardType); dispid 9;
  end;

  // *********************************************************************//
  // Interface: ISpeechRecoResultDispatch
  // Flags:     (4432) Hidden Dual OleAutomation Dispatchable
  // GUID:      {6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}
  // *********************************************************************//
  ISpeechRecoResultDispatch = interface(IDispatch)
    ['{6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}']
    function Get_RecoContext: ISpeechRecoContext; safecall;
    function Get_Times: ISpeechRecoResultTimes; safecall;
    procedure _Set_AudioFormat(const Format: ISpeechAudioFormat); safecall;
    function Get_AudioFormat: ISpeechAudioFormat; safecall;
    function Get_PhraseInfo: ISpeechPhraseInfo; safecall;
    function Alternates(RequestCount: Integer; StartElement: Integer;
      Elements: Integer): ISpeechPhraseAlternates; safecall;
    function Audio(StartElement: Integer; Elements: Integer)
      : ISpeechMemoryStream; safecall;
    function SpeakAudio(StartElement: Integer; Elements: Integer;
      Flags: SpeechVoiceSpeakFlags): Integer; safecall;
    function SaveToMemory: OleVariant; safecall;
    procedure DiscardResultInfo(ValueTypes: SpeechDiscardType); safecall;
    function GetXMLResult(Options: SPXMLRESULTOPTIONS): WideString; safecall;
    function GetXMLErrorInfo(out LineNumber: Integer;
      out ScriptLine: WideString; out Source: WideString;
      out Description: WideString; out ResultCode: HResult): WordBool; safecall;
    procedure SetTextFeedback(const Feedback: WideString;
      WasSuccessful: WordBool); safecall;
    property RecoContext: ISpeechRecoContext read Get_RecoContext;
    property Times: ISpeechRecoResultTimes read Get_Times;
    property AudioFormat: ISpeechAudioFormat read Get_AudioFormat
      write _Set_AudioFormat;
    property PhraseInfo: ISpeechPhraseInfo read Get_PhraseInfo;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechRecoResultDispatchDisp
  // Flags:     (4432) Hidden Dual OleAutomation Dispatchable
  // GUID:      {6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}
  // *********************************************************************//
  ISpeechRecoResultDispatchDisp = dispinterface
    ['{6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}']
    property RecoContext: ISpeechRecoContext readonly dispid 1;
    property Times: ISpeechRecoResultTimes readonly dispid 2;
    property AudioFormat: ISpeechAudioFormat dispid 3;
    property PhraseInfo: ISpeechPhraseInfo readonly dispid 4;
    function Alternates(RequestCount: Integer; StartElement: Integer;
      Elements: Integer): ISpeechPhraseAlternates; dispid 5;
    function Audio(StartElement: Integer; Elements: Integer)
      : ISpeechMemoryStream; dispid 6;
    function SpeakAudio(StartElement: Integer; Elements: Integer;
      Flags: SpeechVoiceSpeakFlags): Integer; dispid 7;
    function SaveToMemory: OleVariant; dispid 8;
    procedure DiscardResultInfo(ValueTypes: SpeechDiscardType); dispid 9;
    function GetXMLResult(Options: SPXMLRESULTOPTIONS): WideString; dispid 10;
    function GetXMLErrorInfo(out LineNumber: Integer;
      out ScriptLine: WideString; out Source: WideString;
      out Description: WideString; out ResultCode: HResult): WordBool;
      dispid 11;
    procedure SetTextFeedback(const Feedback: WideString;
      WasSuccessful: WordBool); dispid 12;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhraseInfoBuilder
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {3B151836-DF3A-4E0A-846C-D2ADC9334333}
  // *********************************************************************//
  ISpeechPhraseInfoBuilder = interface(IDispatch)
    ['{3B151836-DF3A-4E0A-846C-D2ADC9334333}']
    function RestorePhraseFromMemory(const PhraseInMemory: OleVariant)
      : ISpeechPhraseInfo; safecall;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhraseInfoBuilderDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {3B151836-DF3A-4E0A-846C-D2ADC9334333}
  // *********************************************************************//
  ISpeechPhraseInfoBuilderDisp = dispinterface
    ['{3B151836-DF3A-4E0A-846C-D2ADC9334333}']
    function RestorePhraseFromMemory(const PhraseInMemory: OleVariant)
      : ISpeechPhraseInfo; dispid 1;
  end;

  // *********************************************************************//
  // Interface: ISpeechPhoneConverter
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {C3E4F353-433F-43D6-89A1-6A62A7054C3D}
  // *********************************************************************//
  ISpeechPhoneConverter = interface(IDispatch)
    ['{C3E4F353-433F-43D6-89A1-6A62A7054C3D}']
    function Get_LanguageId: Integer; safecall;
    procedure Set_LanguageId(LanguageId: Integer); safecall;
    function PhoneToId(const Phonemes: WideString): OleVariant; safecall;
    function IdToPhone(IdArray: OleVariant): WideString; safecall;
    property LanguageId: Integer read Get_LanguageId write Set_LanguageId;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechPhoneConverterDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {C3E4F353-433F-43D6-89A1-6A62A7054C3D}
  // *********************************************************************//
  ISpeechPhoneConverterDisp = dispinterface
    ['{C3E4F353-433F-43D6-89A1-6A62A7054C3D}']
    property LanguageId: Integer dispid 1;
    function PhoneToId(const Phonemes: WideString): OleVariant; dispid 2;
    function IdToPhone(IdArray: OleVariant): WideString; dispid 3;
  end;

  // *********************************************************************//
  // Interface: ISpNotifySink
  // Flags:     (512) Restricted
  // GUID:      {259684DC-37C3-11D2-9603-00C04F8EE628}
  // *********************************************************************//
  ISpNotifySink = interface(IUnknown)
    ['{259684DC-37C3-11D2-9603-00C04F8EE628}']
    function Notify: HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpNotifyTranslator
  // Flags:     (512) Restricted
  // GUID:      {ACA16614-5D3D-11D2-960E-00C04F8EE628}
  // *********************************************************************//
  ISpNotifyTranslator = interface(ISpNotifySink)
    ['{ACA16614-5D3D-11D2-960E-00C04F8EE628}']
    function InitWindowMessage(var hWnd: _RemotableHandle; Msg: SYSUINT;
      wParam: UINT_PTR; lParam: LONG_PTR): HResult; stdcall;
    function InitCallback(pfnCallback: PPPrivateAlias1; wParam: UINT_PTR;
      lParam: LONG_PTR): HResult; stdcall;
    function InitSpNotifyCallback(pSpCallback: PPPrivateAlias1;
      wParam: UINT_PTR; lParam: LONG_PTR): HResult; stdcall;
    function InitWin32Event(hEvent: Pointer; fCloseHandleOnRelease: Integer)
      : HResult; stdcall;
    function Wait(dwMilliseconds: LongWord): HResult; stdcall;
    function GetEventHandle: Pointer; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpDataKey
  // Flags:     (512) Restricted
  // GUID:      {14056581-E16C-11D2-BB90-00C04F8EE6C0}
  // *********************************************************************//
  ISpDataKey = interface(IUnknown)
    ['{14056581-E16C-11D2-BB90-00C04F8EE6C0}']
    function SetData(pszValueName: PWideChar; cbData: LongWord; var pData: Byte)
      : HResult; stdcall;
    function GetData(pszValueName: PWideChar; var pcbData: LongWord;
      out pData: Byte): HResult; stdcall;
    function SetStringValue(pszValueName: PWideChar; pszValue: PWideChar)
      : HResult; stdcall;
    function GetStringValue(pszValueName: PWideChar; out ppszValue: PWideChar)
      : HResult; stdcall;
    function SetDWORD(pszValueName: PWideChar; dwValue: LongWord)
      : HResult; stdcall;
    function GetDWORD(pszValueName: PWideChar; out pdwValue: LongWord)
      : HResult; stdcall;
    function OpenKey(pszSubKeyName: PWideChar; out ppSubKey: ISpDataKey)
      : HResult; stdcall;
    function CreateKey(pszSubKey: PWideChar; out ppSubKey: ISpDataKey)
      : HResult; stdcall;
    function DeleteKey(pszSubKey: PWideChar): HResult; stdcall;
    function DeleteValue(pszValueName: PWideChar): HResult; stdcall;
    function EnumKeys(Index: LongWord; out ppszSubKeyName: PWideChar)
      : HResult; stdcall;
    function EnumValues(Index: LongWord; out ppszValueName: PWideChar)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpObjectTokenCategory
  // Flags:     (512) Restricted
  // GUID:      {2D3D3845-39AF-4850-BBF9-40B49780011D}
  // *********************************************************************//
  ISpObjectTokenCategory = interface(ISpDataKey)
    ['{2D3D3845-39AF-4850-BBF9-40B49780011D}']
    function SetId(pszCategoryId: PWideChar; fCreateIfNotExist: Integer)
      : HResult; stdcall;
    function GetId(out ppszCoMemCategoryId: PWideChar): HResult; stdcall;
    function GetDataKey(spdkl: SPDATAKEYLOCATION; out ppDataKey: ISpDataKey)
      : HResult; stdcall;
    function EnumTokens(pzsReqAttribs: PWideChar; pszOptAttribs: PWideChar;
      out ppEnum: IEnumSpObjectTokens): HResult; stdcall;
    function SetDefaultTokenId(pszTokenId: PWideChar): HResult; stdcall;
    function GetDefaultTokenId(out ppszCoMemTokenId: PWideChar)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: IEnumSpObjectTokens
  // Flags:     (512) Restricted
  // GUID:      {06B64F9E-7FDA-11D2-B4F2-00C04F797396}
  // *********************************************************************//
  IEnumSpObjectTokens = interface(IUnknown)
    ['{06B64F9E-7FDA-11D2-B4F2-00C04F797396}']
    function Next(celt: LongWord; out pelt: ISpObjectToken;
      out pceltFetched: LongWord): HResult; stdcall;
    function Skip(celt: LongWord): HResult; stdcall;
    function Reset: HResult; stdcall;
    function Clone(out ppEnum: IEnumSpObjectTokens): HResult; stdcall;
    function Item(Index: LongWord; out ppToken: ISpObjectToken)
      : HResult; stdcall;
    function GetCount(out pCount: LongWord): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpObjectToken
  // Flags:     (512) Restricted
  // GUID:      {14056589-E16C-11D2-BB90-00C04F8EE6C0}
  // *********************************************************************//
  ISpObjectToken = interface(ISpDataKey)
    ['{14056589-E16C-11D2-BB90-00C04F8EE6C0}']
    function SetId(pszCategoryId: PWideChar; pszTokenId: PWideChar;
      fCreateIfNotExist: Integer): HResult; stdcall;
    function GetId(out ppszCoMemTokenId: PWideChar): HResult; stdcall;
    function GetCategory(out ppTokenCategory: ISpObjectTokenCategory)
      : HResult; stdcall;
    function CreateInstance(const pUnkOuter: IUnknown; dwClsContext: LongWord;
      var riid: TGUID; out ppvObject: Pointer): HResult; stdcall;
    function GetStorageFileName(var clsidCaller: TGUID; pszValueName: PWideChar;
      pszFileNameSpecifier: PWideChar; nFolder: LongWord;
      out ppszFilePath: PWideChar): HResult; stdcall;
    function RemoveStorageFileName(var clsidCaller: TGUID;
      pszKeyName: PWideChar; fDeleteFile: Integer): HResult; stdcall;
    function Remove(var pclsidCaller: TGUID): HResult; stdcall;
    function IsUISupported(pszTypeOfUI: PWideChar; pvExtraData: Pointer;
      cbExtraData: LongWord; const punkObject: IUnknown;
      out pfSupported: Integer): HResult; stdcall;
    function DisplayUI(var hWndParent: _RemotableHandle; pszTitle: PWideChar;
      pszTypeOfUI: PWideChar; pvExtraData: Pointer; cbExtraData: LongWord;
      const punkObject: IUnknown): HResult; stdcall;
    function MatchesAttributes(pszAttributes: PWideChar; out pfMatches: Integer)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: IServiceProvider
  // Flags:     (0)
  // GUID:      {6D5140C1-7436-11CE-8034-00AA006009FA}
  // *********************************************************************//
  IServiceProvider = interface(IUnknown)
    ['{6D5140C1-7436-11CE-8034-00AA006009FA}']
    function RemoteQueryService(var guidService: TGUID; var riid: TGUID;
      out ppvObject: IUnknown): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpResourceManager
  // Flags:     (512) Restricted
  // GUID:      {93384E18-5014-43D5-ADBB-A78E055926BD}
  // *********************************************************************//
  ISpResourceManager = interface(IServiceProvider)
    ['{93384E18-5014-43D5-ADBB-A78E055926BD}']
    function SetObject(var guidServiceId: TGUID; const punkObject: IUnknown)
      : HResult; stdcall;
    function GetObject(var guidServiceId: TGUID; var ObjectCLSID: TGUID;
      var ObjectIID: TGUID; fReleaseWhenLastExternalRefReleased: Integer;
      out ppObject: Pointer): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISequentialStream
  // Flags:     (0)
  // GUID:      {0C733A30-2A1C-11CE-ADE5-00AA0044773D}
  // *********************************************************************//
  ISequentialStream = interface(IUnknown)
    ['{0C733A30-2A1C-11CE-ADE5-00AA0044773D}']
    function RemoteRead(out pv: Byte; cb: LongWord; out pcbRead: LongWord)
      : HResult; stdcall;
    function RemoteWrite(var pv: Byte; cb: LongWord; out pcbWritten: LongWord)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: IStream
  // Flags:     (0)
  // GUID:      {0000000C-0000-0000-C000-000000000046}
  // *********************************************************************//
  IStream = interface(ISequentialStream)
    ['{0000000C-0000-0000-C000-000000000046}']
    function RemoteSeek(dlibMove: _LARGE_INTEGER; dwOrigin: LongWord;
      out plibNewPosition: _ULARGE_INTEGER): HResult; stdcall;
    function SetSize(libNewSize: _ULARGE_INTEGER): HResult; stdcall;
    function RemoteCopyTo(const pstm: IStream; cb: _ULARGE_INTEGER;
      out pcbRead: _ULARGE_INTEGER; out pcbWritten: _ULARGE_INTEGER)
      : HResult; stdcall;
    function Commit(grfCommitFlags: LongWord): HResult; stdcall;
    function Revert: HResult; stdcall;
    function LockRegion(libOffset: _ULARGE_INTEGER; cb: _ULARGE_INTEGER;
      dwLockType: LongWord): HResult; stdcall;
    function UnlockRegion(libOffset: _ULARGE_INTEGER; cb: _ULARGE_INTEGER;
      dwLockType: LongWord): HResult; stdcall;
    function Stat(out pstatstg: tagSTATSTG; grfStatFlag: LongWord)
      : HResult; stdcall;
    function Clone(out ppstm: IStream): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpStreamFormat
  // Flags:     (512) Restricted
  // GUID:      {BED530BE-2606-4F4D-A1C0-54C5CDA5566F}
  // *********************************************************************//
  ISpStreamFormat = interface(IStream)
    ['{BED530BE-2606-4F4D-A1C0-54C5CDA5566F}']
    function GetFormat(var pguidFormatId: TGUID;
      out ppCoMemWaveFormatEx: PUserType2): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpStreamFormatConverter
  // Flags:     (512) Restricted
  // GUID:      {678A932C-EA71-4446-9B41-78FDA6280A29}
  // *********************************************************************//
  ISpStreamFormatConverter = interface(ISpStreamFormat)
    ['{678A932C-EA71-4446-9B41-78FDA6280A29}']
    function SetBaseStream(const pStream: ISpStreamFormat;
      fSetFormatToBaseStreamFormat: Integer; fWriteToBaseStream: Integer)
      : HResult; stdcall;
    function GetBaseStream(out ppStream: ISpStreamFormat): HResult; stdcall;
    function SetFormat(var rguidFormatIdOfConvertedStream: TGUID;
      var pWaveFormatExOfConvertedStream: WAVEFORMATEX): HResult; stdcall;
    function ResetSeekPosition: HResult; stdcall;
    function ScaleConvertedToBaseOffset(ullOffsetConvertedStream: Largeuint;
      out pullOffsetBaseStream: Largeuint): HResult; stdcall;
    function ScaleBaseToConvertedOffset(ullOffsetBaseStream: Largeuint;
      out pullOffsetConvertedStream: Largeuint): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpNotifySource
  // Flags:     (512) Restricted
  // GUID:      {5EFF4AEF-8487-11D2-961C-00C04F8EE628}
  // *********************************************************************//
  ISpNotifySource = interface(IUnknown)
    ['{5EFF4AEF-8487-11D2-961C-00C04F8EE628}']
    function SetNotifySink(const pNotifySink: ISpNotifySink): HResult; stdcall;
    function SetNotifyWindowMessage(var hWnd: _RemotableHandle; Msg: SYSUINT;
      wParam: UINT_PTR; lParam: LONG_PTR): HResult; stdcall;
    function SetNotifyCallbackFunction(pfnCallback: PPPrivateAlias1;
      wParam: UINT_PTR; lParam: LONG_PTR): HResult; stdcall;
    function SetNotifyCallbackInterface(pSpCallback: PPPrivateAlias1;
      wParam: UINT_PTR; lParam: LONG_PTR): HResult; stdcall;
    function SetNotifyWin32Event: HResult; stdcall;
    function WaitForNotifyEvent(dwMilliseconds: LongWord): HResult; stdcall;
    function GetNotifyEventHandle: Pointer; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpEventSource
  // Flags:     (512) Restricted
  // GUID:      {BE7A9CCE-5F9E-11D2-960F-00C04F8EE628}
  // *********************************************************************//
  ISpEventSource = interface(ISpNotifySource)
    ['{BE7A9CCE-5F9E-11D2-960F-00C04F8EE628}']
    function SetInterest(ullEventInterest: Largeuint;
      ullQueuedInterest: Largeuint): HResult; stdcall;
    function GetEvents(ulCount: LongWord; out pEventArray: SPEVENT;
      out pulFetched: LongWord): HResult; stdcall;
    function GetInfo(out pInfo: SPEVENTSOURCEINFO): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpEventSink
  // Flags:     (512) Restricted
  // GUID:      {BE7A9CC9-5F9E-11D2-960F-00C04F8EE628}
  // *********************************************************************//
  ISpEventSink = interface(IUnknown)
    ['{BE7A9CC9-5F9E-11D2-960F-00C04F8EE628}']
    function AddEvents(var pEventArray: SPEVENT; ulCount: LongWord)
      : HResult; stdcall;
    function GetEventInterest(out pullEventInterest: Largeuint)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpObjectWithToken
  // Flags:     (512) Restricted
  // GUID:      {5B559F40-E952-11D2-BB91-00C04F8EE6C0}
  // *********************************************************************//
  ISpObjectWithToken = interface(IUnknown)
    ['{5B559F40-E952-11D2-BB91-00C04F8EE6C0}']
    function SetObjectToken(const pToken: ISpObjectToken): HResult; stdcall;
    function GetObjectToken(out ppToken: ISpObjectToken): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpAudio
  // Flags:     (512) Restricted
  // GUID:      {C05C768F-FAE8-4EC2-8E07-338321C12452}
  // *********************************************************************//
  ISpAudio = interface(ISpStreamFormat)
    ['{C05C768F-FAE8-4EC2-8E07-338321C12452}']
    function SetState(NewState: SPAUDIOSTATE; ullReserved: Largeuint)
      : HResult; stdcall;
    function SetFormat(var rguidFmtId: TGUID; var pWaveFormatEx: WAVEFORMATEX)
      : HResult; stdcall;
    function GetStatus(out pStatus: SPAUDIOSTATUS): HResult; stdcall;
    function SetBufferInfo(var pBuffInfo: SPAUDIOBUFFERINFO): HResult; stdcall;
    function GetBufferInfo(out pBuffInfo: SPAUDIOBUFFERINFO): HResult; stdcall;
    function GetDefaultFormat(out pFormatId: TGUID;
      out ppCoMemWaveFormatEx: PUserType2): HResult; stdcall;
    function EventHandle: Pointer; stdcall;
    function GetVolumeLevel(out pLevel: LongWord): HResult; stdcall;
    function SetVolumeLevel(Level: LongWord): HResult; stdcall;
    function GetBufferNotifySize(out pcbSize: LongWord): HResult; stdcall;
    function SetBufferNotifySize(cbSize: LongWord): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpMMSysAudio
  // Flags:     (512) Restricted
  // GUID:      {15806F6E-1D70-4B48-98E6-3B1A007509AB}
  // *********************************************************************//
  ISpMMSysAudio = interface(ISpAudio)
    ['{15806F6E-1D70-4B48-98E6-3B1A007509AB}']
    function GetDeviceId(out puDeviceId: SYSUINT): HResult; stdcall;
    function SetDeviceId(uDeviceId: SYSUINT): HResult; stdcall;
    function GetMMHandle(out pHandle: Pointer): HResult; stdcall;
    function GetLineId(out puLineId: SYSUINT): HResult; stdcall;
    function SetLineId(uLineId: SYSUINT): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpStream
  // Flags:     (512) Restricted
  // GUID:      {12E3CCA9-7518-44C5-A5E7-BA5A79CB929E}
  // *********************************************************************//
  ISpStream = interface(ISpStreamFormat)
    ['{12E3CCA9-7518-44C5-A5E7-BA5A79CB929E}']
    function SetBaseStream(const pStream: IStream; var rguidFormat: TGUID;
      var pWaveFormatEx: WAVEFORMATEX): HResult; stdcall;
    function GetBaseStream(out ppStream: IStream): HResult; stdcall;
    function BindToFile(pszFileName: PWideChar; eMode: SPFILEMODE;
      var pFormatId: TGUID; var pWaveFormatEx: WAVEFORMATEX;
      ullEventInterest: Largeuint): HResult; stdcall;
    function Close: HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpVoice
  // Flags:     (512) Restricted
  // GUID:      {6C44DF74-72B9-4992-A1EC-EF996E0422D4}
  // *********************************************************************//
  ISpVoice = interface(ISpEventSource)
    ['{6C44DF74-72B9-4992-A1EC-EF996E0422D4}']
    function SetOutput(const pUnkOutput: IUnknown; fAllowFormatChanges: Integer)
      : HResult; stdcall;
    function GetOutputObjectToken(out ppObjectToken: ISpObjectToken)
      : HResult; stdcall;
    function GetOutputStream(out ppStream: ISpStreamFormat): HResult; stdcall;
    function Pause: HResult; stdcall;
    function Resume: HResult; stdcall;
    function SetVoice(const pToken: ISpObjectToken): HResult; stdcall;
    function GetVoice(out ppToken: ISpObjectToken): HResult; stdcall;
    function Speak(pwcs: PWideChar; dwFlags: LongWord;
      out pulStreamNumber: LongWord): HResult; stdcall;
    function SpeakStream(const pStream: IStream; dwFlags: LongWord;
      out pulStreamNumber: LongWord): HResult; stdcall;
    function GetStatus(out pStatus: SPVOICESTATUS;
      out ppszLastBookmark: PWideChar): HResult; stdcall;
    function Skip(pItemType: PWideChar; lNumItems: Integer;
      out pulNumSkipped: LongWord): HResult; stdcall;
    function SetPriority(ePriority: SPVPRIORITY): HResult; stdcall;
    function GetPriority(out pePriority: SPVPRIORITY): HResult; stdcall;
    function SetAlertBoundary(eBoundary: SPEVENTENUM): HResult; stdcall;
    function GetAlertBoundary(out peBoundary: SPEVENTENUM): HResult; stdcall;
    function SetRate(RateAdjust: Integer): HResult; stdcall;
    function GetRate(out pRateAdjust: Integer): HResult; stdcall;
    function SetVolume(usVolume: Word): HResult; stdcall;
    function GetVolume(out pusVolume: Word): HResult; stdcall;
    function WaitUntilDone(msTimeout: LongWord): HResult; stdcall;
    function SetSyncSpeakTimeout(msTimeout: LongWord): HResult; stdcall;
    function GetSyncSpeakTimeout(out pmsTimeout: LongWord): HResult; stdcall;
    function SpeakCompleteEvent: Pointer; stdcall;
    function IsUISupported(pszTypeOfUI: PWideChar; pvExtraData: Pointer;
      cbExtraData: LongWord; out pfSupported: Integer): HResult; stdcall;
    function DisplayUI(var hWndParent: _RemotableHandle; pszTitle: PWideChar;
      pszTypeOfUI: PWideChar; pvExtraData: Pointer; cbExtraData: LongWord)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpPhoneticAlphabetSelection
  // Flags:     (512) Restricted
  // GUID:      {B2745EFD-42CE-48CA-81F1-A96E02538A90}
  // *********************************************************************//
  ISpPhoneticAlphabetSelection = interface(IUnknown)
    ['{B2745EFD-42CE-48CA-81F1-A96E02538A90}']
    function IsAlphabetUPS(out pfIsUPS: Integer): HResult; stdcall;
    function SetAlphabetToUPS(fForceUPS: Integer): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecoContext
  // Flags:     (512) Restricted
  // GUID:      {F740A62F-7C15-489E-8234-940A33D9272D}
  // *********************************************************************//
  ISpRecoContext = interface(ISpEventSource)
    ['{F740A62F-7C15-489E-8234-940A33D9272D}']
    function GetRecognizer(out ppRecognizer: ISpRecognizer): HResult; stdcall;
    function CreateGrammar(ullGrammarID: Largeuint;
      out ppGrammar: ISpRecoGrammar): HResult; stdcall;
    function GetStatus(out pStatus: SPRECOCONTEXTSTATUS): HResult; stdcall;
    function GetMaxAlternates(var pcAlternates: LongWord): HResult; stdcall;
    function SetMaxAlternates(cAlternates: LongWord): HResult; stdcall;
    function SetAudioOptions(Options: SPAUDIOOPTIONS; var pAudioFormatId: TGUID;
      var pWaveFormatEx: WAVEFORMATEX): HResult; stdcall;
    function GetAudioOptions(var pOptions: SPAUDIOOPTIONS;
      out pAudioFormatId: TGUID; out ppCoMemWFEX: PUserType2): HResult; stdcall;
    function DeserializeResult(var pSerializedResult: SPSERIALIZEDRESULT;
      out ppResult: ISpRecoResult): HResult; stdcall;
    function Bookmark(Options: SPBOOKMARKOPTIONS; ullStreamPosition: Largeuint;
      lparamEvent: LONG_PTR): HResult; stdcall;
    function SetAdaptationData(pAdaptationData: PWideChar; cch: LongWord)
      : HResult; stdcall;
    function Pause(dwReserved: LongWord): HResult; stdcall;
    function Resume(dwReserved: LongWord): HResult; stdcall;
    function SetVoice(const pVoice: ISpVoice; fAllowFormatChanges: Integer)
      : HResult; stdcall;
    function GetVoice(out ppVoice: ISpVoice): HResult; stdcall;
    function SetVoicePurgeEvent(ullEventInterest: Largeuint): HResult; stdcall;
    function GetVoicePurgeEvent(out pullEventInterest: Largeuint)
      : HResult; stdcall;
    function SetContextState(eContextState: SPCONTEXTSTATE): HResult; stdcall;
    function GetContextState(out peContextState: SPCONTEXTSTATE)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecoContext2
  // Flags:     (512) Restricted
  // GUID:      {BEAD311C-52FF-437F-9464-6B21054CA73D}
  // *********************************************************************//
  ISpRecoContext2 = interface(IUnknown)
    ['{BEAD311C-52FF-437F-9464-6B21054CA73D}']
    function SetGrammarOptions(eGrammarOptions: LongWord): HResult; stdcall;
    function GetGrammarOptions(out peGrammarOptions: LongWord)
      : HResult; stdcall;
    function SetAdaptationData2(pAdaptationData: PWideChar; cch: LongWord;
      pTopicName: PWideChar; eAdaptationSettings: LongWord;
      eRelevance: SPADAPTATIONRELEVANCE): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpProperties
  // Flags:     (512) Restricted
  // GUID:      {5B4FB971-B115-4DE1-AD97-E482E3BF6EE4}
  // *********************************************************************//
  ISpProperties = interface(IUnknown)
    ['{5B4FB971-B115-4DE1-AD97-E482E3BF6EE4}']
    function SetPropertyNum(pName: PWideChar; lValue: Integer)
      : HResult; stdcall;
    function GetPropertyNum(pName: PWideChar; out plValue: Integer)
      : HResult; stdcall;
    function SetPropertyString(pName: PWideChar; pValue: PWideChar)
      : HResult; stdcall;
    function GetPropertyString(pName: PWideChar; out ppCoMemValue: PWideChar)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecognizer
  // Flags:     (512) Restricted
  // GUID:      {C2B5F241-DAA0-4507-9E16-5A1EAA2B7A5C}
  // *********************************************************************//
  ISpRecognizer = interface(ISpProperties)
    ['{C2B5F241-DAA0-4507-9E16-5A1EAA2B7A5C}']
    function SetRecognizer(const pRecognizer: ISpObjectToken): HResult; stdcall;
    function GetRecognizer(out ppRecognizer: ISpObjectToken): HResult; stdcall;
    function SetInput(const pUnkInput: IUnknown; fAllowFormatChanges: Integer)
      : HResult; stdcall;
    function GetInputObjectToken(out ppToken: ISpObjectToken): HResult; stdcall;
    function GetInputStream(out ppStream: ISpStreamFormat): HResult; stdcall;
    function CreateRecoContext(out ppNewCtxt: ISpRecoContext): HResult; stdcall;
    function GetRecoProfile(out ppToken: ISpObjectToken): HResult; stdcall;
    function SetRecoProfile(const pToken: ISpObjectToken): HResult; stdcall;
    function IsSharedInstance: HResult; stdcall;
    function GetRecoState(out pState: SPRECOSTATE): HResult; stdcall;
    function SetRecoState(NewState: SPRECOSTATE): HResult; stdcall;
    function GetStatus(out pStatus: SPRECOGNIZERSTATUS): HResult; stdcall;
    function GetFormat(WaveFormatType: SPSTREAMFORMATTYPE; out pFormatId: TGUID;
      out ppCoMemWFEX: PUserType2): HResult; stdcall;
    function IsUISupported(pszTypeOfUI: PWideChar; pvExtraData: Pointer;
      cbExtraData: LongWord; out pfSupported: Integer): HResult; stdcall;
    function DisplayUI(var hWndParent: _RemotableHandle; pszTitle: PWideChar;
      pszTypeOfUI: PWideChar; pvExtraData: Pointer; cbExtraData: LongWord)
      : HResult; stdcall;
    function EmulateRecognition(const pPhrase: ISpPhrase): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpPhrase
  // Flags:     (512) Restricted
  // GUID:      {1A5C0354-B621-4B5A-8791-D306ED379E53}
  // *********************************************************************//
  ISpPhrase = interface(IUnknown)
    ['{1A5C0354-B621-4B5A-8791-D306ED379E53}']
    function GetPhrase(out ppCoMemPhrase: PUserType7): HResult; stdcall;
    function GetSerializedPhrase(out ppCoMemPhrase: PUserType8)
      : HResult; stdcall;
    function GetText(ulStart: LongWord; ulCount: LongWord;
      fUseTextReplacements: Integer; out ppszCoMemText: PWideChar;
      out pbDisplayAttributes: Byte): HResult; stdcall;
    function Discard(dwValueTypes: LongWord): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpGrammarBuilder
  // Flags:     (512) Restricted
  // GUID:      {8137828F-591A-4A42-BE58-49EA7EBAAC68}
  // *********************************************************************//
  ISpGrammarBuilder = interface(IUnknown)
    ['{8137828F-591A-4A42-BE58-49EA7EBAAC68}']
    function ResetGrammar(NewLanguage: Word): HResult; stdcall;
    function GetRule(pszRuleName: PWideChar; dwRuleId: LongWord;
      dwAttributes: LongWord; fCreateIfNotExist: Integer;
      out phInitialState: Pointer): HResult; stdcall;
    function ClearRule(hState: Pointer): HResult; stdcall;
    function CreateNewState(hState: Pointer; out phState: Pointer)
      : HResult; stdcall;
    function AddWordTransition(hFromState: Pointer; hToState: Pointer;
      psz: PWideChar; pszSeparators: PWideChar; eWordType: SPGRAMMARWORDTYPE;
      Weight: Single; var pPropInfo: SPPROPERTYINFO): HResult; stdcall;
    function AddRuleTransition(hFromState: Pointer; hToState: Pointer;
      hRule: Pointer; Weight: Single; var pPropInfo: SPPROPERTYINFO)
      : HResult; stdcall;
    function AddResource(hRuleState: Pointer; pszResourceName: PWideChar;
      pszResourceValue: PWideChar): HResult; stdcall;
    function Commit(dwReserved: LongWord): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecoGrammar
  // Flags:     (512) Restricted
  // GUID:      {2177DB29-7F45-47D0-8554-067E91C80502}
  // *********************************************************************//
  ISpRecoGrammar = interface(ISpGrammarBuilder)
    ['{2177DB29-7F45-47D0-8554-067E91C80502}']
    function GetGrammarId(out pullGrammarId: Largeuint): HResult; stdcall;
    function GetRecoContext(out ppRecoCtxt: ISpRecoContext): HResult; stdcall;
    function LoadCmdFromFile(pszFileName: PWideChar; Options: SPLOADOPTIONS)
      : HResult; stdcall;
    function LoadCmdFromObject(var rcid: TGUID; pszGrammarName: PWideChar;
      Options: SPLOADOPTIONS): HResult; stdcall;
    function LoadCmdFromResource(hModule: Pointer; pszResourceName: PWideChar;
      pszResourceType: PWideChar; wLanguage: Word; Options: SPLOADOPTIONS)
      : HResult; stdcall;
    function LoadCmdFromMemory(var pGrammar: SPBINARYGRAMMAR;
      Options: SPLOADOPTIONS): HResult; stdcall;
    function LoadCmdFromProprietaryGrammar(var rguidParam: TGUID;
      pszStringParam: PWideChar; pvDataPrarm: Pointer; cbDataSize: LongWord;
      Options: SPLOADOPTIONS): HResult; stdcall;
    function SetRuleState(pszName: PWideChar; pReserved: Pointer;
      NewState: SPRULESTATE): HResult; stdcall;
    function SetRuleIdState(ulRuleId: LongWord; NewState: SPRULESTATE)
      : HResult; stdcall;
    function LoadDictation(pszTopicName: PWideChar; Options: SPLOADOPTIONS)
      : HResult; stdcall;
    function UnloadDictation: HResult; stdcall;
    function SetDictationState(NewState: SPRULESTATE): HResult; stdcall;
    function SetWordSequenceData(var pText: Word; cchText: LongWord;
      var pInfo: SPTEXTSELECTIONINFO): HResult; stdcall;
    function SetTextSelection(var pInfo: SPTEXTSELECTIONINFO): HResult; stdcall;
    function IsPronounceable(pszWord: PWideChar;
      out pWordPronounceable: SPWORDPRONOUNCEABLE): HResult; stdcall;
    function SetGrammarState(eGrammarState: SPGRAMMARSTATE): HResult; stdcall;
    function SaveCmd(const pStream: IStream; out ppszCoMemErrorText: PWideChar)
      : HResult; stdcall;
    function GetGrammarState(out peGrammarState: SPGRAMMARSTATE)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecoResult
  // Flags:     (512) Restricted
  // GUID:      {20B053BE-E235-43CD-9A2A-8D17A48B7842}
  // *********************************************************************//
  ISpRecoResult = interface(ISpPhrase)
    ['{20B053BE-E235-43CD-9A2A-8D17A48B7842}']
    function GetResultTimes(out pTimes: SPRECORESULTTIMES): HResult; stdcall;
    function GetAlternates(ulStartElement: LongWord; cElements: LongWord;
      ulRequestCount: LongWord; out ppPhrases: ISpPhraseAlt;
      out pcPhrasesReturned: LongWord): HResult; stdcall;
    function GetAudio(ulStartElement: LongWord; cElements: LongWord;
      out ppStream: ISpStreamFormat): HResult; stdcall;
    function SpeakAudio(ulStartElement: LongWord; cElements: LongWord;
      dwFlags: LongWord; out pulStreamNumber: LongWord): HResult; stdcall;
    function Serialize(out ppCoMemSerializedResult: PUserType6)
      : HResult; stdcall;
    function ScaleAudio(var pAudioFormatId: TGUID;
      var pWaveFormatEx: WAVEFORMATEX): HResult; stdcall;
    function GetRecoContext(out ppRecoContext: ISpRecoContext)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpPhraseAlt
  // Flags:     (512) Restricted
  // GUID:      {8FCEBC98-4E49-4067-9C6C-D86A0E092E3D}
  // *********************************************************************//
  ISpPhraseAlt = interface(ISpPhrase)
    ['{8FCEBC98-4E49-4067-9C6C-D86A0E092E3D}']
    function GetAltInfo(out ppParent: ISpPhrase;
      out pulStartElementInParent: LongWord; out pcElementsInParent: LongWord;
      out pcElementsInAlt: LongWord): HResult; stdcall;
    function Commit: HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecognizer2
  // Flags:     (512) Restricted
  // GUID:      {8FC6D974-C81E-4098-93C5-0147F61ED4D3}
  // *********************************************************************//
  ISpRecognizer2 = interface(IUnknown)
    ['{8FC6D974-C81E-4098-93C5-0147F61ED4D3}']
    function EmulateRecognitionEx(const pPhrase: ISpPhrase;
      dwCompareFlags: LongWord): HResult; stdcall;
    function SetTrainingState(fDoingTraining: Integer;
      fAdaptFromTrainingData: Integer): HResult; stdcall;
    function ResetAcousticModelAdaptation: HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecognizer3
  // Flags:     (512) Restricted
  // GUID:      {DF1B943C-5838-4AA2-8706-D7CD5B333499}
  // *********************************************************************//
  ISpRecognizer3 = interface(IUnknown)
    ['{DF1B943C-5838-4AA2-8706-D7CD5B333499}']
    function GetCategory(categoryType: SPCATEGORYTYPE;
      out ppCategory: ISpRecoCategory): HResult; stdcall;
    function SetActiveCategory(const pCategory: ISpRecoCategory)
      : HResult; stdcall;
    function GetActiveCategory(out ppCategory: ISpRecoCategory)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpSerializeState
  // Flags:     (512) Restricted
  // GUID:      {21B501A0-0EC7-46C9-92C3-A2BC784C54B9}
  // *********************************************************************//
  ISpSerializeState = interface(IUnknown)
    ['{21B501A0-0EC7-46C9-92C3-A2BC784C54B9}']
    function GetSerializedState(out ppbData: PByte1; out pulSize: LongWord;
      dwReserved: LongWord): HResult; stdcall;
    function SetSerializedState(var pbData: Byte; ulSize: LongWord;
      dwReserved: LongWord): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecoCategory
  // Flags:     (512) Restricted
  // GUID:      {DA0CD0F9-14A2-4F09-8C2A-85CC48979345}
  // *********************************************************************//
  ISpRecoCategory = interface(IUnknown)
    ['{DA0CD0F9-14A2-4F09-8C2A-85CC48979345}']
    function GetType(out peCategoryType: SPCATEGORYTYPE): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpLexicon
  // Flags:     (512) Restricted
  // GUID:      {DA41A7C2-5383-4DB2-916B-6C1719E3DB58}
  // *********************************************************************//
  ISpLexicon = interface(IUnknown)
    ['{DA41A7C2-5383-4DB2-916B-6C1719E3DB58}']
    function GetPronunciations(pszWord: PWideChar; LangId: Word;
      dwFlags: LongWord; var pWordPronunciationList: SPWORDPRONUNCIATIONLIST)
      : HResult; stdcall;
    function AddPronunciation(pszWord: PWideChar; LangId: Word;
      ePartOfSpeech: SPPARTOFSPEECH; pszPronunciation: PWideChar)
      : HResult; stdcall;
    function RemovePronunciation(pszWord: PWideChar; LangId: Word;
      ePartOfSpeech: SPPARTOFSPEECH; pszPronunciation: PWideChar)
      : HResult; stdcall;
    function GetGeneration(out pdwGeneration: LongWord): HResult; stdcall;
    function GetGenerationChange(dwFlags: LongWord; var pdwGeneration: LongWord;
      var pWordList: SPWORDLIST): HResult; stdcall;
    function GetWords(dwFlags: LongWord; var pdwGeneration: LongWord;
      var pdwCookie: LongWord; var pWordList: SPWORDLIST): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpShortcut
  // Flags:     (512) Restricted
  // GUID:      {3DF681E2-EA56-11D9-8BDE-F66BAD1E3F3A}
  // *********************************************************************//
  ISpShortcut = interface(IUnknown)
    ['{3DF681E2-EA56-11D9-8BDE-F66BAD1E3F3A}']
    function AddShortcut(pszDisplay: PWideChar; LangId: Word;
      pszSpoken: PWideChar; shType: SPSHORTCUTTYPE): HResult; stdcall;
    function RemoveShortcut(pszDisplay: PWideChar; LangId: Word;
      pszSpoken: PWideChar; shType: SPSHORTCUTTYPE): HResult; stdcall;
    function GetShortcuts(LangId: Word;
      var pShortcutpairList: SPSHORTCUTPAIRLIST): HResult; stdcall;
    function GetGeneration(out pdwGeneration: LongWord): HResult; stdcall;
    function GetWordsFromGenerationChange(var pdwGeneration: LongWord;
      var pWordList: SPWORDLIST): HResult; stdcall;
    function GetWords(var pdwGeneration: LongWord; var pdwCookie: LongWord;
      var pWordList: SPWORDLIST): HResult; stdcall;
    function GetShortcutsForGeneration(var pdwGeneration: LongWord;
      var pdwCookie: LongWord; var pShortcutpairList: SPSHORTCUTPAIRLIST)
      : HResult; stdcall;
    function GetGenerationChange(var pdwGeneration: LongWord;
      var pShortcutpairList: SPSHORTCUTPAIRLIST): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpPhoneConverter
  // Flags:     (512) Restricted
  // GUID:      {8445C581-0CAC-4A38-ABFE-9B2CE2826455}
  // *********************************************************************//
  ISpPhoneConverter = interface(ISpObjectWithToken)
    ['{8445C581-0CAC-4A38-ABFE-9B2CE2826455}']
    function PhoneToId(pszPhone: PWideChar; out pId: Word): HResult; stdcall;
    function IdToPhone(pId: PWideChar; out pszPhone: Word): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpPhoneticAlphabetConverter
  // Flags:     (512) Restricted
  // GUID:      {133ADCD4-19B4-4020-9FDC-842E78253B17}
  // *********************************************************************//
  ISpPhoneticAlphabetConverter = interface(IUnknown)
    ['{133ADCD4-19B4-4020-9FDC-842E78253B17}']
    function GetLangId(out pLangID: Word): HResult; stdcall;
    function SetLangId(LangId: Word): HResult; stdcall;
    function SAPI2UPS(var pszSAPIId: Word; out pszUPSId: Word;
      cMaxLength: LongWord): HResult; stdcall;
    function UPS2SAPI(var pszUPSId: Word; out pszSAPIId: Word;
      cMaxLength: LongWord): HResult; stdcall;
    function GetMaxConvertLength(cSrcLength: LongWord; bSAPI2UPS: Integer;
      out pcMaxDestLength: LongWord): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpXMLRecoResult
  // Flags:     (512) Restricted
  // GUID:      {AE39362B-45A8-4074-9B9E-CCF49AA2D0B6}
  // *********************************************************************//
  ISpXMLRecoResult = interface(ISpRecoResult)
    ['{AE39362B-45A8-4074-9B9E-CCF49AA2D0B6}']
    function GetXMLResult(out ppszCoMemXMLResult: PWideChar;
      Options: SPXMLRESULTOPTIONS): HResult; stdcall;
    function GetXMLErrorInfo(out pSemanticErrorInfo: SPSEMANTICERRORINFO)
      : HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpRecoGrammar2
  // Flags:     (512) Restricted
  // GUID:      {4B37BC9E-9ED6-44A3-93D3-18F022B79EC3}
  // *********************************************************************//
  ISpRecoGrammar2 = interface(IUnknown)
    ['{4B37BC9E-9ED6-44A3-93D3-18F022B79EC3}']
    function GetRules(out ppCoMemRules: PUserType17; out puNumRules: SYSUINT)
      : HResult; stdcall;
    function LoadCmdFromFile2(pszFileName: PWideChar; Options: SPLOADOPTIONS;
      pszSharingUri: PWideChar; pszBaseUri: PWideChar): HResult; stdcall;
    function LoadCmdFromMemory2(var pGrammar: SPBINARYGRAMMAR;
      Options: SPLOADOPTIONS; pszSharingUri: PWideChar; pszBaseUri: PWideChar)
      : HResult; stdcall;
    function SetRulePriority(pszRuleName: PWideChar; ulRuleId: LongWord;
      nRulePriority: SYSINT): HResult; stdcall;
    function SetRuleWeight(pszRuleName: PWideChar; ulRuleId: LongWord;
      flWeight: Single): HResult; stdcall;
    function SetDictationWeight(flWeight: Single): HResult; stdcall;
    function SetGrammarLoader(const pLoader: ISpeechResourceLoader)
      : HResult; stdcall;
    function SetSMLSecurityManager(const pSMLSecurityManager
      : IInternetSecurityManager): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: ISpeechResourceLoader
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}
  // *********************************************************************//
  ISpeechResourceLoader = interface(IDispatch)
    ['{B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}']
    procedure LoadResource(const bstrResourceUri: WideString;
      fAlwaysReload: WordBool; out pStream: IUnknown;
      out pbstrMIMEType: WideString; out pfModified: WordBool;
      out pbstrRedirectUrl: WideString); safecall;
    procedure GetLocalCopy(const bstrResourceUri: WideString;
      out pbstrLocalPath: WideString; out pbstrMIMEType: WideString;
      out pbstrRedirectUrl: WideString); safecall;
    procedure ReleaseLocalCopy(const pbstrLocalPath: WideString); safecall;
  end;

  // *********************************************************************//
  // DispIntf:  ISpeechResourceLoaderDisp
  // Flags:     (4416) Dual OleAutomation Dispatchable
  // GUID:      {B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}
  // *********************************************************************//
  ISpeechResourceLoaderDisp = dispinterface
    ['{B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}']
    procedure LoadResource(const bstrResourceUri: WideString;
      fAlwaysReload: WordBool; out pStream: IUnknown;
      out pbstrMIMEType: WideString; out pfModified: WordBool;
      out pbstrRedirectUrl: WideString); dispid 1;
    procedure GetLocalCopy(const bstrResourceUri: WideString;
      out pbstrLocalPath: WideString; out pbstrMIMEType: WideString;
      out pbstrRedirectUrl: WideString); dispid 2;
    procedure ReleaseLocalCopy(const pbstrLocalPath: WideString); dispid 3;
  end;

  // *********************************************************************//
  // Interface: IInternetSecurityManager
  // Flags:     (0)
  // GUID:      {79EAC9EE-BAF9-11CE-8C82-00AA004BA90B}
  // *********************************************************************//
  IInternetSecurityManager = interface(IUnknown)
    ['{79EAC9EE-BAF9-11CE-8C82-00AA004BA90B}']
    function SetSecuritySite(const pSite: IInternetSecurityMgrSite)
      : HResult; stdcall;
    function GetSecuritySite(out ppSite: IInternetSecurityMgrSite)
      : HResult; stdcall;
    function MapUrlToZone(pwszUrl: PWideChar; out pdwZone: LongWord;
      dwFlags: LongWord): HResult; stdcall;
    function GetSecurityId(pwszUrl: PWideChar; out pbSecurityId: Byte;
      var pcbSecurityId: LongWord; dwReserved: ULONG_PTR): HResult; stdcall;
    function ProcessUrlAction(pwszUrl: PWideChar; dwAction: LongWord;
      out pPolicy: Byte; cbPolicy: LongWord; var pContext: Byte;
      cbContext: LongWord; dwFlags: LongWord; dwReserved: LongWord)
      : HResult; stdcall;
    function QueryCustomPolicy(pwszUrl: PWideChar; var guidKey: TGUID;
      out ppPolicy: PByte1; out pcbPolicy: LongWord; var pContext: Byte;
      cbContext: LongWord; dwReserved: LongWord): HResult; stdcall;
    function SetZoneMapping(dwZone: LongWord; lpszPattern: PWideChar;
      dwFlags: LongWord): HResult; stdcall;
    function GetZoneMappings(dwZone: LongWord; out ppenumString: IEnumString;
      dwFlags: LongWord): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: IInternetSecurityMgrSite
  // Flags:     (0)
  // GUID:      {79EAC9ED-BAF9-11CE-8C82-00AA004BA90B}
  // *********************************************************************//
  IInternetSecurityMgrSite = interface(IUnknown)
    ['{79EAC9ED-BAF9-11CE-8C82-00AA004BA90B}']
    function GetWindow(out phwnd: wireHWND): HResult; stdcall;
    function EnableModeless(fEnable: Integer): HResult; stdcall;
  end;

  // *********************************************************************//
  // Interface: IEnumString
  // Flags:     (0)
  // GUID:      {00000101-0000-0000-C000-000000000046}
  // *********************************************************************//
  IEnumString = interface(IUnknown)
    ['{00000101-0000-0000-C000-000000000046}']
    function RemoteNext(celt: LongWord; out rgelt: PWideChar;
      out pceltFetched: LongWord): HResult; stdcall;
    function Skip(celt: LongWord): HResult; stdcall;
    function Reset: HResult; stdcall;
    function Clone(out ppEnum: IEnumString): HResult; stdcall;
  end;

  // *********************************************************************//
  // The Class CoSpNotifyTranslator provides a Create and CreateRemote method to
  // create instances of the default interface ISpNotifyTranslator exposed by
  // the CoClass SpNotifyTranslator. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpNotifyTranslator = class
    class function Create: ISpNotifyTranslator;
    class function CreateRemote(const MachineName: string): ISpNotifyTranslator;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpNotifyTranslator
  // Help String      : SpNotify
  // Default Interface: ISpNotifyTranslator
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (530) CanCreate Hidden Restricted
  // *********************************************************************//
  TSpNotifyTranslator = class(TOleServer)
  private
    FIntf: ISpNotifyTranslator;
    function GetDefaultInterface: ISpNotifyTranslator;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpNotifyTranslator);
    procedure Disconnect; override;
    function Notify: HResult;
    function InitWindowMessage(var hWnd: _RemotableHandle; Msg: SYSUINT;
      wParam: UINT_PTR; lParam: LONG_PTR): HResult;
    function InitCallback(pfnCallback: PPPrivateAlias1; wParam: UINT_PTR;
      lParam: LONG_PTR): HResult;
    function InitSpNotifyCallback(pSpCallback: PPPrivateAlias1;
      wParam: UINT_PTR; lParam: LONG_PTR): HResult;
    function InitWin32Event(hEvent: Pointer;
      fCloseHandleOnRelease: Integer): HResult;
    function Wait(dwMilliseconds: LongWord): HResult;
    function GetEventHandle: Pointer;
    property DefaultInterface: ISpNotifyTranslator read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpObjectTokenCategory provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechObjectTokenCategory exposed by
  // the CoClass SpObjectTokenCategory. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpObjectTokenCategory = class
    class function Create: ISpeechObjectTokenCategory;
    class function CreateRemote(const MachineName: string)
      : ISpeechObjectTokenCategory;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpObjectTokenCategory
  // Help String      : SpObjectTokenCategory Class
  // Default Interface: ISpeechObjectTokenCategory
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpObjectTokenCategory = class(TOleServer)
  private
    FIntf: ISpeechObjectTokenCategory;
    function GetDefaultInterface: ISpeechObjectTokenCategory;
  protected
    procedure InitServerData; override;
    function Get_Id: WideString;
    procedure Set_Default(const TokenId: WideString);
    function Get_Default: WideString;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechObjectTokenCategory);
    procedure Disconnect; override;
    procedure SetId(const Id: WideString; CreateIfNotExist: WordBool);
    function GetDataKey(Location: SpeechDataKeyLocation): ISpeechDataKey;
    function EnumerateTokens(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    property DefaultInterface: ISpeechObjectTokenCategory
      read GetDefaultInterface;
    property Id: WideString read Get_Id;
    property Default: WideString read Get_Default write Set_Default;
  published
  end;

  // *********************************************************************//
  // The Class CoSpObjectToken provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechObjectToken exposed by
  // the CoClass SpObjectToken. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpObjectToken = class
    class function Create: ISpeechObjectToken;
    class function CreateRemote(const MachineName: string): ISpeechObjectToken;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpObjectToken
  // Help String      : SpObjectToken Class
  // Default Interface: ISpeechObjectToken
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpObjectToken = class(TOleServer)
  private
    FIntf: ISpeechObjectToken;
    function GetDefaultInterface: ISpeechObjectToken;
  protected
    procedure InitServerData; override;
    function Get_Id: WideString;
    function Get_DataKey: ISpeechDataKey;
    function Get_Category: ISpeechObjectTokenCategory;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechObjectToken);
    procedure Disconnect; override;
    function GetDescription(Locale: Integer): WideString;
    procedure SetId(const Id: WideString; const CategoryID: WideString;
      CreateIfNotExist: WordBool);
    function GetAttribute(const AttributeName: WideString): WideString;
    function CreateInstance(const pUnkOuter: IUnknown;
      ClsContext: SpeechTokenContext): IUnknown;
    procedure Remove(const ObjectStorageCLSID: WideString);
    function GetStorageFileName(const ObjectStorageCLSID: WideString;
      const KeyName: WideString; const FileName: WideString;
      Folder: SpeechTokenShellFolder): WideString;
    procedure RemoveStorageFileName(const ObjectStorageCLSID: WideString;
      const KeyName: WideString; DeleteFile: WordBool);
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant; const Object_: IUnknown): WordBool;
    procedure DisplayUI(hWnd: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant;
      const Object_: IUnknown);
    function MatchesAttributes(const Attributes: WideString): WordBool;
    property DefaultInterface: ISpeechObjectToken read GetDefaultInterface;
    property Id: WideString read Get_Id;
    property DataKey: ISpeechDataKey read Get_DataKey;
    property Category: ISpeechObjectTokenCategory read Get_Category;
  published
  end;

  // *********************************************************************//
  // The Class CoSpResourceManager provides a Create and CreateRemote method to
  // create instances of the default interface ISpResourceManager exposed by
  // the CoClass SpResourceManager. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpResourceManager = class
    class function Create: ISpResourceManager;
    class function CreateRemote(const MachineName: string): ISpResourceManager;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpResourceManager
  // Help String      : SpResourceManger
  // Default Interface: ISpResourceManager
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (530) CanCreate Hidden Restricted
  // *********************************************************************//
  TSpResourceManager = class(TOleServer)
  private
    FIntf: ISpResourceManager;
    function GetDefaultInterface: ISpResourceManager;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpResourceManager);
    procedure Disconnect; override;
    function RemoteQueryService(var guidService: TGUID; var riid: TGUID;
      out ppvObject: IUnknown): HResult;
    function SetObject(var guidServiceId: TGUID;
      const punkObject: IUnknown): HResult;
    function GetObject(var guidServiceId: TGUID; var ObjectCLSID: TGUID;
      var ObjectIID: TGUID; fReleaseWhenLastExternalRefReleased: Integer;
      out ppObject: Pointer): HResult;
    property DefaultInterface: ISpResourceManager read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpStreamFormatConverter provides a Create and CreateRemote method to
  // create instances of the default interface ISpStreamFormatConverter exposed by
  // the CoClass SpStreamFormatConverter. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpStreamFormatConverter = class
    class function Create: ISpStreamFormatConverter;
    class function CreateRemote(const MachineName: string)
      : ISpStreamFormatConverter;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpStreamFormatConverter
  // Help String      : FormatConverter Class
  // Default Interface: ISpStreamFormatConverter
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (530) CanCreate Hidden Restricted
  // *********************************************************************//
  TSpStreamFormatConverter = class(TOleServer)
  private
    FIntf: ISpStreamFormatConverter;
    function GetDefaultInterface: ISpStreamFormatConverter;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpStreamFormatConverter);
    procedure Disconnect; override;
    function RemoteRead(out pv: Byte; cb: LongWord;
      out pcbRead: LongWord): HResult;
    function RemoteWrite(var pv: Byte; cb: LongWord;
      out pcbWritten: LongWord): HResult;
    function RemoteSeek(dlibMove: _LARGE_INTEGER; dwOrigin: LongWord;
      out plibNewPosition: _ULARGE_INTEGER): HResult;
    function SetSize(libNewSize: _ULARGE_INTEGER): HResult;
    function RemoteCopyTo(const pstm: IStream; cb: _ULARGE_INTEGER;
      out pcbRead: _ULARGE_INTEGER; out pcbWritten: _ULARGE_INTEGER): HResult;
    function Commit(grfCommitFlags: LongWord): HResult;
    function Revert: HResult;
    function LockRegion(libOffset: _ULARGE_INTEGER; cb: _ULARGE_INTEGER;
      dwLockType: LongWord): HResult;
    function UnlockRegion(libOffset: _ULARGE_INTEGER; cb: _ULARGE_INTEGER;
      dwLockType: LongWord): HResult;
    function Stat(out pstatstg: tagSTATSTG; grfStatFlag: LongWord): HResult;
    function Clone(out ppstm: IStream): HResult;
    function GetFormat(var pguidFormatId: TGUID;
      out ppCoMemWaveFormatEx: PUserType2): HResult;
    function SetBaseStream(const pStream: ISpStreamFormat;
      fSetFormatToBaseStreamFormat: Integer;
      fWriteToBaseStream: Integer): HResult;
    function GetBaseStream(out ppStream: ISpStreamFormat): HResult;
    function SetFormat(var rguidFormatIdOfConvertedStream: TGUID;
      var pWaveFormatExOfConvertedStream: WAVEFORMATEX): HResult;
    function ResetSeekPosition: HResult;
    function ScaleConvertedToBaseOffset(ullOffsetConvertedStream: Largeuint;
      out pullOffsetBaseStream: Largeuint): HResult;
    function ScaleBaseToConvertedOffset(ullOffsetBaseStream: Largeuint;
      out pullOffsetConvertedStream: Largeuint): HResult;
    property DefaultInterface: ISpStreamFormatConverter
      read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpMMAudioEnum provides a Create and CreateRemote method to
  // create instances of the default interface IEnumSpObjectTokens exposed by
  // the CoClass SpMMAudioEnum. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpMMAudioEnum = class
    class function Create: IEnumSpObjectTokens;
    class function CreateRemote(const MachineName: string): IEnumSpObjectTokens;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpMMAudioEnum
  // Help String      : SpMMAudioEnum Class
  // Default Interface: IEnumSpObjectTokens
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (530) CanCreate Hidden Restricted
  // *********************************************************************//
  TSpMMAudioEnum = class(TOleServer)
  private
    FIntf: IEnumSpObjectTokens;
    function GetDefaultInterface: IEnumSpObjectTokens;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: IEnumSpObjectTokens);
    procedure Disconnect; override;
    function Next(celt: LongWord; out pelt: ISpObjectToken;
      out pceltFetched: LongWord): HResult;
    function Skip(celt: LongWord): HResult;
    function Reset: HResult;
    function Clone(out ppEnum: IEnumSpObjectTokens): HResult;
    function Item(Index: LongWord; out ppToken: ISpObjectToken): HResult;
    function GetCount(out pCount: LongWord): HResult;
    property DefaultInterface: IEnumSpObjectTokens read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpMMAudioIn provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechMMSysAudio exposed by
  // the CoClass SpMMAudioIn. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpMMAudioIn = class
    class function Create: ISpeechMMSysAudio;
    class function CreateRemote(const MachineName: string): ISpeechMMSysAudio;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpMMAudioIn
  // Help String      : SpMMAudioIn Class
  // Default Interface: ISpeechMMSysAudio
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpMMAudioIn = class(TOleServer)
  private
    FIntf: ISpeechMMSysAudio;
    function GetDefaultInterface: ISpeechMMSysAudio;
  protected
    procedure InitServerData; override;
    function Get_Format: ISpeechAudioFormat;
    procedure _Set_Format(const AudioFormat: ISpeechAudioFormat);
    function Get_Status: ISpeechAudioStatus;
    function Get_BufferInfo: ISpeechAudioBufferInfo;
    function Get_DefaultFormat: ISpeechAudioFormat;
    function Get_Volume: Integer;
    procedure Set_Volume(Volume: Integer);
    function Get_BufferNotifySize: Integer;
    procedure Set_BufferNotifySize(BufferNotifySize: Integer);
    function Get_EventHandle: Integer;
    function Get_DeviceId: Integer;
    procedure Set_DeviceId(DeviceId: Integer);
    function Get_LineId: Integer;
    procedure Set_LineId(LineId: Integer);
    function Get_MMHandle: Integer;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechMMSysAudio);
    procedure Disconnect; override;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer): Integer;
    function Write(Buffer: OleVariant): Integer;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant;
    procedure SetState(State: SpeechAudioState);
    property DefaultInterface: ISpeechMMSysAudio read GetDefaultInterface;
    property Format: ISpeechAudioFormat read Get_Format write _Set_Format;
    property Status: ISpeechAudioStatus read Get_Status;
    property BufferInfo: ISpeechAudioBufferInfo read Get_BufferInfo;
    property DefaultFormat: ISpeechAudioFormat read Get_DefaultFormat;
    property EventHandle: Integer read Get_EventHandle;
    property MMHandle: Integer read Get_MMHandle;
    property Volume: Integer read Get_Volume write Set_Volume;
    property BufferNotifySize: Integer read Get_BufferNotifySize
      write Set_BufferNotifySize;
    property DeviceId: Integer read Get_DeviceId write Set_DeviceId;
    property LineId: Integer read Get_LineId write Set_LineId;
  published
  end;

  // *********************************************************************//
  // The Class CoSpMMAudioOut provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechMMSysAudio exposed by
  // the CoClass SpMMAudioOut. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpMMAudioOut = class
    class function Create: ISpeechMMSysAudio;
    class function CreateRemote(const MachineName: string): ISpeechMMSysAudio;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpMMAudioOut
  // Help String      : SpMMAudioOut Class
  // Default Interface: ISpeechMMSysAudio
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpMMAudioOut = class(TOleServer)
  private
    FIntf: ISpeechMMSysAudio;
    function GetDefaultInterface: ISpeechMMSysAudio;
  protected
    procedure InitServerData; override;
    function Get_Format: ISpeechAudioFormat;
    procedure _Set_Format(const AudioFormat: ISpeechAudioFormat);
    function Get_Status: ISpeechAudioStatus;
    function Get_BufferInfo: ISpeechAudioBufferInfo;
    function Get_DefaultFormat: ISpeechAudioFormat;
    function Get_Volume: Integer;
    procedure Set_Volume(Volume: Integer);
    function Get_BufferNotifySize: Integer;
    procedure Set_BufferNotifySize(BufferNotifySize: Integer);
    function Get_EventHandle: Integer;
    function Get_DeviceId: Integer;
    procedure Set_DeviceId(DeviceId: Integer);
    function Get_LineId: Integer;
    procedure Set_LineId(LineId: Integer);
    function Get_MMHandle: Integer;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechMMSysAudio);
    procedure Disconnect; override;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer): Integer;
    function Write(Buffer: OleVariant): Integer;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant;
    procedure SetState(State: SpeechAudioState);
    property DefaultInterface: ISpeechMMSysAudio read GetDefaultInterface;
    property Format: ISpeechAudioFormat read Get_Format write _Set_Format;
    property Status: ISpeechAudioStatus read Get_Status;
    property BufferInfo: ISpeechAudioBufferInfo read Get_BufferInfo;
    property DefaultFormat: ISpeechAudioFormat read Get_DefaultFormat;
    property EventHandle: Integer read Get_EventHandle;
    property MMHandle: Integer read Get_MMHandle;
    property Volume: Integer read Get_Volume write Set_Volume;
    property BufferNotifySize: Integer read Get_BufferNotifySize
      write Set_BufferNotifySize;
    property DeviceId: Integer read Get_DeviceId write Set_DeviceId;
    property LineId: Integer read Get_LineId write Set_LineId;
  published
  end;

  // *********************************************************************//
  // The Class CoSpStream provides a Create and CreateRemote method to
  // create instances of the default interface ISpStream exposed by
  // the CoClass SpStream. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpStream = class
    class function Create: ISpStream;
    class function CreateRemote(const MachineName: string): ISpStream;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpStream
  // Help String      : SpStream Class
  // Default Interface: ISpStream
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (530) CanCreate Hidden Restricted
  // *********************************************************************//
  TSpStream = class(TOleServer)
  private
    FIntf: ISpStream;
    function GetDefaultInterface: ISpStream;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpStream);
    procedure Disconnect; override;
    function RemoteRead(out pv: Byte; cb: LongWord;
      out pcbRead: LongWord): HResult;
    function RemoteWrite(var pv: Byte; cb: LongWord;
      out pcbWritten: LongWord): HResult;
    function RemoteSeek(dlibMove: _LARGE_INTEGER; dwOrigin: LongWord;
      out plibNewPosition: _ULARGE_INTEGER): HResult;
    function SetSize(libNewSize: _ULARGE_INTEGER): HResult;
    function RemoteCopyTo(const pstm: IStream; cb: _ULARGE_INTEGER;
      out pcbRead: _ULARGE_INTEGER; out pcbWritten: _ULARGE_INTEGER): HResult;
    function Commit(grfCommitFlags: LongWord): HResult;
    function Revert: HResult;
    function LockRegion(libOffset: _ULARGE_INTEGER; cb: _ULARGE_INTEGER;
      dwLockType: LongWord): HResult;
    function UnlockRegion(libOffset: _ULARGE_INTEGER; cb: _ULARGE_INTEGER;
      dwLockType: LongWord): HResult;
    function Stat(out pstatstg: tagSTATSTG; grfStatFlag: LongWord): HResult;
    function Clone(out ppstm: IStream): HResult;
    function GetFormat(var pguidFormatId: TGUID;
      out ppCoMemWaveFormatEx: PUserType2): HResult;
    function SetBaseStream(const pStream: IStream; var rguidFormat: TGUID;
      var pWaveFormatEx: WAVEFORMATEX): HResult;
    function GetBaseStream(out ppStream: IStream): HResult;
    function BindToFile(pszFileName: PWideChar; eMode: SPFILEMODE;
      var pFormatId: TGUID; var pWaveFormatEx: WAVEFORMATEX;
      ullEventInterest: Largeuint): HResult;
    function Close: HResult;
    property DefaultInterface: ISpStream read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpVoice provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechVoice exposed by
  // the CoClass SpVoice. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpVoice = class
    class function Create: ISpeechVoice;
    class function CreateRemote(const MachineName: string): ISpeechVoice;
  end;

  TSpVoiceStartStream = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant) of object;
  TSpVoiceEndStream = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant) of object;
  TSpVoiceVoiceChange = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant; const VoiceObjectToken: ISpeechObjectToken)
    of object;
  TSpVoiceBookmark = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant; const Bookmark: WideString; BookmarkId: Integer)
    of object;
  TSpVoiceWord = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant; CharacterPosition: Integer; Length: Integer)
    of object;
  TSpVoiceSentence = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant; CharacterPosition: Integer; Length: Integer)
    of object;
  TSpVoicePhoneme = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant; Duration: Integer; NextPhoneId: Smallint;
    Feature: SpeechVisemeFeature; CurrentPhoneId: Smallint) of object;
  TSpVoiceViseme = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant; Duration: Integer;
    NextVisemeId: SpeechVisemeType; Feature: SpeechVisemeFeature;
    CurrentVisemeId: SpeechVisemeType) of object;
  TSpVoiceAudioLevel = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: OleVariant; AudioLevel: Integer) of object;
  TSpVoiceEnginePrivate = procedure(ASender: TObject; StreamNumber: Integer;
    StreamPosition: Integer; EngineData: OleVariant) of object;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpVoice
  // Help String      : SpVoice Class
  // Default Interface: ISpeechVoice
  // Def. Intf. DISP? : No
  // Event   Interface: _ISpeechVoiceEvents
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpVoice = class(TOleServer)
  private
    FOnStartStream: TSpVoiceStartStream;
    FOnEndStream: TSpVoiceEndStream;
    FOnVoiceChange: TSpVoiceVoiceChange;
    FOnBookmark: TSpVoiceBookmark;
    FOnWord: TSpVoiceWord;
    FOnSentence: TSpVoiceSentence;
    FOnPhoneme: TSpVoicePhoneme;
    FOnViseme: TSpVoiceViseme;
    FOnAudioLevel: TSpVoiceAudioLevel;
    FOnEnginePrivate: TSpVoiceEnginePrivate;
    FIntf: ISpeechVoice;
    function GetDefaultInterface: ISpeechVoice;
  protected
    procedure InitServerData; override;
    procedure InvokeEvent(dispid: TDispID; var Params: TVariantArray); override;
    function Get_Status: ISpeechVoiceStatus;
    function Get_Voice: ISpeechObjectToken;
    procedure _Set_Voice(const Voice: ISpeechObjectToken);
    function Get_AudioOutput: ISpeechObjectToken;
    procedure _Set_AudioOutput(const AudioOutput: ISpeechObjectToken);
    function Get_AudioOutputStream: ISpeechBaseStream;
    procedure _Set_AudioOutputStream(const AudioOutputStream
      : ISpeechBaseStream);
    function Get_Rate: Integer;
    procedure Set_Rate(Rate: Integer);
    function Get_Volume: Integer;
    procedure Set_Volume(Volume: Integer);
    procedure Set_AllowAudioOutputFormatChangesOnNextSet(Allow: WordBool);
    function Get_AllowAudioOutputFormatChangesOnNextSet: WordBool;
    function Get_EventInterests: SpeechVoiceEvents;
    procedure Set_EventInterests(EventInterestFlags: SpeechVoiceEvents);
    procedure Set_Priority(Priority: SpeechVoicePriority);
    function Get_Priority: SpeechVoicePriority;
    procedure Set_AlertBoundary(Boundary: SpeechVoiceEvents);
    function Get_AlertBoundary: SpeechVoiceEvents;
    procedure Set_SynchronousSpeakTimeout(msTimeout: Integer);
    function Get_SynchronousSpeakTimeout: Integer;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechVoice);
    procedure Disconnect; override;
    function Speak(const Text: WideString;
      Flags: SpeechVoiceSpeakFlags): Integer;
    function SpeakStream(const Stream: ISpeechBaseStream;
      Flags: SpeechVoiceSpeakFlags): Integer;
    procedure Pause;
    procedure Resume;
    function Skip(const type_: WideString; NumItems: Integer): Integer;
    function GetVoices(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    function GetAudioOutputs(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    function WaitUntilDone(msTimeout: Integer): WordBool;
    function SpeakCompleteEvent: Integer;
    function IsUISupported(const TypeOfUI: WideString): WordBool; overload;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant): WordBool; overload;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString); overload;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant); overload;
    property DefaultInterface: ISpeechVoice read GetDefaultInterface;
    property Status: ISpeechVoiceStatus read Get_Status;
    property Voice: ISpeechObjectToken read Get_Voice write _Set_Voice;
    property AudioOutput: ISpeechObjectToken read Get_AudioOutput
      write _Set_AudioOutput;
    property AudioOutputStream: ISpeechBaseStream read Get_AudioOutputStream
      write _Set_AudioOutputStream;
    property AllowAudioOutputFormatChangesOnNextSet: WordBool
      read Get_AllowAudioOutputFormatChangesOnNextSet
      write Set_AllowAudioOutputFormatChangesOnNextSet;
    property Rate: Integer read Get_Rate write Set_Rate;
    property Volume: Integer read Get_Volume write Set_Volume;
    property EventInterests: SpeechVoiceEvents read Get_EventInterests
      write Set_EventInterests;
    property Priority: SpeechVoicePriority read Get_Priority write Set_Priority;
    property AlertBoundary: SpeechVoiceEvents read Get_AlertBoundary
      write Set_AlertBoundary;
    property SynchronousSpeakTimeout: Integer read Get_SynchronousSpeakTimeout
      write Set_SynchronousSpeakTimeout;
  published
    property OnStartStream: TSpVoiceStartStream read FOnStartStream
      write FOnStartStream;
    property OnEndStream: TSpVoiceEndStream read FOnEndStream
      write FOnEndStream;
    property OnVoiceChange: TSpVoiceVoiceChange read FOnVoiceChange
      write FOnVoiceChange;
    property OnBookmark: TSpVoiceBookmark read FOnBookmark write FOnBookmark;
    property OnWord: TSpVoiceWord read FOnWord write FOnWord;
    property OnSentence: TSpVoiceSentence read FOnSentence write FOnSentence;
    property OnPhoneme: TSpVoicePhoneme read FOnPhoneme write FOnPhoneme;
    property OnViseme: TSpVoiceViseme read FOnViseme write FOnViseme;
    property OnAudioLevel: TSpVoiceAudioLevel read FOnAudioLevel
      write FOnAudioLevel;
    property OnEnginePrivate: TSpVoiceEnginePrivate read FOnEnginePrivate
      write FOnEnginePrivate;
  end;

  // *********************************************************************//
  // The Class CoSpSharedRecoContext provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechRecoContext exposed by
  // the CoClass SpSharedRecoContext. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpSharedRecoContext = class
    class function Create: ISpeechRecoContext;
    class function CreateRemote(const MachineName: string): ISpeechRecoContext;
  end;

  TSpSharedRecoContextStartStream = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpSharedRecoContextEndStream = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; StreamReleased: WordBool)
    of object;
  TSpSharedRecoContextBookmark = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; BookmarkId: OleVariant;
    Options: SpeechBookmarkOptions) of object;
  TSpSharedRecoContextSoundStart = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpSharedRecoContextSoundEnd = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpSharedRecoContextPhraseStart = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpSharedRecoContextRecognition = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    RecognitionType: SpeechRecognitionType; const Result: ISpeechRecoResult)
    of object;
  TSpSharedRecoContextHypothesis = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    const Result: ISpeechRecoResult) of object;
  TSpSharedRecoContextPropertyNumberChange = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    const PropertyName: WideString; NewNumberValue: Integer) of object;
  TSpSharedRecoContextPropertyStringChange = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    const PropertyName: WideString; const NewStringValue: WideString) of object;
  TSpSharedRecoContextFalseRecognition = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    const Result: ISpeechRecoResult) of object;
  TSpSharedRecoContextInterference = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    Interference: SpeechInterference) of object;
  TSpSharedRecoContextRequestUI = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; const UIType: WideString)
    of object;
  TSpSharedRecoContextRecognizerStateChange = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    NewState: SpeechRecognizerState) of object;
  TSpSharedRecoContextAdaptation = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpSharedRecoContextRecognitionForOtherContext = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpSharedRecoContextAudioLevel = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; AudioLevel: Integer)
    of object;
  TSpSharedRecoContextEnginePrivate = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; EngineData: OleVariant)
    of object;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpSharedRecoContext
  // Help String      : SpSharedRecoContext Class
  // Default Interface: ISpeechRecoContext
  // Def. Intf. DISP? : No
  // Event   Interface: _ISpeechRecoContextEvents
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpSharedRecoContext = class(TOleServer)
  private
    FOnStartStream: TSpSharedRecoContextStartStream;
    FOnEndStream: TSpSharedRecoContextEndStream;
    FOnBookmark: TSpSharedRecoContextBookmark;
    FOnSoundStart: TSpSharedRecoContextSoundStart;
    FOnSoundEnd: TSpSharedRecoContextSoundEnd;
    FOnPhraseStart: TSpSharedRecoContextPhraseStart;
    FOnRecognition: TSpSharedRecoContextRecognition;
    FOnHypothesis: TSpSharedRecoContextHypothesis;
    FOnPropertyNumberChange: TSpSharedRecoContextPropertyNumberChange;
    FOnPropertyStringChange: TSpSharedRecoContextPropertyStringChange;
    FOnFalseRecognition: TSpSharedRecoContextFalseRecognition;
    FOnInterference: TSpSharedRecoContextInterference;
    FOnRequestUI: TSpSharedRecoContextRequestUI;
    FOnRecognizerStateChange: TSpSharedRecoContextRecognizerStateChange;
    FOnAdaptation: TSpSharedRecoContextAdaptation;
    FOnRecognitionForOtherContext
      : TSpSharedRecoContextRecognitionForOtherContext;
    FOnAudioLevel: TSpSharedRecoContextAudioLevel;
    FOnEnginePrivate: TSpSharedRecoContextEnginePrivate;
    FIntf: ISpeechRecoContext;
    function GetDefaultInterface: ISpeechRecoContext;
  protected
    procedure InitServerData; override;
    procedure InvokeEvent(dispid: TDispID; var Params: TVariantArray); override;
    function Get_Recognizer: ISpeechRecognizer;
    function Get_AudioInputInterferenceStatus: SpeechInterference;
    function Get_RequestedUIType: WideString;
    procedure _Set_Voice(const Voice: ISpeechVoice);
    function Get_Voice: ISpeechVoice;
    procedure Set_AllowVoiceFormatMatchingOnNextSet(pAllow: WordBool);
    function Get_AllowVoiceFormatMatchingOnNextSet: WordBool;
    procedure Set_VoicePurgeEvent(EventInterest: SpeechRecoEvents);
    function Get_VoicePurgeEvent: SpeechRecoEvents;
    procedure Set_EventInterests(EventInterest: SpeechRecoEvents);
    function Get_EventInterests: SpeechRecoEvents;
    procedure Set_CmdMaxAlternates(MaxAlternates: Integer);
    function Get_CmdMaxAlternates: Integer;
    procedure Set_State(State: SpeechRecoContextState);
    function Get_State: SpeechRecoContextState;
    procedure Set_RetainedAudio(Option: SpeechRetainedAudioOptions);
    function Get_RetainedAudio: SpeechRetainedAudioOptions;
    procedure _Set_RetainedAudioFormat(const Format: ISpeechAudioFormat);
    function Get_RetainedAudioFormat: ISpeechAudioFormat;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechRecoContext);
    procedure Disconnect; override;
    procedure Pause;
    procedure Resume;
    function CreateGrammar: ISpeechRecoGrammar; overload;
    function CreateGrammar(GrammarId: OleVariant): ISpeechRecoGrammar; overload;
    function CreateResultFromMemory(const ResultBlock: OleVariant)
      : ISpeechRecoResult;
    procedure Bookmark(Options: SpeechBookmarkOptions; StreamPos: OleVariant;
      BookmarkId: OleVariant);
    procedure SetAdaptationData(const AdaptationString: WideString);
    property DefaultInterface: ISpeechRecoContext read GetDefaultInterface;
    property Recognizer: ISpeechRecognizer read Get_Recognizer;
    property AudioInputInterferenceStatus: SpeechInterference
      read Get_AudioInputInterferenceStatus;
    property RequestedUIType: WideString read Get_RequestedUIType;
    property Voice: ISpeechVoice read Get_Voice write _Set_Voice;
    property AllowVoiceFormatMatchingOnNextSet: WordBool
      read Get_AllowVoiceFormatMatchingOnNextSet
      write Set_AllowVoiceFormatMatchingOnNextSet;
    property RetainedAudioFormat: ISpeechAudioFormat
      read Get_RetainedAudioFormat write _Set_RetainedAudioFormat;
    property VoicePurgeEvent: SpeechRecoEvents read Get_VoicePurgeEvent
      write Set_VoicePurgeEvent;
    property EventInterests: SpeechRecoEvents read Get_EventInterests
      write Set_EventInterests;
    property CmdMaxAlternates: Integer read Get_CmdMaxAlternates
      write Set_CmdMaxAlternates;
    property State: SpeechRecoContextState read Get_State write Set_State;
    property RetainedAudio: SpeechRetainedAudioOptions read Get_RetainedAudio
      write Set_RetainedAudio;
  published
    property OnStartStream: TSpSharedRecoContextStartStream read FOnStartStream
      write FOnStartStream;
    property OnEndStream: TSpSharedRecoContextEndStream read FOnEndStream
      write FOnEndStream;
    property OnBookmark: TSpSharedRecoContextBookmark read FOnBookmark
      write FOnBookmark;
    property OnSoundStart: TSpSharedRecoContextSoundStart read FOnSoundStart
      write FOnSoundStart;
    property OnSoundEnd: TSpSharedRecoContextSoundEnd read FOnSoundEnd
      write FOnSoundEnd;
    property OnPhraseStart: TSpSharedRecoContextPhraseStart read FOnPhraseStart
      write FOnPhraseStart;
    property OnRecognition: TSpSharedRecoContextRecognition read FOnRecognition
      write FOnRecognition;
    property OnHypothesis: TSpSharedRecoContextHypothesis read FOnHypothesis
      write FOnHypothesis;
    property OnPropertyNumberChange: TSpSharedRecoContextPropertyNumberChange
      read FOnPropertyNumberChange write FOnPropertyNumberChange;
    property OnPropertyStringChange: TSpSharedRecoContextPropertyStringChange
      read FOnPropertyStringChange write FOnPropertyStringChange;
    property OnFalseRecognition: TSpSharedRecoContextFalseRecognition
      read FOnFalseRecognition write FOnFalseRecognition;
    property OnInterference: TSpSharedRecoContextInterference
      read FOnInterference write FOnInterference;
    property OnRequestUI: TSpSharedRecoContextRequestUI read FOnRequestUI
      write FOnRequestUI;
    property OnRecognizerStateChange: TSpSharedRecoContextRecognizerStateChange
      read FOnRecognizerStateChange write FOnRecognizerStateChange;
    property OnAdaptation: TSpSharedRecoContextAdaptation read FOnAdaptation
      write FOnAdaptation;
    property OnRecognitionForOtherContext
      : TSpSharedRecoContextRecognitionForOtherContext
      read FOnRecognitionForOtherContext write FOnRecognitionForOtherContext;
    property OnAudioLevel: TSpSharedRecoContextAudioLevel read FOnAudioLevel
      write FOnAudioLevel;
    property OnEnginePrivate: TSpSharedRecoContextEnginePrivate
      read FOnEnginePrivate write FOnEnginePrivate;
  end;

  // *********************************************************************//
  // The Class CoSpInprocRecognizer provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechRecognizer exposed by
  // the CoClass SpInprocRecognizer. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpInprocRecognizer = class
    class function Create: ISpeechRecognizer;
    class function CreateRemote(const MachineName: string): ISpeechRecognizer;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpInprocRecognizer
  // Help String      : SpInprocRecognizer Class
  // Default Interface: ISpeechRecognizer
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpInprocRecognizer = class(TOleServer)
  private
    FIntf: ISpeechRecognizer;
    function GetDefaultInterface: ISpeechRecognizer;
  protected
    procedure InitServerData; override;
    procedure _Set_Recognizer(const Recognizer: ISpeechObjectToken);
    function Get_Recognizer: ISpeechObjectToken;
    procedure Set_AllowAudioInputFormatChangesOnNextSet(Allow: WordBool);
    function Get_AllowAudioInputFormatChangesOnNextSet: WordBool;
    procedure _Set_AudioInput(const AudioInput: ISpeechObjectToken);
    function Get_AudioInput: ISpeechObjectToken;
    procedure _Set_AudioInputStream(const AudioInputStream: ISpeechBaseStream);
    function Get_AudioInputStream: ISpeechBaseStream;
    function Get_IsShared: WordBool;
    procedure Set_State(State: SpeechRecognizerState);
    function Get_State: SpeechRecognizerState;
    function Get_Status: ISpeechRecognizerStatus;
    procedure _Set_Profile(const Profile: ISpeechObjectToken);
    function Get_Profile: ISpeechObjectToken;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechRecognizer);
    procedure Disconnect; override;
    procedure EmulateRecognition(TextElements: OleVariant;
      const ElementDisplayAttributes: OleVariant; LanguageId: Integer);
    function CreateRecoContext: ISpeechRecoContext;
    function GetFormat(type_: SpeechFormatType): ISpeechAudioFormat;
    function SetPropertyNumber(const Name: WideString; Value: Integer)
      : WordBool;
    function GetPropertyNumber(const Name: WideString; var Value: Integer)
      : WordBool;
    function SetPropertyString(const Name: WideString; const Value: WideString)
      : WordBool;
    function GetPropertyString(const Name: WideString; var Value: WideString)
      : WordBool;
    function IsUISupported(const TypeOfUI: WideString): WordBool; overload;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant): WordBool; overload;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString); overload;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant); overload;
    function GetRecognizers(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    function GetAudioInputs(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    function GetProfiles(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    property DefaultInterface: ISpeechRecognizer read GetDefaultInterface;
    property Recognizer: ISpeechObjectToken read Get_Recognizer
      write _Set_Recognizer;
    property AllowAudioInputFormatChangesOnNextSet: WordBool
      read Get_AllowAudioInputFormatChangesOnNextSet
      write Set_AllowAudioInputFormatChangesOnNextSet;
    property AudioInput: ISpeechObjectToken read Get_AudioInput
      write _Set_AudioInput;
    property AudioInputStream: ISpeechBaseStream read Get_AudioInputStream
      write _Set_AudioInputStream;
    property IsShared: WordBool read Get_IsShared;
    property Status: ISpeechRecognizerStatus read Get_Status;
    property Profile: ISpeechObjectToken read Get_Profile write _Set_Profile;
    property State: SpeechRecognizerState read Get_State write Set_State;
  published
  end;

  // *********************************************************************//
  // The Class CoSpSharedRecognizer provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechRecognizer exposed by
  // the CoClass SpSharedRecognizer. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpSharedRecognizer = class
    class function Create: ISpeechRecognizer;
    class function CreateRemote(const MachineName: string): ISpeechRecognizer;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpSharedRecognizer
  // Help String      : SpSharedRecognizer Class
  // Default Interface: ISpeechRecognizer
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpSharedRecognizer = class(TOleServer)
  private
    FIntf: ISpeechRecognizer;
    function GetDefaultInterface: ISpeechRecognizer;
  protected
    procedure InitServerData; override;
    procedure _Set_Recognizer(const Recognizer: ISpeechObjectToken);
    function Get_Recognizer: ISpeechObjectToken;
    procedure Set_AllowAudioInputFormatChangesOnNextSet(Allow: WordBool);
    function Get_AllowAudioInputFormatChangesOnNextSet: WordBool;
    procedure _Set_AudioInput(const AudioInput: ISpeechObjectToken);
    function Get_AudioInput: ISpeechObjectToken;
    procedure _Set_AudioInputStream(const AudioInputStream: ISpeechBaseStream);
    function Get_AudioInputStream: ISpeechBaseStream;
    function Get_IsShared: WordBool;
    procedure Set_State(State: SpeechRecognizerState);
    function Get_State: SpeechRecognizerState;
    function Get_Status: ISpeechRecognizerStatus;
    procedure _Set_Profile(const Profile: ISpeechObjectToken);
    function Get_Profile: ISpeechObjectToken;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechRecognizer);
    procedure Disconnect; override;
    procedure EmulateRecognition(TextElements: OleVariant;
      const ElementDisplayAttributes: OleVariant; LanguageId: Integer);
    function CreateRecoContext: ISpeechRecoContext;
    function GetFormat(type_: SpeechFormatType): ISpeechAudioFormat;
    function SetPropertyNumber(const Name: WideString; Value: Integer)
      : WordBool;
    function GetPropertyNumber(const Name: WideString; var Value: Integer)
      : WordBool;
    function SetPropertyString(const Name: WideString; const Value: WideString)
      : WordBool;
    function GetPropertyString(const Name: WideString; var Value: WideString)
      : WordBool;
    function IsUISupported(const TypeOfUI: WideString): WordBool; overload;
    function IsUISupported(const TypeOfUI: WideString;
      const ExtraData: OleVariant): WordBool; overload;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString); overload;
    procedure DisplayUI(hWndParent: Integer; const Title: WideString;
      const TypeOfUI: WideString; const ExtraData: OleVariant); overload;
    function GetRecognizers(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    function GetAudioInputs(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    function GetProfiles(const RequiredAttributes: WideString;
      const OptionalAttributes: WideString): ISpeechObjectTokens;
    property DefaultInterface: ISpeechRecognizer read GetDefaultInterface;
    property Recognizer: ISpeechObjectToken read Get_Recognizer
      write _Set_Recognizer;
    property AllowAudioInputFormatChangesOnNextSet: WordBool
      read Get_AllowAudioInputFormatChangesOnNextSet
      write Set_AllowAudioInputFormatChangesOnNextSet;
    property AudioInput: ISpeechObjectToken read Get_AudioInput
      write _Set_AudioInput;
    property AudioInputStream: ISpeechBaseStream read Get_AudioInputStream
      write _Set_AudioInputStream;
    property IsShared: WordBool read Get_IsShared;
    property Status: ISpeechRecognizerStatus read Get_Status;
    property Profile: ISpeechObjectToken read Get_Profile write _Set_Profile;
    property State: SpeechRecognizerState read Get_State write Set_State;
  published
  end;

  // *********************************************************************//
  // The Class CoSpLexicon provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechLexicon exposed by
  // the CoClass SpLexicon. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpLexicon = class
    class function Create: ISpeechLexicon;
    class function CreateRemote(const MachineName: string): ISpeechLexicon;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpLexicon
  // Help String      : SpLexicon Class
  // Default Interface: ISpeechLexicon
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpLexicon = class(TOleServer)
  private
    FIntf: ISpeechLexicon;
    function GetDefaultInterface: ISpeechLexicon;
  protected
    procedure InitServerData; override;
    function Get_GenerationId: Integer;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechLexicon);
    procedure Disconnect; override;
    function GetWords(Flags: SpeechLexiconType; out GenerationId: Integer)
      : ISpeechLexiconWords;
    procedure AddPronunciation(const bstrWord: WideString; LangId: Integer;
      PartOfSpeech: SpeechPartOfSpeech; const bstrPronunciation: WideString);
    procedure AddPronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech); overload;
    procedure AddPronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
      const PhoneIds: OleVariant); overload;
    procedure RemovePronunciation(const bstrWord: WideString; LangId: Integer;
      PartOfSpeech: SpeechPartOfSpeech; const bstrPronunciation: WideString);
    procedure RemovePronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech); overload;
    procedure RemovePronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
      const PhoneIds: OleVariant); overload;
    function GetPronunciations(const bstrWord: WideString; LangId: Integer;
      TypeFlags: SpeechLexiconType): ISpeechLexiconPronunciations;
    function GetGenerationChange(var GenerationId: Integer)
      : ISpeechLexiconWords;
    property DefaultInterface: ISpeechLexicon read GetDefaultInterface;
    property GenerationId: Integer read Get_GenerationId;
  published
  end;

  // *********************************************************************//
  // The Class CoSpUnCompressedLexicon provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechLexicon exposed by
  // the CoClass SpUnCompressedLexicon. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpUnCompressedLexicon = class
    class function Create: ISpeechLexicon;
    class function CreateRemote(const MachineName: string): ISpeechLexicon;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpUnCompressedLexicon
  // Help String      : SpUnCompressedLexicon Class
  // Default Interface: ISpeechLexicon
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpUnCompressedLexicon = class(TOleServer)
  private
    FIntf: ISpeechLexicon;
    function GetDefaultInterface: ISpeechLexicon;
  protected
    procedure InitServerData; override;
    function Get_GenerationId: Integer;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechLexicon);
    procedure Disconnect; override;
    function GetWords(Flags: SpeechLexiconType; out GenerationId: Integer)
      : ISpeechLexiconWords;
    procedure AddPronunciation(const bstrWord: WideString; LangId: Integer;
      PartOfSpeech: SpeechPartOfSpeech; const bstrPronunciation: WideString);
    procedure AddPronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech); overload;
    procedure AddPronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
      const PhoneIds: OleVariant); overload;
    procedure RemovePronunciation(const bstrWord: WideString; LangId: Integer;
      PartOfSpeech: SpeechPartOfSpeech; const bstrPronunciation: WideString);
    procedure RemovePronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech); overload;
    procedure RemovePronunciationByPhoneIds(const bstrWord: WideString;
      LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
      const PhoneIds: OleVariant); overload;
    function GetPronunciations(const bstrWord: WideString; LangId: Integer;
      TypeFlags: SpeechLexiconType): ISpeechLexiconPronunciations;
    function GetGenerationChange(var GenerationId: Integer)
      : ISpeechLexiconWords;
    property DefaultInterface: ISpeechLexicon read GetDefaultInterface;
    property GenerationId: Integer read Get_GenerationId;
  published
  end;

  // *********************************************************************//
  // The Class CoSpCompressedLexicon provides a Create and CreateRemote method to
  // create instances of the default interface ISpLexicon exposed by
  // the CoClass SpCompressedLexicon. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpCompressedLexicon = class
    class function Create: ISpLexicon;
    class function CreateRemote(const MachineName: string): ISpLexicon;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpCompressedLexicon
  // Help String      : SpCompressedLexicon Class
  // Default Interface: ISpLexicon
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (530) CanCreate Hidden Restricted
  // *********************************************************************//
  TSpCompressedLexicon = class(TOleServer)
  private
    FIntf: ISpLexicon;
    function GetDefaultInterface: ISpLexicon;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpLexicon);
    procedure Disconnect; override;
    function GetPronunciations(pszWord: PWideChar; LangId: Word;
      dwFlags: LongWord; var pWordPronunciationList
      : SPWORDPRONUNCIATIONLIST): HResult;
    function AddPronunciation(pszWord: PWideChar; LangId: Word;
      ePartOfSpeech: SPPARTOFSPEECH; pszPronunciation: PWideChar): HResult;
    function RemovePronunciation(pszWord: PWideChar; LangId: Word;
      ePartOfSpeech: SPPARTOFSPEECH; pszPronunciation: PWideChar): HResult;
    function GetGeneration(out pdwGeneration: LongWord): HResult;
    function GetGenerationChange(dwFlags: LongWord; var pdwGeneration: LongWord;
      var pWordList: SPWORDLIST): HResult;
    function GetWords(dwFlags: LongWord; var pdwGeneration: LongWord;
      var pdwCookie: LongWord; var pWordList: SPWORDLIST): HResult;
    property DefaultInterface: ISpLexicon read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpShortcut provides a Create and CreateRemote method to
  // create instances of the default interface ISpShortcut exposed by
  // the CoClass SpShortcut. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpShortcut = class
    class function Create: ISpShortcut;
    class function CreateRemote(const MachineName: string): ISpShortcut;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpShortcut
  // Help String      : SpShortcut Class
  // Default Interface: ISpShortcut
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpShortcut = class(TOleServer)
  private
    FIntf: ISpShortcut;
    function GetDefaultInterface: ISpShortcut;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpShortcut);
    procedure Disconnect; override;
    function AddShortcut(pszDisplay: PWideChar; LangId: Word;
      pszSpoken: PWideChar; shType: SPSHORTCUTTYPE): HResult;
    function RemoveShortcut(pszDisplay: PWideChar; LangId: Word;
      pszSpoken: PWideChar; shType: SPSHORTCUTTYPE): HResult;
    function GetShortcuts(LangId: Word;
      var pShortcutpairList: SPSHORTCUTPAIRLIST): HResult;
    function GetGeneration(out pdwGeneration: LongWord): HResult;
    function GetWordsFromGenerationChange(var pdwGeneration: LongWord;
      var pWordList: SPWORDLIST): HResult;
    function GetWords(var pdwGeneration: LongWord; var pdwCookie: LongWord;
      var pWordList: SPWORDLIST): HResult;
    function GetShortcutsForGeneration(var pdwGeneration: LongWord;
      var pdwCookie: LongWord;
      var pShortcutpairList: SPSHORTCUTPAIRLIST): HResult;
    function GetGenerationChange(var pdwGeneration: LongWord;
      var pShortcutpairList: SPSHORTCUTPAIRLIST): HResult;
    property DefaultInterface: ISpShortcut read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpPhoneConverter provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechPhoneConverter exposed by
  // the CoClass SpPhoneConverter. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpPhoneConverter = class
    class function Create: ISpeechPhoneConverter;
    class function CreateRemote(const MachineName: string)
      : ISpeechPhoneConverter;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpPhoneConverter
  // Help String      : SpPhoneConverter Class
  // Default Interface: ISpeechPhoneConverter
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpPhoneConverter = class(TOleServer)
  private
    FIntf: ISpeechPhoneConverter;
    function GetDefaultInterface: ISpeechPhoneConverter;
  protected
    procedure InitServerData; override;
    function Get_LanguageId: Integer;
    procedure Set_LanguageId(LanguageId: Integer);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechPhoneConverter);
    procedure Disconnect; override;
    function PhoneToId(const Phonemes: WideString): OleVariant;
    function IdToPhone(IdArray: OleVariant): WideString;
    property DefaultInterface: ISpeechPhoneConverter read GetDefaultInterface;
    property LanguageId: Integer read Get_LanguageId write Set_LanguageId;
  published
  end;

  // *********************************************************************//
  // The Class CoSpPhoneticAlphabetConverter provides a Create and CreateRemote method to
  // create instances of the default interface ISpPhoneticAlphabetConverter exposed by
  // the CoClass SpPhoneticAlphabetConverter. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpPhoneticAlphabetConverter = class
    class function Create: ISpPhoneticAlphabetConverter;
    class function CreateRemote(const MachineName: string)
      : ISpPhoneticAlphabetConverter;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpPhoneticAlphabetConverter
  // Help String      : SpPhoneticAlphabetConverter Class
  // Default Interface: ISpPhoneticAlphabetConverter
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpPhoneticAlphabetConverter = class(TOleServer)
  private
    FIntf: ISpPhoneticAlphabetConverter;
    function GetDefaultInterface: ISpPhoneticAlphabetConverter;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpPhoneticAlphabetConverter);
    procedure Disconnect; override;
    function GetLangId(out pLangID: Word): HResult;
    function SetLangId(LangId: Word): HResult;
    function SAPI2UPS(var pszSAPIId: Word; out pszUPSId: Word;
      cMaxLength: LongWord): HResult;
    function UPS2SAPI(var pszUPSId: Word; out pszSAPIId: Word;
      cMaxLength: LongWord): HResult;
    function GetMaxConvertLength(cSrcLength: LongWord; bSAPI2UPS: Integer;
      out pcMaxDestLength: LongWord): HResult;
    property DefaultInterface: ISpPhoneticAlphabetConverter
      read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpNullPhoneConverter provides a Create and CreateRemote method to
  // create instances of the default interface ISpPhoneConverter exposed by
  // the CoClass SpNullPhoneConverter. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpNullPhoneConverter = class
    class function Create: ISpPhoneConverter;
    class function CreateRemote(const MachineName: string): ISpPhoneConverter;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpNullPhoneConverter
  // Help String      : SpNullPhoneConverter Class
  // Default Interface: ISpPhoneConverter
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (530) CanCreate Hidden Restricted
  // *********************************************************************//
  TSpNullPhoneConverter = class(TOleServer)
  private
    FIntf: ISpPhoneConverter;
    function GetDefaultInterface: ISpPhoneConverter;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpPhoneConverter);
    procedure Disconnect; override;
    function SetObjectToken(const pToken: ISpObjectToken): HResult;
    function GetObjectToken(out ppToken: ISpObjectToken): HResult;
    function PhoneToId(pszPhone: PWideChar; out pId: Word): HResult;
    function IdToPhone(pId: PWideChar; out pszPhone: Word): HResult;
    property DefaultInterface: ISpPhoneConverter read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpTextSelectionInformation provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechTextSelectionInformation exposed by
  // the CoClass SpTextSelectionInformation. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpTextSelectionInformation = class
    class function Create: ISpeechTextSelectionInformation;
    class function CreateRemote(const MachineName: string)
      : ISpeechTextSelectionInformation;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpTextSelectionInformation
  // Help String      : SpTextSelectionInformation Class
  // Default Interface: ISpeechTextSelectionInformation
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpTextSelectionInformation = class(TOleServer)
  private
    FIntf: ISpeechTextSelectionInformation;
    function GetDefaultInterface: ISpeechTextSelectionInformation;
  protected
    procedure InitServerData; override;
    procedure Set_ActiveOffset(ActiveOffset: Integer);
    function Get_ActiveOffset: Integer;
    procedure Set_ActiveLength(ActiveLength: Integer);
    function Get_ActiveLength: Integer;
    procedure Set_SelectionOffset(SelectionOffset: Integer);
    function Get_SelectionOffset: Integer;
    procedure Set_SelectionLength(SelectionLength: Integer);
    function Get_SelectionLength: Integer;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechTextSelectionInformation);
    procedure Disconnect; override;
    property DefaultInterface: ISpeechTextSelectionInformation
      read GetDefaultInterface;
    property ActiveOffset: Integer read Get_ActiveOffset write Set_ActiveOffset;
    property ActiveLength: Integer read Get_ActiveLength write Set_ActiveLength;
    property SelectionOffset: Integer read Get_SelectionOffset
      write Set_SelectionOffset;
    property SelectionLength: Integer read Get_SelectionLength
      write Set_SelectionLength;
  published
  end;

  // *********************************************************************//
  // The Class CoSpPhraseInfoBuilder provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechPhraseInfoBuilder exposed by
  // the CoClass SpPhraseInfoBuilder. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpPhraseInfoBuilder = class
    class function Create: ISpeechPhraseInfoBuilder;
    class function CreateRemote(const MachineName: string)
      : ISpeechPhraseInfoBuilder;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpPhraseInfoBuilder
  // Help String      : SpPhraseInfoBuilder Class
  // Default Interface: ISpeechPhraseInfoBuilder
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpPhraseInfoBuilder = class(TOleServer)
  private
    FIntf: ISpeechPhraseInfoBuilder;
    function GetDefaultInterface: ISpeechPhraseInfoBuilder;
  protected
    procedure InitServerData; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechPhraseInfoBuilder);
    procedure Disconnect; override;
    function RestorePhraseFromMemory(const PhraseInMemory: OleVariant)
      : ISpeechPhraseInfo;
    property DefaultInterface: ISpeechPhraseInfoBuilder
      read GetDefaultInterface;
  published
  end;

  // *********************************************************************//
  // The Class CoSpAudioFormat provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechAudioFormat exposed by
  // the CoClass SpAudioFormat. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpAudioFormat = class
    class function Create: ISpeechAudioFormat;
    class function CreateRemote(const MachineName: string): ISpeechAudioFormat;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpAudioFormat
  // Help String      : SpAudioFormat Class
  // Default Interface: ISpeechAudioFormat
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpAudioFormat = class(TOleServer)
  private
    FIntf: ISpeechAudioFormat;
    function GetDefaultInterface: ISpeechAudioFormat;
  protected
    procedure InitServerData; override;
    function Get_type_: SpeechAudioFormatType;
    procedure Set_type_(AudioFormat: SpeechAudioFormatType);
    function Get_Guid: WideString;
    procedure Set_Guid(const Guid: WideString);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechAudioFormat);
    procedure Disconnect; override;
    function GetWaveFormatEx: ISpeechWaveFormatEx;
    procedure SetWaveFormatEx(const SpeechWaveFormatEx: ISpeechWaveFormatEx);
    property DefaultInterface: ISpeechAudioFormat read GetDefaultInterface;
    property Guid: WideString read Get_Guid write Set_Guid;
    property type_: SpeechAudioFormatType read Get_type_ write Set_type_;
  published
  end;

  // *********************************************************************//
  // The Class CoSpWaveFormatEx provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechWaveFormatEx exposed by
  // the CoClass SpWaveFormatEx. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpWaveFormatEx = class
    class function Create: ISpeechWaveFormatEx;
    class function CreateRemote(const MachineName: string): ISpeechWaveFormatEx;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpWaveFormatEx
  // Help String      : SpWaveFormatEx Class
  // Default Interface: ISpeechWaveFormatEx
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpWaveFormatEx = class(TOleServer)
  private
    FIntf: ISpeechWaveFormatEx;
    function GetDefaultInterface: ISpeechWaveFormatEx;
  protected
    procedure InitServerData; override;
    function Get_FormatTag: Smallint;
    procedure Set_FormatTag(FormatTag: Smallint);
    function Get_Channels: Smallint;
    procedure Set_Channels(Channels: Smallint);
    function Get_SamplesPerSec: Integer;
    procedure Set_SamplesPerSec(SamplesPerSec: Integer);
    function Get_AvgBytesPerSec: Integer;
    procedure Set_AvgBytesPerSec(AvgBytesPerSec: Integer);
    function Get_BlockAlign: Smallint;
    procedure Set_BlockAlign(BlockAlign: Smallint);
    function Get_BitsPerSample: Smallint;
    procedure Set_BitsPerSample(BitsPerSample: Smallint);
    function Get_ExtraData: OleVariant;
    procedure Set_ExtraData(ExtraData: OleVariant);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechWaveFormatEx);
    procedure Disconnect; override;
    property DefaultInterface: ISpeechWaveFormatEx read GetDefaultInterface;
    property ExtraData: OleVariant read Get_ExtraData write Set_ExtraData;
    property FormatTag: Smallint read Get_FormatTag write Set_FormatTag;
    property Channels: Smallint read Get_Channels write Set_Channels;
    property SamplesPerSec: Integer read Get_SamplesPerSec
      write Set_SamplesPerSec;
    property AvgBytesPerSec: Integer read Get_AvgBytesPerSec
      write Set_AvgBytesPerSec;
    property BlockAlign: Smallint read Get_BlockAlign write Set_BlockAlign;
    property BitsPerSample: Smallint read Get_BitsPerSample
      write Set_BitsPerSample;
  published
  end;

  // *********************************************************************//
  // The Class CoSpInProcRecoContext provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechRecoContext exposed by
  // the CoClass SpInProcRecoContext. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpInProcRecoContext = class
    class function Create: ISpeechRecoContext;
    class function CreateRemote(const MachineName: string): ISpeechRecoContext;
  end;

  TSpInProcRecoContextStartStream = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpInProcRecoContextEndStream = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; StreamReleased: WordBool)
    of object;
  TSpInProcRecoContextBookmark = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; BookmarkId: OleVariant;
    Options: SpeechBookmarkOptions) of object;
  TSpInProcRecoContextSoundStart = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpInProcRecoContextSoundEnd = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpInProcRecoContextPhraseStart = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpInProcRecoContextRecognition = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    RecognitionType: SpeechRecognitionType; const Result: ISpeechRecoResult)
    of object;
  TSpInProcRecoContextHypothesis = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    const Result: ISpeechRecoResult) of object;
  TSpInProcRecoContextPropertyNumberChange = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    const PropertyName: WideString; NewNumberValue: Integer) of object;
  TSpInProcRecoContextPropertyStringChange = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    const PropertyName: WideString; const NewStringValue: WideString) of object;
  TSpInProcRecoContextFalseRecognition = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    const Result: ISpeechRecoResult) of object;
  TSpInProcRecoContextInterference = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    Interference: SpeechInterference) of object;
  TSpInProcRecoContextRequestUI = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; const UIType: WideString)
    of object;
  TSpInProcRecoContextRecognizerStateChange = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant;
    NewState: SpeechRecognizerState) of object;
  TSpInProcRecoContextAdaptation = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpInProcRecoContextRecognitionForOtherContext = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant) of object;
  TSpInProcRecoContextAudioLevel = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; AudioLevel: Integer)
    of object;
  TSpInProcRecoContextEnginePrivate = procedure(ASender: TObject;
    StreamNumber: Integer; StreamPosition: OleVariant; EngineData: OleVariant)
    of object;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpInProcRecoContext
  // Help String      : SpInProcRecoContext Class
  // Default Interface: ISpeechRecoContext
  // Def. Intf. DISP? : No
  // Event   Interface: _ISpeechRecoContextEvents
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpInProcRecoContext = class(TOleServer)
  private
    FOnStartStream: TSpInProcRecoContextStartStream;
    FOnEndStream: TSpInProcRecoContextEndStream;
    FOnBookmark: TSpInProcRecoContextBookmark;
    FOnSoundStart: TSpInProcRecoContextSoundStart;
    FOnSoundEnd: TSpInProcRecoContextSoundEnd;
    FOnPhraseStart: TSpInProcRecoContextPhraseStart;
    FOnRecognition: TSpInProcRecoContextRecognition;
    FOnHypothesis: TSpInProcRecoContextHypothesis;
    FOnPropertyNumberChange: TSpInProcRecoContextPropertyNumberChange;
    FOnPropertyStringChange: TSpInProcRecoContextPropertyStringChange;
    FOnFalseRecognition: TSpInProcRecoContextFalseRecognition;
    FOnInterference: TSpInProcRecoContextInterference;
    FOnRequestUI: TSpInProcRecoContextRequestUI;
    FOnRecognizerStateChange: TSpInProcRecoContextRecognizerStateChange;
    FOnAdaptation: TSpInProcRecoContextAdaptation;
    FOnRecognitionForOtherContext
      : TSpInProcRecoContextRecognitionForOtherContext;
    FOnAudioLevel: TSpInProcRecoContextAudioLevel;
    FOnEnginePrivate: TSpInProcRecoContextEnginePrivate;
    FIntf: ISpeechRecoContext;
    function GetDefaultInterface: ISpeechRecoContext;
  protected
    procedure InitServerData; override;
    procedure InvokeEvent(dispid: TDispID; var Params: TVariantArray); override;
    function Get_Recognizer: ISpeechRecognizer;
    function Get_AudioInputInterferenceStatus: SpeechInterference;
    function Get_RequestedUIType: WideString;
    procedure _Set_Voice(const Voice: ISpeechVoice);
    function Get_Voice: ISpeechVoice;
    procedure Set_AllowVoiceFormatMatchingOnNextSet(pAllow: WordBool);
    function Get_AllowVoiceFormatMatchingOnNextSet: WordBool;
    procedure Set_VoicePurgeEvent(EventInterest: SpeechRecoEvents);
    function Get_VoicePurgeEvent: SpeechRecoEvents;
    procedure Set_EventInterests(EventInterest: SpeechRecoEvents);
    function Get_EventInterests: SpeechRecoEvents;
    procedure Set_CmdMaxAlternates(MaxAlternates: Integer);
    function Get_CmdMaxAlternates: Integer;
    procedure Set_State(State: SpeechRecoContextState);
    function Get_State: SpeechRecoContextState;
    procedure Set_RetainedAudio(Option: SpeechRetainedAudioOptions);
    function Get_RetainedAudio: SpeechRetainedAudioOptions;
    procedure _Set_RetainedAudioFormat(const Format: ISpeechAudioFormat);
    function Get_RetainedAudioFormat: ISpeechAudioFormat;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechRecoContext);
    procedure Disconnect; override;
    procedure Pause;
    procedure Resume;
    function CreateGrammar: ISpeechRecoGrammar; overload;
    function CreateGrammar(GrammarId: OleVariant): ISpeechRecoGrammar; overload;
    function CreateResultFromMemory(const ResultBlock: OleVariant)
      : ISpeechRecoResult;
    procedure Bookmark(Options: SpeechBookmarkOptions; StreamPos: OleVariant;
      BookmarkId: OleVariant);
    procedure SetAdaptationData(const AdaptationString: WideString);
    property DefaultInterface: ISpeechRecoContext read GetDefaultInterface;
    property Recognizer: ISpeechRecognizer read Get_Recognizer;
    property AudioInputInterferenceStatus: SpeechInterference
      read Get_AudioInputInterferenceStatus;
    property RequestedUIType: WideString read Get_RequestedUIType;
    property Voice: ISpeechVoice read Get_Voice write _Set_Voice;
    property AllowVoiceFormatMatchingOnNextSet: WordBool
      read Get_AllowVoiceFormatMatchingOnNextSet
      write Set_AllowVoiceFormatMatchingOnNextSet;
    property RetainedAudioFormat: ISpeechAudioFormat
      read Get_RetainedAudioFormat write _Set_RetainedAudioFormat;
    property VoicePurgeEvent: SpeechRecoEvents read Get_VoicePurgeEvent
      write Set_VoicePurgeEvent;
    property EventInterests: SpeechRecoEvents read Get_EventInterests
      write Set_EventInterests;
    property CmdMaxAlternates: Integer read Get_CmdMaxAlternates
      write Set_CmdMaxAlternates;
    property State: SpeechRecoContextState read Get_State write Set_State;
    property RetainedAudio: SpeechRetainedAudioOptions read Get_RetainedAudio
      write Set_RetainedAudio;
  published
    property OnStartStream: TSpInProcRecoContextStartStream read FOnStartStream
      write FOnStartStream;
    property OnEndStream: TSpInProcRecoContextEndStream read FOnEndStream
      write FOnEndStream;
    property OnBookmark: TSpInProcRecoContextBookmark read FOnBookmark
      write FOnBookmark;
    property OnSoundStart: TSpInProcRecoContextSoundStart read FOnSoundStart
      write FOnSoundStart;
    property OnSoundEnd: TSpInProcRecoContextSoundEnd read FOnSoundEnd
      write FOnSoundEnd;
    property OnPhraseStart: TSpInProcRecoContextPhraseStart read FOnPhraseStart
      write FOnPhraseStart;
    property OnRecognition: TSpInProcRecoContextRecognition read FOnRecognition
      write FOnRecognition;
    property OnHypothesis: TSpInProcRecoContextHypothesis read FOnHypothesis
      write FOnHypothesis;
    property OnPropertyNumberChange: TSpInProcRecoContextPropertyNumberChange
      read FOnPropertyNumberChange write FOnPropertyNumberChange;
    property OnPropertyStringChange: TSpInProcRecoContextPropertyStringChange
      read FOnPropertyStringChange write FOnPropertyStringChange;
    property OnFalseRecognition: TSpInProcRecoContextFalseRecognition
      read FOnFalseRecognition write FOnFalseRecognition;
    property OnInterference: TSpInProcRecoContextInterference
      read FOnInterference write FOnInterference;
    property OnRequestUI: TSpInProcRecoContextRequestUI read FOnRequestUI
      write FOnRequestUI;
    property OnRecognizerStateChange: TSpInProcRecoContextRecognizerStateChange
      read FOnRecognizerStateChange write FOnRecognizerStateChange;
    property OnAdaptation: TSpInProcRecoContextAdaptation read FOnAdaptation
      write FOnAdaptation;
    property OnRecognitionForOtherContext
      : TSpInProcRecoContextRecognitionForOtherContext
      read FOnRecognitionForOtherContext write FOnRecognitionForOtherContext;
    property OnAudioLevel: TSpInProcRecoContextAudioLevel read FOnAudioLevel
      write FOnAudioLevel;
    property OnEnginePrivate: TSpInProcRecoContextEnginePrivate
      read FOnEnginePrivate write FOnEnginePrivate;
  end;

  // *********************************************************************//
  // The Class CoSpCustomStream provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechCustomStream exposed by
  // the CoClass SpCustomStream. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpCustomStream = class
    class function Create: ISpeechCustomStream;
    class function CreateRemote(const MachineName: string): ISpeechCustomStream;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpCustomStream
  // Help String      : SpCustomStream Class
  // Default Interface: ISpeechCustomStream
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpCustomStream = class(TOleServer)
  private
    FIntf: ISpeechCustomStream;
    function GetDefaultInterface: ISpeechCustomStream;
  protected
    procedure InitServerData; override;
    function Get_Format: ISpeechAudioFormat;
    procedure _Set_Format(const AudioFormat: ISpeechAudioFormat);
    function Get_BaseStream: IUnknown;
    procedure _Set_BaseStream(const ppUnkStream: IUnknown);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechCustomStream);
    procedure Disconnect; override;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer): Integer;
    function Write(Buffer: OleVariant): Integer;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant;
    property DefaultInterface: ISpeechCustomStream read GetDefaultInterface;
    property Format: ISpeechAudioFormat read Get_Format write _Set_Format;
    property BaseStream: IUnknown read Get_BaseStream write _Set_BaseStream;
  published
  end;

  // *********************************************************************//
  // The Class CoSpFileStream provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechFileStream exposed by
  // the CoClass SpFileStream. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpFileStream = class
    class function Create: ISpeechFileStream;
    class function CreateRemote(const MachineName: string): ISpeechFileStream;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpFileStream
  // Help String      : SpFileStream Class
  // Default Interface: ISpeechFileStream
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpFileStream = class(TOleServer)
  private
    FIntf: ISpeechFileStream;
    function GetDefaultInterface: ISpeechFileStream;
  protected
    procedure InitServerData; override;
    function Get_Format: ISpeechAudioFormat;
    procedure _Set_Format(const AudioFormat: ISpeechAudioFormat);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechFileStream);
    procedure Disconnect; override;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer): Integer;
    function Write(Buffer: OleVariant): Integer;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant;
    procedure Open(const FileName: WideString; FileMode: SpeechStreamFileMode;
      DoEvents: WordBool);
    procedure Close;
    property DefaultInterface: ISpeechFileStream read GetDefaultInterface;
    property Format: ISpeechAudioFormat read Get_Format write _Set_Format;
  published
  end;

  // *********************************************************************//
  // The Class CoSpMemoryStream provides a Create and CreateRemote method to
  // create instances of the default interface ISpeechMemoryStream exposed by
  // the CoClass SpMemoryStream. The functions are intended to be used by
  // clients wishing to automate the CoClass objects exposed by the
  // server of this typelibrary.
  // *********************************************************************//
  CoSpMemoryStream = class
    class function Create: ISpeechMemoryStream;
    class function CreateRemote(const MachineName: string): ISpeechMemoryStream;
  end;

  // *********************************************************************//
  // OLE Server Proxy class declaration
  // Server Object    : TSpMemoryStream
  // Help String      : SpMemoryStream Class
  // Default Interface: ISpeechMemoryStream
  // Def. Intf. DISP? : No
  // Event   Interface:
  // TypeFlags        : (2) CanCreate
  // *********************************************************************//
  TSpMemoryStream = class(TOleServer)
  private
    FIntf: ISpeechMemoryStream;
    function GetDefaultInterface: ISpeechMemoryStream;
  protected
    procedure InitServerData; override;
    function Get_Format: ISpeechAudioFormat;
    procedure _Set_Format(const AudioFormat: ISpeechAudioFormat);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Connect; override;
    procedure ConnectTo(svrIntf: ISpeechMemoryStream);
    procedure Disconnect; override;
    function Read(out Buffer: OleVariant; NumberOfBytes: Integer): Integer;
    function Write(Buffer: OleVariant): Integer;
    function Seek(Position: OleVariant; Origin: SpeechStreamSeekPositionType)
      : OleVariant;
    procedure SetData(Data: OleVariant);
    function GetData: OleVariant;
    property DefaultInterface: ISpeechMemoryStream read GetDefaultInterface;
    property Format: ISpeechAudioFormat read Get_Format write _Set_Format;
  published
  end;

resourcestring
  dtlServerPage = 'ActiveX';

  dtlOcxPage = 'ActiveX';

{$ENDREGION}

{$REGION 'Luna.Common'}
type

  { TLuBaseObjectList }
  TLuBaseObjectList = class;

  { TLuObjectAttributeSet }
  TLuObjectAttributeSet = set of Byte;

  { TLuBaseObject }
  TLuBaseObject = class
  protected
    FOwner: TLuBaseObjectList;
    FPrev: TLuBaseObject;
    FNext: TLuBaseObject;
    FAttributes: TLuObjectAttributeSet;
    function GetAttribute(aIndex: Byte): Boolean;
    procedure SetAttribute(aIndex: Byte; aValue: Boolean);
    function GetAttributes: TLuObjectAttributeSet;
    procedure SetAttributes(aValue: TLuObjectAttributeSet);
  public
    property Owner: TLuBaseObjectList read FOwner write FOwner;
    property Prev: TLuBaseObject read FPrev write FPrev;
    property Next: TLuBaseObject read FNext write FNext;
    property Attribute[aIndex: Byte]: Boolean read GetAttribute write SetAttribute;
    property Attributes: TLuObjectAttributeSet read GetAttributes  write SetAttributes;
    constructor Create; virtual;
    destructor Destroy; override;
    function AttributesAreSet(aAttrs: TLuObjectAttributeSet): Boolean;
  end;

  { TLuBaseObjectList }
  TLuBaseObjectList = class
  protected
    FHead: TLuBaseObject;
    FTail: TLuBaseObject;
    FCount: Integer;
  public
    property Count: Integer read FCount;
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Add(aObject: TLuBaseObject);
    procedure Remove(aObject: TLuBaseObject; aDispose: Boolean);
    procedure Clean; virtual;
    procedure Clear(aAttrs: TLuObjectAttributeSet);
  end;

{$ENDREGION}

{$REGION 'Luna.Speech'}
type
  { TLuSpeechVoiceAttribute }
  TLuSpeechVoiceAttribute = (vaDescription, vaName, vaVendor, vaAge, vaGender, vaLanguage, vaId);

  { TLuSpeech }
  TLuSpeech = class
  protected
    FSpVoice: TSpVoice;
    FVoiceList: TInterfaceList;
    FVoiceDescList: TStringList;
    FPaused: Boolean;
    FText: string;
    FWord: string;
    FVoice: Integer;
    FSubList: TDictionary<string, string>;
    procedure OnWord(aSender: TObject; aStreamNumber: Integer; aStreamPosition: OleVariant; aCharacterPosition, aLength: Integer);
    //procedure OnStartStream(aSender: TObject; aStreamNumber: Integer; aStreamPosition: OleVariant);
    procedure DoSpeak(aText: string; aFlags: Integer);
    procedure EnumVoices;
    procedure FreeVoices;
    procedure Setup;
    procedure Shutdown;
  public
    constructor Create; virtual;
    destructor Destroy; override;
    function  GetVoiceCount: Integer;
    function  GetVoiceAttribute(aIndex: Integer; aAttribute: TLuSpeechVoiceAttribute): WideString;
    procedure ChangeVoice(aIndex: Integer);
    function  GetVoice: Integer;
    procedure SetVolume(aVolume: Single);
    function  GetVolume: Single;
    procedure SetRate(aRate: Single);
    function  GetRate: Single;
    procedure Clear;
    procedure Say(const aText: WideString; aPurge: Boolean);
    function  Active: Boolean;
    procedure Pause;
    procedure Resume;
    procedure Reset;
    procedure SubstituteWord(const aWord: WideString; const aSubstituteWord: WideString);
  end;

{$ENDREGION}

{$REGION 'Luna.CloudDb'}
type
  { TLuCloudDb }
  TLuCloudDb = class(TLuBaseObject)
  protected const
    cURL = '/?apikey=%s&keyspace=%s&query=%s';
    cTest = 1;
  protected
    FUrl: string;
    FApiKey: string;
    FDatabase: string;
    FResponseText: string;
    FLastError: string;
    FHttp: THTTPClient;
    FSQL: TStringList;
    FPrepairedSQL: string;
    FJSON: TJSONObject;
    FDataset: TJSONArray;
    FMacros: TDictionary<string, string>;
    FParams: TDictionary<string, string>;
    procedure SetMacroValue(const aName, aValue: string);
    procedure SetParamValue(const aName, aValue: string);
    procedure Prepair;
    function  GetQueryURL(const aSQL: string): string;
    function  GetPrepairedSQL: string;
    function  GetResponseText: string;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Setup(const aURL, aApiKey, aDatabase: string);
    procedure ClearSQLText;
    procedure AddSQLText(const aText: string; const aArgs: array of const);
    function  GetSQLText: string;
    procedure SetSQLText(const aText: string);
    function  GetMacro(const aName: string): string;
    procedure SetMacro(const aName, aValue: string);
    function  GetParam(const aName: string): string;
    procedure SetParam(const aName, aValue: string);
    function  RecordCount: Integer;
    function  GetField(const aIndex: Cardinal; const aName: string): string;
    function  Execute: Boolean;
    function  ExecuteSQL(const aSQL: string): Boolean;
    function  GetLastError: string;
  end;

{$ENDREGION}

{$REGION 'Luna.Game'}
type

  { TLuGame }
  TLuGame = class
  protected
    FMarshaller: TMarshaller;
    FMasterObjectList: TLuBaseObjectList;
    FOrgName: string;
    FAppName: string;
    FSpeech: TObject;
  public
    { Properties }
    property MasterObjectList: TLuBaseObjectList read FMasterObjectList;

    { Construct/Destruct }
    constructor Create; virtual;
    destructor Destroy; override;

    { Callbacks }
    function  OnStartup: Boolean; virtual;
    procedure OnShutdown; virtual;
    procedure OnRun; virtual;
    procedure OnSpeechWord(const aWord, aText: string); virtual;

    { Utils }
    procedure ShellOpen(const aFilename: string);
    function  GetVersionInfo(aInstance: THandle; aIdent: string): string; overload;
    function  GetVersionInfo(const aFilename: string; aIdent: string): string; overload;
    procedure FreeNilObject(const [ref] aObject: TObject);
    function  UnitToScalarValue(const aValue, aMaxValue: Double): Double;
    function  HttpGet(const aURL: string; aStatus: PString=nil): string;

    { Console }
    function  HasConsoleOutput: Boolean;
    function  HasConsoleOnStartup: Boolean;
    procedure WaitForAnyKey;
    procedure Pause(const aMsg: string='');
    procedure Print(const aMsg: string); overload;
    procedure Print(const aMsg: string; const aArgs: array of const); overload;
    procedure PrintLn; overload;
    procedure PrintLn(const aMsg: string); overload;
    procedure PrintLn(const aMsg: string; const aArgs: array of const); overload;

    { Prefs }
    function  GetOrgName: string;
    procedure SetOrgName(const aOrgName: string);
    function  GetAppName: string;
    procedure SetAppName(const aAppName: string);
    function  GetPrefsPath: string;
    procedure GotoPrefsPath;

    { Speech }
    function  GetSpeechVoiceCount: Integer;
    function  GetSpeechVoiceAttribute(aIndex: Integer; aAttribute: TLuSpeechVoiceAttribute): string;
    procedure ChangeSpeechVoice(aIndex: Integer);
    function  GetSpeechVoice: Integer;
    procedure SetSpeechVolume(aVolume: Single);
    function  GetSpeechVolume: Single;
    procedure SetSpeechRate(aRate: Single);
    function  GetSpeechRate: Single;
    procedure ClearSpeech;
    procedure Speak(const aText: string; aPurge: Boolean);
    function  SpeechActive: Boolean;
    procedure PauseSpeech;
    procedure ResumeSpeech;
    procedure ResetSpeech;
    procedure SubstituteSpeechWord(const aWord, aSubstituteWord: string);

  end;

  { TLuGameClass }
  TLuGameClass = class of TLuGame;

{ Variables }
var
  Game: TLuGame = nil;

{ Routines }
procedure LuRunGame(const aGame: TLuGameClass);

{$ENDREGION}

implementation

{$REGION 'Luna.Deps'}
{$R Luna.Deps.res}

procedure GetExports(const aDLLHandle: THandle);
begin
{$REGION 'Exports'}
  if aDllHandle = 0 then Exit;
  __debugbreak := GetProcAddress(aDLLHandle, '__debugbreak');
  aacircleColor := GetProcAddress(aDLLHandle, 'aacircleColor');
  aacircleRGBA := GetProcAddress(aDLLHandle, 'aacircleRGBA');
  aaellipseColor := GetProcAddress(aDLLHandle, 'aaellipseColor');
  aaellipseRGBA := GetProcAddress(aDLLHandle, 'aaellipseRGBA');
  aalineColor := GetProcAddress(aDLLHandle, 'aalineColor');
  aalineRGBA := GetProcAddress(aDLLHandle, 'aalineRGBA');
  aapolygonColor := GetProcAddress(aDLLHandle, 'aapolygonColor');
  aapolygonRGBA := GetProcAddress(aDLLHandle, 'aapolygonRGBA');
  aatrigonColor := GetProcAddress(aDLLHandle, 'aatrigonColor');
  aatrigonRGBA := GetProcAddress(aDLLHandle, 'aatrigonRGBA');
  arcColor := GetProcAddress(aDLLHandle, 'arcColor');
  arcRGBA := GetProcAddress(aDLLHandle, 'arcRGBA');
  bezierColor := GetProcAddress(aDLLHandle, 'bezierColor');
  bezierRGBA := GetProcAddress(aDLLHandle, 'bezierRGBA');
  boxColor := GetProcAddress(aDLLHandle, 'boxColor');
  boxRGBA := GetProcAddress(aDLLHandle, 'boxRGBA');
  characterColor := GetProcAddress(aDLLHandle, 'characterColor');
  characterRGBA := GetProcAddress(aDLLHandle, 'characterRGBA');
  circleColor := GetProcAddress(aDLLHandle, 'circleColor');
  circleRGBA := GetProcAddress(aDLLHandle, 'circleRGBA');
  crc32 := GetProcAddress(aDLLHandle, 'crc32');
  ellipseColor := GetProcAddress(aDLLHandle, 'ellipseColor');
  ellipseRGBA := GetProcAddress(aDLLHandle, 'ellipseRGBA');
  filledCircleColor := GetProcAddress(aDLLHandle, 'filledCircleColor');
  filledCircleRGBA := GetProcAddress(aDLLHandle, 'filledCircleRGBA');
  filledEllipseColor := GetProcAddress(aDLLHandle, 'filledEllipseColor');
  filledEllipseRGBA := GetProcAddress(aDLLHandle, 'filledEllipseRGBA');
  filledPieColor := GetProcAddress(aDLLHandle, 'filledPieColor');
  filledPieRGBA := GetProcAddress(aDLLHandle, 'filledPieRGBA');
  filledPolygonColor := GetProcAddress(aDLLHandle, 'filledPolygonColor');
  filledPolygonRGBA := GetProcAddress(aDLLHandle, 'filledPolygonRGBA');
  filledTrigonColor := GetProcAddress(aDLLHandle, 'filledTrigonColor');
  filledTrigonRGBA := GetProcAddress(aDLLHandle, 'filledTrigonRGBA');
  gfxPrimitivesSetFont := GetProcAddress(aDLLHandle, 'gfxPrimitivesSetFont');
  gfxPrimitivesSetFontRotation := GetProcAddress(aDLLHandle, 'gfxPrimitivesSetFontRotation');
  hlineColor := GetProcAddress(aDLLHandle, 'hlineColor');
  hlineRGBA := GetProcAddress(aDLLHandle, 'hlineRGBA');
  IMG_FreeAnimation := GetProcAddress(aDLLHandle, 'IMG_FreeAnimation');
  IMG_Init := GetProcAddress(aDLLHandle, 'IMG_Init');
  IMG_isAVIF := GetProcAddress(aDLLHandle, 'IMG_isAVIF');
  IMG_isBMP := GetProcAddress(aDLLHandle, 'IMG_isBMP');
  IMG_isCUR := GetProcAddress(aDLLHandle, 'IMG_isCUR');
  IMG_isGIF := GetProcAddress(aDLLHandle, 'IMG_isGIF');
  IMG_isICO := GetProcAddress(aDLLHandle, 'IMG_isICO');
  IMG_isJPG := GetProcAddress(aDLLHandle, 'IMG_isJPG');
  IMG_isJXL := GetProcAddress(aDLLHandle, 'IMG_isJXL');
  IMG_isLBM := GetProcAddress(aDLLHandle, 'IMG_isLBM');
  IMG_isPCX := GetProcAddress(aDLLHandle, 'IMG_isPCX');
  IMG_isPNG := GetProcAddress(aDLLHandle, 'IMG_isPNG');
  IMG_isPNM := GetProcAddress(aDLLHandle, 'IMG_isPNM');
  IMG_isQOI := GetProcAddress(aDLLHandle, 'IMG_isQOI');
  IMG_isSVG := GetProcAddress(aDLLHandle, 'IMG_isSVG');
  IMG_isTIF := GetProcAddress(aDLLHandle, 'IMG_isTIF');
  IMG_isWEBP := GetProcAddress(aDLLHandle, 'IMG_isWEBP');
  IMG_isXCF := GetProcAddress(aDLLHandle, 'IMG_isXCF');
  IMG_isXPM := GetProcAddress(aDLLHandle, 'IMG_isXPM');
  IMG_isXV := GetProcAddress(aDLLHandle, 'IMG_isXV');
  IMG_Linked_Version := GetProcAddress(aDLLHandle, 'IMG_Linked_Version');
  IMG_Load := GetProcAddress(aDLLHandle, 'IMG_Load');
  IMG_Load_RW := GetProcAddress(aDLLHandle, 'IMG_Load_RW');
  IMG_LoadAnimation := GetProcAddress(aDLLHandle, 'IMG_LoadAnimation');
  IMG_LoadAnimation_RW := GetProcAddress(aDLLHandle, 'IMG_LoadAnimation_RW');
  IMG_LoadAnimationTyped_RW := GetProcAddress(aDLLHandle, 'IMG_LoadAnimationTyped_RW');
  IMG_LoadAVIF_RW := GetProcAddress(aDLLHandle, 'IMG_LoadAVIF_RW');
  IMG_LoadBMP_RW := GetProcAddress(aDLLHandle, 'IMG_LoadBMP_RW');
  IMG_LoadCUR_RW := GetProcAddress(aDLLHandle, 'IMG_LoadCUR_RW');
  IMG_LoadGIF_RW := GetProcAddress(aDLLHandle, 'IMG_LoadGIF_RW');
  IMG_LoadGIFAnimation_RW := GetProcAddress(aDLLHandle, 'IMG_LoadGIFAnimation_RW');
  IMG_LoadICO_RW := GetProcAddress(aDLLHandle, 'IMG_LoadICO_RW');
  IMG_LoadJPG_RW := GetProcAddress(aDLLHandle, 'IMG_LoadJPG_RW');
  IMG_LoadJXL_RW := GetProcAddress(aDLLHandle, 'IMG_LoadJXL_RW');
  IMG_LoadLBM_RW := GetProcAddress(aDLLHandle, 'IMG_LoadLBM_RW');
  IMG_LoadPCX_RW := GetProcAddress(aDLLHandle, 'IMG_LoadPCX_RW');
  IMG_LoadPNG_RW := GetProcAddress(aDLLHandle, 'IMG_LoadPNG_RW');
  IMG_LoadPNM_RW := GetProcAddress(aDLLHandle, 'IMG_LoadPNM_RW');
  IMG_LoadQOI_RW := GetProcAddress(aDLLHandle, 'IMG_LoadQOI_RW');
  IMG_LoadSizedSVG_RW := GetProcAddress(aDLLHandle, 'IMG_LoadSizedSVG_RW');
  IMG_LoadSVG_RW := GetProcAddress(aDLLHandle, 'IMG_LoadSVG_RW');
  IMG_LoadTexture := GetProcAddress(aDLLHandle, 'IMG_LoadTexture');
  IMG_LoadTexture_RW := GetProcAddress(aDLLHandle, 'IMG_LoadTexture_RW');
  IMG_LoadTextureTyped_RW := GetProcAddress(aDLLHandle, 'IMG_LoadTextureTyped_RW');
  IMG_LoadTGA_RW := GetProcAddress(aDLLHandle, 'IMG_LoadTGA_RW');
  IMG_LoadTIF_RW := GetProcAddress(aDLLHandle, 'IMG_LoadTIF_RW');
  IMG_LoadTyped_RW := GetProcAddress(aDLLHandle, 'IMG_LoadTyped_RW');
  IMG_LoadWEBP_RW := GetProcAddress(aDLLHandle, 'IMG_LoadWEBP_RW');
  IMG_LoadXCF_RW := GetProcAddress(aDLLHandle, 'IMG_LoadXCF_RW');
  IMG_LoadXPM_RW := GetProcAddress(aDLLHandle, 'IMG_LoadXPM_RW');
  IMG_LoadXV_RW := GetProcAddress(aDLLHandle, 'IMG_LoadXV_RW');
  IMG_Quit := GetProcAddress(aDLLHandle, 'IMG_Quit');
  IMG_ReadXPMFromArray := GetProcAddress(aDLLHandle, 'IMG_ReadXPMFromArray');
  IMG_ReadXPMFromArrayToRGB888 := GetProcAddress(aDLLHandle, 'IMG_ReadXPMFromArrayToRGB888');
  IMG_SaveJPG := GetProcAddress(aDLLHandle, 'IMG_SaveJPG');
  IMG_SaveJPG_RW := GetProcAddress(aDLLHandle, 'IMG_SaveJPG_RW');
  IMG_SavePNG := GetProcAddress(aDLLHandle, 'IMG_SavePNG');
  IMG_SavePNG_RW := GetProcAddress(aDLLHandle, 'IMG_SavePNG_RW');
  lineColor := GetProcAddress(aDLLHandle, 'lineColor');
  lineRGBA := GetProcAddress(aDLLHandle, 'lineRGBA');
  Mix_AllocateChannels := GetProcAddress(aDLLHandle, 'Mix_AllocateChannels');
  Mix_ChannelFinished := GetProcAddress(aDLLHandle, 'Mix_ChannelFinished');
  Mix_CloseAudio := GetProcAddress(aDLLHandle, 'Mix_CloseAudio');
  Mix_EachSoundFont := GetProcAddress(aDLLHandle, 'Mix_EachSoundFont');
  Mix_ExpireChannel := GetProcAddress(aDLLHandle, 'Mix_ExpireChannel');
  Mix_FadeInChannel := GetProcAddress(aDLLHandle, 'Mix_FadeInChannel');
  Mix_FadeInChannelTimed := GetProcAddress(aDLLHandle, 'Mix_FadeInChannelTimed');
  Mix_FadeInMusic := GetProcAddress(aDLLHandle, 'Mix_FadeInMusic');
  Mix_FadeInMusicPos := GetProcAddress(aDLLHandle, 'Mix_FadeInMusicPos');
  Mix_FadeOutChannel := GetProcAddress(aDLLHandle, 'Mix_FadeOutChannel');
  Mix_FadeOutGroup := GetProcAddress(aDLLHandle, 'Mix_FadeOutGroup');
  Mix_FadeOutMusic := GetProcAddress(aDLLHandle, 'Mix_FadeOutMusic');
  Mix_FadingChannel := GetProcAddress(aDLLHandle, 'Mix_FadingChannel');
  Mix_FadingMusic := GetProcAddress(aDLLHandle, 'Mix_FadingMusic');
  Mix_FreeChunk := GetProcAddress(aDLLHandle, 'Mix_FreeChunk');
  Mix_FreeMusic := GetProcAddress(aDLLHandle, 'Mix_FreeMusic');
  Mix_GetChunk := GetProcAddress(aDLLHandle, 'Mix_GetChunk');
  Mix_GetChunkDecoder := GetProcAddress(aDLLHandle, 'Mix_GetChunkDecoder');
  Mix_GetMusicAlbumTag := GetProcAddress(aDLLHandle, 'Mix_GetMusicAlbumTag');
  Mix_GetMusicArtistTag := GetProcAddress(aDLLHandle, 'Mix_GetMusicArtistTag');
  Mix_GetMusicCopyrightTag := GetProcAddress(aDLLHandle, 'Mix_GetMusicCopyrightTag');
  Mix_GetMusicDecoder := GetProcAddress(aDLLHandle, 'Mix_GetMusicDecoder');
  Mix_GetMusicHookData := GetProcAddress(aDLLHandle, 'Mix_GetMusicHookData');
  Mix_GetMusicLoopEndTime := GetProcAddress(aDLLHandle, 'Mix_GetMusicLoopEndTime');
  Mix_GetMusicLoopLengthTime := GetProcAddress(aDLLHandle, 'Mix_GetMusicLoopLengthTime');
  Mix_GetMusicLoopStartTime := GetProcAddress(aDLLHandle, 'Mix_GetMusicLoopStartTime');
  Mix_GetMusicPosition := GetProcAddress(aDLLHandle, 'Mix_GetMusicPosition');
  Mix_GetMusicTitle := GetProcAddress(aDLLHandle, 'Mix_GetMusicTitle');
  Mix_GetMusicTitleTag := GetProcAddress(aDLLHandle, 'Mix_GetMusicTitleTag');
  Mix_GetMusicType := GetProcAddress(aDLLHandle, 'Mix_GetMusicType');
  Mix_GetMusicVolume := GetProcAddress(aDLLHandle, 'Mix_GetMusicVolume');
  Mix_GetNumChunkDecoders := GetProcAddress(aDLLHandle, 'Mix_GetNumChunkDecoders');
  Mix_GetNumMusicDecoders := GetProcAddress(aDLLHandle, 'Mix_GetNumMusicDecoders');
  Mix_GetSoundFonts := GetProcAddress(aDLLHandle, 'Mix_GetSoundFonts');
  Mix_GetSynchroValue := GetProcAddress(aDLLHandle, 'Mix_GetSynchroValue');
  Mix_GetTimidityCfg := GetProcAddress(aDLLHandle, 'Mix_GetTimidityCfg');
  Mix_GroupAvailable := GetProcAddress(aDLLHandle, 'Mix_GroupAvailable');
  Mix_GroupChannel := GetProcAddress(aDLLHandle, 'Mix_GroupChannel');
  Mix_GroupChannels := GetProcAddress(aDLLHandle, 'Mix_GroupChannels');
  Mix_GroupCount := GetProcAddress(aDLLHandle, 'Mix_GroupCount');
  Mix_GroupNewer := GetProcAddress(aDLLHandle, 'Mix_GroupNewer');
  Mix_GroupOldest := GetProcAddress(aDLLHandle, 'Mix_GroupOldest');
  Mix_HaltChannel := GetProcAddress(aDLLHandle, 'Mix_HaltChannel');
  Mix_HaltGroup := GetProcAddress(aDLLHandle, 'Mix_HaltGroup');
  Mix_HaltMusic := GetProcAddress(aDLLHandle, 'Mix_HaltMusic');
  Mix_HasChunkDecoder := GetProcAddress(aDLLHandle, 'Mix_HasChunkDecoder');
  Mix_HasMusicDecoder := GetProcAddress(aDLLHandle, 'Mix_HasMusicDecoder');
  Mix_HookMusic := GetProcAddress(aDLLHandle, 'Mix_HookMusic');
  Mix_HookMusicFinished := GetProcAddress(aDLLHandle, 'Mix_HookMusicFinished');
  Mix_Init := GetProcAddress(aDLLHandle, 'Mix_Init');
  Mix_Linked_Version := GetProcAddress(aDLLHandle, 'Mix_Linked_Version');
  Mix_LoadMUS := GetProcAddress(aDLLHandle, 'Mix_LoadMUS');
  Mix_LoadMUS_RW := GetProcAddress(aDLLHandle, 'Mix_LoadMUS_RW');
  Mix_LoadMUSType_RW := GetProcAddress(aDLLHandle, 'Mix_LoadMUSType_RW');
  Mix_LoadWAV := GetProcAddress(aDLLHandle, 'Mix_LoadWAV');
  Mix_LoadWAV_RW := GetProcAddress(aDLLHandle, 'Mix_LoadWAV_RW');
  Mix_MasterVolume := GetProcAddress(aDLLHandle, 'Mix_MasterVolume');
  Mix_ModMusicJumpToOrder := GetProcAddress(aDLLHandle, 'Mix_ModMusicJumpToOrder');
  Mix_MusicDuration := GetProcAddress(aDLLHandle, 'Mix_MusicDuration');
  Mix_OpenAudio := GetProcAddress(aDLLHandle, 'Mix_OpenAudio');
  Mix_OpenAudioDevice := GetProcAddress(aDLLHandle, 'Mix_OpenAudioDevice');
  Mix_Pause := GetProcAddress(aDLLHandle, 'Mix_Pause');
  Mix_Paused := GetProcAddress(aDLLHandle, 'Mix_Paused');
  Mix_PausedMusic := GetProcAddress(aDLLHandle, 'Mix_PausedMusic');
  Mix_PauseMusic := GetProcAddress(aDLLHandle, 'Mix_PauseMusic');
  Mix_PlayChannel := GetProcAddress(aDLLHandle, 'Mix_PlayChannel');
  Mix_PlayChannelTimed := GetProcAddress(aDLLHandle, 'Mix_PlayChannelTimed');
  Mix_Playing := GetProcAddress(aDLLHandle, 'Mix_Playing');
  Mix_PlayingMusic := GetProcAddress(aDLLHandle, 'Mix_PlayingMusic');
  Mix_PlayMusic := GetProcAddress(aDLLHandle, 'Mix_PlayMusic');
  Mix_QuerySpec := GetProcAddress(aDLLHandle, 'Mix_QuerySpec');
  Mix_QuickLoad_RAW := GetProcAddress(aDLLHandle, 'Mix_QuickLoad_RAW');
  Mix_QuickLoad_WAV := GetProcAddress(aDLLHandle, 'Mix_QuickLoad_WAV');
  Mix_Quit := GetProcAddress(aDLLHandle, 'Mix_Quit');
  Mix_RegisterEffect := GetProcAddress(aDLLHandle, 'Mix_RegisterEffect');
  Mix_ReserveChannels := GetProcAddress(aDLLHandle, 'Mix_ReserveChannels');
  Mix_Resume := GetProcAddress(aDLLHandle, 'Mix_Resume');
  Mix_ResumeMusic := GetProcAddress(aDLLHandle, 'Mix_ResumeMusic');
  Mix_RewindMusic := GetProcAddress(aDLLHandle, 'Mix_RewindMusic');
  Mix_SetDistance := GetProcAddress(aDLLHandle, 'Mix_SetDistance');
  Mix_SetMusicCMD := GetProcAddress(aDLLHandle, 'Mix_SetMusicCMD');
  Mix_SetMusicPosition := GetProcAddress(aDLLHandle, 'Mix_SetMusicPosition');
  Mix_SetPanning := GetProcAddress(aDLLHandle, 'Mix_SetPanning');
  Mix_SetPosition := GetProcAddress(aDLLHandle, 'Mix_SetPosition');
  Mix_SetPostMix := GetProcAddress(aDLLHandle, 'Mix_SetPostMix');
  Mix_SetReverseStereo := GetProcAddress(aDLLHandle, 'Mix_SetReverseStereo');
  Mix_SetSoundFonts := GetProcAddress(aDLLHandle, 'Mix_SetSoundFonts');
  Mix_SetSynchroValue := GetProcAddress(aDLLHandle, 'Mix_SetSynchroValue');
  Mix_SetTimidityCfg := GetProcAddress(aDLLHandle, 'Mix_SetTimidityCfg');
  Mix_UnregisterAllEffects := GetProcAddress(aDLLHandle, 'Mix_UnregisterAllEffects');
  Mix_UnregisterEffect := GetProcAddress(aDLLHandle, 'Mix_UnregisterEffect');
  Mix_Volume := GetProcAddress(aDLLHandle, 'Mix_Volume');
  Mix_VolumeChunk := GetProcAddress(aDLLHandle, 'Mix_VolumeChunk');
  Mix_VolumeMusic := GetProcAddress(aDLLHandle, 'Mix_VolumeMusic');
  nk__begin := GetProcAddress(aDLLHandle, 'nk__begin');
  nk__draw_begin := GetProcAddress(aDLLHandle, 'nk__draw_begin');
  nk__draw_end := GetProcAddress(aDLLHandle, 'nk__draw_end');
  nk__draw_list_begin := GetProcAddress(aDLLHandle, 'nk__draw_list_begin');
  nk__draw_list_end := GetProcAddress(aDLLHandle, 'nk__draw_list_end');
  nk__draw_list_next := GetProcAddress(aDLLHandle, 'nk__draw_list_next');
  nk__draw_next := GetProcAddress(aDLLHandle, 'nk__draw_next');
  nk__next := GetProcAddress(aDLLHandle, 'nk__next');
  nk_begin := GetProcAddress(aDLLHandle, 'nk_begin');
  nk_begin_titled := GetProcAddress(aDLLHandle, 'nk_begin_titled');
  nk_buffer_clear := GetProcAddress(aDLLHandle, 'nk_buffer_clear');
  nk_buffer_free := GetProcAddress(aDLLHandle, 'nk_buffer_free');
  nk_buffer_info := GetProcAddress(aDLLHandle, 'nk_buffer_info');
  nk_buffer_init := GetProcAddress(aDLLHandle, 'nk_buffer_init');
  nk_buffer_init_default := GetProcAddress(aDLLHandle, 'nk_buffer_init_default');
  nk_buffer_init_fixed := GetProcAddress(aDLLHandle, 'nk_buffer_init_fixed');
  nk_buffer_mark := GetProcAddress(aDLLHandle, 'nk_buffer_mark');
  nk_buffer_memory := GetProcAddress(aDLLHandle, 'nk_buffer_memory');
  nk_buffer_memory_const := GetProcAddress(aDLLHandle, 'nk_buffer_memory_const');
  nk_buffer_push := GetProcAddress(aDLLHandle, 'nk_buffer_push');
  nk_buffer_reset := GetProcAddress(aDLLHandle, 'nk_buffer_reset');
  nk_buffer_total := GetProcAddress(aDLLHandle, 'nk_buffer_total');
  nk_button_color := GetProcAddress(aDLLHandle, 'nk_button_color');
  nk_button_image := GetProcAddress(aDLLHandle, 'nk_button_image');
  nk_button_image_label := GetProcAddress(aDLLHandle, 'nk_button_image_label');
  nk_button_image_label_styled := GetProcAddress(aDLLHandle, 'nk_button_image_label_styled');
  nk_button_image_styled := GetProcAddress(aDLLHandle, 'nk_button_image_styled');
  nk_button_image_text := GetProcAddress(aDLLHandle, 'nk_button_image_text');
  nk_button_image_text_styled := GetProcAddress(aDLLHandle, 'nk_button_image_text_styled');
  nk_button_label := GetProcAddress(aDLLHandle, 'nk_button_label');
  nk_button_label_styled := GetProcAddress(aDLLHandle, 'nk_button_label_styled');
  nk_button_pop_behavior := GetProcAddress(aDLLHandle, 'nk_button_pop_behavior');
  nk_button_push_behavior := GetProcAddress(aDLLHandle, 'nk_button_push_behavior');
  nk_button_set_behavior := GetProcAddress(aDLLHandle, 'nk_button_set_behavior');
  nk_button_symbol := GetProcAddress(aDLLHandle, 'nk_button_symbol');
  nk_button_symbol_label := GetProcAddress(aDLLHandle, 'nk_button_symbol_label');
  nk_button_symbol_label_styled := GetProcAddress(aDLLHandle, 'nk_button_symbol_label_styled');
  nk_button_symbol_styled := GetProcAddress(aDLLHandle, 'nk_button_symbol_styled');
  nk_button_symbol_text := GetProcAddress(aDLLHandle, 'nk_button_symbol_text');
  nk_button_symbol_text_styled := GetProcAddress(aDLLHandle, 'nk_button_symbol_text_styled');
  nk_button_text := GetProcAddress(aDLLHandle, 'nk_button_text');
  nk_button_text_styled := GetProcAddress(aDLLHandle, 'nk_button_text_styled');
  nk_chart_add_slot := GetProcAddress(aDLLHandle, 'nk_chart_add_slot');
  nk_chart_add_slot_colored := GetProcAddress(aDLLHandle, 'nk_chart_add_slot_colored');
  nk_chart_begin := GetProcAddress(aDLLHandle, 'nk_chart_begin');
  nk_chart_begin_colored := GetProcAddress(aDLLHandle, 'nk_chart_begin_colored');
  nk_chart_end := GetProcAddress(aDLLHandle, 'nk_chart_end');
  nk_chart_push := GetProcAddress(aDLLHandle, 'nk_chart_push');
  nk_chart_push_slot := GetProcAddress(aDLLHandle, 'nk_chart_push_slot');
  nk_check_flags_label := GetProcAddress(aDLLHandle, 'nk_check_flags_label');
  nk_check_flags_text := GetProcAddress(aDLLHandle, 'nk_check_flags_text');
  nk_check_label := GetProcAddress(aDLLHandle, 'nk_check_label');
  nk_check_text := GetProcAddress(aDLLHandle, 'nk_check_text');
  nk_checkbox_flags_label := GetProcAddress(aDLLHandle, 'nk_checkbox_flags_label');
  nk_checkbox_flags_text := GetProcAddress(aDLLHandle, 'nk_checkbox_flags_text');
  nk_checkbox_label := GetProcAddress(aDLLHandle, 'nk_checkbox_label');
  nk_checkbox_text := GetProcAddress(aDLLHandle, 'nk_checkbox_text');
  nk_clear := GetProcAddress(aDLLHandle, 'nk_clear');
  nk_color_cf := GetProcAddress(aDLLHandle, 'nk_color_cf');
  nk_color_d := GetProcAddress(aDLLHandle, 'nk_color_d');
  nk_color_dv := GetProcAddress(aDLLHandle, 'nk_color_dv');
  nk_color_f := GetProcAddress(aDLLHandle, 'nk_color_f');
  nk_color_fv := GetProcAddress(aDLLHandle, 'nk_color_fv');
  nk_color_hex_rgb := GetProcAddress(aDLLHandle, 'nk_color_hex_rgb');
  nk_color_hex_rgba := GetProcAddress(aDLLHandle, 'nk_color_hex_rgba');
  nk_color_hsv_b := GetProcAddress(aDLLHandle, 'nk_color_hsv_b');
  nk_color_hsv_bv := GetProcAddress(aDLLHandle, 'nk_color_hsv_bv');
  nk_color_hsv_f := GetProcAddress(aDLLHandle, 'nk_color_hsv_f');
  nk_color_hsv_fv := GetProcAddress(aDLLHandle, 'nk_color_hsv_fv');
  nk_color_hsv_i := GetProcAddress(aDLLHandle, 'nk_color_hsv_i');
  nk_color_hsv_iv := GetProcAddress(aDLLHandle, 'nk_color_hsv_iv');
  nk_color_hsva_b := GetProcAddress(aDLLHandle, 'nk_color_hsva_b');
  nk_color_hsva_bv := GetProcAddress(aDLLHandle, 'nk_color_hsva_bv');
  nk_color_hsva_f := GetProcAddress(aDLLHandle, 'nk_color_hsva_f');
  nk_color_hsva_fv := GetProcAddress(aDLLHandle, 'nk_color_hsva_fv');
  nk_color_hsva_i := GetProcAddress(aDLLHandle, 'nk_color_hsva_i');
  nk_color_hsva_iv := GetProcAddress(aDLLHandle, 'nk_color_hsva_iv');
  nk_color_pick := GetProcAddress(aDLLHandle, 'nk_color_pick');
  nk_color_picker := GetProcAddress(aDLLHandle, 'nk_color_picker');
  nk_color_u32 := GetProcAddress(aDLLHandle, 'nk_color_u32');
  nk_colorf_hsva_f := GetProcAddress(aDLLHandle, 'nk_colorf_hsva_f');
  nk_colorf_hsva_fv := GetProcAddress(aDLLHandle, 'nk_colorf_hsva_fv');
  nk_combo := GetProcAddress(aDLLHandle, 'nk_combo');
  nk_combo_begin_color := GetProcAddress(aDLLHandle, 'nk_combo_begin_color');
  nk_combo_begin_image := GetProcAddress(aDLLHandle, 'nk_combo_begin_image');
  nk_combo_begin_image_label := GetProcAddress(aDLLHandle, 'nk_combo_begin_image_label');
  nk_combo_begin_image_text := GetProcAddress(aDLLHandle, 'nk_combo_begin_image_text');
  nk_combo_begin_label := GetProcAddress(aDLLHandle, 'nk_combo_begin_label');
  nk_combo_begin_symbol := GetProcAddress(aDLLHandle, 'nk_combo_begin_symbol');
  nk_combo_begin_symbol_label := GetProcAddress(aDLLHandle, 'nk_combo_begin_symbol_label');
  nk_combo_begin_symbol_text := GetProcAddress(aDLLHandle, 'nk_combo_begin_symbol_text');
  nk_combo_begin_text := GetProcAddress(aDLLHandle, 'nk_combo_begin_text');
  nk_combo_callback := GetProcAddress(aDLLHandle, 'nk_combo_callback');
  nk_combo_close := GetProcAddress(aDLLHandle, 'nk_combo_close');
  nk_combo_end := GetProcAddress(aDLLHandle, 'nk_combo_end');
  nk_combo_item_image_label := GetProcAddress(aDLLHandle, 'nk_combo_item_image_label');
  nk_combo_item_image_text := GetProcAddress(aDLLHandle, 'nk_combo_item_image_text');
  nk_combo_item_label := GetProcAddress(aDLLHandle, 'nk_combo_item_label');
  nk_combo_item_symbol_label := GetProcAddress(aDLLHandle, 'nk_combo_item_symbol_label');
  nk_combo_item_symbol_text := GetProcAddress(aDLLHandle, 'nk_combo_item_symbol_text');
  nk_combo_item_text := GetProcAddress(aDLLHandle, 'nk_combo_item_text');
  nk_combo_separator := GetProcAddress(aDLLHandle, 'nk_combo_separator');
  nk_combo_string := GetProcAddress(aDLLHandle, 'nk_combo_string');
  nk_combobox := GetProcAddress(aDLLHandle, 'nk_combobox');
  nk_combobox_callback := GetProcAddress(aDLLHandle, 'nk_combobox_callback');
  nk_combobox_separator := GetProcAddress(aDLLHandle, 'nk_combobox_separator');
  nk_combobox_string := GetProcAddress(aDLLHandle, 'nk_combobox_string');
  nk_contextual_begin := GetProcAddress(aDLLHandle, 'nk_contextual_begin');
  nk_contextual_close := GetProcAddress(aDLLHandle, 'nk_contextual_close');
  nk_contextual_end := GetProcAddress(aDLLHandle, 'nk_contextual_end');
  nk_contextual_item_image_label := GetProcAddress(aDLLHandle, 'nk_contextual_item_image_label');
  nk_contextual_item_image_text := GetProcAddress(aDLLHandle, 'nk_contextual_item_image_text');
  nk_contextual_item_label := GetProcAddress(aDLLHandle, 'nk_contextual_item_label');
  nk_contextual_item_symbol_label := GetProcAddress(aDLLHandle, 'nk_contextual_item_symbol_label');
  nk_contextual_item_symbol_text := GetProcAddress(aDLLHandle, 'nk_contextual_item_symbol_text');
  nk_contextual_item_text := GetProcAddress(aDLLHandle, 'nk_contextual_item_text');
  nk_convert := GetProcAddress(aDLLHandle, 'nk_convert');
  nk_draw_image := GetProcAddress(aDLLHandle, 'nk_draw_image');
  nk_draw_list_add_image := GetProcAddress(aDLLHandle, 'nk_draw_list_add_image');
  nk_draw_list_add_text := GetProcAddress(aDLLHandle, 'nk_draw_list_add_text');
  nk_draw_list_fill_circle := GetProcAddress(aDLLHandle, 'nk_draw_list_fill_circle');
  nk_draw_list_fill_poly_convex := GetProcAddress(aDLLHandle, 'nk_draw_list_fill_poly_convex');
  nk_draw_list_fill_rect := GetProcAddress(aDLLHandle, 'nk_draw_list_fill_rect');
  nk_draw_list_fill_rect_multi_color := GetProcAddress(aDLLHandle, 'nk_draw_list_fill_rect_multi_color');
  nk_draw_list_fill_triangle := GetProcAddress(aDLLHandle, 'nk_draw_list_fill_triangle');
  nk_draw_list_init := GetProcAddress(aDLLHandle, 'nk_draw_list_init');
  nk_draw_list_path_arc_to := GetProcAddress(aDLLHandle, 'nk_draw_list_path_arc_to');
  nk_draw_list_path_arc_to_fast := GetProcAddress(aDLLHandle, 'nk_draw_list_path_arc_to_fast');
  nk_draw_list_path_clear := GetProcAddress(aDLLHandle, 'nk_draw_list_path_clear');
  nk_draw_list_path_curve_to := GetProcAddress(aDLLHandle, 'nk_draw_list_path_curve_to');
  nk_draw_list_path_fill := GetProcAddress(aDLLHandle, 'nk_draw_list_path_fill');
  nk_draw_list_path_line_to := GetProcAddress(aDLLHandle, 'nk_draw_list_path_line_to');
  nk_draw_list_path_rect_to := GetProcAddress(aDLLHandle, 'nk_draw_list_path_rect_to');
  nk_draw_list_path_stroke := GetProcAddress(aDLLHandle, 'nk_draw_list_path_stroke');
  nk_draw_list_setup := GetProcAddress(aDLLHandle, 'nk_draw_list_setup');
  nk_draw_list_stroke_circle := GetProcAddress(aDLLHandle, 'nk_draw_list_stroke_circle');
  nk_draw_list_stroke_curve := GetProcAddress(aDLLHandle, 'nk_draw_list_stroke_curve');
  nk_draw_list_stroke_line := GetProcAddress(aDLLHandle, 'nk_draw_list_stroke_line');
  nk_draw_list_stroke_poly_line := GetProcAddress(aDLLHandle, 'nk_draw_list_stroke_poly_line');
  nk_draw_list_stroke_rect := GetProcAddress(aDLLHandle, 'nk_draw_list_stroke_rect');
  nk_draw_list_stroke_triangle := GetProcAddress(aDLLHandle, 'nk_draw_list_stroke_triangle');
  nk_draw_nine_slice := GetProcAddress(aDLLHandle, 'nk_draw_nine_slice');
  nk_draw_text := GetProcAddress(aDLLHandle, 'nk_draw_text');
  nk_edit_buffer := GetProcAddress(aDLLHandle, 'nk_edit_buffer');
  nk_edit_focus := GetProcAddress(aDLLHandle, 'nk_edit_focus');
  nk_edit_string := GetProcAddress(aDLLHandle, 'nk_edit_string');
  nk_edit_string_zero_terminated := GetProcAddress(aDLLHandle, 'nk_edit_string_zero_terminated');
  nk_edit_unfocus := GetProcAddress(aDLLHandle, 'nk_edit_unfocus');
  nk_end := GetProcAddress(aDLLHandle, 'nk_end');
  nk_fill_arc := GetProcAddress(aDLLHandle, 'nk_fill_arc');
  nk_fill_circle := GetProcAddress(aDLLHandle, 'nk_fill_circle');
  nk_fill_polygon := GetProcAddress(aDLLHandle, 'nk_fill_polygon');
  nk_fill_rect := GetProcAddress(aDLLHandle, 'nk_fill_rect');
  nk_fill_rect_multi_color := GetProcAddress(aDLLHandle, 'nk_fill_rect_multi_color');
  nk_fill_triangle := GetProcAddress(aDLLHandle, 'nk_fill_triangle');
  nk_filter_ascii := GetProcAddress(aDLLHandle, 'nk_filter_ascii');
  nk_filter_binary := GetProcAddress(aDLLHandle, 'nk_filter_binary');
  nk_filter_decimal := GetProcAddress(aDLLHandle, 'nk_filter_decimal');
  nk_filter_default := GetProcAddress(aDLLHandle, 'nk_filter_default');
  nk_filter_float := GetProcAddress(aDLLHandle, 'nk_filter_float');
  nk_filter_hex := GetProcAddress(aDLLHandle, 'nk_filter_hex');
  nk_filter_oct := GetProcAddress(aDLLHandle, 'nk_filter_oct');
  nk_font_atlas_add := GetProcAddress(aDLLHandle, 'nk_font_atlas_add');
  nk_font_atlas_add_compressed := GetProcAddress(aDLLHandle, 'nk_font_atlas_add_compressed');
  nk_font_atlas_add_compressed_base85 := GetProcAddress(aDLLHandle, 'nk_font_atlas_add_compressed_base85');
  nk_font_atlas_add_default := GetProcAddress(aDLLHandle, 'nk_font_atlas_add_default');
  nk_font_atlas_add_from_file := GetProcAddress(aDLLHandle, 'nk_font_atlas_add_from_file');
  nk_font_atlas_add_from_memory := GetProcAddress(aDLLHandle, 'nk_font_atlas_add_from_memory');
  nk_font_atlas_bake := GetProcAddress(aDLLHandle, 'nk_font_atlas_bake');
  nk_font_atlas_begin := GetProcAddress(aDLLHandle, 'nk_font_atlas_begin');
  nk_font_atlas_cleanup := GetProcAddress(aDLLHandle, 'nk_font_atlas_cleanup');
  nk_font_atlas_clear := GetProcAddress(aDLLHandle, 'nk_font_atlas_clear');
  nk_font_atlas_end := GetProcAddress(aDLLHandle, 'nk_font_atlas_end');
  nk_font_atlas_init := GetProcAddress(aDLLHandle, 'nk_font_atlas_init');
  nk_font_atlas_init_custom := GetProcAddress(aDLLHandle, 'nk_font_atlas_init_custom');
  nk_font_atlas_init_default := GetProcAddress(aDLLHandle, 'nk_font_atlas_init_default');
  nk_font_chinese_glyph_ranges := GetProcAddress(aDLLHandle, 'nk_font_chinese_glyph_ranges');
  nk_font_config_rtn := GetProcAddress(aDLLHandle, 'nk_font_config');
  nk_font_cyrillic_glyph_ranges := GetProcAddress(aDLLHandle, 'nk_font_cyrillic_glyph_ranges');
  nk_font_default_glyph_ranges := GetProcAddress(aDLLHandle, 'nk_font_default_glyph_ranges');
  nk_font_find_glyph := GetProcAddress(aDLLHandle, 'nk_font_find_glyph');
  nk_font_korean_glyph_ranges := GetProcAddress(aDLLHandle, 'nk_font_korean_glyph_ranges');
  nk_free := GetProcAddress(aDLLHandle, 'nk_free');
  nk_get_null_rect := GetProcAddress(aDLLHandle, 'nk_get_null_rect');
  nk_group_begin := GetProcAddress(aDLLHandle, 'nk_group_begin');
  nk_group_begin_titled := GetProcAddress(aDLLHandle, 'nk_group_begin_titled');
  nk_group_end := GetProcAddress(aDLLHandle, 'nk_group_end');
  nk_group_get_scroll := GetProcAddress(aDLLHandle, 'nk_group_get_scroll');
  nk_group_scrolled_begin := GetProcAddress(aDLLHandle, 'nk_group_scrolled_begin');
  nk_group_scrolled_end := GetProcAddress(aDLLHandle, 'nk_group_scrolled_end');
  nk_group_scrolled_offset_begin := GetProcAddress(aDLLHandle, 'nk_group_scrolled_offset_begin');
  nk_group_set_scroll := GetProcAddress(aDLLHandle, 'nk_group_set_scroll');
  nk_handle_id := GetProcAddress(aDLLHandle, 'nk_handle_id');
  nk_handle_ptr := GetProcAddress(aDLLHandle, 'nk_handle_ptr');
  nk_hsv := GetProcAddress(aDLLHandle, 'nk_hsv');
  nk_hsv_bv := GetProcAddress(aDLLHandle, 'nk_hsv_bv');
  nk_hsv_f := GetProcAddress(aDLLHandle, 'nk_hsv_f');
  nk_hsv_fv := GetProcAddress(aDLLHandle, 'nk_hsv_fv');
  nk_hsv_iv := GetProcAddress(aDLLHandle, 'nk_hsv_iv');
  nk_hsva := GetProcAddress(aDLLHandle, 'nk_hsva');
  nk_hsva_bv := GetProcAddress(aDLLHandle, 'nk_hsva_bv');
  nk_hsva_colorf := GetProcAddress(aDLLHandle, 'nk_hsva_colorf');
  nk_hsva_colorfv := GetProcAddress(aDLLHandle, 'nk_hsva_colorfv');
  nk_hsva_f := GetProcAddress(aDLLHandle, 'nk_hsva_f');
  nk_hsva_fv := GetProcAddress(aDLLHandle, 'nk_hsva_fv');
  nk_hsva_iv := GetProcAddress(aDLLHandle, 'nk_hsva_iv');
  nk_image_color := GetProcAddress(aDLLHandle, 'nk_image_color');
  nk_image_handle := GetProcAddress(aDLLHandle, 'nk_image_handle');
  nk_image_id := GetProcAddress(aDLLHandle, 'nk_image_id');
  nk_image_is_subimage := GetProcAddress(aDLLHandle, 'nk_image_is_subimage');
  nk_image_ptr := GetProcAddress(aDLLHandle, 'nk_image_ptr');
  nk_image_rtn := GetProcAddress(aDLLHandle, 'nk_image');
  nk_init := GetProcAddress(aDLLHandle, 'nk_init');
  nk_init_custom := GetProcAddress(aDLLHandle, 'nk_init_custom');
  nk_init_default := GetProcAddress(aDLLHandle, 'nk_init_default');
  nk_init_fixed := GetProcAddress(aDLLHandle, 'nk_init_fixed');
  nk_input_any_mouse_click_in_rect := GetProcAddress(aDLLHandle, 'nk_input_any_mouse_click_in_rect');
  nk_input_begin := GetProcAddress(aDLLHandle, 'nk_input_begin');
  nk_input_button := GetProcAddress(aDLLHandle, 'nk_input_button');
  nk_input_char := GetProcAddress(aDLLHandle, 'nk_input_char');
  nk_input_end := GetProcAddress(aDLLHandle, 'nk_input_end');
  nk_input_glyph := GetProcAddress(aDLLHandle, 'nk_input_glyph');
  nk_input_has_mouse_click := GetProcAddress(aDLLHandle, 'nk_input_has_mouse_click');
  nk_input_has_mouse_click_down_in_rect := GetProcAddress(aDLLHandle, 'nk_input_has_mouse_click_down_in_rect');
  nk_input_has_mouse_click_in_button_rect := GetProcAddress(aDLLHandle, 'nk_input_has_mouse_click_in_button_rect');
  nk_input_has_mouse_click_in_rect := GetProcAddress(aDLLHandle, 'nk_input_has_mouse_click_in_rect');
  nk_input_is_key_down := GetProcAddress(aDLLHandle, 'nk_input_is_key_down');
  nk_input_is_key_pressed := GetProcAddress(aDLLHandle, 'nk_input_is_key_pressed');
  nk_input_is_key_released := GetProcAddress(aDLLHandle, 'nk_input_is_key_released');
  nk_input_is_mouse_click_down_in_rect := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_click_down_in_rect');
  nk_input_is_mouse_click_in_rect := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_click_in_rect');
  nk_input_is_mouse_down := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_down');
  nk_input_is_mouse_hovering_rect := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_hovering_rect');
  nk_input_is_mouse_pressed := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_pressed');
  nk_input_is_mouse_prev_hovering_rect := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_prev_hovering_rect');
  nk_input_is_mouse_released := GetProcAddress(aDLLHandle, 'nk_input_is_mouse_released');
  nk_input_key := GetProcAddress(aDLLHandle, 'nk_input_key');
  nk_input_motion := GetProcAddress(aDLLHandle, 'nk_input_motion');
  nk_input_mouse_clicked := GetProcAddress(aDLLHandle, 'nk_input_mouse_clicked');
  nk_input_scroll := GetProcAddress(aDLLHandle, 'nk_input_scroll');
  nk_input_unicode := GetProcAddress(aDLLHandle, 'nk_input_unicode');
  nk_item_is_any_active := GetProcAddress(aDLLHandle, 'nk_item_is_any_active');
  nk_label := GetProcAddress(aDLLHandle, 'nk_label');
  nk_label_colored := GetProcAddress(aDLLHandle, 'nk_label_colored');
  nk_label_colored_wrap := GetProcAddress(aDLLHandle, 'nk_label_colored_wrap');
  nk_label_wrap := GetProcAddress(aDLLHandle, 'nk_label_wrap');
  nk_labelf := GetProcAddress(aDLLHandle, 'nk_labelf');
  nk_labelf_colored := GetProcAddress(aDLLHandle, 'nk_labelf_colored');
  nk_labelf_colored_wrap := GetProcAddress(aDLLHandle, 'nk_labelf_colored_wrap');
  nk_labelf_wrap := GetProcAddress(aDLLHandle, 'nk_labelf_wrap');
  nk_labelfv := GetProcAddress(aDLLHandle, 'nk_labelfv');
  nk_labelfv_colored := GetProcAddress(aDLLHandle, 'nk_labelfv_colored');
  nk_labelfv_colored_wrap := GetProcAddress(aDLLHandle, 'nk_labelfv_colored_wrap');
  nk_labelfv_wrap := GetProcAddress(aDLLHandle, 'nk_labelfv_wrap');
  nk_layout_ratio_from_pixel := GetProcAddress(aDLLHandle, 'nk_layout_ratio_from_pixel');
  nk_layout_reset_min_row_height := GetProcAddress(aDLLHandle, 'nk_layout_reset_min_row_height');
  nk_layout_row := GetProcAddress(aDLLHandle, 'nk_layout_row');
  nk_layout_row_begin := GetProcAddress(aDLLHandle, 'nk_layout_row_begin');
  nk_layout_row_dynamic := GetProcAddress(aDLLHandle, 'nk_layout_row_dynamic');
  nk_layout_row_end := GetProcAddress(aDLLHandle, 'nk_layout_row_end');
  nk_layout_row_push := GetProcAddress(aDLLHandle, 'nk_layout_row_push');
  nk_layout_row_static := GetProcAddress(aDLLHandle, 'nk_layout_row_static');
  nk_layout_row_template_begin := GetProcAddress(aDLLHandle, 'nk_layout_row_template_begin');
  nk_layout_row_template_end := GetProcAddress(aDLLHandle, 'nk_layout_row_template_end');
  nk_layout_row_template_push_dynamic := GetProcAddress(aDLLHandle, 'nk_layout_row_template_push_dynamic');
  nk_layout_row_template_push_static := GetProcAddress(aDLLHandle, 'nk_layout_row_template_push_static');
  nk_layout_row_template_push_variable := GetProcAddress(aDLLHandle, 'nk_layout_row_template_push_variable');
  nk_layout_set_min_row_height := GetProcAddress(aDLLHandle, 'nk_layout_set_min_row_height');
  nk_layout_space_begin := GetProcAddress(aDLLHandle, 'nk_layout_space_begin');
  nk_layout_space_bounds := GetProcAddress(aDLLHandle, 'nk_layout_space_bounds');
  nk_layout_space_end := GetProcAddress(aDLLHandle, 'nk_layout_space_end');
  nk_layout_space_push := GetProcAddress(aDLLHandle, 'nk_layout_space_push');
  nk_layout_space_rect_to_local := GetProcAddress(aDLLHandle, 'nk_layout_space_rect_to_local');
  nk_layout_space_rect_to_screen := GetProcAddress(aDLLHandle, 'nk_layout_space_rect_to_screen');
  nk_layout_space_to_local := GetProcAddress(aDLLHandle, 'nk_layout_space_to_local');
  nk_layout_space_to_screen := GetProcAddress(aDLLHandle, 'nk_layout_space_to_screen');
  nk_layout_widget_bounds := GetProcAddress(aDLLHandle, 'nk_layout_widget_bounds');
  nk_list_view_begin := GetProcAddress(aDLLHandle, 'nk_list_view_begin');
  nk_list_view_end := GetProcAddress(aDLLHandle, 'nk_list_view_end');
  nk_menu_begin_image := GetProcAddress(aDLLHandle, 'nk_menu_begin_image');
  nk_menu_begin_image_label := GetProcAddress(aDLLHandle, 'nk_menu_begin_image_label');
  nk_menu_begin_image_text := GetProcAddress(aDLLHandle, 'nk_menu_begin_image_text');
  nk_menu_begin_label := GetProcAddress(aDLLHandle, 'nk_menu_begin_label');
  nk_menu_begin_symbol := GetProcAddress(aDLLHandle, 'nk_menu_begin_symbol');
  nk_menu_begin_symbol_label := GetProcAddress(aDLLHandle, 'nk_menu_begin_symbol_label');
  nk_menu_begin_symbol_text := GetProcAddress(aDLLHandle, 'nk_menu_begin_symbol_text');
  nk_menu_begin_text := GetProcAddress(aDLLHandle, 'nk_menu_begin_text');
  nk_menu_close := GetProcAddress(aDLLHandle, 'nk_menu_close');
  nk_menu_end := GetProcAddress(aDLLHandle, 'nk_menu_end');
  nk_menu_item_image_label := GetProcAddress(aDLLHandle, 'nk_menu_item_image_label');
  nk_menu_item_image_text := GetProcAddress(aDLLHandle, 'nk_menu_item_image_text');
  nk_menu_item_label := GetProcAddress(aDLLHandle, 'nk_menu_item_label');
  nk_menu_item_symbol_label := GetProcAddress(aDLLHandle, 'nk_menu_item_symbol_label');
  nk_menu_item_symbol_text := GetProcAddress(aDLLHandle, 'nk_menu_item_symbol_text');
  nk_menu_item_text := GetProcAddress(aDLLHandle, 'nk_menu_item_text');
  nk_menubar_begin := GetProcAddress(aDLLHandle, 'nk_menubar_begin');
  nk_menubar_end := GetProcAddress(aDLLHandle, 'nk_menubar_end');
  nk_murmur_hash := GetProcAddress(aDLLHandle, 'nk_murmur_hash');
  nk_nine_slice_handle := GetProcAddress(aDLLHandle, 'nk_nine_slice_handle');
  nk_nine_slice_id := GetProcAddress(aDLLHandle, 'nk_nine_slice_id');
  nk_nine_slice_is_sub9slice := GetProcAddress(aDLLHandle, 'nk_nine_slice_is_sub9slice');
  nk_nine_slice_ptr := GetProcAddress(aDLLHandle, 'nk_nine_slice_ptr');
  nk_option_label := GetProcAddress(aDLLHandle, 'nk_option_label');
  nk_option_text := GetProcAddress(aDLLHandle, 'nk_option_text');
  nk_plot := GetProcAddress(aDLLHandle, 'nk_plot');
  nk_plot_function := GetProcAddress(aDLLHandle, 'nk_plot_function');
  nk_popup_begin := GetProcAddress(aDLLHandle, 'nk_popup_begin');
  nk_popup_close := GetProcAddress(aDLLHandle, 'nk_popup_close');
  nk_popup_end := GetProcAddress(aDLLHandle, 'nk_popup_end');
  nk_popup_get_scroll := GetProcAddress(aDLLHandle, 'nk_popup_get_scroll');
  nk_popup_set_scroll := GetProcAddress(aDLLHandle, 'nk_popup_set_scroll');
  nk_prog := GetProcAddress(aDLLHandle, 'nk_prog');
  nk_progress := GetProcAddress(aDLLHandle, 'nk_progress');
  nk_property_double := GetProcAddress(aDLLHandle, 'nk_property_double');
  nk_property_float := GetProcAddress(aDLLHandle, 'nk_property_float');
  nk_property_int := GetProcAddress(aDLLHandle, 'nk_property_int');
  nk_propertyd := GetProcAddress(aDLLHandle, 'nk_propertyd');
  nk_propertyf := GetProcAddress(aDLLHandle, 'nk_propertyf');
  nk_propertyi := GetProcAddress(aDLLHandle, 'nk_propertyi');
  nk_push_custom := GetProcAddress(aDLLHandle, 'nk_push_custom');
  nk_push_scissor := GetProcAddress(aDLLHandle, 'nk_push_scissor');
  nk_radio_label := GetProcAddress(aDLLHandle, 'nk_radio_label');
  nk_radio_text := GetProcAddress(aDLLHandle, 'nk_radio_text');
  nk_rect_pos := GetProcAddress(aDLLHandle, 'nk_rect_pos');
  nk_rect_rtn := GetProcAddress(aDLLHandle, 'nk_rect');
  nk_rect_size := GetProcAddress(aDLLHandle, 'nk_rect_size');
  nk_recta := GetProcAddress(aDLLHandle, 'nk_recta');
  nk_recti_rtn := GetProcAddress(aDLLHandle, 'nk_recti');
  nk_rectiv := GetProcAddress(aDLLHandle, 'nk_rectiv');
  nk_rectv := GetProcAddress(aDLLHandle, 'nk_rectv');
  nk_rgb_bv := GetProcAddress(aDLLHandle, 'nk_rgb_bv');
  nk_rgb_cf := GetProcAddress(aDLLHandle, 'nk_rgb_cf');
  nk_rgb_f := GetProcAddress(aDLLHandle, 'nk_rgb_f');
  nk_rgb_fv := GetProcAddress(aDLLHandle, 'nk_rgb_fv');
  nk_rgb_hex := GetProcAddress(aDLLHandle, 'nk_rgb_hex');
  nk_rgb_iv := GetProcAddress(aDLLHandle, 'nk_rgb_iv');
  nk_rgb_rtn := GetProcAddress(aDLLHandle, 'nk_rgb');
  nk_rgba_bv := GetProcAddress(aDLLHandle, 'nk_rgba_bv');
  nk_rgba_cf := GetProcAddress(aDLLHandle, 'nk_rgba_cf');
  nk_rgba_f := GetProcAddress(aDLLHandle, 'nk_rgba_f');
  nk_rgba_fv := GetProcAddress(aDLLHandle, 'nk_rgba_fv');
  nk_rgba_hex := GetProcAddress(aDLLHandle, 'nk_rgba_hex');
  nk_rgba_iv := GetProcAddress(aDLLHandle, 'nk_rgba_iv');
  nk_rgba_rtn := GetProcAddress(aDLLHandle, 'nk_rgba');
  nk_rgba_u32 := GetProcAddress(aDLLHandle, 'nk_rgba_u32');
  nk_sdl_font_stash_begin := GetProcAddress(aDLLHandle, 'nk_sdl_font_stash_begin');
  nk_sdl_font_stash_end := GetProcAddress(aDLLHandle, 'nk_sdl_font_stash_end');
  nk_sdl_handle_event := GetProcAddress(aDLLHandle, 'nk_sdl_handle_event');
  nk_sdl_init := GetProcAddress(aDLLHandle, 'nk_sdl_init');
  nk_sdl_render := GetProcAddress(aDLLHandle, 'nk_sdl_render');
  nk_sdl_shutdown := GetProcAddress(aDLLHandle, 'nk_sdl_shutdown');
  nk_select_image_label := GetProcAddress(aDLLHandle, 'nk_select_image_label');
  nk_select_image_text := GetProcAddress(aDLLHandle, 'nk_select_image_text');
  nk_select_label := GetProcAddress(aDLLHandle, 'nk_select_label');
  nk_select_symbol_label := GetProcAddress(aDLLHandle, 'nk_select_symbol_label');
  nk_select_symbol_text := GetProcAddress(aDLLHandle, 'nk_select_symbol_text');
  nk_select_text := GetProcAddress(aDLLHandle, 'nk_select_text');
  nk_selectable_image_label := GetProcAddress(aDLLHandle, 'nk_selectable_image_label');
  nk_selectable_image_text := GetProcAddress(aDLLHandle, 'nk_selectable_image_text');
  nk_selectable_label := GetProcAddress(aDLLHandle, 'nk_selectable_label');
  nk_selectable_symbol_label := GetProcAddress(aDLLHandle, 'nk_selectable_symbol_label');
  nk_selectable_symbol_text := GetProcAddress(aDLLHandle, 'nk_selectable_symbol_text');
  nk_selectable_text := GetProcAddress(aDLLHandle, 'nk_selectable_text');
  nk_slide_float := GetProcAddress(aDLLHandle, 'nk_slide_float');
  nk_slide_int := GetProcAddress(aDLLHandle, 'nk_slide_int');
  nk_slider_float := GetProcAddress(aDLLHandle, 'nk_slider_float');
  nk_slider_int := GetProcAddress(aDLLHandle, 'nk_slider_int');
  nk_spacer := GetProcAddress(aDLLHandle, 'nk_spacer');
  nk_spacing := GetProcAddress(aDLLHandle, 'nk_spacing');
  nk_str_append_str_char := GetProcAddress(aDLLHandle, 'nk_str_append_str_char');
  nk_str_append_str_runes := GetProcAddress(aDLLHandle, 'nk_str_append_str_runes');
  nk_str_append_str_utf8 := GetProcAddress(aDLLHandle, 'nk_str_append_str_utf8');
  nk_str_append_text_char := GetProcAddress(aDLLHandle, 'nk_str_append_text_char');
  nk_str_append_text_runes := GetProcAddress(aDLLHandle, 'nk_str_append_text_runes');
  nk_str_append_text_utf8 := GetProcAddress(aDLLHandle, 'nk_str_append_text_utf8');
  nk_str_at_char := GetProcAddress(aDLLHandle, 'nk_str_at_char');
  nk_str_at_char_const := GetProcAddress(aDLLHandle, 'nk_str_at_char_const');
  nk_str_at_const := GetProcAddress(aDLLHandle, 'nk_str_at_const');
  nk_str_at_rune := GetProcAddress(aDLLHandle, 'nk_str_at_rune');
  nk_str_clear := GetProcAddress(aDLLHandle, 'nk_str_clear');
  nk_str_delete_chars := GetProcAddress(aDLLHandle, 'nk_str_delete_chars');
  nk_str_delete_runes := GetProcAddress(aDLLHandle, 'nk_str_delete_runes');
  nk_str_free := GetProcAddress(aDLLHandle, 'nk_str_free');
  nk_str_get := GetProcAddress(aDLLHandle, 'nk_str_get');
  nk_str_get_const := GetProcAddress(aDLLHandle, 'nk_str_get_const');
  nk_str_init := GetProcAddress(aDLLHandle, 'nk_str_init');
  nk_str_init_default := GetProcAddress(aDLLHandle, 'nk_str_init_default');
  nk_str_init_fixed := GetProcAddress(aDLLHandle, 'nk_str_init_fixed');
  nk_str_insert_at_char := GetProcAddress(aDLLHandle, 'nk_str_insert_at_char');
  nk_str_insert_at_rune := GetProcAddress(aDLLHandle, 'nk_str_insert_at_rune');
  nk_str_insert_str_char := GetProcAddress(aDLLHandle, 'nk_str_insert_str_char');
  nk_str_insert_str_runes := GetProcAddress(aDLLHandle, 'nk_str_insert_str_runes');
  nk_str_insert_str_utf8 := GetProcAddress(aDLLHandle, 'nk_str_insert_str_utf8');
  nk_str_insert_text_char := GetProcAddress(aDLLHandle, 'nk_str_insert_text_char');
  nk_str_insert_text_runes := GetProcAddress(aDLLHandle, 'nk_str_insert_text_runes');
  nk_str_insert_text_utf8 := GetProcAddress(aDLLHandle, 'nk_str_insert_text_utf8');
  nk_str_len := GetProcAddress(aDLLHandle, 'nk_str_len');
  nk_str_len_char := GetProcAddress(aDLLHandle, 'nk_str_len_char');
  nk_str_remove_chars := GetProcAddress(aDLLHandle, 'nk_str_remove_chars');
  nk_str_remove_runes := GetProcAddress(aDLLHandle, 'nk_str_remove_runes');
  nk_str_rune_at := GetProcAddress(aDLLHandle, 'nk_str_rune_at');
  nk_strfilter := GetProcAddress(aDLLHandle, 'nk_strfilter');
  nk_stricmp := GetProcAddress(aDLLHandle, 'nk_stricmp');
  nk_stricmpn := GetProcAddress(aDLLHandle, 'nk_stricmpn');
  nk_strlen := GetProcAddress(aDLLHandle, 'nk_strlen');
  nk_strmatch_fuzzy_string := GetProcAddress(aDLLHandle, 'nk_strmatch_fuzzy_string');
  nk_strmatch_fuzzy_text := GetProcAddress(aDLLHandle, 'nk_strmatch_fuzzy_text');
  nk_stroke_arc := GetProcAddress(aDLLHandle, 'nk_stroke_arc');
  nk_stroke_circle := GetProcAddress(aDLLHandle, 'nk_stroke_circle');
  nk_stroke_curve := GetProcAddress(aDLLHandle, 'nk_stroke_curve');
  nk_stroke_line := GetProcAddress(aDLLHandle, 'nk_stroke_line');
  nk_stroke_polygon := GetProcAddress(aDLLHandle, 'nk_stroke_polygon');
  nk_stroke_polyline := GetProcAddress(aDLLHandle, 'nk_stroke_polyline');
  nk_stroke_rect := GetProcAddress(aDLLHandle, 'nk_stroke_rect');
  nk_stroke_triangle := GetProcAddress(aDLLHandle, 'nk_stroke_triangle');
  nk_strtod := GetProcAddress(aDLLHandle, 'nk_strtod');
  nk_strtof := GetProcAddress(aDLLHandle, 'nk_strtof');
  nk_strtoi := GetProcAddress(aDLLHandle, 'nk_strtoi');
  nk_style_default := GetProcAddress(aDLLHandle, 'nk_style_default');
  nk_style_from_table := GetProcAddress(aDLLHandle, 'nk_style_from_table');
  nk_style_get_color_by_name := GetProcAddress(aDLLHandle, 'nk_style_get_color_by_name');
  nk_style_hide_cursor := GetProcAddress(aDLLHandle, 'nk_style_hide_cursor');
  nk_style_item_color_rtn := GetProcAddress(aDLLHandle, 'nk_style_item_color');
  nk_style_item_hide := GetProcAddress(aDLLHandle, 'nk_style_item_hide');
  nk_style_item_image_rtn := GetProcAddress(aDLLHandle, 'nk_style_item_image');
  nk_style_item_nine_slice_rtn := GetProcAddress(aDLLHandle, 'nk_style_item_nine_slice');
  nk_style_load_all_cursors := GetProcAddress(aDLLHandle, 'nk_style_load_all_cursors');
  nk_style_load_cursor := GetProcAddress(aDLLHandle, 'nk_style_load_cursor');
  nk_style_pop_color := GetProcAddress(aDLLHandle, 'nk_style_pop_color');
  nk_style_pop_flags := GetProcAddress(aDLLHandle, 'nk_style_pop_flags');
  nk_style_pop_float := GetProcAddress(aDLLHandle, 'nk_style_pop_float');
  nk_style_pop_font := GetProcAddress(aDLLHandle, 'nk_style_pop_font');
  nk_style_pop_style_item := GetProcAddress(aDLLHandle, 'nk_style_pop_style_item');
  nk_style_pop_vec2 := GetProcAddress(aDLLHandle, 'nk_style_pop_vec2');
  nk_style_push_color := GetProcAddress(aDLLHandle, 'nk_style_push_color');
  nk_style_push_flags := GetProcAddress(aDLLHandle, 'nk_style_push_flags');
  nk_style_push_float := GetProcAddress(aDLLHandle, 'nk_style_push_float');
  nk_style_push_font := GetProcAddress(aDLLHandle, 'nk_style_push_font');
  nk_style_push_style_item := GetProcAddress(aDLLHandle, 'nk_style_push_style_item');
  nk_style_push_vec2 := GetProcAddress(aDLLHandle, 'nk_style_push_vec2');
  nk_style_set_cursor := GetProcAddress(aDLLHandle, 'nk_style_set_cursor');
  nk_style_set_font := GetProcAddress(aDLLHandle, 'nk_style_set_font');
  nk_style_show_cursor := GetProcAddress(aDLLHandle, 'nk_style_show_cursor');
  nk_sub9slice_handle := GetProcAddress(aDLLHandle, 'nk_sub9slice_handle');
  nk_sub9slice_id := GetProcAddress(aDLLHandle, 'nk_sub9slice_id');
  nk_sub9slice_ptr := GetProcAddress(aDLLHandle, 'nk_sub9slice_ptr');
  nk_subimage_handle := GetProcAddress(aDLLHandle, 'nk_subimage_handle');
  nk_subimage_id := GetProcAddress(aDLLHandle, 'nk_subimage_id');
  nk_subimage_ptr := GetProcAddress(aDLLHandle, 'nk_subimage_ptr');
  nk_text := GetProcAddress(aDLLHandle, 'nk_text');
  nk_text_colored := GetProcAddress(aDLLHandle, 'nk_text_colored');
  nk_text_wrap := GetProcAddress(aDLLHandle, 'nk_text_wrap');
  nk_text_wrap_colored := GetProcAddress(aDLLHandle, 'nk_text_wrap_colored');
  nk_textedit_cut := GetProcAddress(aDLLHandle, 'nk_textedit_cut');
  nk_textedit_delete := GetProcAddress(aDLLHandle, 'nk_textedit_delete');
  nk_textedit_delete_selection := GetProcAddress(aDLLHandle, 'nk_textedit_delete_selection');
  nk_textedit_free := GetProcAddress(aDLLHandle, 'nk_textedit_free');
  nk_textedit_init := GetProcAddress(aDLLHandle, 'nk_textedit_init');
  nk_textedit_init_default := GetProcAddress(aDLLHandle, 'nk_textedit_init_default');
  nk_textedit_init_fixed := GetProcAddress(aDLLHandle, 'nk_textedit_init_fixed');
  nk_textedit_paste := GetProcAddress(aDLLHandle, 'nk_textedit_paste');
  nk_textedit_redo := GetProcAddress(aDLLHandle, 'nk_textedit_redo');
  nk_textedit_select_all := GetProcAddress(aDLLHandle, 'nk_textedit_select_all');
  nk_textedit_text := GetProcAddress(aDLLHandle, 'nk_textedit_text');
  nk_textedit_undo := GetProcAddress(aDLLHandle, 'nk_textedit_undo');
  nk_tooltip := GetProcAddress(aDLLHandle, 'nk_tooltip');
  nk_tooltip_begin := GetProcAddress(aDLLHandle, 'nk_tooltip_begin');
  nk_tooltip_end := GetProcAddress(aDLLHandle, 'nk_tooltip_end');
  nk_tooltipf := GetProcAddress(aDLLHandle, 'nk_tooltipf');
  nk_tooltipfv := GetProcAddress(aDLLHandle, 'nk_tooltipfv');
  nk_tree_element_image_push_hashed := GetProcAddress(aDLLHandle, 'nk_tree_element_image_push_hashed');
  nk_tree_element_pop := GetProcAddress(aDLLHandle, 'nk_tree_element_pop');
  nk_tree_element_push_hashed := GetProcAddress(aDLLHandle, 'nk_tree_element_push_hashed');
  nk_tree_image_push_hashed := GetProcAddress(aDLLHandle, 'nk_tree_image_push_hashed');
  nk_tree_pop := GetProcAddress(aDLLHandle, 'nk_tree_pop');
  nk_tree_push_hashed := GetProcAddress(aDLLHandle, 'nk_tree_push_hashed');
  nk_tree_state_image_push := GetProcAddress(aDLLHandle, 'nk_tree_state_image_push');
  nk_tree_state_pop := GetProcAddress(aDLLHandle, 'nk_tree_state_pop');
  nk_tree_state_push := GetProcAddress(aDLLHandle, 'nk_tree_state_push');
  nk_triangle_from_direction := GetProcAddress(aDLLHandle, 'nk_triangle_from_direction');
  nk_utf_at := GetProcAddress(aDLLHandle, 'nk_utf_at');
  nk_utf_decode := GetProcAddress(aDLLHandle, 'nk_utf_decode');
  nk_utf_encode := GetProcAddress(aDLLHandle, 'nk_utf_encode');
  nk_utf_len := GetProcAddress(aDLLHandle, 'nk_utf_len');
  nk_value_bool := GetProcAddress(aDLLHandle, 'nk_value_bool');
  nk_value_color_byte := GetProcAddress(aDLLHandle, 'nk_value_color_byte');
  nk_value_color_float := GetProcAddress(aDLLHandle, 'nk_value_color_float');
  nk_value_color_hex := GetProcAddress(aDLLHandle, 'nk_value_color_hex');
  nk_value_float := GetProcAddress(aDLLHandle, 'nk_value_float');
  nk_value_int := GetProcAddress(aDLLHandle, 'nk_value_int');
  nk_value_uint := GetProcAddress(aDLLHandle, 'nk_value_uint');
  nk_vec2_rtn := GetProcAddress(aDLLHandle, 'nk_vec2');
  nk_vec2i_rtn := GetProcAddress(aDLLHandle, 'nk_vec2i');
  nk_vec2iv := GetProcAddress(aDLLHandle, 'nk_vec2iv');
  nk_vec2v := GetProcAddress(aDLLHandle, 'nk_vec2v');
  nk_widget := GetProcAddress(aDLLHandle, 'nk_widget');
  nk_widget_bounds := GetProcAddress(aDLLHandle, 'nk_widget_bounds');
  nk_widget_fitting := GetProcAddress(aDLLHandle, 'nk_widget_fitting');
  nk_widget_has_mouse_click_down := GetProcAddress(aDLLHandle, 'nk_widget_has_mouse_click_down');
  nk_widget_height := GetProcAddress(aDLLHandle, 'nk_widget_height');
  nk_widget_is_hovered := GetProcAddress(aDLLHandle, 'nk_widget_is_hovered');
  nk_widget_is_mouse_clicked := GetProcAddress(aDLLHandle, 'nk_widget_is_mouse_clicked');
  nk_widget_position := GetProcAddress(aDLLHandle, 'nk_widget_position');
  nk_widget_size := GetProcAddress(aDLLHandle, 'nk_widget_size');
  nk_widget_width := GetProcAddress(aDLLHandle, 'nk_widget_width');
  nk_window_close := GetProcAddress(aDLLHandle, 'nk_window_close');
  nk_window_collapse := GetProcAddress(aDLLHandle, 'nk_window_collapse');
  nk_window_collapse_if := GetProcAddress(aDLLHandle, 'nk_window_collapse_if');
  nk_window_find := GetProcAddress(aDLLHandle, 'nk_window_find');
  nk_window_get_bounds := GetProcAddress(aDLLHandle, 'nk_window_get_bounds');
  nk_window_get_canvas := GetProcAddress(aDLLHandle, 'nk_window_get_canvas');
  nk_window_get_content_region := GetProcAddress(aDLLHandle, 'nk_window_get_content_region');
  nk_window_get_content_region_max := GetProcAddress(aDLLHandle, 'nk_window_get_content_region_max');
  nk_window_get_content_region_min := GetProcAddress(aDLLHandle, 'nk_window_get_content_region_min');
  nk_window_get_content_region_size := GetProcAddress(aDLLHandle, 'nk_window_get_content_region_size');
  nk_window_get_height := GetProcAddress(aDLLHandle, 'nk_window_get_height');
  nk_window_get_panel := GetProcAddress(aDLLHandle, 'nk_window_get_panel');
  nk_window_get_position := GetProcAddress(aDLLHandle, 'nk_window_get_position');
  nk_window_get_scroll := GetProcAddress(aDLLHandle, 'nk_window_get_scroll');
  nk_window_get_size := GetProcAddress(aDLLHandle, 'nk_window_get_size');
  nk_window_get_width := GetProcAddress(aDLLHandle, 'nk_window_get_width');
  nk_window_has_focus := GetProcAddress(aDLLHandle, 'nk_window_has_focus');
  nk_window_is_active := GetProcAddress(aDLLHandle, 'nk_window_is_active');
  nk_window_is_any_hovered := GetProcAddress(aDLLHandle, 'nk_window_is_any_hovered');
  nk_window_is_closed := GetProcAddress(aDLLHandle, 'nk_window_is_closed');
  nk_window_is_collapsed := GetProcAddress(aDLLHandle, 'nk_window_is_collapsed');
  nk_window_is_hidden := GetProcAddress(aDLLHandle, 'nk_window_is_hidden');
  nk_window_is_hovered := GetProcAddress(aDLLHandle, 'nk_window_is_hovered');
  nk_window_set_bounds := GetProcAddress(aDLLHandle, 'nk_window_set_bounds');
  nk_window_set_focus := GetProcAddress(aDLLHandle, 'nk_window_set_focus');
  nk_window_set_position := GetProcAddress(aDLLHandle, 'nk_window_set_position');
  nk_window_set_scroll := GetProcAddress(aDLLHandle, 'nk_window_set_scroll');
  nk_window_set_size := GetProcAddress(aDLLHandle, 'nk_window_set_size');
  nk_window_show := GetProcAddress(aDLLHandle, 'nk_window_show');
  nk_window_show_if := GetProcAddress(aDLLHandle, 'nk_window_show_if');
  PHYSFS_deinit := GetProcAddress(aDLLHandle, 'PHYSFS_deinit');
  PHYSFS_getWriteDir := GetProcAddress(aDLLHandle, 'PHYSFS_getWriteDir');
  PHYSFS_init := GetProcAddress(aDLLHandle, 'PHYSFS_init');
  PHYSFS_mount := GetProcAddress(aDLLHandle, 'PHYSFS_mount');
  PHYSFS_setWriteDir := GetProcAddress(aDLLHandle, 'PHYSFS_setWriteDir');
  PHYSFS_unmount := GetProcAddress(aDLLHandle, 'PHYSFS_unmount');
  PHYSFSRWOPS_openAppend := GetProcAddress(aDLLHandle, 'PHYSFSRWOPS_openAppend');
  PHYSFSRWOPS_openRead := GetProcAddress(aDLLHandle, 'PHYSFSRWOPS_openRead');
  PHYSFSRWOPS_openWrite := GetProcAddress(aDLLHandle, 'PHYSFSRWOPS_openWrite');
  pieColor := GetProcAddress(aDLLHandle, 'pieColor');
  pieRGBA := GetProcAddress(aDLLHandle, 'pieRGBA');
  pixelColor := GetProcAddress(aDLLHandle, 'pixelColor');
  pixelRGBA := GetProcAddress(aDLLHandle, 'pixelRGBA');
  plm_audio_create_with_buffer := GetProcAddress(aDLLHandle, 'plm_audio_create_with_buffer');
  plm_audio_decode := GetProcAddress(aDLLHandle, 'plm_audio_decode');
  plm_audio_destroy := GetProcAddress(aDLLHandle, 'plm_audio_destroy');
  plm_audio_get_samplerate := GetProcAddress(aDLLHandle, 'plm_audio_get_samplerate');
  plm_audio_get_time := GetProcAddress(aDLLHandle, 'plm_audio_get_time');
  plm_audio_has_ended := GetProcAddress(aDLLHandle, 'plm_audio_has_ended');
  plm_audio_has_header := GetProcAddress(aDLLHandle, 'plm_audio_has_header');
  plm_audio_rewind := GetProcAddress(aDLLHandle, 'plm_audio_rewind');
  plm_audio_set_time := GetProcAddress(aDLLHandle, 'plm_audio_set_time');
  plm_buffer_create_for_appending := GetProcAddress(aDLLHandle, 'plm_buffer_create_for_appending');
  plm_buffer_create_with_capacity := GetProcAddress(aDLLHandle, 'plm_buffer_create_with_capacity');
  plm_buffer_create_with_file := GetProcAddress(aDLLHandle, 'plm_buffer_create_with_file');
  plm_buffer_create_with_filename := GetProcAddress(aDLLHandle, 'plm_buffer_create_with_filename');
  plm_buffer_create_with_memory := GetProcAddress(aDLLHandle, 'plm_buffer_create_with_memory');
  plm_buffer_destroy := GetProcAddress(aDLLHandle, 'plm_buffer_destroy');
  plm_buffer_get_remaining := GetProcAddress(aDLLHandle, 'plm_buffer_get_remaining');
  plm_buffer_get_size := GetProcAddress(aDLLHandle, 'plm_buffer_get_size');
  plm_buffer_has_ended := GetProcAddress(aDLLHandle, 'plm_buffer_has_ended');
  plm_buffer_rewind := GetProcAddress(aDLLHandle, 'plm_buffer_rewind');
  plm_buffer_set_load_callback := GetProcAddress(aDLLHandle, 'plm_buffer_set_load_callback');
  plm_buffer_signal_end := GetProcAddress(aDLLHandle, 'plm_buffer_signal_end');
  plm_buffer_write := GetProcAddress(aDLLHandle, 'plm_buffer_write');
  plm_create_with_buffer := GetProcAddress(aDLLHandle, 'plm_create_with_buffer');
  plm_create_with_file := GetProcAddress(aDLLHandle, 'plm_create_with_file');
  plm_create_with_filename := GetProcAddress(aDLLHandle, 'plm_create_with_filename');
  plm_create_with_memory := GetProcAddress(aDLLHandle, 'plm_create_with_memory');
  plm_decode := GetProcAddress(aDLLHandle, 'plm_decode');
  plm_decode_audio := GetProcAddress(aDLLHandle, 'plm_decode_audio');
  plm_decode_video := GetProcAddress(aDLLHandle, 'plm_decode_video');
  plm_demux_create := GetProcAddress(aDLLHandle, 'plm_demux_create');
  plm_demux_decode := GetProcAddress(aDLLHandle, 'plm_demux_decode');
  plm_demux_destroy := GetProcAddress(aDLLHandle, 'plm_demux_destroy');
  plm_demux_get_duration := GetProcAddress(aDLLHandle, 'plm_demux_get_duration');
  plm_demux_get_num_audio_streams := GetProcAddress(aDLLHandle, 'plm_demux_get_num_audio_streams');
  plm_demux_get_num_video_streams := GetProcAddress(aDLLHandle, 'plm_demux_get_num_video_streams');
  plm_demux_get_start_time := GetProcAddress(aDLLHandle, 'plm_demux_get_start_time');
  plm_demux_has_ended := GetProcAddress(aDLLHandle, 'plm_demux_has_ended');
  plm_demux_has_headers := GetProcAddress(aDLLHandle, 'plm_demux_has_headers');
  plm_demux_rewind := GetProcAddress(aDLLHandle, 'plm_demux_rewind');
  plm_demux_seek := GetProcAddress(aDLLHandle, 'plm_demux_seek');
  plm_destroy := GetProcAddress(aDLLHandle, 'plm_destroy');
  plm_frame_to_abgr := GetProcAddress(aDLLHandle, 'plm_frame_to_abgr');
  plm_frame_to_argb := GetProcAddress(aDLLHandle, 'plm_frame_to_argb');
  plm_frame_to_bgr := GetProcAddress(aDLLHandle, 'plm_frame_to_bgr');
  plm_frame_to_bgra := GetProcAddress(aDLLHandle, 'plm_frame_to_bgra');
  plm_frame_to_rgb := GetProcAddress(aDLLHandle, 'plm_frame_to_rgb');
  plm_frame_to_rgba := GetProcAddress(aDLLHandle, 'plm_frame_to_rgba');
  plm_get_audio_enabled := GetProcAddress(aDLLHandle, 'plm_get_audio_enabled');
  plm_get_audio_lead_time := GetProcAddress(aDLLHandle, 'plm_get_audio_lead_time');
  plm_get_duration := GetProcAddress(aDLLHandle, 'plm_get_duration');
  plm_get_framerate := GetProcAddress(aDLLHandle, 'plm_get_framerate');
  plm_get_height := GetProcAddress(aDLLHandle, 'plm_get_height');
  plm_get_loop := GetProcAddress(aDLLHandle, 'plm_get_loop');
  plm_get_num_audio_streams := GetProcAddress(aDLLHandle, 'plm_get_num_audio_streams');
  plm_get_num_video_streams := GetProcAddress(aDLLHandle, 'plm_get_num_video_streams');
  plm_get_samplerate := GetProcAddress(aDLLHandle, 'plm_get_samplerate');
  plm_get_time := GetProcAddress(aDLLHandle, 'plm_get_time');
  plm_get_video_enabled := GetProcAddress(aDLLHandle, 'plm_get_video_enabled');
  plm_get_width := GetProcAddress(aDLLHandle, 'plm_get_width');
  plm_has_ended := GetProcAddress(aDLLHandle, 'plm_has_ended');
  plm_has_headers := GetProcAddress(aDLLHandle, 'plm_has_headers');
  plm_rewind := GetProcAddress(aDLLHandle, 'plm_rewind');
  plm_seek := GetProcAddress(aDLLHandle, 'plm_seek');
  plm_seek_frame := GetProcAddress(aDLLHandle, 'plm_seek_frame');
  plm_set_audio_decode_callback := GetProcAddress(aDLLHandle, 'plm_set_audio_decode_callback');
  plm_set_audio_enabled := GetProcAddress(aDLLHandle, 'plm_set_audio_enabled');
  plm_set_audio_lead_time := GetProcAddress(aDLLHandle, 'plm_set_audio_lead_time');
  plm_set_audio_stream := GetProcAddress(aDLLHandle, 'plm_set_audio_stream');
  plm_set_loop := GetProcAddress(aDLLHandle, 'plm_set_loop');
  plm_set_video_decode_callback := GetProcAddress(aDLLHandle, 'plm_set_video_decode_callback');
  plm_set_video_enabled := GetProcAddress(aDLLHandle, 'plm_set_video_enabled');
  plm_video_create_with_buffer := GetProcAddress(aDLLHandle, 'plm_video_create_with_buffer');
  plm_video_decode := GetProcAddress(aDLLHandle, 'plm_video_decode');
  plm_video_destroy := GetProcAddress(aDLLHandle, 'plm_video_destroy');
  plm_video_get_framerate := GetProcAddress(aDLLHandle, 'plm_video_get_framerate');
  plm_video_get_height := GetProcAddress(aDLLHandle, 'plm_video_get_height');
  plm_video_get_time := GetProcAddress(aDLLHandle, 'plm_video_get_time');
  plm_video_get_width := GetProcAddress(aDLLHandle, 'plm_video_get_width');
  plm_video_has_ended := GetProcAddress(aDLLHandle, 'plm_video_has_ended');
  plm_video_has_header := GetProcAddress(aDLLHandle, 'plm_video_has_header');
  plm_video_rewind := GetProcAddress(aDLLHandle, 'plm_video_rewind');
  plm_video_set_no_delay := GetProcAddress(aDLLHandle, 'plm_video_set_no_delay');
  plm_video_set_time := GetProcAddress(aDLLHandle, 'plm_video_set_time');
  polygonColor := GetProcAddress(aDLLHandle, 'polygonColor');
  polygonRGBA := GetProcAddress(aDLLHandle, 'polygonRGBA');
  rectangleColor := GetProcAddress(aDLLHandle, 'rectangleColor');
  rectangleRGBA := GetProcAddress(aDLLHandle, 'rectangleRGBA');
  roundedBoxColor := GetProcAddress(aDLLHandle, 'roundedBoxColor');
  roundedBoxRGBA := GetProcAddress(aDLLHandle, 'roundedBoxRGBA');
  roundedRectangleColor := GetProcAddress(aDLLHandle, 'roundedRectangleColor');
  roundedRectangleRGBA := GetProcAddress(aDLLHandle, 'roundedRectangleRGBA');
  SDL_abs := GetProcAddress(aDLLHandle, 'SDL_abs');
  SDL_acos := GetProcAddress(aDLLHandle, 'SDL_acos');
  SDL_acosf := GetProcAddress(aDLLHandle, 'SDL_acosf');
  SDL_AddEventWatch := GetProcAddress(aDLLHandle, 'SDL_AddEventWatch');
  SDL_AddHintCallback := GetProcAddress(aDLLHandle, 'SDL_AddHintCallback');
  SDL_AddTimer := GetProcAddress(aDLLHandle, 'SDL_AddTimer');
  SDL_AllocFormat := GetProcAddress(aDLLHandle, 'SDL_AllocFormat');
  SDL_AllocPalette := GetProcAddress(aDLLHandle, 'SDL_AllocPalette');
  SDL_AllocRW := GetProcAddress(aDLLHandle, 'SDL_AllocRW');
  SDL_asin := GetProcAddress(aDLLHandle, 'SDL_asin');
  SDL_asinf := GetProcAddress(aDLLHandle, 'SDL_asinf');
  SDL_asprintf := GetProcAddress(aDLLHandle, 'SDL_asprintf');
  SDL_atan := GetProcAddress(aDLLHandle, 'SDL_atan');
  SDL_atan2 := GetProcAddress(aDLLHandle, 'SDL_atan2');
  SDL_atan2f := GetProcAddress(aDLLHandle, 'SDL_atan2f');
  SDL_atanf := GetProcAddress(aDLLHandle, 'SDL_atanf');
  SDL_atof := GetProcAddress(aDLLHandle, 'SDL_atof');
  SDL_atoi := GetProcAddress(aDLLHandle, 'SDL_atoi');
  SDL_AtomicAdd := GetProcAddress(aDLLHandle, 'SDL_AtomicAdd');
  SDL_AtomicCAS := GetProcAddress(aDLLHandle, 'SDL_AtomicCAS');
  SDL_AtomicCASPtr := GetProcAddress(aDLLHandle, 'SDL_AtomicCASPtr');
  SDL_AtomicGet := GetProcAddress(aDLLHandle, 'SDL_AtomicGet');
  SDL_AtomicGetPtr := GetProcAddress(aDLLHandle, 'SDL_AtomicGetPtr');
  SDL_AtomicLock := GetProcAddress(aDLLHandle, 'SDL_AtomicLock');
  SDL_AtomicSet := GetProcAddress(aDLLHandle, 'SDL_AtomicSet');
  SDL_AtomicSetPtr := GetProcAddress(aDLLHandle, 'SDL_AtomicSetPtr');
  SDL_AtomicTryLock := GetProcAddress(aDLLHandle, 'SDL_AtomicTryLock');
  SDL_AtomicUnlock := GetProcAddress(aDLLHandle, 'SDL_AtomicUnlock');
  SDL_AudioInit := GetProcAddress(aDLLHandle, 'SDL_AudioInit');
  SDL_AudioQuit := GetProcAddress(aDLLHandle, 'SDL_AudioQuit');
  SDL_AudioStreamAvailable := GetProcAddress(aDLLHandle, 'SDL_AudioStreamAvailable');
  SDL_AudioStreamClear := GetProcAddress(aDLLHandle, 'SDL_AudioStreamClear');
  SDL_AudioStreamFlush := GetProcAddress(aDLLHandle, 'SDL_AudioStreamFlush');
  SDL_AudioStreamGet := GetProcAddress(aDLLHandle, 'SDL_AudioStreamGet');
  SDL_AudioStreamPut := GetProcAddress(aDLLHandle, 'SDL_AudioStreamPut');
  SDL_bsearch := GetProcAddress(aDLLHandle, 'SDL_bsearch');
  SDL_BuildAudioCVT := GetProcAddress(aDLLHandle, 'SDL_BuildAudioCVT');
  SDL_CalculateGammaRamp := GetProcAddress(aDLLHandle, 'SDL_CalculateGammaRamp');
  SDL_calloc := GetProcAddress(aDLLHandle, 'SDL_calloc');
  SDL_CaptureMouse := GetProcAddress(aDLLHandle, 'SDL_CaptureMouse');
  SDL_ceil := GetProcAddress(aDLLHandle, 'SDL_ceil');
  SDL_ceilf := GetProcAddress(aDLLHandle, 'SDL_ceilf');
  SDL_ClearComposition := GetProcAddress(aDLLHandle, 'SDL_ClearComposition');
  SDL_ClearError := GetProcAddress(aDLLHandle, 'SDL_ClearError');
  SDL_ClearHints := GetProcAddress(aDLLHandle, 'SDL_ClearHints');
  SDL_ClearQueuedAudio := GetProcAddress(aDLLHandle, 'SDL_ClearQueuedAudio');
  SDL_CloseAudio := GetProcAddress(aDLLHandle, 'SDL_CloseAudio');
  SDL_CloseAudioDevice := GetProcAddress(aDLLHandle, 'SDL_CloseAudioDevice');
  SDL_ComposeCustomBlendMode := GetProcAddress(aDLLHandle, 'SDL_ComposeCustomBlendMode');
  SDL_CondBroadcast := GetProcAddress(aDLLHandle, 'SDL_CondBroadcast');
  SDL_CondSignal := GetProcAddress(aDLLHandle, 'SDL_CondSignal');
  SDL_CondWait := GetProcAddress(aDLLHandle, 'SDL_CondWait');
  SDL_CondWaitTimeout := GetProcAddress(aDLLHandle, 'SDL_CondWaitTimeout');
  SDL_ConvertAudio := GetProcAddress(aDLLHandle, 'SDL_ConvertAudio');
  SDL_ConvertPixels := GetProcAddress(aDLLHandle, 'SDL_ConvertPixels');
  SDL_ConvertSurface := GetProcAddress(aDLLHandle, 'SDL_ConvertSurface');
  SDL_ConvertSurfaceFormat := GetProcAddress(aDLLHandle, 'SDL_ConvertSurfaceFormat');
  SDL_copysign := GetProcAddress(aDLLHandle, 'SDL_copysign');
  SDL_copysignf := GetProcAddress(aDLLHandle, 'SDL_copysignf');
  SDL_cos := GetProcAddress(aDLLHandle, 'SDL_cos');
  SDL_cosf := GetProcAddress(aDLLHandle, 'SDL_cosf');
  SDL_crc16 := GetProcAddress(aDLLHandle, 'SDL_crc16');
  SDL_crc32 := GetProcAddress(aDLLHandle, 'SDL_crc32');
  SDL_CreateColorCursor := GetProcAddress(aDLLHandle, 'SDL_CreateColorCursor');
  SDL_CreateCond := GetProcAddress(aDLLHandle, 'SDL_CreateCond');
  SDL_CreateCursor := GetProcAddress(aDLLHandle, 'SDL_CreateCursor');
  SDL_CreateMutex := GetProcAddress(aDLLHandle, 'SDL_CreateMutex');
  SDL_CreateRenderer := GetProcAddress(aDLLHandle, 'SDL_CreateRenderer');
  SDL_CreateRGBSurface := GetProcAddress(aDLLHandle, 'SDL_CreateRGBSurface');
  SDL_CreateRGBSurfaceFrom := GetProcAddress(aDLLHandle, 'SDL_CreateRGBSurfaceFrom');
  SDL_CreateRGBSurfaceWithFormat := GetProcAddress(aDLLHandle, 'SDL_CreateRGBSurfaceWithFormat');
  SDL_CreateRGBSurfaceWithFormatFrom := GetProcAddress(aDLLHandle, 'SDL_CreateRGBSurfaceWithFormatFrom');
  SDL_CreateSemaphore := GetProcAddress(aDLLHandle, 'SDL_CreateSemaphore');
  SDL_CreateShapedWindow := GetProcAddress(aDLLHandle, 'SDL_CreateShapedWindow');
  SDL_CreateSoftwareRenderer := GetProcAddress(aDLLHandle, 'SDL_CreateSoftwareRenderer');
  SDL_CreateSystemCursor := GetProcAddress(aDLLHandle, 'SDL_CreateSystemCursor');
  SDL_CreateTexture := GetProcAddress(aDLLHandle, 'SDL_CreateTexture');
  SDL_CreateTextureFromSurface := GetProcAddress(aDLLHandle, 'SDL_CreateTextureFromSurface');
  SDL_CreateThread := GetProcAddress(aDLLHandle, 'SDL_CreateThread');
  SDL_CreateThreadWithStackSize := GetProcAddress(aDLLHandle, 'SDL_CreateThreadWithStackSize');
  SDL_CreateWindow := GetProcAddress(aDLLHandle, 'SDL_CreateWindow');
  SDL_CreateWindowAndRenderer := GetProcAddress(aDLLHandle, 'SDL_CreateWindowAndRenderer');
  SDL_CreateWindowFrom := GetProcAddress(aDLLHandle, 'SDL_CreateWindowFrom');
  SDL_Delay := GetProcAddress(aDLLHandle, 'SDL_Delay');
  SDL_DelEventWatch := GetProcAddress(aDLLHandle, 'SDL_DelEventWatch');
  SDL_DelHintCallback := GetProcAddress(aDLLHandle, 'SDL_DelHintCallback');
  SDL_DequeueAudio := GetProcAddress(aDLLHandle, 'SDL_DequeueAudio');
  SDL_DestroyCond := GetProcAddress(aDLLHandle, 'SDL_DestroyCond');
  SDL_DestroyMutex := GetProcAddress(aDLLHandle, 'SDL_DestroyMutex');
  SDL_DestroyRenderer := GetProcAddress(aDLLHandle, 'SDL_DestroyRenderer');
  SDL_DestroySemaphore := GetProcAddress(aDLLHandle, 'SDL_DestroySemaphore');
  SDL_DestroyTexture := GetProcAddress(aDLLHandle, 'SDL_DestroyTexture');
  SDL_DestroyWindow := GetProcAddress(aDLLHandle, 'SDL_DestroyWindow');
  SDL_DetachThread := GetProcAddress(aDLLHandle, 'SDL_DetachThread');
  SDL_Direct3D9GetAdapterIndex := GetProcAddress(aDLLHandle, 'SDL_Direct3D9GetAdapterIndex');
  SDL_DisableScreenSaver := GetProcAddress(aDLLHandle, 'SDL_DisableScreenSaver');
  SDL_DuplicateSurface := GetProcAddress(aDLLHandle, 'SDL_DuplicateSurface');
  SDL_DXGIGetOutputInfo := GetProcAddress(aDLLHandle, 'SDL_DXGIGetOutputInfo');
  SDL_EnableScreenSaver := GetProcAddress(aDLLHandle, 'SDL_EnableScreenSaver');
  SDL_EncloseFPoints := GetProcAddress(aDLLHandle, 'SDL_EncloseFPoints');
  SDL_EnclosePoints := GetProcAddress(aDLLHandle, 'SDL_EnclosePoints');
  SDL_Error := GetProcAddress(aDLLHandle, 'SDL_Error');
  SDL_EventState := GetProcAddress(aDLLHandle, 'SDL_EventState');
  SDL_exp := GetProcAddress(aDLLHandle, 'SDL_exp');
  SDL_expf := GetProcAddress(aDLLHandle, 'SDL_expf');
  SDL_fabs := GetProcAddress(aDLLHandle, 'SDL_fabs');
  SDL_fabsf := GetProcAddress(aDLLHandle, 'SDL_fabsf');
  SDL_FillRect := GetProcAddress(aDLLHandle, 'SDL_FillRect');
  SDL_FillRects := GetProcAddress(aDLLHandle, 'SDL_FillRects');
  SDL_FilterEvents := GetProcAddress(aDLLHandle, 'SDL_FilterEvents');
  SDL_FlashWindow := GetProcAddress(aDLLHandle, 'SDL_FlashWindow');
  SDL_floor := GetProcAddress(aDLLHandle, 'SDL_floor');
  SDL_floorf := GetProcAddress(aDLLHandle, 'SDL_floorf');
  SDL_FlushEvent := GetProcAddress(aDLLHandle, 'SDL_FlushEvent');
  SDL_FlushEvents := GetProcAddress(aDLLHandle, 'SDL_FlushEvents');
  SDL_fmod := GetProcAddress(aDLLHandle, 'SDL_fmod');
  SDL_fmodf := GetProcAddress(aDLLHandle, 'SDL_fmodf');
  SDL_free := GetProcAddress(aDLLHandle, 'SDL_free');
  SDL_FreeAudioStream := GetProcAddress(aDLLHandle, 'SDL_FreeAudioStream');
  SDL_FreeCursor := GetProcAddress(aDLLHandle, 'SDL_FreeCursor');
  SDL_FreeFormat := GetProcAddress(aDLLHandle, 'SDL_FreeFormat');
  SDL_FreePalette := GetProcAddress(aDLLHandle, 'SDL_FreePalette');
  SDL_FreeRW := GetProcAddress(aDLLHandle, 'SDL_FreeRW');
  SDL_FreeSurface := GetProcAddress(aDLLHandle, 'SDL_FreeSurface');
  SDL_FreeWAV := GetProcAddress(aDLLHandle, 'SDL_FreeWAV');
  SDL_GameControllerAddMapping := GetProcAddress(aDLLHandle, 'SDL_GameControllerAddMapping');
  SDL_GameControllerAddMappingsFromRW := GetProcAddress(aDLLHandle, 'SDL_GameControllerAddMappingsFromRW');
  SDL_GameControllerClose := GetProcAddress(aDLLHandle, 'SDL_GameControllerClose');
  SDL_GameControllerEventState := GetProcAddress(aDLLHandle, 'SDL_GameControllerEventState');
  SDL_GameControllerFromInstanceID := GetProcAddress(aDLLHandle, 'SDL_GameControllerFromInstanceID');
  SDL_GameControllerFromPlayerIndex := GetProcAddress(aDLLHandle, 'SDL_GameControllerFromPlayerIndex');
  SDL_GameControllerGetAppleSFSymbolsNameForAxis := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetAppleSFSymbolsNameForAxis');
  SDL_GameControllerGetAppleSFSymbolsNameForButton := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetAppleSFSymbolsNameForButton');
  SDL_GameControllerGetAttached := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetAttached');
  SDL_GameControllerGetAxis := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetAxis');
  SDL_GameControllerGetAxisFromString := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetAxisFromString');
  SDL_GameControllerGetBindForAxis := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetBindForAxis');
  SDL_GameControllerGetBindForButton := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetBindForButton');
  SDL_GameControllerGetButton := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetButton');
  SDL_GameControllerGetButtonFromString := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetButtonFromString');
  SDL_GameControllerGetFirmwareVersion := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetFirmwareVersion');
  SDL_GameControllerGetJoystick := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetJoystick');
  SDL_GameControllerGetNumTouchpadFingers := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetNumTouchpadFingers');
  SDL_GameControllerGetNumTouchpads := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetNumTouchpads');
  SDL_GameControllerGetPlayerIndex := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetPlayerIndex');
  SDL_GameControllerGetProduct := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetProduct');
  SDL_GameControllerGetProductVersion := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetProductVersion');
  SDL_GameControllerGetSensorData := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetSensorData');
  SDL_GameControllerGetSensorDataRate := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetSensorDataRate');
  SDL_GameControllerGetSerial := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetSerial');
  SDL_GameControllerGetStringForAxis := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetStringForAxis');
  SDL_GameControllerGetStringForButton := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetStringForButton');
  SDL_GameControllerGetTouchpadFinger := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetTouchpadFinger');
  SDL_GameControllerGetType := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetType');
  SDL_GameControllerGetVendor := GetProcAddress(aDLLHandle, 'SDL_GameControllerGetVendor');
  SDL_GameControllerHasAxis := GetProcAddress(aDLLHandle, 'SDL_GameControllerHasAxis');
  SDL_GameControllerHasButton := GetProcAddress(aDLLHandle, 'SDL_GameControllerHasButton');
  SDL_GameControllerHasLED := GetProcAddress(aDLLHandle, 'SDL_GameControllerHasLED');
  SDL_GameControllerHasRumble := GetProcAddress(aDLLHandle, 'SDL_GameControllerHasRumble');
  SDL_GameControllerHasRumbleTriggers := GetProcAddress(aDLLHandle, 'SDL_GameControllerHasRumbleTriggers');
  SDL_GameControllerHasSensor := GetProcAddress(aDLLHandle, 'SDL_GameControllerHasSensor');
  SDL_GameControllerIsSensorEnabled := GetProcAddress(aDLLHandle, 'SDL_GameControllerIsSensorEnabled');
  SDL_GameControllerMapping := GetProcAddress(aDLLHandle, 'SDL_GameControllerMapping');
  SDL_GameControllerMappingForDeviceIndex := GetProcAddress(aDLLHandle, 'SDL_GameControllerMappingForDeviceIndex');
  SDL_GameControllerMappingForGUID := GetProcAddress(aDLLHandle, 'SDL_GameControllerMappingForGUID');
  SDL_GameControllerMappingForIndex := GetProcAddress(aDLLHandle, 'SDL_GameControllerMappingForIndex');
  SDL_GameControllerName := GetProcAddress(aDLLHandle, 'SDL_GameControllerName');
  SDL_GameControllerNameForIndex := GetProcAddress(aDLLHandle, 'SDL_GameControllerNameForIndex');
  SDL_GameControllerNumMappings := GetProcAddress(aDLLHandle, 'SDL_GameControllerNumMappings');
  SDL_GameControllerOpen := GetProcAddress(aDLLHandle, 'SDL_GameControllerOpen');
  SDL_GameControllerPath := GetProcAddress(aDLLHandle, 'SDL_GameControllerPath');
  SDL_GameControllerPathForIndex := GetProcAddress(aDLLHandle, 'SDL_GameControllerPathForIndex');
  SDL_GameControllerRumble := GetProcAddress(aDLLHandle, 'SDL_GameControllerRumble');
  SDL_GameControllerRumbleTriggers := GetProcAddress(aDLLHandle, 'SDL_GameControllerRumbleTriggers');
  SDL_GameControllerSendEffect := GetProcAddress(aDLLHandle, 'SDL_GameControllerSendEffect');
  SDL_GameControllerSetLED := GetProcAddress(aDLLHandle, 'SDL_GameControllerSetLED');
  SDL_GameControllerSetPlayerIndex := GetProcAddress(aDLLHandle, 'SDL_GameControllerSetPlayerIndex');
  SDL_GameControllerSetSensorEnabled := GetProcAddress(aDLLHandle, 'SDL_GameControllerSetSensorEnabled');
  SDL_GameControllerTypeForIndex := GetProcAddress(aDLLHandle, 'SDL_GameControllerTypeForIndex');
  SDL_GameControllerUpdate := GetProcAddress(aDLLHandle, 'SDL_GameControllerUpdate');
  SDL_GetAssertionHandler := GetProcAddress(aDLLHandle, 'SDL_GetAssertionHandler');
  SDL_GetAssertionReport := GetProcAddress(aDLLHandle, 'SDL_GetAssertionReport');
  SDL_GetAudioDeviceName := GetProcAddress(aDLLHandle, 'SDL_GetAudioDeviceName');
  SDL_GetAudioDeviceSpec := GetProcAddress(aDLLHandle, 'SDL_GetAudioDeviceSpec');
  SDL_GetAudioDeviceStatus := GetProcAddress(aDLLHandle, 'SDL_GetAudioDeviceStatus');
  SDL_GetAudioDriver := GetProcAddress(aDLLHandle, 'SDL_GetAudioDriver');
  SDL_GetAudioStatus := GetProcAddress(aDLLHandle, 'SDL_GetAudioStatus');
  SDL_GetBasePath := GetProcAddress(aDLLHandle, 'SDL_GetBasePath');
  SDL_GetClipboardText := GetProcAddress(aDLLHandle, 'SDL_GetClipboardText');
  SDL_GetClipRect := GetProcAddress(aDLLHandle, 'SDL_GetClipRect');
  SDL_GetClosestDisplayMode := GetProcAddress(aDLLHandle, 'SDL_GetClosestDisplayMode');
  SDL_GetColorKey := GetProcAddress(aDLLHandle, 'SDL_GetColorKey');
  SDL_GetCPUCacheLineSize := GetProcAddress(aDLLHandle, 'SDL_GetCPUCacheLineSize');
  SDL_GetCPUCount := GetProcAddress(aDLLHandle, 'SDL_GetCPUCount');
  SDL_GetCurrentAudioDriver := GetProcAddress(aDLLHandle, 'SDL_GetCurrentAudioDriver');
  SDL_GetCurrentDisplayMode := GetProcAddress(aDLLHandle, 'SDL_GetCurrentDisplayMode');
  SDL_GetCurrentVideoDriver := GetProcAddress(aDLLHandle, 'SDL_GetCurrentVideoDriver');
  SDL_GetCursor := GetProcAddress(aDLLHandle, 'SDL_GetCursor');
  SDL_GetDefaultAssertionHandler := GetProcAddress(aDLLHandle, 'SDL_GetDefaultAssertionHandler');
  SDL_GetDefaultAudioInfo := GetProcAddress(aDLLHandle, 'SDL_GetDefaultAudioInfo');
  SDL_GetDefaultCursor := GetProcAddress(aDLLHandle, 'SDL_GetDefaultCursor');
  SDL_GetDesktopDisplayMode := GetProcAddress(aDLLHandle, 'SDL_GetDesktopDisplayMode');
  SDL_GetDisplayBounds := GetProcAddress(aDLLHandle, 'SDL_GetDisplayBounds');
  SDL_GetDisplayDPI := GetProcAddress(aDLLHandle, 'SDL_GetDisplayDPI');
  SDL_GetDisplayMode := GetProcAddress(aDLLHandle, 'SDL_GetDisplayMode');
  SDL_GetDisplayName := GetProcAddress(aDLLHandle, 'SDL_GetDisplayName');
  SDL_GetDisplayOrientation := GetProcAddress(aDLLHandle, 'SDL_GetDisplayOrientation');
  SDL_GetDisplayUsableBounds := GetProcAddress(aDLLHandle, 'SDL_GetDisplayUsableBounds');
  SDL_getenv := GetProcAddress(aDLLHandle, 'SDL_getenv');
  SDL_GetError := GetProcAddress(aDLLHandle, 'SDL_GetError');
  SDL_GetErrorMsg := GetProcAddress(aDLLHandle, 'SDL_GetErrorMsg');
  SDL_GetEventFilter := GetProcAddress(aDLLHandle, 'SDL_GetEventFilter');
  SDL_GetGlobalMouseState := GetProcAddress(aDLLHandle, 'SDL_GetGlobalMouseState');
  SDL_GetGrabbedWindow := GetProcAddress(aDLLHandle, 'SDL_GetGrabbedWindow');
  SDL_GetHint := GetProcAddress(aDLLHandle, 'SDL_GetHint');
  SDL_GetHintBoolean := GetProcAddress(aDLLHandle, 'SDL_GetHintBoolean');
  SDL_GetJoystickGUIDInfo := GetProcAddress(aDLLHandle, 'SDL_GetJoystickGUIDInfo');
  SDL_GetKeyboardFocus := GetProcAddress(aDLLHandle, 'SDL_GetKeyboardFocus');
  SDL_GetKeyboardState := GetProcAddress(aDLLHandle, 'SDL_GetKeyboardState');
  SDL_GetKeyFromName := GetProcAddress(aDLLHandle, 'SDL_GetKeyFromName');
  SDL_GetKeyFromScancode := GetProcAddress(aDLLHandle, 'SDL_GetKeyFromScancode');
  SDL_GetKeyName := GetProcAddress(aDLLHandle, 'SDL_GetKeyName');
  SDL_GetMemoryFunctions := GetProcAddress(aDLLHandle, 'SDL_GetMemoryFunctions');
  SDL_GetModState := GetProcAddress(aDLLHandle, 'SDL_GetModState');
  SDL_GetMouseFocus := GetProcAddress(aDLLHandle, 'SDL_GetMouseFocus');
  SDL_GetMouseState := GetProcAddress(aDLLHandle, 'SDL_GetMouseState');
  SDL_GetNumAllocations := GetProcAddress(aDLLHandle, 'SDL_GetNumAllocations');
  SDL_GetNumAudioDevices := GetProcAddress(aDLLHandle, 'SDL_GetNumAudioDevices');
  SDL_GetNumAudioDrivers := GetProcAddress(aDLLHandle, 'SDL_GetNumAudioDrivers');
  SDL_GetNumDisplayModes := GetProcAddress(aDLLHandle, 'SDL_GetNumDisplayModes');
  SDL_GetNumRenderDrivers := GetProcAddress(aDLLHandle, 'SDL_GetNumRenderDrivers');
  SDL_GetNumTouchDevices := GetProcAddress(aDLLHandle, 'SDL_GetNumTouchDevices');
  SDL_GetNumTouchFingers := GetProcAddress(aDLLHandle, 'SDL_GetNumTouchFingers');
  SDL_GetNumVideoDisplays := GetProcAddress(aDLLHandle, 'SDL_GetNumVideoDisplays');
  SDL_GetNumVideoDrivers := GetProcAddress(aDLLHandle, 'SDL_GetNumVideoDrivers');
  SDL_GetOriginalMemoryFunctions := GetProcAddress(aDLLHandle, 'SDL_GetOriginalMemoryFunctions');
  SDL_GetPerformanceCounter := GetProcAddress(aDLLHandle, 'SDL_GetPerformanceCounter');
  SDL_GetPerformanceFrequency := GetProcAddress(aDLLHandle, 'SDL_GetPerformanceFrequency');
  SDL_GetPixelFormatName := GetProcAddress(aDLLHandle, 'SDL_GetPixelFormatName');
  SDL_GetPlatform := GetProcAddress(aDLLHandle, 'SDL_GetPlatform');
  SDL_GetPointDisplayIndex := GetProcAddress(aDLLHandle, 'SDL_GetPointDisplayIndex');
  SDL_GetPowerInfo := GetProcAddress(aDLLHandle, 'SDL_GetPowerInfo');
  SDL_GetPreferredLocales := GetProcAddress(aDLLHandle, 'SDL_GetPreferredLocales');
  SDL_GetPrefPath := GetProcAddress(aDLLHandle, 'SDL_GetPrefPath');
  SDL_GetPrimarySelectionText := GetProcAddress(aDLLHandle, 'SDL_GetPrimarySelectionText');
  SDL_GetQueuedAudioSize := GetProcAddress(aDLLHandle, 'SDL_GetQueuedAudioSize');
  SDL_GetRectDisplayIndex := GetProcAddress(aDLLHandle, 'SDL_GetRectDisplayIndex');
  SDL_GetRelativeMouseMode := GetProcAddress(aDLLHandle, 'SDL_GetRelativeMouseMode');
  SDL_GetRelativeMouseState := GetProcAddress(aDLLHandle, 'SDL_GetRelativeMouseState');
  SDL_GetRenderDrawBlendMode := GetProcAddress(aDLLHandle, 'SDL_GetRenderDrawBlendMode');
  SDL_GetRenderDrawColor := GetProcAddress(aDLLHandle, 'SDL_GetRenderDrawColor');
  SDL_GetRenderDriverInfo := GetProcAddress(aDLLHandle, 'SDL_GetRenderDriverInfo');
  SDL_GetRenderer := GetProcAddress(aDLLHandle, 'SDL_GetRenderer');
  SDL_GetRendererInfo := GetProcAddress(aDLLHandle, 'SDL_GetRendererInfo');
  SDL_GetRendererOutputSize := GetProcAddress(aDLLHandle, 'SDL_GetRendererOutputSize');
  SDL_GetRenderTarget := GetProcAddress(aDLLHandle, 'SDL_GetRenderTarget');
  SDL_GetRevision := GetProcAddress(aDLLHandle, 'SDL_GetRevision');
  SDL_GetRevisionNumber := GetProcAddress(aDLLHandle, 'SDL_GetRevisionNumber');
  SDL_GetRGB := GetProcAddress(aDLLHandle, 'SDL_GetRGB');
  SDL_GetRGBA := GetProcAddress(aDLLHandle, 'SDL_GetRGBA');
  SDL_GetScancodeFromKey := GetProcAddress(aDLLHandle, 'SDL_GetScancodeFromKey');
  SDL_GetScancodeFromName := GetProcAddress(aDLLHandle, 'SDL_GetScancodeFromName');
  SDL_GetScancodeName := GetProcAddress(aDLLHandle, 'SDL_GetScancodeName');
  SDL_GetShapedWindowMode := GetProcAddress(aDLLHandle, 'SDL_GetShapedWindowMode');
  SDL_GetSurfaceAlphaMod := GetProcAddress(aDLLHandle, 'SDL_GetSurfaceAlphaMod');
  SDL_GetSurfaceBlendMode := GetProcAddress(aDLLHandle, 'SDL_GetSurfaceBlendMode');
  SDL_GetSurfaceColorMod := GetProcAddress(aDLLHandle, 'SDL_GetSurfaceColorMod');
  SDL_GetSystemRAM := GetProcAddress(aDLLHandle, 'SDL_GetSystemRAM');
  SDL_GetTextureAlphaMod := GetProcAddress(aDLLHandle, 'SDL_GetTextureAlphaMod');
  SDL_GetTextureBlendMode := GetProcAddress(aDLLHandle, 'SDL_GetTextureBlendMode');
  SDL_GetTextureColorMod := GetProcAddress(aDLLHandle, 'SDL_GetTextureColorMod');
  SDL_GetTextureScaleMode := GetProcAddress(aDLLHandle, 'SDL_GetTextureScaleMode');
  SDL_GetTextureUserData := GetProcAddress(aDLLHandle, 'SDL_GetTextureUserData');
  SDL_GetThreadID := GetProcAddress(aDLLHandle, 'SDL_GetThreadID');
  SDL_GetThreadName := GetProcAddress(aDLLHandle, 'SDL_GetThreadName');
  SDL_GetTicks := GetProcAddress(aDLLHandle, 'SDL_GetTicks');
  SDL_GetTicks64 := GetProcAddress(aDLLHandle, 'SDL_GetTicks64');
  SDL_GetTouchDevice := GetProcAddress(aDLLHandle, 'SDL_GetTouchDevice');
  SDL_GetTouchDeviceType := GetProcAddress(aDLLHandle, 'SDL_GetTouchDeviceType');
  SDL_GetTouchFinger := GetProcAddress(aDLLHandle, 'SDL_GetTouchFinger');
  SDL_GetTouchName := GetProcAddress(aDLLHandle, 'SDL_GetTouchName');
  SDL_GetVersion := GetProcAddress(aDLLHandle, 'SDL_GetVersion');
  SDL_GetVideoDriver := GetProcAddress(aDLLHandle, 'SDL_GetVideoDriver');
  SDL_GetWindowBordersSize := GetProcAddress(aDLLHandle, 'SDL_GetWindowBordersSize');
  SDL_GetWindowBrightness := GetProcAddress(aDLLHandle, 'SDL_GetWindowBrightness');
  SDL_GetWindowData := GetProcAddress(aDLLHandle, 'SDL_GetWindowData');
  SDL_GetWindowDisplayIndex := GetProcAddress(aDLLHandle, 'SDL_GetWindowDisplayIndex');
  SDL_GetWindowDisplayMode := GetProcAddress(aDLLHandle, 'SDL_GetWindowDisplayMode');
  SDL_GetWindowFlags := GetProcAddress(aDLLHandle, 'SDL_GetWindowFlags');
  SDL_GetWindowFromID := GetProcAddress(aDLLHandle, 'SDL_GetWindowFromID');
  SDL_GetWindowGammaRamp := GetProcAddress(aDLLHandle, 'SDL_GetWindowGammaRamp');
  SDL_GetWindowGrab := GetProcAddress(aDLLHandle, 'SDL_GetWindowGrab');
  SDL_GetWindowICCProfile := GetProcAddress(aDLLHandle, 'SDL_GetWindowICCProfile');
  SDL_GetWindowID := GetProcAddress(aDLLHandle, 'SDL_GetWindowID');
  SDL_GetWindowKeyboardGrab := GetProcAddress(aDLLHandle, 'SDL_GetWindowKeyboardGrab');
  SDL_GetWindowMaximumSize := GetProcAddress(aDLLHandle, 'SDL_GetWindowMaximumSize');
  SDL_GetWindowMinimumSize := GetProcAddress(aDLLHandle, 'SDL_GetWindowMinimumSize');
  SDL_GetWindowMouseGrab := GetProcAddress(aDLLHandle, 'SDL_GetWindowMouseGrab');
  SDL_GetWindowMouseRect := GetProcAddress(aDLLHandle, 'SDL_GetWindowMouseRect');
  SDL_GetWindowOpacity := GetProcAddress(aDLLHandle, 'SDL_GetWindowOpacity');
  SDL_GetWindowPixelFormat := GetProcAddress(aDLLHandle, 'SDL_GetWindowPixelFormat');
  SDL_GetWindowPosition := GetProcAddress(aDLLHandle, 'SDL_GetWindowPosition');
  SDL_GetWindowSize := GetProcAddress(aDLLHandle, 'SDL_GetWindowSize');
  SDL_GetWindowSizeInPixels := GetProcAddress(aDLLHandle, 'SDL_GetWindowSizeInPixels');
  SDL_GetWindowSurface := GetProcAddress(aDLLHandle, 'SDL_GetWindowSurface');
  SDL_GetWindowTitle := GetProcAddress(aDLLHandle, 'SDL_GetWindowTitle');
  SDL_GetYUVConversionMode := GetProcAddress(aDLLHandle, 'SDL_GetYUVConversionMode');
  SDL_GetYUVConversionModeForResolution := GetProcAddress(aDLLHandle, 'SDL_GetYUVConversionModeForResolution');
  SDL_GL_BindTexture := GetProcAddress(aDLLHandle, 'SDL_GL_BindTexture');
  SDL_GL_CreateContext := GetProcAddress(aDLLHandle, 'SDL_GL_CreateContext');
  SDL_GL_DeleteContext := GetProcAddress(aDLLHandle, 'SDL_GL_DeleteContext');
  SDL_GL_ExtensionSupported := GetProcAddress(aDLLHandle, 'SDL_GL_ExtensionSupported');
  SDL_GL_GetAttribute := GetProcAddress(aDLLHandle, 'SDL_GL_GetAttribute');
  SDL_GL_GetCurrentContext := GetProcAddress(aDLLHandle, 'SDL_GL_GetCurrentContext');
  SDL_GL_GetCurrentWindow := GetProcAddress(aDLLHandle, 'SDL_GL_GetCurrentWindow');
  SDL_GL_GetDrawableSize := GetProcAddress(aDLLHandle, 'SDL_GL_GetDrawableSize');
  SDL_GL_GetProcAddress := GetProcAddress(aDLLHandle, 'SDL_GL_GetProcAddress');
  SDL_GL_GetSwapInterval := GetProcAddress(aDLLHandle, 'SDL_GL_GetSwapInterval');
  SDL_GL_LoadLibrary := GetProcAddress(aDLLHandle, 'SDL_GL_LoadLibrary');
  SDL_GL_MakeCurrent := GetProcAddress(aDLLHandle, 'SDL_GL_MakeCurrent');
  SDL_GL_ResetAttributes := GetProcAddress(aDLLHandle, 'SDL_GL_ResetAttributes');
  SDL_GL_SetAttribute := GetProcAddress(aDLLHandle, 'SDL_GL_SetAttribute');
  SDL_GL_SetSwapInterval := GetProcAddress(aDLLHandle, 'SDL_GL_SetSwapInterval');
  SDL_GL_SwapWindow := GetProcAddress(aDLLHandle, 'SDL_GL_SwapWindow');
  SDL_GL_UnbindTexture := GetProcAddress(aDLLHandle, 'SDL_GL_UnbindTexture');
  SDL_GL_UnloadLibrary := GetProcAddress(aDLLHandle, 'SDL_GL_UnloadLibrary');
  SDL_GUIDFromString := GetProcAddress(aDLLHandle, 'SDL_GUIDFromString');
  SDL_GUIDToString := GetProcAddress(aDLLHandle, 'SDL_GUIDToString');
  SDL_HapticClose := GetProcAddress(aDLLHandle, 'SDL_HapticClose');
  SDL_HapticDestroyEffect := GetProcAddress(aDLLHandle, 'SDL_HapticDestroyEffect');
  SDL_HapticEffectSupported := GetProcAddress(aDLLHandle, 'SDL_HapticEffectSupported');
  SDL_HapticGetEffectStatus := GetProcAddress(aDLLHandle, 'SDL_HapticGetEffectStatus');
  SDL_HapticIndex := GetProcAddress(aDLLHandle, 'SDL_HapticIndex');
  SDL_HapticName := GetProcAddress(aDLLHandle, 'SDL_HapticName');
  SDL_HapticNewEffect := GetProcAddress(aDLLHandle, 'SDL_HapticNewEffect');
  SDL_HapticNumAxes := GetProcAddress(aDLLHandle, 'SDL_HapticNumAxes');
  SDL_HapticNumEffects := GetProcAddress(aDLLHandle, 'SDL_HapticNumEffects');
  SDL_HapticNumEffectsPlaying := GetProcAddress(aDLLHandle, 'SDL_HapticNumEffectsPlaying');
  SDL_HapticOpen := GetProcAddress(aDLLHandle, 'SDL_HapticOpen');
  SDL_HapticOpened := GetProcAddress(aDLLHandle, 'SDL_HapticOpened');
  SDL_HapticOpenFromJoystick := GetProcAddress(aDLLHandle, 'SDL_HapticOpenFromJoystick');
  SDL_HapticOpenFromMouse := GetProcAddress(aDLLHandle, 'SDL_HapticOpenFromMouse');
  SDL_HapticPause := GetProcAddress(aDLLHandle, 'SDL_HapticPause');
  SDL_HapticQuery := GetProcAddress(aDLLHandle, 'SDL_HapticQuery');
  SDL_HapticRumbleInit := GetProcAddress(aDLLHandle, 'SDL_HapticRumbleInit');
  SDL_HapticRumblePlay := GetProcAddress(aDLLHandle, 'SDL_HapticRumblePlay');
  SDL_HapticRumbleStop := GetProcAddress(aDLLHandle, 'SDL_HapticRumbleStop');
  SDL_HapticRumbleSupported := GetProcAddress(aDLLHandle, 'SDL_HapticRumbleSupported');
  SDL_HapticRunEffect := GetProcAddress(aDLLHandle, 'SDL_HapticRunEffect');
  SDL_HapticSetAutocenter := GetProcAddress(aDLLHandle, 'SDL_HapticSetAutocenter');
  SDL_HapticSetGain := GetProcAddress(aDLLHandle, 'SDL_HapticSetGain');
  SDL_HapticStopAll := GetProcAddress(aDLLHandle, 'SDL_HapticStopAll');
  SDL_HapticStopEffect := GetProcAddress(aDLLHandle, 'SDL_HapticStopEffect');
  SDL_HapticUnpause := GetProcAddress(aDLLHandle, 'SDL_HapticUnpause');
  SDL_HapticUpdateEffect := GetProcAddress(aDLLHandle, 'SDL_HapticUpdateEffect');
  SDL_Has3DNow := GetProcAddress(aDLLHandle, 'SDL_Has3DNow');
  SDL_HasAltiVec := GetProcAddress(aDLLHandle, 'SDL_HasAltiVec');
  SDL_HasARMSIMD := GetProcAddress(aDLLHandle, 'SDL_HasARMSIMD');
  SDL_HasAVX := GetProcAddress(aDLLHandle, 'SDL_HasAVX');
  SDL_HasAVX2 := GetProcAddress(aDLLHandle, 'SDL_HasAVX2');
  SDL_HasAVX512F := GetProcAddress(aDLLHandle, 'SDL_HasAVX512F');
  SDL_HasClipboardText := GetProcAddress(aDLLHandle, 'SDL_HasClipboardText');
  SDL_HasColorKey := GetProcAddress(aDLLHandle, 'SDL_HasColorKey');
  SDL_HasEvent := GetProcAddress(aDLLHandle, 'SDL_HasEvent');
  SDL_HasEvents := GetProcAddress(aDLLHandle, 'SDL_HasEvents');
  SDL_HasIntersection := GetProcAddress(aDLLHandle, 'SDL_HasIntersection');
  SDL_HasIntersectionF := GetProcAddress(aDLLHandle, 'SDL_HasIntersectionF');
  SDL_HasLASX := GetProcAddress(aDLLHandle, 'SDL_HasLASX');
  SDL_HasLSX := GetProcAddress(aDLLHandle, 'SDL_HasLSX');
  SDL_HasMMX := GetProcAddress(aDLLHandle, 'SDL_HasMMX');
  SDL_HasNEON := GetProcAddress(aDLLHandle, 'SDL_HasNEON');
  SDL_HasPrimarySelectionText := GetProcAddress(aDLLHandle, 'SDL_HasPrimarySelectionText');
  SDL_HasRDTSC := GetProcAddress(aDLLHandle, 'SDL_HasRDTSC');
  SDL_HasScreenKeyboardSupport := GetProcAddress(aDLLHandle, 'SDL_HasScreenKeyboardSupport');
  SDL_HasSSE := GetProcAddress(aDLLHandle, 'SDL_HasSSE');
  SDL_HasSSE2 := GetProcAddress(aDLLHandle, 'SDL_HasSSE2');
  SDL_HasSSE3 := GetProcAddress(aDLLHandle, 'SDL_HasSSE3');
  SDL_HasSSE41 := GetProcAddress(aDLLHandle, 'SDL_HasSSE41');
  SDL_HasSSE42 := GetProcAddress(aDLLHandle, 'SDL_HasSSE42');
  SDL_HasSurfaceRLE := GetProcAddress(aDLLHandle, 'SDL_HasSurfaceRLE');
  SDL_hid_ble_scan := GetProcAddress(aDLLHandle, 'SDL_hid_ble_scan');
  SDL_hid_close := GetProcAddress(aDLLHandle, 'SDL_hid_close');
  SDL_hid_device_change_count := GetProcAddress(aDLLHandle, 'SDL_hid_device_change_count');
  SDL_hid_enumerate := GetProcAddress(aDLLHandle, 'SDL_hid_enumerate');
  SDL_hid_exit := GetProcAddress(aDLLHandle, 'SDL_hid_exit');
  SDL_hid_free_enumeration := GetProcAddress(aDLLHandle, 'SDL_hid_free_enumeration');
  SDL_hid_get_feature_report := GetProcAddress(aDLLHandle, 'SDL_hid_get_feature_report');
  SDL_hid_get_indexed_string := GetProcAddress(aDLLHandle, 'SDL_hid_get_indexed_string');
  SDL_hid_get_manufacturer_string := GetProcAddress(aDLLHandle, 'SDL_hid_get_manufacturer_string');
  SDL_hid_get_product_string := GetProcAddress(aDLLHandle, 'SDL_hid_get_product_string');
  SDL_hid_get_serial_number_string := GetProcAddress(aDLLHandle, 'SDL_hid_get_serial_number_string');
  SDL_hid_init := GetProcAddress(aDLLHandle, 'SDL_hid_init');
  SDL_hid_open := GetProcAddress(aDLLHandle, 'SDL_hid_open');
  SDL_hid_open_path := GetProcAddress(aDLLHandle, 'SDL_hid_open_path');
  SDL_hid_read := GetProcAddress(aDLLHandle, 'SDL_hid_read');
  SDL_hid_read_timeout := GetProcAddress(aDLLHandle, 'SDL_hid_read_timeout');
  SDL_hid_send_feature_report := GetProcAddress(aDLLHandle, 'SDL_hid_send_feature_report');
  SDL_hid_set_nonblocking := GetProcAddress(aDLLHandle, 'SDL_hid_set_nonblocking');
  SDL_hid_write := GetProcAddress(aDLLHandle, 'SDL_hid_write');
  SDL_HideWindow := GetProcAddress(aDLLHandle, 'SDL_HideWindow');
  SDL_iconv := GetProcAddress(aDLLHandle, 'SDL_iconv');
  SDL_iconv_close := GetProcAddress(aDLLHandle, 'SDL_iconv_close');
  SDL_iconv_open := GetProcAddress(aDLLHandle, 'SDL_iconv_open');
  SDL_iconv_string := GetProcAddress(aDLLHandle, 'SDL_iconv_string');
  SDL_Init := GetProcAddress(aDLLHandle, 'SDL_Init');
  SDL_InitSubSystem := GetProcAddress(aDLLHandle, 'SDL_InitSubSystem');
  SDL_IntersectFRect := GetProcAddress(aDLLHandle, 'SDL_IntersectFRect');
  SDL_IntersectFRectAndLine := GetProcAddress(aDLLHandle, 'SDL_IntersectFRectAndLine');
  SDL_IntersectRect := GetProcAddress(aDLLHandle, 'SDL_IntersectRect');
  SDL_IntersectRectAndLine := GetProcAddress(aDLLHandle, 'SDL_IntersectRectAndLine');
  SDL_isalnum := GetProcAddress(aDLLHandle, 'SDL_isalnum');
  SDL_isalpha := GetProcAddress(aDLLHandle, 'SDL_isalpha');
  SDL_isblank := GetProcAddress(aDLLHandle, 'SDL_isblank');
  SDL_iscntrl := GetProcAddress(aDLLHandle, 'SDL_iscntrl');
  SDL_isdigit := GetProcAddress(aDLLHandle, 'SDL_isdigit');
  SDL_IsGameController := GetProcAddress(aDLLHandle, 'SDL_IsGameController');
  SDL_isgraph := GetProcAddress(aDLLHandle, 'SDL_isgraph');
  SDL_islower := GetProcAddress(aDLLHandle, 'SDL_islower');
  SDL_isprint := GetProcAddress(aDLLHandle, 'SDL_isprint');
  SDL_ispunct := GetProcAddress(aDLLHandle, 'SDL_ispunct');
  SDL_IsScreenKeyboardShown := GetProcAddress(aDLLHandle, 'SDL_IsScreenKeyboardShown');
  SDL_IsScreenSaverEnabled := GetProcAddress(aDLLHandle, 'SDL_IsScreenSaverEnabled');
  SDL_IsShapedWindow := GetProcAddress(aDLLHandle, 'SDL_IsShapedWindow');
  SDL_isspace := GetProcAddress(aDLLHandle, 'SDL_isspace');
  SDL_IsTablet := GetProcAddress(aDLLHandle, 'SDL_IsTablet');
  SDL_IsTextInputActive := GetProcAddress(aDLLHandle, 'SDL_IsTextInputActive');
  SDL_IsTextInputShown := GetProcAddress(aDLLHandle, 'SDL_IsTextInputShown');
  SDL_isupper := GetProcAddress(aDLLHandle, 'SDL_isupper');
  SDL_isxdigit := GetProcAddress(aDLLHandle, 'SDL_isxdigit');
  SDL_itoa := GetProcAddress(aDLLHandle, 'SDL_itoa');
  SDL_JoystickAttachVirtual := GetProcAddress(aDLLHandle, 'SDL_JoystickAttachVirtual');
  SDL_JoystickAttachVirtualEx := GetProcAddress(aDLLHandle, 'SDL_JoystickAttachVirtualEx');
  SDL_JoystickClose := GetProcAddress(aDLLHandle, 'SDL_JoystickClose');
  SDL_JoystickCurrentPowerLevel := GetProcAddress(aDLLHandle, 'SDL_JoystickCurrentPowerLevel');
  SDL_JoystickDetachVirtual := GetProcAddress(aDLLHandle, 'SDL_JoystickDetachVirtual');
  SDL_JoystickEventState := GetProcAddress(aDLLHandle, 'SDL_JoystickEventState');
  SDL_JoystickFromInstanceID := GetProcAddress(aDLLHandle, 'SDL_JoystickFromInstanceID');
  SDL_JoystickFromPlayerIndex := GetProcAddress(aDLLHandle, 'SDL_JoystickFromPlayerIndex');
  SDL_JoystickGetAttached := GetProcAddress(aDLLHandle, 'SDL_JoystickGetAttached');
  SDL_JoystickGetAxis := GetProcAddress(aDLLHandle, 'SDL_JoystickGetAxis');
  SDL_JoystickGetAxisInitialState := GetProcAddress(aDLLHandle, 'SDL_JoystickGetAxisInitialState');
  SDL_JoystickGetBall := GetProcAddress(aDLLHandle, 'SDL_JoystickGetBall');
  SDL_JoystickGetButton := GetProcAddress(aDLLHandle, 'SDL_JoystickGetButton');
  SDL_JoystickGetDeviceGUID := GetProcAddress(aDLLHandle, 'SDL_JoystickGetDeviceGUID');
  SDL_JoystickGetDeviceInstanceID := GetProcAddress(aDLLHandle, 'SDL_JoystickGetDeviceInstanceID');
  SDL_JoystickGetDevicePlayerIndex := GetProcAddress(aDLLHandle, 'SDL_JoystickGetDevicePlayerIndex');
  SDL_JoystickGetDeviceProduct := GetProcAddress(aDLLHandle, 'SDL_JoystickGetDeviceProduct');
  SDL_JoystickGetDeviceProductVersion := GetProcAddress(aDLLHandle, 'SDL_JoystickGetDeviceProductVersion');
  SDL_JoystickGetDeviceType := GetProcAddress(aDLLHandle, 'SDL_JoystickGetDeviceType');
  SDL_JoystickGetDeviceVendor := GetProcAddress(aDLLHandle, 'SDL_JoystickGetDeviceVendor');
  SDL_JoystickGetFirmwareVersion := GetProcAddress(aDLLHandle, 'SDL_JoystickGetFirmwareVersion');
  SDL_JoystickGetGUID := GetProcAddress(aDLLHandle, 'SDL_JoystickGetGUID');
  SDL_JoystickGetGUIDFromString := GetProcAddress(aDLLHandle, 'SDL_JoystickGetGUIDFromString');
  SDL_JoystickGetGUIDString := GetProcAddress(aDLLHandle, 'SDL_JoystickGetGUIDString');
  SDL_JoystickGetHat := GetProcAddress(aDLLHandle, 'SDL_JoystickGetHat');
  SDL_JoystickGetPlayerIndex := GetProcAddress(aDLLHandle, 'SDL_JoystickGetPlayerIndex');
  SDL_JoystickGetProduct := GetProcAddress(aDLLHandle, 'SDL_JoystickGetProduct');
  SDL_JoystickGetProductVersion := GetProcAddress(aDLLHandle, 'SDL_JoystickGetProductVersion');
  SDL_JoystickGetSerial := GetProcAddress(aDLLHandle, 'SDL_JoystickGetSerial');
  SDL_JoystickGetType := GetProcAddress(aDLLHandle, 'SDL_JoystickGetType');
  SDL_JoystickGetVendor := GetProcAddress(aDLLHandle, 'SDL_JoystickGetVendor');
  SDL_JoystickHasLED := GetProcAddress(aDLLHandle, 'SDL_JoystickHasLED');
  SDL_JoystickHasRumble := GetProcAddress(aDLLHandle, 'SDL_JoystickHasRumble');
  SDL_JoystickHasRumbleTriggers := GetProcAddress(aDLLHandle, 'SDL_JoystickHasRumbleTriggers');
  SDL_JoystickInstanceID := GetProcAddress(aDLLHandle, 'SDL_JoystickInstanceID');
  SDL_JoystickIsHaptic := GetProcAddress(aDLLHandle, 'SDL_JoystickIsHaptic');
  SDL_JoystickIsVirtual := GetProcAddress(aDLLHandle, 'SDL_JoystickIsVirtual');
  SDL_JoystickName := GetProcAddress(aDLLHandle, 'SDL_JoystickName');
  SDL_JoystickNameForIndex := GetProcAddress(aDLLHandle, 'SDL_JoystickNameForIndex');
  SDL_JoystickNumAxes := GetProcAddress(aDLLHandle, 'SDL_JoystickNumAxes');
  SDL_JoystickNumBalls := GetProcAddress(aDLLHandle, 'SDL_JoystickNumBalls');
  SDL_JoystickNumButtons := GetProcAddress(aDLLHandle, 'SDL_JoystickNumButtons');
  SDL_JoystickNumHats := GetProcAddress(aDLLHandle, 'SDL_JoystickNumHats');
  SDL_JoystickOpen := GetProcAddress(aDLLHandle, 'SDL_JoystickOpen');
  SDL_JoystickPath := GetProcAddress(aDLLHandle, 'SDL_JoystickPath');
  SDL_JoystickPathForIndex := GetProcAddress(aDLLHandle, 'SDL_JoystickPathForIndex');
  SDL_JoystickRumble := GetProcAddress(aDLLHandle, 'SDL_JoystickRumble');
  SDL_JoystickRumbleTriggers := GetProcAddress(aDLLHandle, 'SDL_JoystickRumbleTriggers');
  SDL_JoystickSendEffect := GetProcAddress(aDLLHandle, 'SDL_JoystickSendEffect');
  SDL_JoystickSetLED := GetProcAddress(aDLLHandle, 'SDL_JoystickSetLED');
  SDL_JoystickSetPlayerIndex := GetProcAddress(aDLLHandle, 'SDL_JoystickSetPlayerIndex');
  SDL_JoystickSetVirtualAxis := GetProcAddress(aDLLHandle, 'SDL_JoystickSetVirtualAxis');
  SDL_JoystickSetVirtualButton := GetProcAddress(aDLLHandle, 'SDL_JoystickSetVirtualButton');
  SDL_JoystickSetVirtualHat := GetProcAddress(aDLLHandle, 'SDL_JoystickSetVirtualHat');
  SDL_JoystickUpdate := GetProcAddress(aDLLHandle, 'SDL_JoystickUpdate');
  SDL_lltoa := GetProcAddress(aDLLHandle, 'SDL_lltoa');
  SDL_LoadBMP_RW := GetProcAddress(aDLLHandle, 'SDL_LoadBMP_RW');
  SDL_LoadDollarTemplates := GetProcAddress(aDLLHandle, 'SDL_LoadDollarTemplates');
  SDL_LoadFile := GetProcAddress(aDLLHandle, 'SDL_LoadFile');
  SDL_LoadFile_RW := GetProcAddress(aDLLHandle, 'SDL_LoadFile_RW');
  SDL_LoadFunction := GetProcAddress(aDLLHandle, 'SDL_LoadFunction');
  SDL_LoadObject := GetProcAddress(aDLLHandle, 'SDL_LoadObject');
  SDL_LoadWAV_RW := GetProcAddress(aDLLHandle, 'SDL_LoadWAV_RW');
  SDL_LockAudio := GetProcAddress(aDLLHandle, 'SDL_LockAudio');
  SDL_LockAudioDevice := GetProcAddress(aDLLHandle, 'SDL_LockAudioDevice');
  SDL_LockJoysticks := GetProcAddress(aDLLHandle, 'SDL_LockJoysticks');
  SDL_LockMutex := GetProcAddress(aDLLHandle, 'SDL_LockMutex');
  SDL_LockSensors := GetProcAddress(aDLLHandle, 'SDL_LockSensors');
  SDL_LockSurface := GetProcAddress(aDLLHandle, 'SDL_LockSurface');
  SDL_LockTexture := GetProcAddress(aDLLHandle, 'SDL_LockTexture');
  SDL_LockTextureToSurface := GetProcAddress(aDLLHandle, 'SDL_LockTextureToSurface');
  SDL_log := GetProcAddress(aDLLHandle, 'SDL_log');
  SDL_Log_ := GetProcAddress(aDLLHandle, 'SDL_Log_');
  SDL_log10 := GetProcAddress(aDLLHandle, 'SDL_log10');
  SDL_log10f := GetProcAddress(aDLLHandle, 'SDL_log10f');
  SDL_LogCritical := GetProcAddress(aDLLHandle, 'SDL_LogCritical');
  SDL_LogDebug := GetProcAddress(aDLLHandle, 'SDL_LogDebug');
  SDL_LogError := GetProcAddress(aDLLHandle, 'SDL_LogError');
  SDL_logf := GetProcAddress(aDLLHandle, 'SDL_logf');
  SDL_LogGetOutputFunction := GetProcAddress(aDLLHandle, 'SDL_LogGetOutputFunction');
  SDL_LogGetPriority := GetProcAddress(aDLLHandle, 'SDL_LogGetPriority');
  SDL_LogInfo := GetProcAddress(aDLLHandle, 'SDL_LogInfo');
  SDL_LogMessage := GetProcAddress(aDLLHandle, 'SDL_LogMessage');
  SDL_LogMessageV := GetProcAddress(aDLLHandle, 'SDL_LogMessageV');
  SDL_LogResetPriorities := GetProcAddress(aDLLHandle, 'SDL_LogResetPriorities');
  SDL_LogSetAllPriority := GetProcAddress(aDLLHandle, 'SDL_LogSetAllPriority');
  SDL_LogSetOutputFunction := GetProcAddress(aDLLHandle, 'SDL_LogSetOutputFunction');
  SDL_LogSetPriority := GetProcAddress(aDLLHandle, 'SDL_LogSetPriority');
  SDL_LogVerbose := GetProcAddress(aDLLHandle, 'SDL_LogVerbose');
  SDL_LogWarn := GetProcAddress(aDLLHandle, 'SDL_LogWarn');
  SDL_LowerBlit := GetProcAddress(aDLLHandle, 'SDL_LowerBlit');
  SDL_LowerBlitScaled := GetProcAddress(aDLLHandle, 'SDL_LowerBlitScaled');
  SDL_lround := GetProcAddress(aDLLHandle, 'SDL_lround');
  SDL_lroundf := GetProcAddress(aDLLHandle, 'SDL_lroundf');
  SDL_ltoa := GetProcAddress(aDLLHandle, 'SDL_ltoa');
  SDL_main := GetProcAddress(aDLLHandle, 'SDL_main');
  SDL_malloc := GetProcAddress(aDLLHandle, 'SDL_malloc');
  SDL_MapRGB := GetProcAddress(aDLLHandle, 'SDL_MapRGB');
  SDL_MapRGBA := GetProcAddress(aDLLHandle, 'SDL_MapRGBA');
  SDL_MasksToPixelFormatEnum := GetProcAddress(aDLLHandle, 'SDL_MasksToPixelFormatEnum');
  SDL_MaximizeWindow := GetProcAddress(aDLLHandle, 'SDL_MaximizeWindow');
  SDL_memcmp := GetProcAddress(aDLLHandle, 'SDL_memcmp');
  SDL_memcpy := GetProcAddress(aDLLHandle, 'SDL_memcpy');
  SDL_memmove := GetProcAddress(aDLLHandle, 'SDL_memmove');
  SDL_MemoryBarrierAcquireFunction := GetProcAddress(aDLLHandle, 'SDL_MemoryBarrierAcquireFunction');
  SDL_MemoryBarrierReleaseFunction := GetProcAddress(aDLLHandle, 'SDL_MemoryBarrierReleaseFunction');
  SDL_memset := GetProcAddress(aDLLHandle, 'SDL_memset');
  SDL_Metal_CreateView := GetProcAddress(aDLLHandle, 'SDL_Metal_CreateView');
  SDL_Metal_DestroyView := GetProcAddress(aDLLHandle, 'SDL_Metal_DestroyView');
  SDL_Metal_GetDrawableSize := GetProcAddress(aDLLHandle, 'SDL_Metal_GetDrawableSize');
  SDL_Metal_GetLayer := GetProcAddress(aDLLHandle, 'SDL_Metal_GetLayer');
  SDL_MinimizeWindow := GetProcAddress(aDLLHandle, 'SDL_MinimizeWindow');
  SDL_MixAudio := GetProcAddress(aDLLHandle, 'SDL_MixAudio');
  SDL_MixAudioFormat := GetProcAddress(aDLLHandle, 'SDL_MixAudioFormat');
  SDL_MouseIsHaptic := GetProcAddress(aDLLHandle, 'SDL_MouseIsHaptic');
  SDL_NewAudioStream := GetProcAddress(aDLLHandle, 'SDL_NewAudioStream');
  SDL_NumHaptics := GetProcAddress(aDLLHandle, 'SDL_NumHaptics');
  SDL_NumJoysticks := GetProcAddress(aDLLHandle, 'SDL_NumJoysticks');
  SDL_NumSensors := GetProcAddress(aDLLHandle, 'SDL_NumSensors');
  SDL_OnApplicationDidBecomeActive := GetProcAddress(aDLLHandle, 'SDL_OnApplicationDidBecomeActive');
  SDL_OnApplicationDidEnterBackground := GetProcAddress(aDLLHandle, 'SDL_OnApplicationDidEnterBackground');
  SDL_OnApplicationDidReceiveMemoryWarning := GetProcAddress(aDLLHandle, 'SDL_OnApplicationDidReceiveMemoryWarning');
  SDL_OnApplicationWillEnterForeground := GetProcAddress(aDLLHandle, 'SDL_OnApplicationWillEnterForeground');
  SDL_OnApplicationWillResignActive := GetProcAddress(aDLLHandle, 'SDL_OnApplicationWillResignActive');
  SDL_OnApplicationWillTerminate := GetProcAddress(aDLLHandle, 'SDL_OnApplicationWillTerminate');
  SDL_OpenAudio := GetProcAddress(aDLLHandle, 'SDL_OpenAudio');
  SDL_OpenAudioDevice := GetProcAddress(aDLLHandle, 'SDL_OpenAudioDevice');
  SDL_OpenURL := GetProcAddress(aDLLHandle, 'SDL_OpenURL');
  SDL_PauseAudio := GetProcAddress(aDLLHandle, 'SDL_PauseAudio');
  SDL_PauseAudioDevice := GetProcAddress(aDLLHandle, 'SDL_PauseAudioDevice');
  SDL_PeepEvents := GetProcAddress(aDLLHandle, 'SDL_PeepEvents');
  SDL_PixelFormatEnumToMasks := GetProcAddress(aDLLHandle, 'SDL_PixelFormatEnumToMasks');
  SDL_PollEvent := GetProcAddress(aDLLHandle, 'SDL_PollEvent');
  SDL_pow := GetProcAddress(aDLLHandle, 'SDL_pow');
  SDL_powf := GetProcAddress(aDLLHandle, 'SDL_powf');
  SDL_PremultiplyAlpha := GetProcAddress(aDLLHandle, 'SDL_PremultiplyAlpha');
  SDL_PumpEvents := GetProcAddress(aDLLHandle, 'SDL_PumpEvents');
  SDL_PushEvent := GetProcAddress(aDLLHandle, 'SDL_PushEvent');
  SDL_qsort := GetProcAddress(aDLLHandle, 'SDL_qsort');
  SDL_QueryTexture := GetProcAddress(aDLLHandle, 'SDL_QueryTexture');
  SDL_QueueAudio := GetProcAddress(aDLLHandle, 'SDL_QueueAudio');
  SDL_Quit := GetProcAddress(aDLLHandle, 'SDL_Quit');
  SDL_QuitSubSystem := GetProcAddress(aDLLHandle, 'SDL_QuitSubSystem');
  SDL_RaiseWindow := GetProcAddress(aDLLHandle, 'SDL_RaiseWindow');
  SDL_ReadBE16 := GetProcAddress(aDLLHandle, 'SDL_ReadBE16');
  SDL_ReadBE32 := GetProcAddress(aDLLHandle, 'SDL_ReadBE32');
  SDL_ReadBE64 := GetProcAddress(aDLLHandle, 'SDL_ReadBE64');
  SDL_ReadLE16 := GetProcAddress(aDLLHandle, 'SDL_ReadLE16');
  SDL_ReadLE32 := GetProcAddress(aDLLHandle, 'SDL_ReadLE32');
  SDL_ReadLE64 := GetProcAddress(aDLLHandle, 'SDL_ReadLE64');
  SDL_ReadU8 := GetProcAddress(aDLLHandle, 'SDL_ReadU8');
  SDL_realloc := GetProcAddress(aDLLHandle, 'SDL_realloc');
  SDL_RecordGesture := GetProcAddress(aDLLHandle, 'SDL_RecordGesture');
  SDL_RegisterApp := GetProcAddress(aDLLHandle, 'SDL_RegisterApp');
  SDL_RegisterEvents := GetProcAddress(aDLLHandle, 'SDL_RegisterEvents');
  SDL_RemoveTimer := GetProcAddress(aDLLHandle, 'SDL_RemoveTimer');
  SDL_RenderClear := GetProcAddress(aDLLHandle, 'SDL_RenderClear');
  SDL_RenderCopy := GetProcAddress(aDLLHandle, 'SDL_RenderCopy');
  SDL_RenderCopyEx := GetProcAddress(aDLLHandle, 'SDL_RenderCopyEx');
  SDL_RenderCopyExF := GetProcAddress(aDLLHandle, 'SDL_RenderCopyExF');
  SDL_RenderCopyF := GetProcAddress(aDLLHandle, 'SDL_RenderCopyF');
  SDL_RenderDrawLine := GetProcAddress(aDLLHandle, 'SDL_RenderDrawLine');
  SDL_RenderDrawLineF := GetProcAddress(aDLLHandle, 'SDL_RenderDrawLineF');
  SDL_RenderDrawLines := GetProcAddress(aDLLHandle, 'SDL_RenderDrawLines');
  SDL_RenderDrawLinesF := GetProcAddress(aDLLHandle, 'SDL_RenderDrawLinesF');
  SDL_RenderDrawPoint := GetProcAddress(aDLLHandle, 'SDL_RenderDrawPoint');
  SDL_RenderDrawPointF := GetProcAddress(aDLLHandle, 'SDL_RenderDrawPointF');
  SDL_RenderDrawPoints := GetProcAddress(aDLLHandle, 'SDL_RenderDrawPoints');
  SDL_RenderDrawPointsF := GetProcAddress(aDLLHandle, 'SDL_RenderDrawPointsF');
  SDL_RenderDrawRect := GetProcAddress(aDLLHandle, 'SDL_RenderDrawRect');
  SDL_RenderDrawRectF := GetProcAddress(aDLLHandle, 'SDL_RenderDrawRectF');
  SDL_RenderDrawRects := GetProcAddress(aDLLHandle, 'SDL_RenderDrawRects');
  SDL_RenderDrawRectsF := GetProcAddress(aDLLHandle, 'SDL_RenderDrawRectsF');
  SDL_RenderFillRect := GetProcAddress(aDLLHandle, 'SDL_RenderFillRect');
  SDL_RenderFillRectF := GetProcAddress(aDLLHandle, 'SDL_RenderFillRectF');
  SDL_RenderFillRects := GetProcAddress(aDLLHandle, 'SDL_RenderFillRects');
  SDL_RenderFillRectsF := GetProcAddress(aDLLHandle, 'SDL_RenderFillRectsF');
  SDL_RenderFlush := GetProcAddress(aDLLHandle, 'SDL_RenderFlush');
  SDL_RenderGeometry := GetProcAddress(aDLLHandle, 'SDL_RenderGeometry');
  SDL_RenderGeometryRaw := GetProcAddress(aDLLHandle, 'SDL_RenderGeometryRaw');
  SDL_RenderGetClipRect := GetProcAddress(aDLLHandle, 'SDL_RenderGetClipRect');
  SDL_RenderGetD3D11Device := GetProcAddress(aDLLHandle, 'SDL_RenderGetD3D11Device');
  SDL_RenderGetD3D12Device := GetProcAddress(aDLLHandle, 'SDL_RenderGetD3D12Device');
  SDL_RenderGetD3D9Device := GetProcAddress(aDLLHandle, 'SDL_RenderGetD3D9Device');
  SDL_RenderGetIntegerScale := GetProcAddress(aDLLHandle, 'SDL_RenderGetIntegerScale');
  SDL_RenderGetLogicalSize := GetProcAddress(aDLLHandle, 'SDL_RenderGetLogicalSize');
  SDL_RenderGetMetalCommandEncoder := GetProcAddress(aDLLHandle, 'SDL_RenderGetMetalCommandEncoder');
  SDL_RenderGetMetalLayer := GetProcAddress(aDLLHandle, 'SDL_RenderGetMetalLayer');
  SDL_RenderGetScale := GetProcAddress(aDLLHandle, 'SDL_RenderGetScale');
  SDL_RenderGetViewport := GetProcAddress(aDLLHandle, 'SDL_RenderGetViewport');
  SDL_RenderGetWindow := GetProcAddress(aDLLHandle, 'SDL_RenderGetWindow');
  SDL_RenderIsClipEnabled := GetProcAddress(aDLLHandle, 'SDL_RenderIsClipEnabled');
  SDL_RenderLogicalToWindow := GetProcAddress(aDLLHandle, 'SDL_RenderLogicalToWindow');
  SDL_RenderPresent := GetProcAddress(aDLLHandle, 'SDL_RenderPresent');
  SDL_RenderReadPixels := GetProcAddress(aDLLHandle, 'SDL_RenderReadPixels');
  SDL_RenderSetClipRect := GetProcAddress(aDLLHandle, 'SDL_RenderSetClipRect');
  SDL_RenderSetIntegerScale := GetProcAddress(aDLLHandle, 'SDL_RenderSetIntegerScale');
  SDL_RenderSetLogicalSize := GetProcAddress(aDLLHandle, 'SDL_RenderSetLogicalSize');
  SDL_RenderSetScale := GetProcAddress(aDLLHandle, 'SDL_RenderSetScale');
  SDL_RenderSetViewport := GetProcAddress(aDLLHandle, 'SDL_RenderSetViewport');
  SDL_RenderSetVSync := GetProcAddress(aDLLHandle, 'SDL_RenderSetVSync');
  SDL_RenderTargetSupported := GetProcAddress(aDLLHandle, 'SDL_RenderTargetSupported');
  SDL_RenderWindowToLogical := GetProcAddress(aDLLHandle, 'SDL_RenderWindowToLogical');
  SDL_ReportAssertion := GetProcAddress(aDLLHandle, 'SDL_ReportAssertion');
  SDL_ResetAssertionReport := GetProcAddress(aDLLHandle, 'SDL_ResetAssertionReport');
  SDL_ResetHint := GetProcAddress(aDLLHandle, 'SDL_ResetHint');
  SDL_ResetKeyboard := GetProcAddress(aDLLHandle, 'SDL_ResetKeyboard');
  SDL_RestoreWindow := GetProcAddress(aDLLHandle, 'SDL_RestoreWindow');
  SDL_round := GetProcAddress(aDLLHandle, 'SDL_round');
  SDL_roundf := GetProcAddress(aDLLHandle, 'SDL_roundf');
  SDL_RWclose := GetProcAddress(aDLLHandle, 'SDL_RWclose');
  SDL_RWFromConstMem := GetProcAddress(aDLLHandle, 'SDL_RWFromConstMem');
  SDL_RWFromFile := GetProcAddress(aDLLHandle, 'SDL_RWFromFile');
  SDL_RWFromFP := GetProcAddress(aDLLHandle, 'SDL_RWFromFP');
  SDL_RWFromMem := GetProcAddress(aDLLHandle, 'SDL_RWFromMem');
  SDL_RWread := GetProcAddress(aDLLHandle, 'SDL_RWread');
  SDL_RWseek := GetProcAddress(aDLLHandle, 'SDL_RWseek');
  SDL_RWsize := GetProcAddress(aDLLHandle, 'SDL_RWsize');
  SDL_RWtell := GetProcAddress(aDLLHandle, 'SDL_RWtell');
  SDL_RWwrite := GetProcAddress(aDLLHandle, 'SDL_RWwrite');
  SDL_SaveAllDollarTemplates := GetProcAddress(aDLLHandle, 'SDL_SaveAllDollarTemplates');
  SDL_SaveBMP_RW := GetProcAddress(aDLLHandle, 'SDL_SaveBMP_RW');
  SDL_SaveDollarTemplate := GetProcAddress(aDLLHandle, 'SDL_SaveDollarTemplate');
  SDL_scalbn := GetProcAddress(aDLLHandle, 'SDL_scalbn');
  SDL_scalbnf := GetProcAddress(aDLLHandle, 'SDL_scalbnf');
  SDL_SemPost := GetProcAddress(aDLLHandle, 'SDL_SemPost');
  SDL_SemTryWait := GetProcAddress(aDLLHandle, 'SDL_SemTryWait');
  SDL_SemValue := GetProcAddress(aDLLHandle, 'SDL_SemValue');
  SDL_SemWait := GetProcAddress(aDLLHandle, 'SDL_SemWait');
  SDL_SemWaitTimeout := GetProcAddress(aDLLHandle, 'SDL_SemWaitTimeout');
  SDL_SensorClose := GetProcAddress(aDLLHandle, 'SDL_SensorClose');
  SDL_SensorFromInstanceID := GetProcAddress(aDLLHandle, 'SDL_SensorFromInstanceID');
  SDL_SensorGetData := GetProcAddress(aDLLHandle, 'SDL_SensorGetData');
  SDL_SensorGetDeviceInstanceID := GetProcAddress(aDLLHandle, 'SDL_SensorGetDeviceInstanceID');
  SDL_SensorGetDeviceName := GetProcAddress(aDLLHandle, 'SDL_SensorGetDeviceName');
  SDL_SensorGetDeviceNonPortableType := GetProcAddress(aDLLHandle, 'SDL_SensorGetDeviceNonPortableType');
  SDL_SensorGetDeviceType := GetProcAddress(aDLLHandle, 'SDL_SensorGetDeviceType');
  SDL_SensorGetInstanceID := GetProcAddress(aDLLHandle, 'SDL_SensorGetInstanceID');
  SDL_SensorGetName := GetProcAddress(aDLLHandle, 'SDL_SensorGetName');
  SDL_SensorGetNonPortableType := GetProcAddress(aDLLHandle, 'SDL_SensorGetNonPortableType');
  SDL_SensorGetType := GetProcAddress(aDLLHandle, 'SDL_SensorGetType');
  SDL_SensorOpen := GetProcAddress(aDLLHandle, 'SDL_SensorOpen');
  SDL_SensorUpdate := GetProcAddress(aDLLHandle, 'SDL_SensorUpdate');
  SDL_SetAssertionHandler := GetProcAddress(aDLLHandle, 'SDL_SetAssertionHandler');
  SDL_SetClipboardText := GetProcAddress(aDLLHandle, 'SDL_SetClipboardText');
  SDL_SetClipRect := GetProcAddress(aDLLHandle, 'SDL_SetClipRect');
  SDL_SetColorKey := GetProcAddress(aDLLHandle, 'SDL_SetColorKey');
  SDL_SetCursor := GetProcAddress(aDLLHandle, 'SDL_SetCursor');
  SDL_setenv := GetProcAddress(aDLLHandle, 'SDL_setenv');
  SDL_SetError := GetProcAddress(aDLLHandle, 'SDL_SetError');
  SDL_SetEventFilter := GetProcAddress(aDLLHandle, 'SDL_SetEventFilter');
  SDL_SetHint := GetProcAddress(aDLLHandle, 'SDL_SetHint');
  SDL_SetHintWithPriority := GetProcAddress(aDLLHandle, 'SDL_SetHintWithPriority');
  SDL_SetMainReady := GetProcAddress(aDLLHandle, 'SDL_SetMainReady');
  SDL_SetMemoryFunctions := GetProcAddress(aDLLHandle, 'SDL_SetMemoryFunctions');
  SDL_SetModState := GetProcAddress(aDLLHandle, 'SDL_SetModState');
  SDL_SetPaletteColors := GetProcAddress(aDLLHandle, 'SDL_SetPaletteColors');
  SDL_SetPixelFormatPalette := GetProcAddress(aDLLHandle, 'SDL_SetPixelFormatPalette');
  SDL_SetPrimarySelectionText := GetProcAddress(aDLLHandle, 'SDL_SetPrimarySelectionText');
  SDL_SetRelativeMouseMode := GetProcAddress(aDLLHandle, 'SDL_SetRelativeMouseMode');
  SDL_SetRenderDrawBlendMode := GetProcAddress(aDLLHandle, 'SDL_SetRenderDrawBlendMode');
  SDL_SetRenderDrawColor := GetProcAddress(aDLLHandle, 'SDL_SetRenderDrawColor');
  SDL_SetRenderTarget := GetProcAddress(aDLLHandle, 'SDL_SetRenderTarget');
  SDL_SetSurfaceAlphaMod := GetProcAddress(aDLLHandle, 'SDL_SetSurfaceAlphaMod');
  SDL_SetSurfaceBlendMode := GetProcAddress(aDLLHandle, 'SDL_SetSurfaceBlendMode');
  SDL_SetSurfaceColorMod := GetProcAddress(aDLLHandle, 'SDL_SetSurfaceColorMod');
  SDL_SetSurfacePalette := GetProcAddress(aDLLHandle, 'SDL_SetSurfacePalette');
  SDL_SetSurfaceRLE := GetProcAddress(aDLLHandle, 'SDL_SetSurfaceRLE');
  SDL_SetTextInputRect := GetProcAddress(aDLLHandle, 'SDL_SetTextInputRect');
  SDL_SetTextureAlphaMod := GetProcAddress(aDLLHandle, 'SDL_SetTextureAlphaMod');
  SDL_SetTextureBlendMode := GetProcAddress(aDLLHandle, 'SDL_SetTextureBlendMode');
  SDL_SetTextureColorMod := GetProcAddress(aDLLHandle, 'SDL_SetTextureColorMod');
  SDL_SetTextureScaleMode := GetProcAddress(aDLLHandle, 'SDL_SetTextureScaleMode');
  SDL_SetTextureUserData := GetProcAddress(aDLLHandle, 'SDL_SetTextureUserData');
  SDL_SetThreadPriority := GetProcAddress(aDLLHandle, 'SDL_SetThreadPriority');
  SDL_SetWindowAlwaysOnTop := GetProcAddress(aDLLHandle, 'SDL_SetWindowAlwaysOnTop');
  SDL_SetWindowBordered := GetProcAddress(aDLLHandle, 'SDL_SetWindowBordered');
  SDL_SetWindowBrightness := GetProcAddress(aDLLHandle, 'SDL_SetWindowBrightness');
  SDL_SetWindowData := GetProcAddress(aDLLHandle, 'SDL_SetWindowData');
  SDL_SetWindowDisplayMode := GetProcAddress(aDLLHandle, 'SDL_SetWindowDisplayMode');
  SDL_SetWindowFullscreen := GetProcAddress(aDLLHandle, 'SDL_SetWindowFullscreen');
  SDL_SetWindowGammaRamp := GetProcAddress(aDLLHandle, 'SDL_SetWindowGammaRamp');
  SDL_SetWindowGrab := GetProcAddress(aDLLHandle, 'SDL_SetWindowGrab');
  SDL_SetWindowHitTest := GetProcAddress(aDLLHandle, 'SDL_SetWindowHitTest');
  SDL_SetWindowIcon := GetProcAddress(aDLLHandle, 'SDL_SetWindowIcon');
  SDL_SetWindowInputFocus := GetProcAddress(aDLLHandle, 'SDL_SetWindowInputFocus');
  SDL_SetWindowKeyboardGrab := GetProcAddress(aDLLHandle, 'SDL_SetWindowKeyboardGrab');
  SDL_SetWindowMaximumSize := GetProcAddress(aDLLHandle, 'SDL_SetWindowMaximumSize');
  SDL_SetWindowMinimumSize := GetProcAddress(aDLLHandle, 'SDL_SetWindowMinimumSize');
  SDL_SetWindowModalFor := GetProcAddress(aDLLHandle, 'SDL_SetWindowModalFor');
  SDL_SetWindowMouseGrab := GetProcAddress(aDLLHandle, 'SDL_SetWindowMouseGrab');
  SDL_SetWindowMouseRect := GetProcAddress(aDLLHandle, 'SDL_SetWindowMouseRect');
  SDL_SetWindowOpacity := GetProcAddress(aDLLHandle, 'SDL_SetWindowOpacity');
  SDL_SetWindowPosition := GetProcAddress(aDLLHandle, 'SDL_SetWindowPosition');
  SDL_SetWindowResizable := GetProcAddress(aDLLHandle, 'SDL_SetWindowResizable');
  SDL_SetWindowShape := GetProcAddress(aDLLHandle, 'SDL_SetWindowShape');
  SDL_SetWindowSize := GetProcAddress(aDLLHandle, 'SDL_SetWindowSize');
  SDL_SetWindowsMessageHook := GetProcAddress(aDLLHandle, 'SDL_SetWindowsMessageHook');
  SDL_SetWindowTitle := GetProcAddress(aDLLHandle, 'SDL_SetWindowTitle');
  SDL_SetYUVConversionMode := GetProcAddress(aDLLHandle, 'SDL_SetYUVConversionMode');
  SDL_ShowCursor := GetProcAddress(aDLLHandle, 'SDL_ShowCursor');
  SDL_ShowMessageBox := GetProcAddress(aDLLHandle, 'SDL_ShowMessageBox');
  SDL_ShowSimpleMessageBox := GetProcAddress(aDLLHandle, 'SDL_ShowSimpleMessageBox');
  SDL_ShowWindow := GetProcAddress(aDLLHandle, 'SDL_ShowWindow');
  SDL_SIMDAlloc := GetProcAddress(aDLLHandle, 'SDL_SIMDAlloc');
  SDL_SIMDFree := GetProcAddress(aDLLHandle, 'SDL_SIMDFree');
  SDL_SIMDGetAlignment := GetProcAddress(aDLLHandle, 'SDL_SIMDGetAlignment');
  SDL_SIMDRealloc := GetProcAddress(aDLLHandle, 'SDL_SIMDRealloc');
  SDL_sin := GetProcAddress(aDLLHandle, 'SDL_sin');
  SDL_sinf := GetProcAddress(aDLLHandle, 'SDL_sinf');
  SDL_snprintf := GetProcAddress(aDLLHandle, 'SDL_snprintf');
  SDL_SoftStretch := GetProcAddress(aDLLHandle, 'SDL_SoftStretch');
  SDL_SoftStretchLinear := GetProcAddress(aDLLHandle, 'SDL_SoftStretchLinear');
  SDL_sqrt := GetProcAddress(aDLLHandle, 'SDL_sqrt');
  SDL_sqrtf := GetProcAddress(aDLLHandle, 'SDL_sqrtf');
  SDL_sscanf := GetProcAddress(aDLLHandle, 'SDL_sscanf');
  SDL_StartTextInput := GetProcAddress(aDLLHandle, 'SDL_StartTextInput');
  SDL_StopTextInput := GetProcAddress(aDLLHandle, 'SDL_StopTextInput');
  SDL_strcasecmp := GetProcAddress(aDLLHandle, 'SDL_strcasecmp');
  SDL_strchr := GetProcAddress(aDLLHandle, 'SDL_strchr');
  SDL_strcmp := GetProcAddress(aDLLHandle, 'SDL_strcmp');
  SDL_strdup := GetProcAddress(aDLLHandle, 'SDL_strdup');
  SDL_strlcat := GetProcAddress(aDLLHandle, 'SDL_strlcat');
  SDL_strlcpy := GetProcAddress(aDLLHandle, 'SDL_strlcpy');
  SDL_strlen := GetProcAddress(aDLLHandle, 'SDL_strlen');
  SDL_strlwr := GetProcAddress(aDLLHandle, 'SDL_strlwr');
  SDL_strncasecmp := GetProcAddress(aDLLHandle, 'SDL_strncasecmp');
  SDL_strncmp := GetProcAddress(aDLLHandle, 'SDL_strncmp');
  SDL_strrchr := GetProcAddress(aDLLHandle, 'SDL_strrchr');
  SDL_strrev := GetProcAddress(aDLLHandle, 'SDL_strrev');
  SDL_strstr := GetProcAddress(aDLLHandle, 'SDL_strstr');
  SDL_strtod := GetProcAddress(aDLLHandle, 'SDL_strtod');
  SDL_strtokr := GetProcAddress(aDLLHandle, 'SDL_strtokr');
  SDL_strtol := GetProcAddress(aDLLHandle, 'SDL_strtol');
  SDL_strtoll := GetProcAddress(aDLLHandle, 'SDL_strtoll');
  SDL_strtoul := GetProcAddress(aDLLHandle, 'SDL_strtoul');
  SDL_strtoull := GetProcAddress(aDLLHandle, 'SDL_strtoull');
  SDL_strupr := GetProcAddress(aDLLHandle, 'SDL_strupr');
  SDL_tan := GetProcAddress(aDLLHandle, 'SDL_tan');
  SDL_tanf := GetProcAddress(aDLLHandle, 'SDL_tanf');
  SDL_ThreadID := GetProcAddress(aDLLHandle, 'SDL_ThreadID');
  SDL_TLSCleanup := GetProcAddress(aDLLHandle, 'SDL_TLSCleanup');
  SDL_TLSCreate := GetProcAddress(aDLLHandle, 'SDL_TLSCreate');
  SDL_TLSGet := GetProcAddress(aDLLHandle, 'SDL_TLSGet');
  SDL_TLSSet := GetProcAddress(aDLLHandle, 'SDL_TLSSet');
  SDL_tolower := GetProcAddress(aDLLHandle, 'SDL_tolower');
  SDL_toupper := GetProcAddress(aDLLHandle, 'SDL_toupper');
  SDL_trunc := GetProcAddress(aDLLHandle, 'SDL_trunc');
  SDL_truncf := GetProcAddress(aDLLHandle, 'SDL_truncf');
  SDL_TryLockMutex := GetProcAddress(aDLLHandle, 'SDL_TryLockMutex');
  SDL_uitoa := GetProcAddress(aDLLHandle, 'SDL_uitoa');
  SDL_ulltoa := GetProcAddress(aDLLHandle, 'SDL_ulltoa');
  SDL_ultoa := GetProcAddress(aDLLHandle, 'SDL_ultoa');
  SDL_UnionFRect := GetProcAddress(aDLLHandle, 'SDL_UnionFRect');
  SDL_UnionRect := GetProcAddress(aDLLHandle, 'SDL_UnionRect');
  SDL_UnloadObject := GetProcAddress(aDLLHandle, 'SDL_UnloadObject');
  SDL_UnlockAudio := GetProcAddress(aDLLHandle, 'SDL_UnlockAudio');
  SDL_UnlockAudioDevice := GetProcAddress(aDLLHandle, 'SDL_UnlockAudioDevice');
  SDL_UnlockJoysticks := GetProcAddress(aDLLHandle, 'SDL_UnlockJoysticks');
  SDL_UnlockMutex := GetProcAddress(aDLLHandle, 'SDL_UnlockMutex');
  SDL_UnlockSensors := GetProcAddress(aDLLHandle, 'SDL_UnlockSensors');
  SDL_UnlockSurface := GetProcAddress(aDLLHandle, 'SDL_UnlockSurface');
  SDL_UnlockTexture := GetProcAddress(aDLLHandle, 'SDL_UnlockTexture');
  SDL_UnregisterApp := GetProcAddress(aDLLHandle, 'SDL_UnregisterApp');
  SDL_UpdateNVTexture := GetProcAddress(aDLLHandle, 'SDL_UpdateNVTexture');
  SDL_UpdateTexture := GetProcAddress(aDLLHandle, 'SDL_UpdateTexture');
  SDL_UpdateWindowSurface := GetProcAddress(aDLLHandle, 'SDL_UpdateWindowSurface');
  SDL_UpdateWindowSurfaceRects := GetProcAddress(aDLLHandle, 'SDL_UpdateWindowSurfaceRects');
  SDL_UpdateYUVTexture := GetProcAddress(aDLLHandle, 'SDL_UpdateYUVTexture');
  SDL_UpperBlit := GetProcAddress(aDLLHandle, 'SDL_UpperBlit');
  SDL_UpperBlitScaled := GetProcAddress(aDLLHandle, 'SDL_UpperBlitScaled');
  SDL_utf8strlcpy := GetProcAddress(aDLLHandle, 'SDL_utf8strlcpy');
  SDL_utf8strlen := GetProcAddress(aDLLHandle, 'SDL_utf8strlen');
  SDL_utf8strnlen := GetProcAddress(aDLLHandle, 'SDL_utf8strnlen');
  SDL_vasprintf := GetProcAddress(aDLLHandle, 'SDL_vasprintf');
  SDL_VideoInit := GetProcAddress(aDLLHandle, 'SDL_VideoInit');
  SDL_VideoQuit := GetProcAddress(aDLLHandle, 'SDL_VideoQuit');
  SDL_vsnprintf := GetProcAddress(aDLLHandle, 'SDL_vsnprintf');
  SDL_vsscanf := GetProcAddress(aDLLHandle, 'SDL_vsscanf');
  SDL_WaitEvent := GetProcAddress(aDLLHandle, 'SDL_WaitEvent');
  SDL_WaitEventTimeout := GetProcAddress(aDLLHandle, 'SDL_WaitEventTimeout');
  SDL_WaitThread := GetProcAddress(aDLLHandle, 'SDL_WaitThread');
  SDL_WarpMouseGlobal := GetProcAddress(aDLLHandle, 'SDL_WarpMouseGlobal');
  SDL_WarpMouseInWindow := GetProcAddress(aDLLHandle, 'SDL_WarpMouseInWindow');
  SDL_WasInit := GetProcAddress(aDLLHandle, 'SDL_WasInit');
  SDL_wcscasecmp := GetProcAddress(aDLLHandle, 'SDL_wcscasecmp');
  SDL_wcscmp := GetProcAddress(aDLLHandle, 'SDL_wcscmp');
  SDL_wcsdup := GetProcAddress(aDLLHandle, 'SDL_wcsdup');
  SDL_wcslcat := GetProcAddress(aDLLHandle, 'SDL_wcslcat');
  SDL_wcslcpy := GetProcAddress(aDLLHandle, 'SDL_wcslcpy');
  SDL_wcslen := GetProcAddress(aDLLHandle, 'SDL_wcslen');
  SDL_wcsncasecmp := GetProcAddress(aDLLHandle, 'SDL_wcsncasecmp');
  SDL_wcsncmp := GetProcAddress(aDLLHandle, 'SDL_wcsncmp');
  SDL_wcsstr := GetProcAddress(aDLLHandle, 'SDL_wcsstr');
  SDL_WriteBE16 := GetProcAddress(aDLLHandle, 'SDL_WriteBE16');
  SDL_WriteBE32 := GetProcAddress(aDLLHandle, 'SDL_WriteBE32');
  SDL_WriteBE64 := GetProcAddress(aDLLHandle, 'SDL_WriteBE64');
  SDL_WriteLE16 := GetProcAddress(aDLLHandle, 'SDL_WriteLE16');
  SDL_WriteLE32 := GetProcAddress(aDLLHandle, 'SDL_WriteLE32');
  SDL_WriteLE64 := GetProcAddress(aDLLHandle, 'SDL_WriteLE64');
  SDL_WriteU8 := GetProcAddress(aDLLHandle, 'SDL_WriteU8');
  SDLNet_AddSocket := GetProcAddress(aDLLHandle, 'SDLNet_AddSocket');
  SDLNet_AllocPacket := GetProcAddress(aDLLHandle, 'SDLNet_AllocPacket');
  SDLNet_AllocPacketV := GetProcAddress(aDLLHandle, 'SDLNet_AllocPacketV');
  SDLNet_AllocSocketSet := GetProcAddress(aDLLHandle, 'SDLNet_AllocSocketSet');
  SDLNet_CheckSockets := GetProcAddress(aDLLHandle, 'SDLNet_CheckSockets');
  SDLNet_DelSocket := GetProcAddress(aDLLHandle, 'SDLNet_DelSocket');
  SDLNet_FreePacket := GetProcAddress(aDLLHandle, 'SDLNet_FreePacket');
  SDLNet_FreePacketV := GetProcAddress(aDLLHandle, 'SDLNet_FreePacketV');
  SDLNet_FreeSocketSet := GetProcAddress(aDLLHandle, 'SDLNet_FreeSocketSet');
  SDLNet_GetError := GetProcAddress(aDLLHandle, 'SDLNet_GetError');
  SDLNet_GetLocalAddresses := GetProcAddress(aDLLHandle, 'SDLNet_GetLocalAddresses');
  SDLNet_Init := GetProcAddress(aDLLHandle, 'SDLNet_Init');
  SDLNet_Linked_Version := GetProcAddress(aDLLHandle, 'SDLNet_Linked_Version');
  SDLNet_Quit := GetProcAddress(aDLLHandle, 'SDLNet_Quit');
  SDLNet_ResizePacket := GetProcAddress(aDLLHandle, 'SDLNet_ResizePacket');
  SDLNet_ResolveHost := GetProcAddress(aDLLHandle, 'SDLNet_ResolveHost');
  SDLNet_ResolveIP := GetProcAddress(aDLLHandle, 'SDLNet_ResolveIP');
  SDLNet_SetError := GetProcAddress(aDLLHandle, 'SDLNet_SetError');
  SDLNet_TCP_Accept := GetProcAddress(aDLLHandle, 'SDLNet_TCP_Accept');
  SDLNet_TCP_Close := GetProcAddress(aDLLHandle, 'SDLNet_TCP_Close');
  SDLNet_TCP_GetPeerAddress := GetProcAddress(aDLLHandle, 'SDLNet_TCP_GetPeerAddress');
  SDLNet_TCP_Open := GetProcAddress(aDLLHandle, 'SDLNet_TCP_Open');
  SDLNet_TCP_Recv := GetProcAddress(aDLLHandle, 'SDLNet_TCP_Recv');
  SDLNet_TCP_Send := GetProcAddress(aDLLHandle, 'SDLNet_TCP_Send');
  SDLNet_UDP_Bind := GetProcAddress(aDLLHandle, 'SDLNet_UDP_Bind');
  SDLNet_UDP_Close := GetProcAddress(aDLLHandle, 'SDLNet_UDP_Close');
  SDLNet_UDP_GetPeerAddress := GetProcAddress(aDLLHandle, 'SDLNet_UDP_GetPeerAddress');
  SDLNet_UDP_Open := GetProcAddress(aDLLHandle, 'SDLNet_UDP_Open');
  SDLNet_UDP_Recv := GetProcAddress(aDLLHandle, 'SDLNet_UDP_Recv');
  SDLNet_UDP_RecvV := GetProcAddress(aDLLHandle, 'SDLNet_UDP_RecvV');
  SDLNet_UDP_Send := GetProcAddress(aDLLHandle, 'SDLNet_UDP_Send');
  SDLNet_UDP_SendV := GetProcAddress(aDLLHandle, 'SDLNet_UDP_SendV');
  SDLNet_UDP_SetPacketLoss := GetProcAddress(aDLLHandle, 'SDLNet_UDP_SetPacketLoss');
  SDLNet_UDP_Unbind := GetProcAddress(aDLLHandle, 'SDLNet_UDP_Unbind');
  stringColor := GetProcAddress(aDLLHandle, 'stringColor');
  stringRGBA := GetProcAddress(aDLLHandle, 'stringRGBA');
  texturedPolygon := GetProcAddress(aDLLHandle, 'texturedPolygon');
  thickLineColor := GetProcAddress(aDLLHandle, 'thickLineColor');
  thickLineRGBA := GetProcAddress(aDLLHandle, 'thickLineRGBA');
  trigonColor := GetProcAddress(aDLLHandle, 'trigonColor');
  trigonRGBA := GetProcAddress(aDLLHandle, 'trigonRGBA');
  TTF_ByteSwappedUNICODE := GetProcAddress(aDLLHandle, 'TTF_ByteSwappedUNICODE');
  TTF_CloseFont := GetProcAddress(aDLLHandle, 'TTF_CloseFont');
  TTF_FontAscent := GetProcAddress(aDLLHandle, 'TTF_FontAscent');
  TTF_FontDescent := GetProcAddress(aDLLHandle, 'TTF_FontDescent');
  TTF_FontFaceFamilyName := GetProcAddress(aDLLHandle, 'TTF_FontFaceFamilyName');
  TTF_FontFaceIsFixedWidth := GetProcAddress(aDLLHandle, 'TTF_FontFaceIsFixedWidth');
  TTF_FontFaces := GetProcAddress(aDLLHandle, 'TTF_FontFaces');
  TTF_FontFaceStyleName := GetProcAddress(aDLLHandle, 'TTF_FontFaceStyleName');
  TTF_FontHeight := GetProcAddress(aDLLHandle, 'TTF_FontHeight');
  TTF_FontLineSkip := GetProcAddress(aDLLHandle, 'TTF_FontLineSkip');
  TTF_GetFontHinting := GetProcAddress(aDLLHandle, 'TTF_GetFontHinting');
  TTF_GetFontKerning := GetProcAddress(aDLLHandle, 'TTF_GetFontKerning');
  TTF_GetFontKerningSize := GetProcAddress(aDLLHandle, 'TTF_GetFontKerningSize');
  TTF_GetFontKerningSizeGlyphs := GetProcAddress(aDLLHandle, 'TTF_GetFontKerningSizeGlyphs');
  TTF_GetFontKerningSizeGlyphs32 := GetProcAddress(aDLLHandle, 'TTF_GetFontKerningSizeGlyphs32');
  TTF_GetFontOutline := GetProcAddress(aDLLHandle, 'TTF_GetFontOutline');
  TTF_GetFontSDF := GetProcAddress(aDLLHandle, 'TTF_GetFontSDF');
  TTF_GetFontStyle := GetProcAddress(aDLLHandle, 'TTF_GetFontStyle');
  TTF_GetFontWrappedAlign := GetProcAddress(aDLLHandle, 'TTF_GetFontWrappedAlign');
  TTF_GetFreeTypeVersion := GetProcAddress(aDLLHandle, 'TTF_GetFreeTypeVersion');
  TTF_GetHarfBuzzVersion := GetProcAddress(aDLLHandle, 'TTF_GetHarfBuzzVersion');
  TTF_GlyphIsProvided := GetProcAddress(aDLLHandle, 'TTF_GlyphIsProvided');
  TTF_GlyphIsProvided32 := GetProcAddress(aDLLHandle, 'TTF_GlyphIsProvided32');
  TTF_GlyphMetrics := GetProcAddress(aDLLHandle, 'TTF_GlyphMetrics');
  TTF_GlyphMetrics32 := GetProcAddress(aDLLHandle, 'TTF_GlyphMetrics32');
  TTF_Init := GetProcAddress(aDLLHandle, 'TTF_Init');
  TTF_Linked_Version := GetProcAddress(aDLLHandle, 'TTF_Linked_Version');
  TTF_MeasureText := GetProcAddress(aDLLHandle, 'TTF_MeasureText');
  TTF_MeasureUNICODE := GetProcAddress(aDLLHandle, 'TTF_MeasureUNICODE');
  TTF_MeasureUTF8 := GetProcAddress(aDLLHandle, 'TTF_MeasureUTF8');
  TTF_OpenFont := GetProcAddress(aDLLHandle, 'TTF_OpenFont');
  TTF_OpenFontDPI := GetProcAddress(aDLLHandle, 'TTF_OpenFontDPI');
  TTF_OpenFontDPIRW := GetProcAddress(aDLLHandle, 'TTF_OpenFontDPIRW');
  TTF_OpenFontIndex := GetProcAddress(aDLLHandle, 'TTF_OpenFontIndex');
  TTF_OpenFontIndexDPI := GetProcAddress(aDLLHandle, 'TTF_OpenFontIndexDPI');
  TTF_OpenFontIndexDPIRW := GetProcAddress(aDLLHandle, 'TTF_OpenFontIndexDPIRW');
  TTF_OpenFontIndexRW := GetProcAddress(aDLLHandle, 'TTF_OpenFontIndexRW');
  TTF_OpenFontRW := GetProcAddress(aDLLHandle, 'TTF_OpenFontRW');
  TTF_Quit := GetProcAddress(aDLLHandle, 'TTF_Quit');
  TTF_RenderGlyph_Blended := GetProcAddress(aDLLHandle, 'TTF_RenderGlyph_Blended');
  TTF_RenderGlyph_LCD := GetProcAddress(aDLLHandle, 'TTF_RenderGlyph_LCD');
  TTF_RenderGlyph_Shaded := GetProcAddress(aDLLHandle, 'TTF_RenderGlyph_Shaded');
  TTF_RenderGlyph_Solid := GetProcAddress(aDLLHandle, 'TTF_RenderGlyph_Solid');
  TTF_RenderGlyph32_Blended := GetProcAddress(aDLLHandle, 'TTF_RenderGlyph32_Blended');
  TTF_RenderGlyph32_LCD := GetProcAddress(aDLLHandle, 'TTF_RenderGlyph32_LCD');
  TTF_RenderGlyph32_Shaded := GetProcAddress(aDLLHandle, 'TTF_RenderGlyph32_Shaded');
  TTF_RenderGlyph32_Solid := GetProcAddress(aDLLHandle, 'TTF_RenderGlyph32_Solid');
  TTF_RenderText_Blended := GetProcAddress(aDLLHandle, 'TTF_RenderText_Blended');
  TTF_RenderText_Blended_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderText_Blended_Wrapped');
  TTF_RenderText_LCD := GetProcAddress(aDLLHandle, 'TTF_RenderText_LCD');
  TTF_RenderText_LCD_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderText_LCD_Wrapped');
  TTF_RenderText_Shaded := GetProcAddress(aDLLHandle, 'TTF_RenderText_Shaded');
  TTF_RenderText_Shaded_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderText_Shaded_Wrapped');
  TTF_RenderText_Solid := GetProcAddress(aDLLHandle, 'TTF_RenderText_Solid');
  TTF_RenderText_Solid_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderText_Solid_Wrapped');
  TTF_RenderUNICODE_Blended := GetProcAddress(aDLLHandle, 'TTF_RenderUNICODE_Blended');
  TTF_RenderUNICODE_Blended_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderUNICODE_Blended_Wrapped');
  TTF_RenderUNICODE_LCD := GetProcAddress(aDLLHandle, 'TTF_RenderUNICODE_LCD');
  TTF_RenderUNICODE_LCD_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderUNICODE_LCD_Wrapped');
  TTF_RenderUNICODE_Shaded := GetProcAddress(aDLLHandle, 'TTF_RenderUNICODE_Shaded');
  TTF_RenderUNICODE_Shaded_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderUNICODE_Shaded_Wrapped');
  TTF_RenderUNICODE_Solid := GetProcAddress(aDLLHandle, 'TTF_RenderUNICODE_Solid');
  TTF_RenderUNICODE_Solid_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderUNICODE_Solid_Wrapped');
  TTF_RenderUTF8_Blended := GetProcAddress(aDLLHandle, 'TTF_RenderUTF8_Blended');
  TTF_RenderUTF8_Blended_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderUTF8_Blended_Wrapped');
  TTF_RenderUTF8_LCD := GetProcAddress(aDLLHandle, 'TTF_RenderUTF8_LCD');
  TTF_RenderUTF8_LCD_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderUTF8_LCD_Wrapped');
  TTF_RenderUTF8_Shaded := GetProcAddress(aDLLHandle, 'TTF_RenderUTF8_Shaded');
  TTF_RenderUTF8_Shaded_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderUTF8_Shaded_Wrapped');
  TTF_RenderUTF8_Solid := GetProcAddress(aDLLHandle, 'TTF_RenderUTF8_Solid');
  TTF_RenderUTF8_Solid_Wrapped := GetProcAddress(aDLLHandle, 'TTF_RenderUTF8_Solid_Wrapped');
  TTF_SetDirection := GetProcAddress(aDLLHandle, 'TTF_SetDirection');
  TTF_SetFontDirection := GetProcAddress(aDLLHandle, 'TTF_SetFontDirection');
  TTF_SetFontHinting := GetProcAddress(aDLLHandle, 'TTF_SetFontHinting');
  TTF_SetFontKerning := GetProcAddress(aDLLHandle, 'TTF_SetFontKerning');
  TTF_SetFontOutline := GetProcAddress(aDLLHandle, 'TTF_SetFontOutline');
  TTF_SetFontScriptName := GetProcAddress(aDLLHandle, 'TTF_SetFontScriptName');
  TTF_SetFontSDF := GetProcAddress(aDLLHandle, 'TTF_SetFontSDF');
  TTF_SetFontSize := GetProcAddress(aDLLHandle, 'TTF_SetFontSize');
  TTF_SetFontSizeDPI := GetProcAddress(aDLLHandle, 'TTF_SetFontSizeDPI');
  TTF_SetFontStyle := GetProcAddress(aDLLHandle, 'TTF_SetFontStyle');
  TTF_SetFontWrappedAlign := GetProcAddress(aDLLHandle, 'TTF_SetFontWrappedAlign');
  TTF_SetScript := GetProcAddress(aDLLHandle, 'TTF_SetScript');
  TTF_SizeText := GetProcAddress(aDLLHandle, 'TTF_SizeText');
  TTF_SizeUNICODE := GetProcAddress(aDLLHandle, 'TTF_SizeUNICODE');
  TTF_SizeUTF8 := GetProcAddress(aDLLHandle, 'TTF_SizeUTF8');
  TTF_WasInit := GetProcAddress(aDLLHandle, 'TTF_WasInit');
  vlineColor := GetProcAddress(aDLLHandle, 'vlineColor');
  vlineRGBA := GetProcAddress(aDLLHandle, 'vlineRGBA');
  zipClose := GetProcAddress(aDLLHandle, 'zipClose');
  zipCloseFileInZip := GetProcAddress(aDLLHandle, 'zipCloseFileInZip');
  zipOpen := GetProcAddress(aDLLHandle, 'zipOpen');
  zipOpenNewFileInZip3 := GetProcAddress(aDLLHandle, 'zipOpenNewFileInZip3');
  zipWriteInFileInZip := GetProcAddress(aDLLHandle, 'zipWriteInFileInZip');
{$ENDREGION}
end;

// ==========================================================================
const
  cDllResName  = '6c369f7a70734a64a368fad73ebed671';

var
  uDllHandle: THandle = 0;
  uDllFilename: string = '';

procedure AbortDLL;
begin
  Halt;
end;

procedure LoadDLL;
var
  LResStream: TResourceStream;
  LPath: string;
begin
  if uDllHandle <> 0 then Exit;
  if not Boolean((FindResource(HInstance, PChar(cDllResName), RT_RCDATA) <> 0)) then AbortDLL;
  LResStream := TResourceStream.Create(HInstance, cDLLResName, RT_RCDATA);
  try
    LPath := TPath.Combine(TPath.GetTempPath, TPath.GetGUIDFileName.ToLower + '.tmp');
    LResStream.SaveToFile(LPath);
    if not TFile.Exists(LPath) then AbortDLL;
    uDllFilename := LPath;
    uDllHandle := SafeLoadLibrary(uDllFilename);
    if uDllHandle = 0 then AbortDLL;
    GetExports(uDllHandle);
  finally
    LResStream.Free;
  end;
end;

procedure UnloadDLL;
begin
  if uDllHandle = 0 then Exit;
  FreeLibrary(uDllHandle);
  uDllHandle := 0;
  if not TFile.Exists(uDllFilename) then Exit;
  TFile.Delete(uDllFilename);
  if not TFile.Exists(uDllFilename) then
    uDllFilename := '';
end;

{$ENDREGION}

{$REGION 'Luna.SpeechLib'}
class function CoSpNotifyTranslator.Create: ISpNotifyTranslator;
begin
  Result := CreateComObject(CLASS_SpNotifyTranslator) as ISpNotifyTranslator;
end;

class function CoSpNotifyTranslator.CreateRemote(const MachineName: string)
  : ISpNotifyTranslator;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpNotifyTranslator)
    as ISpNotifyTranslator;
end;

procedure TSpNotifyTranslator.InitServerData;
const
  CServerData: TServerData = (ClassId: '{E2AE5372-5D40-11D2-960E-00C04F8EE628}';
    IntfIID: '{ACA16614-5D3D-11D2-960E-00C04F8EE628}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpNotifyTranslator.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpNotifyTranslator;
  end;
end;

procedure TSpNotifyTranslator.ConnectTo(svrIntf: ISpNotifyTranslator);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpNotifyTranslator.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpNotifyTranslator.GetDefaultInterface: ISpNotifyTranslator;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpNotifyTranslator.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpNotifyTranslator.Destroy;
begin
  inherited Destroy;
end;

function TSpNotifyTranslator.Notify: HResult;
begin
  Result := DefaultInterface.Notify;
end;

function TSpNotifyTranslator.InitWindowMessage(var hWnd: _RemotableHandle;
  Msg: SYSUINT; wParam: UINT_PTR; lParam: LONG_PTR): HResult;
begin
  Result := DefaultInterface.InitWindowMessage(hWnd, Msg, wParam, lParam);
end;

function TSpNotifyTranslator.InitCallback(pfnCallback: PPPrivateAlias1;
  wParam: UINT_PTR; lParam: LONG_PTR): HResult;
begin
  Result := DefaultInterface.InitCallback(pfnCallback, wParam, lParam);
end;

function TSpNotifyTranslator.InitSpNotifyCallback(pSpCallback: PPPrivateAlias1;
  wParam: UINT_PTR; lParam: LONG_PTR): HResult;
begin
  Result := DefaultInterface.InitSpNotifyCallback(pSpCallback, wParam, lParam);
end;

function TSpNotifyTranslator.InitWin32Event(hEvent: Pointer;
  fCloseHandleOnRelease: Integer): HResult;
begin
  Result := DefaultInterface.InitWin32Event(hEvent, fCloseHandleOnRelease);
end;

function TSpNotifyTranslator.Wait(dwMilliseconds: LongWord): HResult;
begin
  Result := DefaultInterface.Wait(dwMilliseconds);
end;

function TSpNotifyTranslator.GetEventHandle: Pointer;
begin
  Result := DefaultInterface.GetEventHandle;
end;

class function CoSpObjectTokenCategory.Create: ISpeechObjectTokenCategory;
begin
  Result := CreateComObject(CLASS_SpObjectTokenCategory)
    as ISpeechObjectTokenCategory;
end;

class function CoSpObjectTokenCategory.CreateRemote(const MachineName: string)
  : ISpeechObjectTokenCategory;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpObjectTokenCategory)
    as ISpeechObjectTokenCategory;
end;

procedure TSpObjectTokenCategory.InitServerData;
const
  CServerData: TServerData = (ClassId: '{A910187F-0C7A-45AC-92CC-59EDAFB77B53}';
    IntfIID: '{CA7EAC50-2D01-4145-86D4-5AE7D70F4469}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpObjectTokenCategory.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechObjectTokenCategory;
  end;
end;

procedure TSpObjectTokenCategory.ConnectTo(svrIntf: ISpeechObjectTokenCategory);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpObjectTokenCategory.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpObjectTokenCategory.GetDefaultInterface: ISpeechObjectTokenCategory;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpObjectTokenCategory.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpObjectTokenCategory.Destroy;
begin
  inherited Destroy;
end;

function TSpObjectTokenCategory.Get_Id: WideString;
begin
  Result := DefaultInterface.Id;
end;

procedure TSpObjectTokenCategory.Set_Default(const TokenId: WideString);
begin
  DefaultInterface.Default := TokenId;
end;

function TSpObjectTokenCategory.Get_Default: WideString;
begin
  Result := DefaultInterface.Default;
end;

procedure TSpObjectTokenCategory.SetId(const Id: WideString;
  CreateIfNotExist: WordBool);
begin
  DefaultInterface.SetId(Id, CreateIfNotExist);
end;

function TSpObjectTokenCategory.GetDataKey(Location: SpeechDataKeyLocation)
  : ISpeechDataKey;
begin
  Result := DefaultInterface.GetDataKey(Location);
end;

function TSpObjectTokenCategory.EnumerateTokens(const RequiredAttributes
  : WideString; const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.EnumerateTokens(RequiredAttributes,
    OptionalAttributes);
end;

class function CoSpObjectToken.Create: ISpeechObjectToken;
begin
  Result := CreateComObject(CLASS_SpObjectToken) as ISpeechObjectToken;
end;

class function CoSpObjectToken.CreateRemote(const MachineName: string)
  : ISpeechObjectToken;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpObjectToken)
    as ISpeechObjectToken;
end;

procedure TSpObjectToken.InitServerData;
const
  CServerData: TServerData = (ClassId: '{EF411752-3736-4CB4-9C8C-8EF4CCB58EFE}';
    IntfIID: '{C74A3ADC-B727-4500-A84A-B526721C8B8C}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpObjectToken.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechObjectToken;
  end;
end;

procedure TSpObjectToken.ConnectTo(svrIntf: ISpeechObjectToken);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpObjectToken.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpObjectToken.GetDefaultInterface: ISpeechObjectToken;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpObjectToken.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpObjectToken.Destroy;
begin
  inherited Destroy;
end;

function TSpObjectToken.Get_Id: WideString;
begin
  Result := DefaultInterface.Id;
end;

function TSpObjectToken.Get_DataKey: ISpeechDataKey;
begin
  Result := DefaultInterface.DataKey;
end;

function TSpObjectToken.Get_Category: ISpeechObjectTokenCategory;
begin
  Result := DefaultInterface.Category;
end;

function TSpObjectToken.GetDescription(Locale: Integer): WideString;
begin
  Result := DefaultInterface.GetDescription(Locale);
end;

procedure TSpObjectToken.SetId(const Id: WideString;
  const CategoryID: WideString; CreateIfNotExist: WordBool);
begin
  DefaultInterface.SetId(Id, CategoryID, CreateIfNotExist);
end;

function TSpObjectToken.GetAttribute(const AttributeName: WideString)
  : WideString;
begin
  Result := DefaultInterface.GetAttribute(AttributeName);
end;

function TSpObjectToken.CreateInstance(const pUnkOuter: IUnknown;
  ClsContext: SpeechTokenContext): IUnknown;
begin
  Result := DefaultInterface.CreateInstance(pUnkOuter, ClsContext);
end;

procedure TSpObjectToken.Remove(const ObjectStorageCLSID: WideString);
begin
  DefaultInterface.Remove(ObjectStorageCLSID);
end;

function TSpObjectToken.GetStorageFileName(const ObjectStorageCLSID: WideString;
  const KeyName: WideString; const FileName: WideString;
  Folder: SpeechTokenShellFolder): WideString;
begin
  Result := DefaultInterface.GetStorageFileName(ObjectStorageCLSID, KeyName,
    FileName, Folder);
end;

procedure TSpObjectToken.RemoveStorageFileName(const ObjectStorageCLSID
  : WideString; const KeyName: WideString; DeleteFile: WordBool);
begin
  DefaultInterface.RemoveStorageFileName(ObjectStorageCLSID, KeyName,
    DeleteFile);
end;

function TSpObjectToken.IsUISupported(const TypeOfUI: WideString;
  const ExtraData: OleVariant; const Object_: IUnknown): WordBool;
begin
  Result := DefaultInterface.IsUISupported(TypeOfUI, ExtraData, Object_);
end;

procedure TSpObjectToken.DisplayUI(hWnd: Integer; const Title: WideString;
  const TypeOfUI: WideString; const ExtraData: OleVariant;
  const Object_: IUnknown);
begin
  DefaultInterface.DisplayUI(hWnd, Title, TypeOfUI, ExtraData, Object_);
end;

function TSpObjectToken.MatchesAttributes(const Attributes: WideString)
  : WordBool;
begin
  Result := DefaultInterface.MatchesAttributes(Attributes);
end;

class function CoSpResourceManager.Create: ISpResourceManager;
begin
  Result := CreateComObject(CLASS_SpResourceManager) as ISpResourceManager;
end;

class function CoSpResourceManager.CreateRemote(const MachineName: string)
  : ISpResourceManager;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpResourceManager)
    as ISpResourceManager;
end;

procedure TSpResourceManager.InitServerData;
const
  CServerData: TServerData = (ClassId: '{96749373-3391-11D2-9EE3-00C04F797396}';
    IntfIID: '{93384E18-5014-43D5-ADBB-A78E055926BD}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpResourceManager.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpResourceManager;
  end;
end;

procedure TSpResourceManager.ConnectTo(svrIntf: ISpResourceManager);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpResourceManager.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpResourceManager.GetDefaultInterface: ISpResourceManager;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpResourceManager.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpResourceManager.Destroy;
begin
  inherited Destroy;
end;

function TSpResourceManager.RemoteQueryService(var guidService: TGUID;
  var riid: TGUID; out ppvObject: IUnknown): HResult;
begin
  Result := DefaultInterface.RemoteQueryService(guidService, riid, ppvObject);
end;

function TSpResourceManager.SetObject(var guidServiceId: TGUID;
  const punkObject: IUnknown): HResult;
begin
  Result := DefaultInterface.SetObject(guidServiceId, punkObject);
end;

function TSpResourceManager.GetObject(var guidServiceId: TGUID;
  var ObjectCLSID: TGUID; var ObjectIID: TGUID;
  fReleaseWhenLastExternalRefReleased: Integer; out ppObject: Pointer): HResult;
begin
  Result := DefaultInterface.GetObject(guidServiceId, ObjectCLSID, ObjectIID,
    fReleaseWhenLastExternalRefReleased, ppObject);
end;

class function CoSpStreamFormatConverter.Create: ISpStreamFormatConverter;
begin
  Result := CreateComObject(CLASS_SpStreamFormatConverter)
    as ISpStreamFormatConverter;
end;

class function CoSpStreamFormatConverter.CreateRemote(const MachineName: string)
  : ISpStreamFormatConverter;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpStreamFormatConverter)
    as ISpStreamFormatConverter;
end;

procedure TSpStreamFormatConverter.InitServerData;
const
  CServerData: TServerData = (ClassId: '{7013943A-E2EC-11D2-A086-00C04F8EF9B5}';
    IntfIID: '{678A932C-EA71-4446-9B41-78FDA6280A29}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpStreamFormatConverter.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpStreamFormatConverter;
  end;
end;

procedure TSpStreamFormatConverter.ConnectTo(svrIntf: ISpStreamFormatConverter);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpStreamFormatConverter.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpStreamFormatConverter.GetDefaultInterface: ISpStreamFormatConverter;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpStreamFormatConverter.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpStreamFormatConverter.Destroy;
begin
  inherited Destroy;
end;

function TSpStreamFormatConverter.RemoteRead(out pv: Byte; cb: LongWord;
  out pcbRead: LongWord): HResult;
begin
  Result := DefaultInterface.RemoteRead(pv, cb, pcbRead);
end;

function TSpStreamFormatConverter.RemoteWrite(var pv: Byte; cb: LongWord;
  out pcbWritten: LongWord): HResult;
begin
  Result := DefaultInterface.RemoteWrite(pv, cb, pcbWritten);
end;

function TSpStreamFormatConverter.RemoteSeek(dlibMove: _LARGE_INTEGER;
  dwOrigin: LongWord; out plibNewPosition: _ULARGE_INTEGER): HResult;
begin
  Result := DefaultInterface.RemoteSeek(dlibMove, dwOrigin, plibNewPosition);
end;

function TSpStreamFormatConverter.SetSize(libNewSize: _ULARGE_INTEGER): HResult;
begin
  Result := DefaultInterface.SetSize(libNewSize);
end;

function TSpStreamFormatConverter.RemoteCopyTo(const pstm: IStream;
  cb: _ULARGE_INTEGER; out pcbRead: _ULARGE_INTEGER;
  out pcbWritten: _ULARGE_INTEGER): HResult;
begin
  Result := DefaultInterface.RemoteCopyTo(pstm, cb, pcbRead, pcbWritten);
end;

function TSpStreamFormatConverter.Commit(grfCommitFlags: LongWord): HResult;
begin
  Result := DefaultInterface.Commit(grfCommitFlags);
end;

function TSpStreamFormatConverter.Revert: HResult;
begin
  Result := DefaultInterface.Revert;
end;

function TSpStreamFormatConverter.LockRegion(libOffset: _ULARGE_INTEGER;
  cb: _ULARGE_INTEGER; dwLockType: LongWord): HResult;
begin
  Result := DefaultInterface.LockRegion(libOffset, cb, dwLockType);
end;

function TSpStreamFormatConverter.UnlockRegion(libOffset: _ULARGE_INTEGER;
  cb: _ULARGE_INTEGER; dwLockType: LongWord): HResult;
begin
  Result := DefaultInterface.UnlockRegion(libOffset, cb, dwLockType);
end;

function TSpStreamFormatConverter.Stat(out pstatstg: tagSTATSTG;
  grfStatFlag: LongWord): HResult;
begin
  Result := DefaultInterface.Stat(pstatstg, grfStatFlag);
end;

function TSpStreamFormatConverter.Clone(out ppstm: IStream): HResult;
begin
  Result := DefaultInterface.Clone(ppstm);
end;

function TSpStreamFormatConverter.GetFormat(var pguidFormatId: TGUID;
  out ppCoMemWaveFormatEx: PUserType2): HResult;
begin
  Result := DefaultInterface.GetFormat(pguidFormatId, ppCoMemWaveFormatEx);
end;

function TSpStreamFormatConverter.SetBaseStream(const pStream: ISpStreamFormat;
  fSetFormatToBaseStreamFormat: Integer; fWriteToBaseStream: Integer): HResult;
begin
  Result := DefaultInterface.SetBaseStream(pStream,
    fSetFormatToBaseStreamFormat, fWriteToBaseStream);
end;

function TSpStreamFormatConverter.GetBaseStream(out ppStream
  : ISpStreamFormat): HResult;
begin
  Result := DefaultInterface.GetBaseStream(ppStream);
end;

function TSpStreamFormatConverter.SetFormat(var rguidFormatIdOfConvertedStream
  : TGUID; var pWaveFormatExOfConvertedStream: WAVEFORMATEX): HResult;
begin
  Result := DefaultInterface.SetFormat(rguidFormatIdOfConvertedStream,
    pWaveFormatExOfConvertedStream);
end;

function TSpStreamFormatConverter.ResetSeekPosition: HResult;
begin
  Result := DefaultInterface.ResetSeekPosition;
end;

function TSpStreamFormatConverter.ScaleConvertedToBaseOffset
  (ullOffsetConvertedStream: Largeuint;
  out pullOffsetBaseStream: Largeuint): HResult;
begin
  Result := DefaultInterface.ScaleConvertedToBaseOffset
    (ullOffsetConvertedStream, pullOffsetBaseStream);
end;

function TSpStreamFormatConverter.ScaleBaseToConvertedOffset(ullOffsetBaseStream
  : Largeuint; out pullOffsetConvertedStream: Largeuint): HResult;
begin
  Result := DefaultInterface.ScaleBaseToConvertedOffset(ullOffsetBaseStream,
    pullOffsetConvertedStream);
end;

class function CoSpMMAudioEnum.Create: IEnumSpObjectTokens;
begin
  Result := CreateComObject(CLASS_SpMMAudioEnum) as IEnumSpObjectTokens;
end;

class function CoSpMMAudioEnum.CreateRemote(const MachineName: string)
  : IEnumSpObjectTokens;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpMMAudioEnum)
    as IEnumSpObjectTokens;
end;

procedure TSpMMAudioEnum.InitServerData;
const
  CServerData: TServerData = (ClassId: '{AB1890A0-E91F-11D2-BB91-00C04F8EE6C0}';
    IntfIID: '{06B64F9E-7FDA-11D2-B4F2-00C04F797396}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpMMAudioEnum.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as IEnumSpObjectTokens;
  end;
end;

procedure TSpMMAudioEnum.ConnectTo(svrIntf: IEnumSpObjectTokens);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpMMAudioEnum.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpMMAudioEnum.GetDefaultInterface: IEnumSpObjectTokens;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpMMAudioEnum.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpMMAudioEnum.Destroy;
begin
  inherited Destroy;
end;

function TSpMMAudioEnum.Next(celt: LongWord; out pelt: ISpObjectToken;
  out pceltFetched: LongWord): HResult;
begin
  Result := DefaultInterface.Next(celt, pelt, pceltFetched);
end;

function TSpMMAudioEnum.Skip(celt: LongWord): HResult;
begin
  Result := DefaultInterface.Skip(celt);
end;

function TSpMMAudioEnum.Reset: HResult;
begin
  Result := DefaultInterface.Reset;
end;

function TSpMMAudioEnum.Clone(out ppEnum: IEnumSpObjectTokens): HResult;
begin
  Result := DefaultInterface.Clone(ppEnum);
end;

function TSpMMAudioEnum.Item(Index: LongWord;
  out ppToken: ISpObjectToken): HResult;
begin
  Result := DefaultInterface.Item(Index, ppToken);
end;

function TSpMMAudioEnum.GetCount(out pCount: LongWord): HResult;
begin
  Result := DefaultInterface.GetCount(pCount);
end;

class function CoSpMMAudioIn.Create: ISpeechMMSysAudio;
begin
  Result := CreateComObject(CLASS_SpMMAudioIn) as ISpeechMMSysAudio;
end;

class function CoSpMMAudioIn.CreateRemote(const MachineName: string)
  : ISpeechMMSysAudio;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpMMAudioIn)
    as ISpeechMMSysAudio;
end;

procedure TSpMMAudioIn.InitServerData;
const
  CServerData: TServerData = (ClassId: '{CF3D2E50-53F2-11D2-960C-00C04F8EE628}';
    IntfIID: '{3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpMMAudioIn.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechMMSysAudio;
  end;
end;

procedure TSpMMAudioIn.ConnectTo(svrIntf: ISpeechMMSysAudio);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpMMAudioIn.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpMMAudioIn.GetDefaultInterface: ISpeechMMSysAudio;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpMMAudioIn.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpMMAudioIn.Destroy;
begin
  inherited Destroy;
end;

function TSpMMAudioIn.Get_Format: ISpeechAudioFormat;
begin
  Result := DefaultInterface.Format;
end;

procedure TSpMMAudioIn._Set_Format(const AudioFormat: ISpeechAudioFormat);
begin
  DefaultInterface.Format := AudioFormat;
end;

function TSpMMAudioIn.Get_Status: ISpeechAudioStatus;
begin
  Result := DefaultInterface.Status;
end;

function TSpMMAudioIn.Get_BufferInfo: ISpeechAudioBufferInfo;
begin
  Result := DefaultInterface.BufferInfo;
end;

function TSpMMAudioIn.Get_DefaultFormat: ISpeechAudioFormat;
begin
  Result := DefaultInterface.DefaultFormat;
end;

function TSpMMAudioIn.Get_Volume: Integer;
begin
  Result := DefaultInterface.Volume;
end;

procedure TSpMMAudioIn.Set_Volume(Volume: Integer);
begin
  DefaultInterface.Volume := Volume;
end;

function TSpMMAudioIn.Get_BufferNotifySize: Integer;
begin
  Result := DefaultInterface.BufferNotifySize;
end;

procedure TSpMMAudioIn.Set_BufferNotifySize(BufferNotifySize: Integer);
begin
  DefaultInterface.BufferNotifySize := BufferNotifySize;
end;

function TSpMMAudioIn.Get_EventHandle: Integer;
begin
  Result := DefaultInterface.EventHandle;
end;

function TSpMMAudioIn.Get_DeviceId: Integer;
begin
  Result := DefaultInterface.DeviceId;
end;

procedure TSpMMAudioIn.Set_DeviceId(DeviceId: Integer);
begin
  DefaultInterface.DeviceId := DeviceId;
end;

function TSpMMAudioIn.Get_LineId: Integer;
begin
  Result := DefaultInterface.LineId;
end;

procedure TSpMMAudioIn.Set_LineId(LineId: Integer);
begin
  DefaultInterface.LineId := LineId;
end;

function TSpMMAudioIn.Get_MMHandle: Integer;
begin
  Result := DefaultInterface.MMHandle;
end;

function TSpMMAudioIn.Read(out Buffer: OleVariant;
  NumberOfBytes: Integer): Integer;
begin
  Result := DefaultInterface.Read(Buffer, NumberOfBytes);
end;

function TSpMMAudioIn.Write(Buffer: OleVariant): Integer;
begin
  Result := DefaultInterface.Write(Buffer);
end;

function TSpMMAudioIn.Seek(Position: OleVariant;
  Origin: SpeechStreamSeekPositionType): OleVariant;
begin
  Result := DefaultInterface.Seek(Position, Origin);
end;

procedure TSpMMAudioIn.SetState(State: SpeechAudioState);
begin
  DefaultInterface.SetState(State);
end;

class function CoSpMMAudioOut.Create: ISpeechMMSysAudio;
begin
  Result := CreateComObject(CLASS_SpMMAudioOut) as ISpeechMMSysAudio;
end;

class function CoSpMMAudioOut.CreateRemote(const MachineName: string)
  : ISpeechMMSysAudio;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpMMAudioOut)
    as ISpeechMMSysAudio;
end;

procedure TSpMMAudioOut.InitServerData;
const
  CServerData: TServerData = (ClassId: '{A8C680EB-3D32-11D2-9EE7-00C04F797396}';
    IntfIID: '{3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpMMAudioOut.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechMMSysAudio;
  end;
end;

procedure TSpMMAudioOut.ConnectTo(svrIntf: ISpeechMMSysAudio);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpMMAudioOut.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpMMAudioOut.GetDefaultInterface: ISpeechMMSysAudio;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpMMAudioOut.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpMMAudioOut.Destroy;
begin
  inherited Destroy;
end;

function TSpMMAudioOut.Get_Format: ISpeechAudioFormat;
begin
  Result := DefaultInterface.Format;
end;

procedure TSpMMAudioOut._Set_Format(const AudioFormat: ISpeechAudioFormat);
begin
  DefaultInterface.Format := AudioFormat;
end;

function TSpMMAudioOut.Get_Status: ISpeechAudioStatus;
begin
  Result := DefaultInterface.Status;
end;

function TSpMMAudioOut.Get_BufferInfo: ISpeechAudioBufferInfo;
begin
  Result := DefaultInterface.BufferInfo;
end;

function TSpMMAudioOut.Get_DefaultFormat: ISpeechAudioFormat;
begin
  Result := DefaultInterface.DefaultFormat;
end;

function TSpMMAudioOut.Get_Volume: Integer;
begin
  Result := DefaultInterface.Volume;
end;

procedure TSpMMAudioOut.Set_Volume(Volume: Integer);
begin
  DefaultInterface.Volume := Volume;
end;

function TSpMMAudioOut.Get_BufferNotifySize: Integer;
begin
  Result := DefaultInterface.BufferNotifySize;
end;

procedure TSpMMAudioOut.Set_BufferNotifySize(BufferNotifySize: Integer);
begin
  DefaultInterface.BufferNotifySize := BufferNotifySize;
end;

function TSpMMAudioOut.Get_EventHandle: Integer;
begin
  Result := DefaultInterface.EventHandle;
end;

function TSpMMAudioOut.Get_DeviceId: Integer;
begin
  Result := DefaultInterface.DeviceId;
end;

procedure TSpMMAudioOut.Set_DeviceId(DeviceId: Integer);
begin
  DefaultInterface.DeviceId := DeviceId;
end;

function TSpMMAudioOut.Get_LineId: Integer;
begin
  Result := DefaultInterface.LineId;
end;

procedure TSpMMAudioOut.Set_LineId(LineId: Integer);
begin
  DefaultInterface.LineId := LineId;
end;

function TSpMMAudioOut.Get_MMHandle: Integer;
begin
  Result := DefaultInterface.MMHandle;
end;

function TSpMMAudioOut.Read(out Buffer: OleVariant;
  NumberOfBytes: Integer): Integer;
begin
  Result := DefaultInterface.Read(Buffer, NumberOfBytes);
end;

function TSpMMAudioOut.Write(Buffer: OleVariant): Integer;
begin
  Result := DefaultInterface.Write(Buffer);
end;

function TSpMMAudioOut.Seek(Position: OleVariant;
  Origin: SpeechStreamSeekPositionType): OleVariant;
begin
  Result := DefaultInterface.Seek(Position, Origin);
end;

procedure TSpMMAudioOut.SetState(State: SpeechAudioState);
begin
  DefaultInterface.SetState(State);
end;

class function CoSpStream.Create: ISpStream;
begin
  Result := CreateComObject(CLASS_SpStream) as ISpStream;
end;

class function CoSpStream.CreateRemote(const MachineName: string): ISpStream;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpStream) as ISpStream;
end;

procedure TSpStream.InitServerData;
const
  CServerData: TServerData = (ClassId: '{715D9C59-4442-11D2-9605-00C04F8EE628}';
    IntfIID: '{12E3CCA9-7518-44C5-A5E7-BA5A79CB929E}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpStream.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpStream;
  end;
end;

procedure TSpStream.ConnectTo(svrIntf: ISpStream);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpStream.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpStream.GetDefaultInterface: ISpStream;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpStream.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpStream.Destroy;
begin
  inherited Destroy;
end;

function TSpStream.RemoteRead(out pv: Byte; cb: LongWord;
  out pcbRead: LongWord): HResult;
begin
  Result := DefaultInterface.RemoteRead(pv, cb, pcbRead);
end;

function TSpStream.RemoteWrite(var pv: Byte; cb: LongWord;
  out pcbWritten: LongWord): HResult;
begin
  Result := DefaultInterface.RemoteWrite(pv, cb, pcbWritten);
end;

function TSpStream.RemoteSeek(dlibMove: _LARGE_INTEGER; dwOrigin: LongWord;
  out plibNewPosition: _ULARGE_INTEGER): HResult;
begin
  Result := DefaultInterface.RemoteSeek(dlibMove, dwOrigin, plibNewPosition);
end;

function TSpStream.SetSize(libNewSize: _ULARGE_INTEGER): HResult;
begin
  Result := DefaultInterface.SetSize(libNewSize);
end;

function TSpStream.RemoteCopyTo(const pstm: IStream; cb: _ULARGE_INTEGER;
  out pcbRead: _ULARGE_INTEGER; out pcbWritten: _ULARGE_INTEGER): HResult;
begin
  Result := DefaultInterface.RemoteCopyTo(pstm, cb, pcbRead, pcbWritten);
end;

function TSpStream.Commit(grfCommitFlags: LongWord): HResult;
begin
  Result := DefaultInterface.Commit(grfCommitFlags);
end;

function TSpStream.Revert: HResult;
begin
  Result := DefaultInterface.Revert;
end;

function TSpStream.LockRegion(libOffset: _ULARGE_INTEGER; cb: _ULARGE_INTEGER;
  dwLockType: LongWord): HResult;
begin
  Result := DefaultInterface.LockRegion(libOffset, cb, dwLockType);
end;

function TSpStream.UnlockRegion(libOffset: _ULARGE_INTEGER; cb: _ULARGE_INTEGER;
  dwLockType: LongWord): HResult;
begin
  Result := DefaultInterface.UnlockRegion(libOffset, cb, dwLockType);
end;

function TSpStream.Stat(out pstatstg: tagSTATSTG;
  grfStatFlag: LongWord): HResult;
begin
  Result := DefaultInterface.Stat(pstatstg, grfStatFlag);
end;

function TSpStream.Clone(out ppstm: IStream): HResult;
begin
  Result := DefaultInterface.Clone(ppstm);
end;

function TSpStream.GetFormat(var pguidFormatId: TGUID;
  out ppCoMemWaveFormatEx: PUserType2): HResult;
begin
  Result := DefaultInterface.GetFormat(pguidFormatId, ppCoMemWaveFormatEx);
end;

function TSpStream.SetBaseStream(const pStream: IStream; var rguidFormat: TGUID;
  var pWaveFormatEx: WAVEFORMATEX): HResult;
begin
  Result := DefaultInterface.SetBaseStream(pStream, rguidFormat, pWaveFormatEx);
end;

function TSpStream.GetBaseStream(out ppStream: IStream): HResult;
begin
  Result := DefaultInterface.GetBaseStream(ppStream);
end;

function TSpStream.BindToFile(pszFileName: PWideChar; eMode: SPFILEMODE;
  var pFormatId: TGUID; var pWaveFormatEx: WAVEFORMATEX;
  ullEventInterest: Largeuint): HResult;
begin
  Result := DefaultInterface.BindToFile(pszFileName, eMode, pFormatId,
    pWaveFormatEx, ullEventInterest);
end;

function TSpStream.Close: HResult;
begin
  Result := DefaultInterface.Close;
end;

class function CoSpVoice.Create: ISpeechVoice;
begin
  Result := CreateComObject(CLASS_SpVoice) as ISpeechVoice;
end;

class function CoSpVoice.CreateRemote(const MachineName: string): ISpeechVoice;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpVoice) as ISpeechVoice;
end;

procedure TSpVoice.InitServerData;
const
  CServerData: TServerData = (ClassId: '{96749377-3391-11D2-9EE3-00C04F797396}';
    IntfIID: '{269316D8-57BD-11D2-9EEE-00C04F797396}';
    EventIID: '{A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}'; LicenseKey: nil;
    Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpVoice.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    ConnectEvents(punk);
    FIntf := punk as ISpeechVoice;
  end;
end;

procedure TSpVoice.ConnectTo(svrIntf: ISpeechVoice);
begin
  Disconnect;
  FIntf := svrIntf;
  ConnectEvents(FIntf);
end;

procedure TSpVoice.Disconnect;
begin
  if FIntf <> nil then
  begin
    DisconnectEvents(FIntf);
    FIntf := nil;
  end;
end;

function TSpVoice.GetDefaultInterface: ISpeechVoice;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpVoice.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpVoice.Destroy;
begin
  inherited Destroy;
end;

procedure TSpVoice.InvokeEvent(dispid: TDispID; var Params: TVariantArray);
begin
  case DispID of
    - 1:
      Exit; // DISPID_UNKNOWN
    1:
      if Assigned(FOnStartStream) then
        FOnStartStream(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    2:
      if Assigned(FOnEndStream) then
        FOnEndStream(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    3:
      if Assigned(FOnVoiceChange) then
        FOnVoiceChange(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          IUnknown(TVarData(Params[2]).VPointer)
          as ISpeechObjectToken { const ISpeechObjectToken } );
    4:
      if Assigned(FOnBookmark) then
        FOnBookmark(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { const WideString } , Params[3] { Integer } );
    5:
      if Assigned(FOnWord) then
        FOnWord(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { Integer } , Params[3] { Integer } );
    7:
      if Assigned(FOnSentence) then
        FOnSentence(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { Integer } , Params[3] { Integer } );
    6:
      if Assigned(FOnPhoneme) then
        FOnPhoneme(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { Integer } , Params[3] { Smallint } ,
          Params[4] { SpeechVisemeFeature } , Params[5] { Smallint } );
    8:
      if Assigned(FOnViseme) then
        FOnViseme(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { Integer } , Params[3] { SpeechVisemeType } ,
          Params[4] { SpeechVisemeFeature } , Params[5] { SpeechVisemeType } );
    9:
      if Assigned(FOnAudioLevel) then
        FOnAudioLevel(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { Integer } );
    10:
      if Assigned(FOnEnginePrivate) then
        FOnEnginePrivate(Self, Params[0] { Integer } , Params[1] { Integer } ,
          Params[2] { OleVariant } );
  end; { case DispID }
end;

function TSpVoice.Get_Status: ISpeechVoiceStatus;
begin
  Result := DefaultInterface.Status;
end;

function TSpVoice.Get_Voice: ISpeechObjectToken;
begin
  Result := DefaultInterface.Voice;
end;

procedure TSpVoice._Set_Voice(const Voice: ISpeechObjectToken);
begin
  DefaultInterface.Voice := Voice;
end;

function TSpVoice.Get_AudioOutput: ISpeechObjectToken;
begin
  Result := DefaultInterface.AudioOutput;
end;

procedure TSpVoice._Set_AudioOutput(const AudioOutput: ISpeechObjectToken);
begin
  DefaultInterface.AudioOutput := AudioOutput;
end;

function TSpVoice.Get_AudioOutputStream: ISpeechBaseStream;
begin
  Result := DefaultInterface.AudioOutputStream;
end;

procedure TSpVoice._Set_AudioOutputStream(const AudioOutputStream
  : ISpeechBaseStream);
begin
  DefaultInterface.AudioOutputStream := AudioOutputStream;
end;

function TSpVoice.Get_Rate: Integer;
begin
  Result := DefaultInterface.Rate;
end;

procedure TSpVoice.Set_Rate(Rate: Integer);
begin
  DefaultInterface.Rate := Rate;
end;

function TSpVoice.Get_Volume: Integer;
begin
  Result := DefaultInterface.Volume;
end;

procedure TSpVoice.Set_Volume(Volume: Integer);
begin
  DefaultInterface.Volume := Volume;
end;

procedure TSpVoice.Set_AllowAudioOutputFormatChangesOnNextSet(Allow: WordBool);
begin
  DefaultInterface.AllowAudioOutputFormatChangesOnNextSet := Allow;
end;

function TSpVoice.Get_AllowAudioOutputFormatChangesOnNextSet: WordBool;
begin
  Result := DefaultInterface.AllowAudioOutputFormatChangesOnNextSet;
end;

function TSpVoice.Get_EventInterests: SpeechVoiceEvents;
begin
  Result := DefaultInterface.EventInterests;
end;

procedure TSpVoice.Set_EventInterests(EventInterestFlags: SpeechVoiceEvents);
begin
  DefaultInterface.EventInterests := EventInterestFlags;
end;

procedure TSpVoice.Set_Priority(Priority: SpeechVoicePriority);
begin
  DefaultInterface.Priority := Priority;
end;

function TSpVoice.Get_Priority: SpeechVoicePriority;
begin
  Result := DefaultInterface.Priority;
end;

procedure TSpVoice.Set_AlertBoundary(Boundary: SpeechVoiceEvents);
begin
  DefaultInterface.AlertBoundary := Boundary;
end;

function TSpVoice.Get_AlertBoundary: SpeechVoiceEvents;
begin
  Result := DefaultInterface.AlertBoundary;
end;

procedure TSpVoice.Set_SynchronousSpeakTimeout(msTimeout: Integer);
begin
  DefaultInterface.SynchronousSpeakTimeout := msTimeout;
end;

function TSpVoice.Get_SynchronousSpeakTimeout: Integer;
begin
  Result := DefaultInterface.SynchronousSpeakTimeout;
end;

function TSpVoice.Speak(const Text: WideString;
  Flags: SpeechVoiceSpeakFlags): Integer;
begin
  Result := DefaultInterface.Speak(Text, Flags);
end;

function TSpVoice.SpeakStream(const Stream: ISpeechBaseStream;
  Flags: SpeechVoiceSpeakFlags): Integer;
begin
  Result := DefaultInterface.SpeakStream(Stream, Flags);
end;

procedure TSpVoice.Pause;
begin
  DefaultInterface.Pause;
end;

procedure TSpVoice.Resume;
begin
  DefaultInterface.Resume;
end;

function TSpVoice.Skip(const type_: WideString; NumItems: Integer): Integer;
begin
  Result := DefaultInterface.Skip(type_, NumItems);
end;

function TSpVoice.GetVoices(const RequiredAttributes: WideString;
  const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetVoices(RequiredAttributes, OptionalAttributes);
end;

function TSpVoice.GetAudioOutputs(const RequiredAttributes: WideString;
  const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetAudioOutputs(RequiredAttributes,
    OptionalAttributes);
end;

function TSpVoice.WaitUntilDone(msTimeout: Integer): WordBool;
begin
  Result := DefaultInterface.WaitUntilDone(msTimeout);
end;

function TSpVoice.SpeakCompleteEvent: Integer;
begin
  Result := DefaultInterface.SpeakCompleteEvent;
end;

function TSpVoice.IsUISupported(const TypeOfUI: WideString): WordBool;
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  Result := DefaultInterface.IsUISupported(TypeOfUI, EmptyParam);
end;

function TSpVoice.IsUISupported(const TypeOfUI: WideString;
  const ExtraData: OleVariant): WordBool;
begin
  Result := DefaultInterface.IsUISupported(TypeOfUI, ExtraData);
end;

procedure TSpVoice.DisplayUI(hWndParent: Integer; const Title: WideString;
  const TypeOfUI: WideString);
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  DefaultInterface.DisplayUI(hWndParent, Title, TypeOfUI, EmptyParam);
end;

procedure TSpVoice.DisplayUI(hWndParent: Integer; const Title: WideString;
  const TypeOfUI: WideString; const ExtraData: OleVariant);
begin
  DefaultInterface.DisplayUI(hWndParent, Title, TypeOfUI, ExtraData);
end;

class function CoSpSharedRecoContext.Create: ISpeechRecoContext;
begin
  Result := CreateComObject(CLASS_SpSharedRecoContext) as ISpeechRecoContext;
end;

class function CoSpSharedRecoContext.CreateRemote(const MachineName: string)
  : ISpeechRecoContext;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpSharedRecoContext)
    as ISpeechRecoContext;
end;

procedure TSpSharedRecoContext.InitServerData;
const
  CServerData: TServerData = (ClassId: '{47206204-5ECA-11D2-960F-00C04F8EE628}';
    IntfIID: '{580AA49D-7E1E-4809-B8E2-57DA806104B8}';
    EventIID: '{7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}'; LicenseKey: nil;
    Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpSharedRecoContext.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    ConnectEvents(punk);
    FIntf := punk as ISpeechRecoContext;
  end;
end;

procedure TSpSharedRecoContext.ConnectTo(svrIntf: ISpeechRecoContext);
begin
  Disconnect;
  FIntf := svrIntf;
  ConnectEvents(FIntf);
end;

procedure TSpSharedRecoContext.Disconnect;
begin
  if FIntf <> nil then
  begin
    DisconnectEvents(FIntf);
    FIntf := nil;
  end;
end;

function TSpSharedRecoContext.GetDefaultInterface: ISpeechRecoContext;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpSharedRecoContext.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpSharedRecoContext.Destroy;
begin
  inherited Destroy;
end;

procedure TSpSharedRecoContext.InvokeEvent(dispid: TDispID;
  var Params: TVariantArray);
begin
  case DispID of
    - 1:
      Exit; // DISPID_UNKNOWN
    1:
      if Assigned(FOnStartStream) then
        FOnStartStream(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    2:
      if Assigned(FOnEndStream) then
        FOnEndStream(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { WordBool } );
    3:
      if Assigned(FOnBookmark) then
        FOnBookmark(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { OleVariant } , Params[3] { SpeechBookmarkOptions } );
    4:
      if Assigned(FOnSoundStart) then
        FOnSoundStart(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    5:
      if Assigned(FOnSoundEnd) then
        FOnSoundEnd(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    6:
      if Assigned(FOnPhraseStart) then
        FOnPhraseStart(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    7:
      if Assigned(FOnRecognition) then
        FOnRecognition(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { SpeechRecognitionType } ,
          IUnknown(TVarData(Params[3]).VPointer)
          as ISpeechRecoResult { const ISpeechRecoResult } );
    8:
      if Assigned(FOnHypothesis) then
        FOnHypothesis(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          IUnknown(TVarData(Params[2]).VPointer)
          as ISpeechRecoResult { const ISpeechRecoResult } );
    9:
      if Assigned(FOnPropertyNumberChange) then
        FOnPropertyNumberChange(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , Params[2] { const WideString } ,
          Params[3] { Integer } );
    10:
      if Assigned(FOnPropertyStringChange) then
        FOnPropertyStringChange(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , Params[2] { const WideString } ,
          Params[3] { const WideString } );
    11:
      if Assigned(FOnFalseRecognition) then
        FOnFalseRecognition(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , IUnknown(TVarData(Params[2]).VPointer)
          as ISpeechRecoResult { const ISpeechRecoResult } );
    12:
      if Assigned(FOnInterference) then
        FOnInterference(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { SpeechInterference } );
    13:
      if Assigned(FOnRequestUI) then
        FOnRequestUI(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { const WideString } );
    14:
      if Assigned(FOnRecognizerStateChange) then
        FOnRecognizerStateChange(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , Params[2] { SpeechRecognizerState } );
    15:
      if Assigned(FOnAdaptation) then
        FOnAdaptation(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    16:
      if Assigned(FOnRecognitionForOtherContext) then
        FOnRecognitionForOtherContext(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } );
    17:
      if Assigned(FOnAudioLevel) then
        FOnAudioLevel(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { Integer } );
    18:
      if Assigned(FOnEnginePrivate) then
        FOnEnginePrivate(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , Params[2] { OleVariant } );
  end; { case DispID }
end;

function TSpSharedRecoContext.Get_Recognizer: ISpeechRecognizer;
begin
  Result := DefaultInterface.Recognizer;
end;

function TSpSharedRecoContext.Get_AudioInputInterferenceStatus
  : SpeechInterference;
begin
  Result := DefaultInterface.AudioInputInterferenceStatus;
end;

function TSpSharedRecoContext.Get_RequestedUIType: WideString;
begin
  Result := DefaultInterface.RequestedUIType;
end;

procedure TSpSharedRecoContext._Set_Voice(const Voice: ISpeechVoice);
begin
  DefaultInterface.Voice := Voice;
end;

function TSpSharedRecoContext.Get_Voice: ISpeechVoice;
begin
  Result := DefaultInterface.Voice;
end;

procedure TSpSharedRecoContext.Set_AllowVoiceFormatMatchingOnNextSet
  (pAllow: WordBool);
begin
  DefaultInterface.AllowVoiceFormatMatchingOnNextSet := pAllow;
end;

function TSpSharedRecoContext.Get_AllowVoiceFormatMatchingOnNextSet: WordBool;
begin
  Result := DefaultInterface.AllowVoiceFormatMatchingOnNextSet;
end;

procedure TSpSharedRecoContext.Set_VoicePurgeEvent(EventInterest
  : SpeechRecoEvents);
begin
  DefaultInterface.VoicePurgeEvent := EventInterest;
end;

function TSpSharedRecoContext.Get_VoicePurgeEvent: SpeechRecoEvents;
begin
  Result := DefaultInterface.VoicePurgeEvent;
end;

procedure TSpSharedRecoContext.Set_EventInterests(EventInterest
  : SpeechRecoEvents);
begin
  DefaultInterface.EventInterests := EventInterest;
end;

function TSpSharedRecoContext.Get_EventInterests: SpeechRecoEvents;
begin
  Result := DefaultInterface.EventInterests;
end;

procedure TSpSharedRecoContext.Set_CmdMaxAlternates(MaxAlternates: Integer);
begin
  DefaultInterface.CmdMaxAlternates := MaxAlternates;
end;

function TSpSharedRecoContext.Get_CmdMaxAlternates: Integer;
begin
  Result := DefaultInterface.CmdMaxAlternates;
end;

procedure TSpSharedRecoContext.Set_State(State: SpeechRecoContextState);
begin
  DefaultInterface.State := State;
end;

function TSpSharedRecoContext.Get_State: SpeechRecoContextState;
begin
  Result := DefaultInterface.State;
end;

procedure TSpSharedRecoContext.Set_RetainedAudio
  (Option: SpeechRetainedAudioOptions);
begin
  DefaultInterface.RetainedAudio := Option;
end;

function TSpSharedRecoContext.Get_RetainedAudio: SpeechRetainedAudioOptions;
begin
  Result := DefaultInterface.RetainedAudio;
end;

procedure TSpSharedRecoContext._Set_RetainedAudioFormat
  (const Format: ISpeechAudioFormat);
begin
  DefaultInterface.RetainedAudioFormat := Format;
end;

function TSpSharedRecoContext.Get_RetainedAudioFormat: ISpeechAudioFormat;
begin
  Result := DefaultInterface.RetainedAudioFormat;
end;

procedure TSpSharedRecoContext.Pause;
begin
  DefaultInterface.Pause;
end;

procedure TSpSharedRecoContext.Resume;
begin
  DefaultInterface.Resume;
end;

function TSpSharedRecoContext.CreateGrammar: ISpeechRecoGrammar;
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  Result := DefaultInterface.CreateGrammar(EmptyParam);
end;

function TSpSharedRecoContext.CreateGrammar(GrammarId: OleVariant)
  : ISpeechRecoGrammar;
begin
  Result := DefaultInterface.CreateGrammar(GrammarId);
end;

function TSpSharedRecoContext.CreateResultFromMemory(const ResultBlock
  : OleVariant): ISpeechRecoResult;
begin
  Result := DefaultInterface.CreateResultFromMemory(ResultBlock);
end;

procedure TSpSharedRecoContext.Bookmark(Options: SpeechBookmarkOptions;
  StreamPos: OleVariant; BookmarkId: OleVariant);
begin
  DefaultInterface.Bookmark(Options, StreamPos, BookmarkId);
end;

procedure TSpSharedRecoContext.SetAdaptationData(const AdaptationString
  : WideString);
begin
  DefaultInterface.SetAdaptationData(AdaptationString);
end;

class function CoSpInprocRecognizer.Create: ISpeechRecognizer;
begin
  Result := CreateComObject(CLASS_SpInprocRecognizer) as ISpeechRecognizer;
end;

class function CoSpInprocRecognizer.CreateRemote(const MachineName: string)
  : ISpeechRecognizer;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpInprocRecognizer)
    as ISpeechRecognizer;
end;

procedure TSpInprocRecognizer.InitServerData;
const
  CServerData: TServerData = (ClassId: '{41B89B6B-9399-11D2-9623-00C04F8EE628}';
    IntfIID: '{2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpInprocRecognizer.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechRecognizer;
  end;
end;

procedure TSpInprocRecognizer.ConnectTo(svrIntf: ISpeechRecognizer);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpInprocRecognizer.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpInprocRecognizer.GetDefaultInterface: ISpeechRecognizer;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpInprocRecognizer.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpInprocRecognizer.Destroy;
begin
  inherited Destroy;
end;

procedure TSpInprocRecognizer._Set_Recognizer(const Recognizer
  : ISpeechObjectToken);
begin
  DefaultInterface.Recognizer := Recognizer;
end;

function TSpInprocRecognizer.Get_Recognizer: ISpeechObjectToken;
begin
  Result := DefaultInterface.Recognizer;
end;

procedure TSpInprocRecognizer.Set_AllowAudioInputFormatChangesOnNextSet
  (Allow: WordBool);
begin
  DefaultInterface.AllowAudioInputFormatChangesOnNextSet := Allow;
end;

function TSpInprocRecognizer.Get_AllowAudioInputFormatChangesOnNextSet
  : WordBool;
begin
  Result := DefaultInterface.AllowAudioInputFormatChangesOnNextSet;
end;

procedure TSpInprocRecognizer._Set_AudioInput(const AudioInput
  : ISpeechObjectToken);
begin
  DefaultInterface.AudioInput := AudioInput;
end;

function TSpInprocRecognizer.Get_AudioInput: ISpeechObjectToken;
begin
  Result := DefaultInterface.AudioInput;
end;

procedure TSpInprocRecognizer._Set_AudioInputStream(const AudioInputStream
  : ISpeechBaseStream);
begin
  DefaultInterface.AudioInputStream := AudioInputStream;
end;

function TSpInprocRecognizer.Get_AudioInputStream: ISpeechBaseStream;
begin
  Result := DefaultInterface.AudioInputStream;
end;

function TSpInprocRecognizer.Get_IsShared: WordBool;
begin
  Result := DefaultInterface.IsShared;
end;

procedure TSpInprocRecognizer.Set_State(State: SpeechRecognizerState);
begin
  DefaultInterface.State := State;
end;

function TSpInprocRecognizer.Get_State: SpeechRecognizerState;
begin
  Result := DefaultInterface.State;
end;

function TSpInprocRecognizer.Get_Status: ISpeechRecognizerStatus;
begin
  Result := DefaultInterface.Status;
end;

procedure TSpInprocRecognizer._Set_Profile(const Profile: ISpeechObjectToken);
begin
  DefaultInterface.Profile := Profile;
end;

function TSpInprocRecognizer.Get_Profile: ISpeechObjectToken;
begin
  Result := DefaultInterface.Profile;
end;

procedure TSpInprocRecognizer.EmulateRecognition(TextElements: OleVariant;
  const ElementDisplayAttributes: OleVariant; LanguageId: Integer);
begin
  DefaultInterface.EmulateRecognition(TextElements, ElementDisplayAttributes,
    LanguageId);
end;

function TSpInprocRecognizer.CreateRecoContext: ISpeechRecoContext;
begin
  Result := DefaultInterface.CreateRecoContext;
end;

function TSpInprocRecognizer.GetFormat(type_: SpeechFormatType)
  : ISpeechAudioFormat;
begin
  Result := DefaultInterface.GetFormat(type_);
end;

function TSpInprocRecognizer.SetPropertyNumber(const Name: WideString;
  Value: Integer): WordBool;
begin
  Result := DefaultInterface.SetPropertyNumber(Name, Value);
end;

function TSpInprocRecognizer.GetPropertyNumber(const Name: WideString;
  var Value: Integer): WordBool;
begin
  Result := DefaultInterface.GetPropertyNumber(Name, Value);
end;

function TSpInprocRecognizer.SetPropertyString(const Name: WideString;
  const Value: WideString): WordBool;
begin
  Result := DefaultInterface.SetPropertyString(Name, Value);
end;

function TSpInprocRecognizer.GetPropertyString(const Name: WideString;
  var Value: WideString): WordBool;
begin
  Result := DefaultInterface.GetPropertyString(Name, Value);
end;

function TSpInprocRecognizer.IsUISupported(const TypeOfUI: WideString)
  : WordBool;
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  Result := DefaultInterface.IsUISupported(TypeOfUI, EmptyParam);
end;

function TSpInprocRecognizer.IsUISupported(const TypeOfUI: WideString;
  const ExtraData: OleVariant): WordBool;
begin
  Result := DefaultInterface.IsUISupported(TypeOfUI, ExtraData);
end;

procedure TSpInprocRecognizer.DisplayUI(hWndParent: Integer;
  const Title: WideString; const TypeOfUI: WideString);
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  DefaultInterface.DisplayUI(hWndParent, Title, TypeOfUI, EmptyParam);
end;

procedure TSpInprocRecognizer.DisplayUI(hWndParent: Integer;
  const Title: WideString; const TypeOfUI: WideString;
  const ExtraData: OleVariant);
begin
  DefaultInterface.DisplayUI(hWndParent, Title, TypeOfUI, ExtraData);
end;

function TSpInprocRecognizer.GetRecognizers(const RequiredAttributes
  : WideString; const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetRecognizers(RequiredAttributes,
    OptionalAttributes);
end;

function TSpInprocRecognizer.GetAudioInputs(const RequiredAttributes
  : WideString; const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetAudioInputs(RequiredAttributes,
    OptionalAttributes);
end;

function TSpInprocRecognizer.GetProfiles(const RequiredAttributes: WideString;
  const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetProfiles(RequiredAttributes,
    OptionalAttributes);
end;

class function CoSpSharedRecognizer.Create: ISpeechRecognizer;
begin
  Result := CreateComObject(CLASS_SpSharedRecognizer) as ISpeechRecognizer;
end;

class function CoSpSharedRecognizer.CreateRemote(const MachineName: string)
  : ISpeechRecognizer;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpSharedRecognizer)
    as ISpeechRecognizer;
end;

procedure TSpSharedRecognizer.InitServerData;
const
  CServerData: TServerData = (ClassId: '{3BEE4890-4FE9-4A37-8C1E-5E7E12791C1F}';
    IntfIID: '{2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpSharedRecognizer.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechRecognizer;
  end;
end;

procedure TSpSharedRecognizer.ConnectTo(svrIntf: ISpeechRecognizer);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpSharedRecognizer.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpSharedRecognizer.GetDefaultInterface: ISpeechRecognizer;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpSharedRecognizer.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpSharedRecognizer.Destroy;
begin
  inherited Destroy;
end;

procedure TSpSharedRecognizer._Set_Recognizer(const Recognizer
  : ISpeechObjectToken);
begin
  DefaultInterface.Recognizer := Recognizer;
end;

function TSpSharedRecognizer.Get_Recognizer: ISpeechObjectToken;
begin
  Result := DefaultInterface.Recognizer;
end;

procedure TSpSharedRecognizer.Set_AllowAudioInputFormatChangesOnNextSet
  (Allow: WordBool);
begin
  DefaultInterface.AllowAudioInputFormatChangesOnNextSet := Allow;
end;

function TSpSharedRecognizer.Get_AllowAudioInputFormatChangesOnNextSet
  : WordBool;
begin
  Result := DefaultInterface.AllowAudioInputFormatChangesOnNextSet;
end;

procedure TSpSharedRecognizer._Set_AudioInput(const AudioInput
  : ISpeechObjectToken);
begin
  DefaultInterface.AudioInput := AudioInput;
end;

function TSpSharedRecognizer.Get_AudioInput: ISpeechObjectToken;
begin
  Result := DefaultInterface.AudioInput;
end;

procedure TSpSharedRecognizer._Set_AudioInputStream(const AudioInputStream
  : ISpeechBaseStream);
begin
  DefaultInterface.AudioInputStream := AudioInputStream;
end;

function TSpSharedRecognizer.Get_AudioInputStream: ISpeechBaseStream;
begin
  Result := DefaultInterface.AudioInputStream;
end;

function TSpSharedRecognizer.Get_IsShared: WordBool;
begin
  Result := DefaultInterface.IsShared;
end;

procedure TSpSharedRecognizer.Set_State(State: SpeechRecognizerState);
begin
  DefaultInterface.State := State;
end;

function TSpSharedRecognizer.Get_State: SpeechRecognizerState;
begin
  Result := DefaultInterface.State;
end;

function TSpSharedRecognizer.Get_Status: ISpeechRecognizerStatus;
begin
  Result := DefaultInterface.Status;
end;

procedure TSpSharedRecognizer._Set_Profile(const Profile: ISpeechObjectToken);
begin
  DefaultInterface.Profile := Profile;
end;

function TSpSharedRecognizer.Get_Profile: ISpeechObjectToken;
begin
  Result := DefaultInterface.Profile;
end;

procedure TSpSharedRecognizer.EmulateRecognition(TextElements: OleVariant;
  const ElementDisplayAttributes: OleVariant; LanguageId: Integer);
begin
  DefaultInterface.EmulateRecognition(TextElements, ElementDisplayAttributes,
    LanguageId);
end;

function TSpSharedRecognizer.CreateRecoContext: ISpeechRecoContext;
begin
  Result := DefaultInterface.CreateRecoContext;
end;

function TSpSharedRecognizer.GetFormat(type_: SpeechFormatType)
  : ISpeechAudioFormat;
begin
  Result := DefaultInterface.GetFormat(type_);
end;

function TSpSharedRecognizer.SetPropertyNumber(const Name: WideString;
  Value: Integer): WordBool;
begin
  Result := DefaultInterface.SetPropertyNumber(Name, Value);
end;

function TSpSharedRecognizer.GetPropertyNumber(const Name: WideString;
  var Value: Integer): WordBool;
begin
  Result := DefaultInterface.GetPropertyNumber(Name, Value);
end;

function TSpSharedRecognizer.SetPropertyString(const Name: WideString;
  const Value: WideString): WordBool;
begin
  Result := DefaultInterface.SetPropertyString(Name, Value);
end;

function TSpSharedRecognizer.GetPropertyString(const Name: WideString;
  var Value: WideString): WordBool;
begin
  Result := DefaultInterface.GetPropertyString(Name, Value);
end;

function TSpSharedRecognizer.IsUISupported(const TypeOfUI: WideString)
  : WordBool;
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  Result := DefaultInterface.IsUISupported(TypeOfUI, EmptyParam);
end;

function TSpSharedRecognizer.IsUISupported(const TypeOfUI: WideString;
  const ExtraData: OleVariant): WordBool;
begin
  Result := DefaultInterface.IsUISupported(TypeOfUI, ExtraData);
end;

procedure TSpSharedRecognizer.DisplayUI(hWndParent: Integer;
  const Title: WideString; const TypeOfUI: WideString);
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  DefaultInterface.DisplayUI(hWndParent, Title, TypeOfUI, EmptyParam);
end;

procedure TSpSharedRecognizer.DisplayUI(hWndParent: Integer;
  const Title: WideString; const TypeOfUI: WideString;
  const ExtraData: OleVariant);
begin
  DefaultInterface.DisplayUI(hWndParent, Title, TypeOfUI, ExtraData);
end;

function TSpSharedRecognizer.GetRecognizers(const RequiredAttributes
  : WideString; const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetRecognizers(RequiredAttributes,
    OptionalAttributes);
end;

function TSpSharedRecognizer.GetAudioInputs(const RequiredAttributes
  : WideString; const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetAudioInputs(RequiredAttributes,
    OptionalAttributes);
end;

function TSpSharedRecognizer.GetProfiles(const RequiredAttributes: WideString;
  const OptionalAttributes: WideString): ISpeechObjectTokens;
begin
  Result := DefaultInterface.GetProfiles(RequiredAttributes,
    OptionalAttributes);
end;

class function CoSpLexicon.Create: ISpeechLexicon;
begin
  Result := CreateComObject(CLASS_SpLexicon) as ISpeechLexicon;
end;

class function CoSpLexicon.CreateRemote(const MachineName: string)
  : ISpeechLexicon;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpLexicon)
    as ISpeechLexicon;
end;

procedure TSpLexicon.InitServerData;
const
  CServerData: TServerData = (ClassId: '{0655E396-25D0-11D3-9C26-00C04F8EF87C}';
    IntfIID: '{3DA7627A-C7AE-4B23-8708-638C50362C25}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpLexicon.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechLexicon;
  end;
end;

procedure TSpLexicon.ConnectTo(svrIntf: ISpeechLexicon);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpLexicon.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpLexicon.GetDefaultInterface: ISpeechLexicon;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpLexicon.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpLexicon.Destroy;
begin
  inherited Destroy;
end;

function TSpLexicon.Get_GenerationId: Integer;
begin
  Result := DefaultInterface.GenerationId;
end;

function TSpLexicon.GetWords(Flags: SpeechLexiconType;
  out GenerationId: Integer): ISpeechLexiconWords;
begin
  Result := DefaultInterface.GetWords(Flags, GenerationId);
end;

procedure TSpLexicon.AddPronunciation(const bstrWord: WideString;
  LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
  const bstrPronunciation: WideString);
begin
  DefaultInterface.AddPronunciation(bstrWord, LangId, PartOfSpeech,
    bstrPronunciation);
end;

procedure TSpLexicon.AddPronunciationByPhoneIds(const bstrWord: WideString;
  LangId: Integer; PartOfSpeech: SpeechPartOfSpeech);
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  DefaultInterface.AddPronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech,
    EmptyParam);
end;

procedure TSpLexicon.AddPronunciationByPhoneIds(const bstrWord: WideString;
  LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
  const PhoneIds: OleVariant);
begin
  DefaultInterface.AddPronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech,
    PhoneIds);
end;

procedure TSpLexicon.RemovePronunciation(const bstrWord: WideString;
  LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
  const bstrPronunciation: WideString);
begin
  DefaultInterface.RemovePronunciation(bstrWord, LangId, PartOfSpeech,
    bstrPronunciation);
end;

procedure TSpLexicon.RemovePronunciationByPhoneIds(const bstrWord: WideString;
  LangId: Integer; PartOfSpeech: SpeechPartOfSpeech);
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  DefaultInterface.RemovePronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech,
    EmptyParam);
end;

procedure TSpLexicon.RemovePronunciationByPhoneIds(const bstrWord: WideString;
  LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
  const PhoneIds: OleVariant);
begin
  DefaultInterface.RemovePronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech,
    PhoneIds);
end;

function TSpLexicon.GetPronunciations(const bstrWord: WideString;
  LangId: Integer; TypeFlags: SpeechLexiconType): ISpeechLexiconPronunciations;
begin
  Result := DefaultInterface.GetPronunciations(bstrWord, LangId, TypeFlags);
end;

function TSpLexicon.GetGenerationChange(var GenerationId: Integer)
  : ISpeechLexiconWords;
begin
  Result := DefaultInterface.GetGenerationChange(GenerationId);
end;

class function CoSpUnCompressedLexicon.Create: ISpeechLexicon;
begin
  Result := CreateComObject(CLASS_SpUnCompressedLexicon) as ISpeechLexicon;
end;

class function CoSpUnCompressedLexicon.CreateRemote(const MachineName: string)
  : ISpeechLexicon;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpUnCompressedLexicon)
    as ISpeechLexicon;
end;

procedure TSpUnCompressedLexicon.InitServerData;
const
  CServerData: TServerData = (ClassId: '{C9E37C15-DF92-4727-85D6-72E5EEB6995A}';
    IntfIID: '{3DA7627A-C7AE-4B23-8708-638C50362C25}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpUnCompressedLexicon.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechLexicon;
  end;
end;

procedure TSpUnCompressedLexicon.ConnectTo(svrIntf: ISpeechLexicon);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpUnCompressedLexicon.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpUnCompressedLexicon.GetDefaultInterface: ISpeechLexicon;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpUnCompressedLexicon.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpUnCompressedLexicon.Destroy;
begin
  inherited Destroy;
end;

function TSpUnCompressedLexicon.Get_GenerationId: Integer;
begin
  Result := DefaultInterface.GenerationId;
end;

function TSpUnCompressedLexicon.GetWords(Flags: SpeechLexiconType;
  out GenerationId: Integer): ISpeechLexiconWords;
begin
  Result := DefaultInterface.GetWords(Flags, GenerationId);
end;

procedure TSpUnCompressedLexicon.AddPronunciation(const bstrWord: WideString;
  LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
  const bstrPronunciation: WideString);
begin
  DefaultInterface.AddPronunciation(bstrWord, LangId, PartOfSpeech,
    bstrPronunciation);
end;

procedure TSpUnCompressedLexicon.AddPronunciationByPhoneIds(const bstrWord
  : WideString; LangId: Integer; PartOfSpeech: SpeechPartOfSpeech);
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  DefaultInterface.AddPronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech,
    EmptyParam);
end;

procedure TSpUnCompressedLexicon.AddPronunciationByPhoneIds(const bstrWord
  : WideString; LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
  const PhoneIds: OleVariant);
begin
  DefaultInterface.AddPronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech,
    PhoneIds);
end;

procedure TSpUnCompressedLexicon.RemovePronunciation(const bstrWord: WideString;
  LangId: Integer; PartOfSpeech: SpeechPartOfSpeech;
  const bstrPronunciation: WideString);
begin
  DefaultInterface.RemovePronunciation(bstrWord, LangId, PartOfSpeech,
    bstrPronunciation);
end;

procedure TSpUnCompressedLexicon.RemovePronunciationByPhoneIds
  (const bstrWord: WideString; LangId: Integer;
  PartOfSpeech: SpeechPartOfSpeech);
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  DefaultInterface.RemovePronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech,
    EmptyParam);
end;

procedure TSpUnCompressedLexicon.RemovePronunciationByPhoneIds
  (const bstrWord: WideString; LangId: Integer;
  PartOfSpeech: SpeechPartOfSpeech; const PhoneIds: OleVariant);
begin
  DefaultInterface.RemovePronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech,
    PhoneIds);
end;

function TSpUnCompressedLexicon.GetPronunciations(const bstrWord: WideString;
  LangId: Integer; TypeFlags: SpeechLexiconType): ISpeechLexiconPronunciations;
begin
  Result := DefaultInterface.GetPronunciations(bstrWord, LangId, TypeFlags);
end;

function TSpUnCompressedLexicon.GetGenerationChange(var GenerationId: Integer)
  : ISpeechLexiconWords;
begin
  Result := DefaultInterface.GetGenerationChange(GenerationId);
end;

class function CoSpCompressedLexicon.Create: ISpLexicon;
begin
  Result := CreateComObject(CLASS_SpCompressedLexicon) as ISpLexicon;
end;

class function CoSpCompressedLexicon.CreateRemote(const MachineName: string)
  : ISpLexicon;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpCompressedLexicon)
    as ISpLexicon;
end;

procedure TSpCompressedLexicon.InitServerData;
const
  CServerData: TServerData = (ClassId: '{90903716-2F42-11D3-9C26-00C04F8EF87C}';
    IntfIID: '{DA41A7C2-5383-4DB2-916B-6C1719E3DB58}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpCompressedLexicon.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpLexicon;
  end;
end;

procedure TSpCompressedLexicon.ConnectTo(svrIntf: ISpLexicon);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpCompressedLexicon.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpCompressedLexicon.GetDefaultInterface: ISpLexicon;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpCompressedLexicon.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpCompressedLexicon.Destroy;
begin
  inherited Destroy;
end;

function TSpCompressedLexicon.GetPronunciations(pszWord: PWideChar;
  LangId: Word; dwFlags: LongWord;
  var pWordPronunciationList: SPWORDPRONUNCIATIONLIST): HResult;
begin
  Result := DefaultInterface.GetPronunciations(pszWord, LangId, dwFlags,
    pWordPronunciationList);
end;

function TSpCompressedLexicon.AddPronunciation(pszWord: PWideChar; LangId: Word;
  ePartOfSpeech: SPPARTOFSPEECH; pszPronunciation: PWideChar): HResult;
begin
  Result := DefaultInterface.AddPronunciation(pszWord, LangId, ePartOfSpeech,
    pszPronunciation);
end;

function TSpCompressedLexicon.RemovePronunciation(pszWord: PWideChar;
  LangId: Word; ePartOfSpeech: SPPARTOFSPEECH;
  pszPronunciation: PWideChar): HResult;
begin
  Result := DefaultInterface.RemovePronunciation(pszWord, LangId, ePartOfSpeech,
    pszPronunciation);
end;

function TSpCompressedLexicon.GetGeneration(out pdwGeneration
  : LongWord): HResult;
begin
  Result := DefaultInterface.GetGeneration(pdwGeneration);
end;

function TSpCompressedLexicon.GetGenerationChange(dwFlags: LongWord;
  var pdwGeneration: LongWord; var pWordList: SPWORDLIST): HResult;
begin
  Result := DefaultInterface.GetGenerationChange(dwFlags, pdwGeneration,
    pWordList);
end;

function TSpCompressedLexicon.GetWords(dwFlags: LongWord;
  var pdwGeneration: LongWord; var pdwCookie: LongWord;
  var pWordList: SPWORDLIST): HResult;
begin
  Result := DefaultInterface.GetWords(dwFlags, pdwGeneration, pdwCookie,
    pWordList);
end;

class function CoSpShortcut.Create: ISpShortcut;
begin
  Result := CreateComObject(CLASS_SpShortcut) as ISpShortcut;
end;

class function CoSpShortcut.CreateRemote(const MachineName: string)
  : ISpShortcut;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpShortcut) as ISpShortcut;
end;

procedure TSpShortcut.InitServerData;
const
  CServerData: TServerData = (ClassId: '{0D722F1A-9FCF-4E62-96D8-6DF8F01A26AA}';
    IntfIID: '{3DF681E2-EA56-11D9-8BDE-F66BAD1E3F3A}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpShortcut.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpShortcut;
  end;
end;

procedure TSpShortcut.ConnectTo(svrIntf: ISpShortcut);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpShortcut.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpShortcut.GetDefaultInterface: ISpShortcut;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpShortcut.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpShortcut.Destroy;
begin
  inherited Destroy;
end;

function TSpShortcut.AddShortcut(pszDisplay: PWideChar; LangId: Word;
  pszSpoken: PWideChar; shType: SPSHORTCUTTYPE): HResult;
begin
  Result := DefaultInterface.AddShortcut(pszDisplay, LangId, pszSpoken, shType);
end;

function TSpShortcut.RemoveShortcut(pszDisplay: PWideChar; LangId: Word;
  pszSpoken: PWideChar; shType: SPSHORTCUTTYPE): HResult;
begin
  Result := DefaultInterface.RemoveShortcut(pszDisplay, LangId,
    pszSpoken, shType);
end;

function TSpShortcut.GetShortcuts(LangId: Word;
  var pShortcutpairList: SPSHORTCUTPAIRLIST): HResult;
begin
  Result := DefaultInterface.GetShortcuts(LangId, pShortcutpairList);
end;

function TSpShortcut.GetGeneration(out pdwGeneration: LongWord): HResult;
begin
  Result := DefaultInterface.GetGeneration(pdwGeneration);
end;

function TSpShortcut.GetWordsFromGenerationChange(var pdwGeneration: LongWord;
  var pWordList: SPWORDLIST): HResult;
begin
  Result := DefaultInterface.GetWordsFromGenerationChange(pdwGeneration,
    pWordList);
end;

function TSpShortcut.GetWords(var pdwGeneration: LongWord;
  var pdwCookie: LongWord; var pWordList: SPWORDLIST): HResult;
begin
  Result := DefaultInterface.GetWords(pdwGeneration, pdwCookie, pWordList);
end;

function TSpShortcut.GetShortcutsForGeneration(var pdwGeneration: LongWord;
  var pdwCookie: LongWord; var pShortcutpairList: SPSHORTCUTPAIRLIST): HResult;
begin
  Result := DefaultInterface.GetShortcutsForGeneration(pdwGeneration, pdwCookie,
    pShortcutpairList);
end;

function TSpShortcut.GetGenerationChange(var pdwGeneration: LongWord;
  var pShortcutpairList: SPSHORTCUTPAIRLIST): HResult;
begin
  Result := DefaultInterface.GetGenerationChange(pdwGeneration,
    pShortcutpairList);
end;

class function CoSpPhoneConverter.Create: ISpeechPhoneConverter;
begin
  Result := CreateComObject(CLASS_SpPhoneConverter) as ISpeechPhoneConverter;
end;

class function CoSpPhoneConverter.CreateRemote(const MachineName: string)
  : ISpeechPhoneConverter;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpPhoneConverter)
    as ISpeechPhoneConverter;
end;

procedure TSpPhoneConverter.InitServerData;
const
  CServerData: TServerData = (ClassId: '{9185F743-1143-4C28-86B5-BFF14F20E5C8}';
    IntfIID: '{C3E4F353-433F-43D6-89A1-6A62A7054C3D}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpPhoneConverter.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechPhoneConverter;
  end;
end;

procedure TSpPhoneConverter.ConnectTo(svrIntf: ISpeechPhoneConverter);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpPhoneConverter.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpPhoneConverter.GetDefaultInterface: ISpeechPhoneConverter;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpPhoneConverter.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpPhoneConverter.Destroy;
begin
  inherited Destroy;
end;

function TSpPhoneConverter.Get_LanguageId: Integer;
begin
  Result := DefaultInterface.LanguageId;
end;

procedure TSpPhoneConverter.Set_LanguageId(LanguageId: Integer);
begin
  DefaultInterface.LanguageId := LanguageId;
end;

function TSpPhoneConverter.PhoneToId(const Phonemes: WideString): OleVariant;
begin
  Result := DefaultInterface.PhoneToId(Phonemes);
end;

function TSpPhoneConverter.IdToPhone(IdArray: OleVariant): WideString;
begin
  Result := DefaultInterface.IdToPhone(IdArray);
end;

class function CoSpPhoneticAlphabetConverter.Create
  : ISpPhoneticAlphabetConverter;
begin
  Result := CreateComObject(CLASS_SpPhoneticAlphabetConverter)
    as ISpPhoneticAlphabetConverter;
end;

class function CoSpPhoneticAlphabetConverter.CreateRemote(const MachineName
  : string): ISpPhoneticAlphabetConverter;
begin
  Result := CreateRemoteComObject(MachineName,
    CLASS_SpPhoneticAlphabetConverter) as ISpPhoneticAlphabetConverter;
end;

procedure TSpPhoneticAlphabetConverter.InitServerData;
const
  CServerData: TServerData = (ClassId: '{4F414126-DFE3-4629-99EE-797978317EAD}';
    IntfIID: '{133ADCD4-19B4-4020-9FDC-842E78253B17}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpPhoneticAlphabetConverter.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpPhoneticAlphabetConverter;
  end;
end;

procedure TSpPhoneticAlphabetConverter.ConnectTo
  (svrIntf: ISpPhoneticAlphabetConverter);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpPhoneticAlphabetConverter.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpPhoneticAlphabetConverter.GetDefaultInterface
  : ISpPhoneticAlphabetConverter;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpPhoneticAlphabetConverter.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpPhoneticAlphabetConverter.Destroy;
begin
  inherited Destroy;
end;

function TSpPhoneticAlphabetConverter.GetLangId(out pLangID: Word): HResult;
begin
  Result := DefaultInterface.GetLangId(pLangID);
end;

function TSpPhoneticAlphabetConverter.SetLangId(LangId: Word): HResult;
begin
  Result := DefaultInterface.SetLangId(LangId);
end;

function TSpPhoneticAlphabetConverter.SAPI2UPS(var pszSAPIId: Word;
  out pszUPSId: Word; cMaxLength: LongWord): HResult;
begin
  Result := DefaultInterface.SAPI2UPS(pszSAPIId, pszUPSId, cMaxLength);
end;

function TSpPhoneticAlphabetConverter.UPS2SAPI(var pszUPSId: Word;
  out pszSAPIId: Word; cMaxLength: LongWord): HResult;
begin
  Result := DefaultInterface.UPS2SAPI(pszUPSId, pszSAPIId, cMaxLength);
end;

function TSpPhoneticAlphabetConverter.GetMaxConvertLength(cSrcLength: LongWord;
  bSAPI2UPS: Integer; out pcMaxDestLength: LongWord): HResult;
begin
  Result := DefaultInterface.GetMaxConvertLength(cSrcLength, bSAPI2UPS,
    pcMaxDestLength);
end;

class function CoSpNullPhoneConverter.Create: ISpPhoneConverter;
begin
  Result := CreateComObject(CLASS_SpNullPhoneConverter) as ISpPhoneConverter;
end;

class function CoSpNullPhoneConverter.CreateRemote(const MachineName: string)
  : ISpPhoneConverter;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpNullPhoneConverter)
    as ISpPhoneConverter;
end;

procedure TSpNullPhoneConverter.InitServerData;
const
  CServerData: TServerData = (ClassId: '{455F24E9-7396-4A16-9715-7C0FDBE3EFE3}';
    IntfIID: '{8445C581-0CAC-4A38-ABFE-9B2CE2826455}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpNullPhoneConverter.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpPhoneConverter;
  end;
end;

procedure TSpNullPhoneConverter.ConnectTo(svrIntf: ISpPhoneConverter);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpNullPhoneConverter.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpNullPhoneConverter.GetDefaultInterface: ISpPhoneConverter;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpNullPhoneConverter.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpNullPhoneConverter.Destroy;
begin
  inherited Destroy;
end;

function TSpNullPhoneConverter.SetObjectToken(const pToken
  : ISpObjectToken): HResult;
begin
  Result := DefaultInterface.SetObjectToken(pToken);
end;

function TSpNullPhoneConverter.GetObjectToken(out ppToken
  : ISpObjectToken): HResult;
begin
  Result := DefaultInterface.GetObjectToken(ppToken);
end;

function TSpNullPhoneConverter.PhoneToId(pszPhone: PWideChar;
  out pId: Word): HResult;
begin
  Result := DefaultInterface.PhoneToId(pszPhone, pId);
end;

function TSpNullPhoneConverter.IdToPhone(pId: PWideChar;
  out pszPhone: Word): HResult;
begin
  Result := DefaultInterface.IdToPhone(pId, pszPhone);
end;

class function CoSpTextSelectionInformation.Create
  : ISpeechTextSelectionInformation;
begin
  Result := CreateComObject(CLASS_SpTextSelectionInformation)
    as ISpeechTextSelectionInformation;
end;

class function CoSpTextSelectionInformation.CreateRemote(const MachineName
  : string): ISpeechTextSelectionInformation;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpTextSelectionInformation)
    as ISpeechTextSelectionInformation;
end;

procedure TSpTextSelectionInformation.InitServerData;
const
  CServerData: TServerData = (ClassId: '{0F92030A-CBFD-4AB8-A164-FF5985547FF6}';
    IntfIID: '{3B9C7E7A-6EEE-4DED-9092-11657279ADBE}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpTextSelectionInformation.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechTextSelectionInformation;
  end;
end;

procedure TSpTextSelectionInformation.ConnectTo
  (svrIntf: ISpeechTextSelectionInformation);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpTextSelectionInformation.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpTextSelectionInformation.GetDefaultInterface
  : ISpeechTextSelectionInformation;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpTextSelectionInformation.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpTextSelectionInformation.Destroy;
begin
  inherited Destroy;
end;

procedure TSpTextSelectionInformation.Set_ActiveOffset(ActiveOffset: Integer);
begin
  DefaultInterface.ActiveOffset := ActiveOffset;
end;

function TSpTextSelectionInformation.Get_ActiveOffset: Integer;
begin
  Result := DefaultInterface.ActiveOffset;
end;

procedure TSpTextSelectionInformation.Set_ActiveLength(ActiveLength: Integer);
begin
  DefaultInterface.ActiveLength := ActiveLength;
end;

function TSpTextSelectionInformation.Get_ActiveLength: Integer;
begin
  Result := DefaultInterface.ActiveLength;
end;

procedure TSpTextSelectionInformation.Set_SelectionOffset(SelectionOffset
  : Integer);
begin
  DefaultInterface.SelectionOffset := SelectionOffset;
end;

function TSpTextSelectionInformation.Get_SelectionOffset: Integer;
begin
  Result := DefaultInterface.SelectionOffset;
end;

procedure TSpTextSelectionInformation.Set_SelectionLength(SelectionLength
  : Integer);
begin
  DefaultInterface.SelectionLength := SelectionLength;
end;

function TSpTextSelectionInformation.Get_SelectionLength: Integer;
begin
  Result := DefaultInterface.SelectionLength;
end;

class function CoSpPhraseInfoBuilder.Create: ISpeechPhraseInfoBuilder;
begin
  Result := CreateComObject(CLASS_SpPhraseInfoBuilder)
    as ISpeechPhraseInfoBuilder;
end;

class function CoSpPhraseInfoBuilder.CreateRemote(const MachineName: string)
  : ISpeechPhraseInfoBuilder;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpPhraseInfoBuilder)
    as ISpeechPhraseInfoBuilder;
end;

procedure TSpPhraseInfoBuilder.InitServerData;
const
  CServerData: TServerData = (ClassId: '{C23FC28D-C55F-4720-8B32-91F73C2BD5D1}';
    IntfIID: '{3B151836-DF3A-4E0A-846C-D2ADC9334333}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpPhraseInfoBuilder.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechPhraseInfoBuilder;
  end;
end;

procedure TSpPhraseInfoBuilder.ConnectTo(svrIntf: ISpeechPhraseInfoBuilder);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpPhraseInfoBuilder.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpPhraseInfoBuilder.GetDefaultInterface: ISpeechPhraseInfoBuilder;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpPhraseInfoBuilder.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpPhraseInfoBuilder.Destroy;
begin
  inherited Destroy;
end;

function TSpPhraseInfoBuilder.RestorePhraseFromMemory(const PhraseInMemory
  : OleVariant): ISpeechPhraseInfo;
begin
  Result := DefaultInterface.RestorePhraseFromMemory(PhraseInMemory);
end;

class function CoSpAudioFormat.Create: ISpeechAudioFormat;
begin
  Result := CreateComObject(CLASS_SpAudioFormat) as ISpeechAudioFormat;
end;

class function CoSpAudioFormat.CreateRemote(const MachineName: string)
  : ISpeechAudioFormat;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpAudioFormat)
    as ISpeechAudioFormat;
end;

procedure TSpAudioFormat.InitServerData;
const
  CServerData: TServerData = (ClassId: '{9EF96870-E160-4792-820D-48CF0649E4EC}';
    IntfIID: '{E6E9C590-3E18-40E3-8299-061F98BDE7C7}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpAudioFormat.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechAudioFormat;
  end;
end;

procedure TSpAudioFormat.ConnectTo(svrIntf: ISpeechAudioFormat);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpAudioFormat.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpAudioFormat.GetDefaultInterface: ISpeechAudioFormat;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpAudioFormat.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpAudioFormat.Destroy;
begin
  inherited Destroy;
end;

function TSpAudioFormat.Get_type_: SpeechAudioFormatType;
begin
  Result := DefaultInterface.type_;
end;

procedure TSpAudioFormat.Set_type_(AudioFormat: SpeechAudioFormatType);
begin
  DefaultInterface.type_ := AudioFormat;
end;

function TSpAudioFormat.Get_Guid: WideString;
begin
  Result := DefaultInterface.Guid;
end;

procedure TSpAudioFormat.Set_Guid(const Guid: WideString);
begin
  DefaultInterface.Guid := Guid;
end;

function TSpAudioFormat.GetWaveFormatEx: ISpeechWaveFormatEx;
begin
  Result := DefaultInterface.GetWaveFormatEx;
end;

procedure TSpAudioFormat.SetWaveFormatEx(const SpeechWaveFormatEx
  : ISpeechWaveFormatEx);
begin
  DefaultInterface.SetWaveFormatEx(SpeechWaveFormatEx);
end;

class function CoSpWaveFormatEx.Create: ISpeechWaveFormatEx;
begin
  Result := CreateComObject(CLASS_SpWaveFormatEx) as ISpeechWaveFormatEx;
end;

class function CoSpWaveFormatEx.CreateRemote(const MachineName: string)
  : ISpeechWaveFormatEx;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpWaveFormatEx)
    as ISpeechWaveFormatEx;
end;

procedure TSpWaveFormatEx.InitServerData;
const
  CServerData: TServerData = (ClassId: '{C79A574C-63BE-44B9-801F-283F87F898BE}';
    IntfIID: '{7A1EF0D5-1581-4741-88E4-209A49F11A10}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpWaveFormatEx.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechWaveFormatEx;
  end;
end;

procedure TSpWaveFormatEx.ConnectTo(svrIntf: ISpeechWaveFormatEx);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpWaveFormatEx.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpWaveFormatEx.GetDefaultInterface: ISpeechWaveFormatEx;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpWaveFormatEx.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpWaveFormatEx.Destroy;
begin
  inherited Destroy;
end;

function TSpWaveFormatEx.Get_FormatTag: Smallint;
begin
  Result := DefaultInterface.FormatTag;
end;

procedure TSpWaveFormatEx.Set_FormatTag(FormatTag: Smallint);
begin
  DefaultInterface.FormatTag := FormatTag;
end;

function TSpWaveFormatEx.Get_Channels: Smallint;
begin
  Result := DefaultInterface.Channels;
end;

procedure TSpWaveFormatEx.Set_Channels(Channels: Smallint);
begin
  DefaultInterface.Channels := Channels;
end;

function TSpWaveFormatEx.Get_SamplesPerSec: Integer;
begin
  Result := DefaultInterface.SamplesPerSec;
end;

procedure TSpWaveFormatEx.Set_SamplesPerSec(SamplesPerSec: Integer);
begin
  DefaultInterface.SamplesPerSec := SamplesPerSec;
end;

function TSpWaveFormatEx.Get_AvgBytesPerSec: Integer;
begin
  Result := DefaultInterface.AvgBytesPerSec;
end;

procedure TSpWaveFormatEx.Set_AvgBytesPerSec(AvgBytesPerSec: Integer);
begin
  DefaultInterface.AvgBytesPerSec := AvgBytesPerSec;
end;

function TSpWaveFormatEx.Get_BlockAlign: Smallint;
begin
  Result := DefaultInterface.BlockAlign;
end;

procedure TSpWaveFormatEx.Set_BlockAlign(BlockAlign: Smallint);
begin
  DefaultInterface.BlockAlign := BlockAlign;
end;

function TSpWaveFormatEx.Get_BitsPerSample: Smallint;
begin
  Result := DefaultInterface.BitsPerSample;
end;

procedure TSpWaveFormatEx.Set_BitsPerSample(BitsPerSample: Smallint);
begin
  DefaultInterface.BitsPerSample := BitsPerSample;
end;

function TSpWaveFormatEx.Get_ExtraData: OleVariant;
begin
  Result := DefaultInterface.ExtraData;
end;

procedure TSpWaveFormatEx.Set_ExtraData(ExtraData: OleVariant);
begin
  DefaultInterface.ExtraData := ExtraData;
end;

class function CoSpInProcRecoContext.Create: ISpeechRecoContext;
begin
  Result := CreateComObject(CLASS_SpInProcRecoContext) as ISpeechRecoContext;
end;

class function CoSpInProcRecoContext.CreateRemote(const MachineName: string)
  : ISpeechRecoContext;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpInProcRecoContext)
    as ISpeechRecoContext;
end;

procedure TSpInProcRecoContext.InitServerData;
const
  CServerData: TServerData = (ClassId: '{73AD6842-ACE0-45E8-A4DD-8795881A2C2A}';
    IntfIID: '{580AA49D-7E1E-4809-B8E2-57DA806104B8}';
    EventIID: '{7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}'; LicenseKey: nil;
    Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpInProcRecoContext.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    ConnectEvents(punk);
    FIntf := punk as ISpeechRecoContext;
  end;
end;

procedure TSpInProcRecoContext.ConnectTo(svrIntf: ISpeechRecoContext);
begin
  Disconnect;
  FIntf := svrIntf;
  ConnectEvents(FIntf);
end;

procedure TSpInProcRecoContext.Disconnect;
begin
  if FIntf <> nil then
  begin
    DisconnectEvents(FIntf);
    FIntf := nil;
  end;
end;

function TSpInProcRecoContext.GetDefaultInterface: ISpeechRecoContext;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpInProcRecoContext.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpInProcRecoContext.Destroy;
begin
  inherited Destroy;
end;

procedure TSpInProcRecoContext.InvokeEvent(dispid: TDispID;
  var Params: TVariantArray);
begin
  case DispID of
    - 1:
      Exit; // DISPID_UNKNOWN
    1:
      if Assigned(FOnStartStream) then
        FOnStartStream(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    2:
      if Assigned(FOnEndStream) then
        FOnEndStream(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { WordBool } );
    3:
      if Assigned(FOnBookmark) then
        FOnBookmark(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { OleVariant } , Params[3] { SpeechBookmarkOptions } );
    4:
      if Assigned(FOnSoundStart) then
        FOnSoundStart(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    5:
      if Assigned(FOnSoundEnd) then
        FOnSoundEnd(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    6:
      if Assigned(FOnPhraseStart) then
        FOnPhraseStart(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    7:
      if Assigned(FOnRecognition) then
        FOnRecognition(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { SpeechRecognitionType } ,
          IUnknown(TVarData(Params[3]).VPointer)
          as ISpeechRecoResult { const ISpeechRecoResult } );
    8:
      if Assigned(FOnHypothesis) then
        FOnHypothesis(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          IUnknown(TVarData(Params[2]).VPointer)
          as ISpeechRecoResult { const ISpeechRecoResult } );
    9:
      if Assigned(FOnPropertyNumberChange) then
        FOnPropertyNumberChange(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , Params[2] { const WideString } ,
          Params[3] { Integer } );
    10:
      if Assigned(FOnPropertyStringChange) then
        FOnPropertyStringChange(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , Params[2] { const WideString } ,
          Params[3] { const WideString } );
    11:
      if Assigned(FOnFalseRecognition) then
        FOnFalseRecognition(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , IUnknown(TVarData(Params[2]).VPointer)
          as ISpeechRecoResult { const ISpeechRecoResult } );
    12:
      if Assigned(FOnInterference) then
        FOnInterference(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { SpeechInterference } );
    13:
      if Assigned(FOnRequestUI) then
        FOnRequestUI(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { const WideString } );
    14:
      if Assigned(FOnRecognizerStateChange) then
        FOnRecognizerStateChange(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , Params[2] { SpeechRecognizerState } );
    15:
      if Assigned(FOnAdaptation) then
        FOnAdaptation(Self, Params[0] { Integer } , Params[1] { OleVariant } );
    16:
      if Assigned(FOnRecognitionForOtherContext) then
        FOnRecognitionForOtherContext(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } );
    17:
      if Assigned(FOnAudioLevel) then
        FOnAudioLevel(Self, Params[0] { Integer } , Params[1] { OleVariant } ,
          Params[2] { Integer } );
    18:
      if Assigned(FOnEnginePrivate) then
        FOnEnginePrivate(Self, Params[0] { Integer } ,
          Params[1] { OleVariant } , Params[2] { OleVariant } );
  end; { case DispID }
end;

function TSpInProcRecoContext.Get_Recognizer: ISpeechRecognizer;
begin
  Result := DefaultInterface.Recognizer;
end;

function TSpInProcRecoContext.Get_AudioInputInterferenceStatus
  : SpeechInterference;
begin
  Result := DefaultInterface.AudioInputInterferenceStatus;
end;

function TSpInProcRecoContext.Get_RequestedUIType: WideString;
begin
  Result := DefaultInterface.RequestedUIType;
end;

procedure TSpInProcRecoContext._Set_Voice(const Voice: ISpeechVoice);
begin
  DefaultInterface.Voice := Voice;
end;

function TSpInProcRecoContext.Get_Voice: ISpeechVoice;
begin
  Result := DefaultInterface.Voice;
end;

procedure TSpInProcRecoContext.Set_AllowVoiceFormatMatchingOnNextSet
  (pAllow: WordBool);
begin
  DefaultInterface.AllowVoiceFormatMatchingOnNextSet := pAllow;
end;

function TSpInProcRecoContext.Get_AllowVoiceFormatMatchingOnNextSet: WordBool;
begin
  Result := DefaultInterface.AllowVoiceFormatMatchingOnNextSet;
end;

procedure TSpInProcRecoContext.Set_VoicePurgeEvent(EventInterest
  : SpeechRecoEvents);
begin
  DefaultInterface.VoicePurgeEvent := EventInterest;
end;

function TSpInProcRecoContext.Get_VoicePurgeEvent: SpeechRecoEvents;
begin
  Result := DefaultInterface.VoicePurgeEvent;
end;

procedure TSpInProcRecoContext.Set_EventInterests(EventInterest
  : SpeechRecoEvents);
begin
  DefaultInterface.EventInterests := EventInterest;
end;

function TSpInProcRecoContext.Get_EventInterests: SpeechRecoEvents;
begin
  Result := DefaultInterface.EventInterests;
end;

procedure TSpInProcRecoContext.Set_CmdMaxAlternates(MaxAlternates: Integer);
begin
  DefaultInterface.CmdMaxAlternates := MaxAlternates;
end;

function TSpInProcRecoContext.Get_CmdMaxAlternates: Integer;
begin
  Result := DefaultInterface.CmdMaxAlternates;
end;

procedure TSpInProcRecoContext.Set_State(State: SpeechRecoContextState);
begin
  DefaultInterface.State := State;
end;

function TSpInProcRecoContext.Get_State: SpeechRecoContextState;
begin
  Result := DefaultInterface.State;
end;

procedure TSpInProcRecoContext.Set_RetainedAudio
  (Option: SpeechRetainedAudioOptions);
begin
  DefaultInterface.RetainedAudio := Option;
end;

function TSpInProcRecoContext.Get_RetainedAudio: SpeechRetainedAudioOptions;
begin
  Result := DefaultInterface.RetainedAudio;
end;

procedure TSpInProcRecoContext._Set_RetainedAudioFormat
  (const Format: ISpeechAudioFormat);
begin
  DefaultInterface.RetainedAudioFormat := Format;
end;

function TSpInProcRecoContext.Get_RetainedAudioFormat: ISpeechAudioFormat;
begin
  Result := DefaultInterface.RetainedAudioFormat;
end;

procedure TSpInProcRecoContext.Pause;
begin
  DefaultInterface.Pause;
end;

procedure TSpInProcRecoContext.Resume;
begin
  DefaultInterface.Resume;
end;

function TSpInProcRecoContext.CreateGrammar: ISpeechRecoGrammar;
var
  EmptyParam: OleVariant;
begin
  EmptyParam := System.Variants.EmptyParam;
  Result := DefaultInterface.CreateGrammar(EmptyParam);
end;

function TSpInProcRecoContext.CreateGrammar(GrammarId: OleVariant)
  : ISpeechRecoGrammar;
begin
  Result := DefaultInterface.CreateGrammar(GrammarId);
end;

function TSpInProcRecoContext.CreateResultFromMemory(const ResultBlock
  : OleVariant): ISpeechRecoResult;
begin
  Result := DefaultInterface.CreateResultFromMemory(ResultBlock);
end;

procedure TSpInProcRecoContext.Bookmark(Options: SpeechBookmarkOptions;
  StreamPos: OleVariant; BookmarkId: OleVariant);
begin
  DefaultInterface.Bookmark(Options, StreamPos, BookmarkId);
end;

procedure TSpInProcRecoContext.SetAdaptationData(const AdaptationString
  : WideString);
begin
  DefaultInterface.SetAdaptationData(AdaptationString);
end;

class function CoSpCustomStream.Create: ISpeechCustomStream;
begin
  Result := CreateComObject(CLASS_SpCustomStream) as ISpeechCustomStream;
end;

class function CoSpCustomStream.CreateRemote(const MachineName: string)
  : ISpeechCustomStream;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpCustomStream)
    as ISpeechCustomStream;
end;

procedure TSpCustomStream.InitServerData;
const
  CServerData: TServerData = (ClassId: '{8DBEF13F-1948-4AA8-8CF0-048EEBED95D8}';
    IntfIID: '{1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpCustomStream.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechCustomStream;
  end;
end;

procedure TSpCustomStream.ConnectTo(svrIntf: ISpeechCustomStream);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpCustomStream.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpCustomStream.GetDefaultInterface: ISpeechCustomStream;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpCustomStream.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpCustomStream.Destroy;
begin
  inherited Destroy;
end;

function TSpCustomStream.Get_Format: ISpeechAudioFormat;
begin
  Result := DefaultInterface.Format;
end;

procedure TSpCustomStream._Set_Format(const AudioFormat: ISpeechAudioFormat);
begin
  DefaultInterface.Format := AudioFormat;
end;

function TSpCustomStream.Get_BaseStream: IUnknown;
begin
  Result := DefaultInterface.BaseStream;
end;

procedure TSpCustomStream._Set_BaseStream(const ppUnkStream: IUnknown);
begin
  DefaultInterface.BaseStream := ppUnkStream;
end;

function TSpCustomStream.Read(out Buffer: OleVariant;
  NumberOfBytes: Integer): Integer;
begin
  Result := DefaultInterface.Read(Buffer, NumberOfBytes);
end;

function TSpCustomStream.Write(Buffer: OleVariant): Integer;
begin
  Result := DefaultInterface.Write(Buffer);
end;

function TSpCustomStream.Seek(Position: OleVariant;
  Origin: SpeechStreamSeekPositionType): OleVariant;
begin
  Result := DefaultInterface.Seek(Position, Origin);
end;

class function CoSpFileStream.Create: ISpeechFileStream;
begin
  Result := CreateComObject(CLASS_SpFileStream) as ISpeechFileStream;
end;

class function CoSpFileStream.CreateRemote(const MachineName: string)
  : ISpeechFileStream;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpFileStream)
    as ISpeechFileStream;
end;

procedure TSpFileStream.InitServerData;
const
  CServerData: TServerData = (ClassId: '{947812B3-2AE1-4644-BA86-9E90DED7EC91}';
    IntfIID: '{AF67F125-AB39-4E93-B4A2-CC2E66E182A7}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpFileStream.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechFileStream;
  end;
end;

procedure TSpFileStream.ConnectTo(svrIntf: ISpeechFileStream);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpFileStream.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpFileStream.GetDefaultInterface: ISpeechFileStream;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpFileStream.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpFileStream.Destroy;
begin
  inherited Destroy;
end;

function TSpFileStream.Get_Format: ISpeechAudioFormat;
begin
  Result := DefaultInterface.Format;
end;

procedure TSpFileStream._Set_Format(const AudioFormat: ISpeechAudioFormat);
begin
  DefaultInterface.Format := AudioFormat;
end;

function TSpFileStream.Read(out Buffer: OleVariant;
  NumberOfBytes: Integer): Integer;
begin
  Result := DefaultInterface.Read(Buffer, NumberOfBytes);
end;

function TSpFileStream.Write(Buffer: OleVariant): Integer;
begin
  Result := DefaultInterface.Write(Buffer);
end;

function TSpFileStream.Seek(Position: OleVariant;
  Origin: SpeechStreamSeekPositionType): OleVariant;
begin
  Result := DefaultInterface.Seek(Position, Origin);
end;

procedure TSpFileStream.Open(const FileName: WideString;
  FileMode: SpeechStreamFileMode; DoEvents: WordBool);
begin
  DefaultInterface.Open(FileName, FileMode, DoEvents);
end;

procedure TSpFileStream.Close;
begin
  DefaultInterface.Close;
end;

class function CoSpMemoryStream.Create: ISpeechMemoryStream;
begin
  Result := CreateComObject(CLASS_SpMemoryStream) as ISpeechMemoryStream;
end;

class function CoSpMemoryStream.CreateRemote(const MachineName: string)
  : ISpeechMemoryStream;
begin
  Result := CreateRemoteComObject(MachineName, CLASS_SpMemoryStream)
    as ISpeechMemoryStream;
end;

procedure TSpMemoryStream.InitServerData;
const
  CServerData: TServerData = (ClassId: '{5FB7EF7D-DFF4-468A-B6B7-2FCBD188F994}';
    IntfIID: '{EEB14B68-808B-4ABE-A5EA-B51DA7588008}'; EventIID: '';
    LicenseKey: nil; Version: 500);
begin
  ServerData := @CServerData;
end;

procedure TSpMemoryStream.Connect;
var
  punk: IUnknown;
begin
  if FIntf = nil then
  begin
    punk := GetServer;
    FIntf := punk as ISpeechMemoryStream;
  end;
end;

procedure TSpMemoryStream.ConnectTo(svrIntf: ISpeechMemoryStream);
begin
  Disconnect;
  FIntf := svrIntf;
end;

procedure TSpMemoryStream.Disconnect;
begin
  if FIntf <> nil then
  begin
    FIntf := nil;
  end;
end;

function TSpMemoryStream.GetDefaultInterface: ISpeechMemoryStream;
begin
  if FIntf = nil then
    Connect;
  Assert(FIntf <> nil,
    'DefaultInterface is NULL. Component is not connected to Server. You must call "Connect" or "ConnectTo" before this operation');
  Result := FIntf;
end;

constructor TSpMemoryStream.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
end;

destructor TSpMemoryStream.Destroy;
begin
  inherited Destroy;
end;

function TSpMemoryStream.Get_Format: ISpeechAudioFormat;
begin
  Result := DefaultInterface.Format;
end;

procedure TSpMemoryStream._Set_Format(const AudioFormat: ISpeechAudioFormat);
begin
  DefaultInterface.Format := AudioFormat;
end;

function TSpMemoryStream.Read(out Buffer: OleVariant;
  NumberOfBytes: Integer): Integer;
begin
  Result := DefaultInterface.Read(Buffer, NumberOfBytes);
end;

function TSpMemoryStream.Write(Buffer: OleVariant): Integer;
begin
  Result := DefaultInterface.Write(Buffer);
end;

function TSpMemoryStream.Seek(Position: OleVariant;
  Origin: SpeechStreamSeekPositionType): OleVariant;
begin
  Result := DefaultInterface.Seek(Position, Origin);
end;

procedure TSpMemoryStream.SetData(Data: OleVariant);
begin
  DefaultInterface.SetData(Data);
end;

function TSpMemoryStream.GetData: OleVariant;
begin
  Result := DefaultInterface.GetData;
end;

{$ENDREGION}

{$REGION 'Luna.Common'}
{ TBaseObject }
function TLuBaseObject.GetAttribute(aIndex: Byte): Boolean;
begin
  Result := Boolean(aIndex in FAttributes);
end;

procedure TLuBaseObject.SetAttribute(aIndex: Byte; aValue: Boolean);
begin
  if aValue then
    Include(FAttributes, aIndex)
  else
    Exclude(FAttributes, aIndex);
end;

function TLuBaseObject.GetAttributes: TLuObjectAttributeSet;
begin
  Result := FAttributes;
end;

procedure TLuBaseObject.SetAttributes(aValue: TLuObjectAttributeSet);
begin
  FAttributes := aValue;
end;

constructor TLuBaseObject.Create;
begin
  inherited;
  FOwner := nil;
  FPrev := nil;
  FNext := nil;
  FAttributes := [];
  Game.MasterObjectList.Add(Self);
end;

destructor TLuBaseObject.Destroy;
begin
  Game.MasterObjectList.Remove(Self, False);
  inherited;
end;

function TLuBaseObject.AttributesAreSet(aAttrs: TLuObjectAttributeSet): Boolean;
var
  LAttr: Byte;
begin
  Result := False;
  for LAttr in aAttrs do
  begin
    if LAttr in FAttributes then
    begin
      Result := True;
      Break;
    end;
  end;
end;

{ TBaseObjectList }
constructor TLuBaseObjectList.Create;
begin
  inherited;
  FHead := nil;
  FTail := nil;
  FCount := 0;
end;

destructor TLuBaseObjectList.Destroy;
begin
  Clean;
  inherited;
end;

procedure TLuBaseObjectList.Add(aObject: TLuBaseObject);
begin
  if not Assigned(aObject) then Exit;

  // check if already on this list
  if aObject.FOwner = Self then Exit;

  // remove if on another list
  if Assigned(aObject.FOwner) then
  begin
    aObject.FOwner.Remove(aObject, False);
  end;

  aObject.Prev := FTail;
  aObject.Next := nil;
  aObject.FOwner := Self;

  if FHead = nil then
    begin
      FHead := aObject;
      FTail := aObject;
    end
  else
    begin
      FTail.Next := aObject;
      FTail := aObject;
    end;

  Inc(FCount);
end;

procedure TLuBaseObjectList.Remove(aObject: TLuBaseObject; aDispose: Boolean);
var
  LFlag: Boolean;
begin
  if not Assigned(aObject) then Exit;

  // check if aObject is on this list
  if aObject.Owner <> Self then Exit;

  LFlag := False;

  if aObject.Next <> nil then
  begin
    aObject.Next.Prev := aObject.Prev;
    LFlag := True;
  end;

  if aObject.Prev <> nil then
  begin
    aObject.Prev.Next := aObject.Next;
    LFlag := True;
  end;

  if FTail = aObject then
  begin
    FTail := FTail.Prev;
    LFlag := True;
  end;

  if FHead = aObject then
  begin
    FHead := FHead.Next;
    LFlag := True;
  end;

  if LFlag = True then
  begin
    aObject.FOwner := nil;
    Dec(FCount);
    if aDispose then
    begin
      aObject.Free;
    end;
  end;
end;

procedure TLuBaseObjectList.Clean;
var
  LPrev: TLuBaseObject;
  LNext: TLuBaseObject;
begin
  // get pointer to head
  LPrev := FHead;

  // exit if list is empty
  if LPrev = nil then
    Exit;

  repeat
    // save pointer to next object
    LNext := LPrev.Next;

    Remove(LPrev, True);

    // get pointer to next object
    LPrev := LNext;

  until LPrev = nil;
end;

procedure TLuBaseObjectList.Clear(aAttrs: TLuObjectAttributeSet);
var
  LPrev: TLuBaseObject;
  LNext: TLuBaseObject;
  LNoAttrs: Boolean;
begin
  // get pointer to head
  LPrev := FHead;

  // exit if list is empty
  if LPrev = nil then Exit;

  // check if we should check for attrs
  LNoAttrs := Boolean(aAttrs = []);

  repeat
    // save pointer to next object
    LNext := LPrev.Next;

    if LNoAttrs then
      begin
        Remove(LPrev, True);
      end
    else
      begin
        if LPrev.AttributesAreSet(aAttrs) then
        begin
          Remove(LPrev, True);
        end;
      end;

    // get pointer to next object
    LPrev := LNext;

  until LPrev = nil;
end;

{$ENDREGION}

{$REGION 'Luna.Speech'}
{ TLuSpeech }
procedure TLuSpeech.OnWord(aSender: TObject; aStreamNumber: Integer; aStreamPosition: OleVariant; aCharacterPosition, aLength: Integer);
var
  LWord: string;
begin
  if FText.IsEmpty then Exit;
  LWord := FText.Substring(aCharacterPosition, aLength);
  if not FSubList.TryGetValue(LWord, FWord) then
    FWord := LWord;
  Game.OnSpeechWord(FWord, FText);
end;

//procedure OnStartStream(aSender: TObject; aStreamNumber: Integer; aStreamPosition: OleVariant);
//begin
//end;

procedure TLuSpeech.DoSpeak(aText: string; aFlags: Integer);
begin
  if FSpVoice = nil then Exit;
  if aText.IsEmpty then Exit;
  if FPaused then Resume;
  FSpVoice.Speak(aText, aFlags);
  FText := aText;
end;

procedure TLuSpeech.EnumVoices;
var
  LI: Integer;
  LSOToken: ISpeechObjectToken;
  LSOTokens: ISpeechObjectTokens;
begin
  FVoiceList := TInterfaceList.Create;
  FVoiceDescList := TStringList.Create;
  LSOTokens := FSpVoice.GetVoices('', '');
  for LI := 0 to LSOTokens.Count - 1 do
  begin
    LSOToken := LSOTokens.Item(LI);
    FVoiceDescList.Add(LSOToken.GetDescription(0));
    FVoiceList.Add(LSOToken);
  end;
end;

procedure TLuSpeech.FreeVoices;
begin
  FreeAndNil(FVoiceDescList);
  FreeAndNil(FVoiceList);
end;

procedure TLuSpeech.Setup;
begin
  FPaused := False;
  FText := '';
  FWord := '';
  FVoice := 0;
  FSpVoice := TSpVoice.Create(nil);
  FSpVoice.EventInterests := SVEAllEvents;
  EnumVoices;
  //FSpVoice.OnStartStream := OnStartStream;
  FSpVoice.OnWord := OnWord;
  FSubList := TDictionary<string, string>.Create;
end;

procedure TLuSpeech.Shutdown;
begin
  FreeAndNil(FSubList);
  FreeVoices;
  FSpVoice.OnWord := nil;
  FSpVoice.Free;
end;

constructor TLuSpeech.Create;
begin
  inherited;

  Setup;
end;

destructor TLuSpeech.Destroy;
begin
  Shutdown;

  inherited;
end;

// --- ISpeech --------------------------------------------------------------
function  TLuSpeech.GetVoiceCount: Integer;
begin
  Result := FVoiceList.Count;
end;

function  TLuSpeech.GetVoiceAttribute(aIndex: Integer; aAttribute: TLuSpeechVoiceAttribute): WideString;
var
  LSOToken: ISpeechObjectToken;

  function GetAttr(aItem: string): string;
  begin
    if aItem = 'Id' then
      Result := LSOToken.Id
    else
      Result := LSOToken.GetAttribute(aItem);
  end;

begin
  Result := '';
  if (aIndex < 0) or (aIndex > FVoiceList.Count - 1) then
    Exit;
  LSOToken := ISpeechObjectToken(FVoiceList.Items[aIndex]);
  case aAttribute of
    vaDescription: Result := FVoiceDescList[aIndex];
    vaName       : Result := GetAttr('Name');
    vaVendor     : Result := GetAttr('Vendor');
    vaAge        : Result := GetAttr('Age');
    vaGender     : Result := GetAttr('Gender');
    vaLanguage   : Result := GetAttr('Language');
    vaId         : Result := GetAttr('Id');
  end;
end;

procedure TLuSpeech.ChangeVoice(aIndex: Integer);
var
  LSOToken: ISpeechObjectToken;
begin
  if (aIndex < 0) or (aIndex > FVoiceList.Count - 1) then Exit;
  if aIndex = FVoice then Exit;
  LSOToken := ISpeechObjectToken(FVoiceList.Items[aIndex]);
  FSpVoice.Voice := LSOToken;
  FVoice := aIndex;
end;

function  TLuSpeech.GetVoice: Integer;
begin
  Result := FVoice;
end;

procedure TLuSpeech.SetVolume(aVolume: Single);
var
  LVolume: Integer;
begin
  if aVolume < 0 then
    aVolume := 0
  else if aVolume > 1 then
    aVolume := 1;

  LVolume := Round(100.0 * aVolume);

  if FSpVoice = nil then
    Exit;
  FSpVoice.Volume := LVolume;
end;

function  TLuSpeech.GetVolume: Single;
begin
  Result := 0;
  if FSpVoice = nil then Exit;
  Result := FSpVoice.Volume / 100.0;
end;

procedure TLuSpeech.SetRate(aRate: Single);
var
  LVolume: Integer;
begin
  if aRate < 0 then
    aRate := 0
  else if aRate > 1 then
    aRate := 1;

  LVolume := Round(20.0 * aRate) - 10;

  if LVolume < -10 then
    LVolume := -10
  else if LVolume > 10 then
    LVolume := 10;

  if FSpVoice = nil then
    Exit;
  FSpVoice.Rate := LVolume;
end;

function  TLuSpeech.GetRate: Single;
begin
  Result := 0;
  if FSpVoice = nil then Exit;
  Result := (FSpVoice.Rate + 10.0) / 20.0;
end;

procedure TLuSpeech.Clear;
begin
  if FSpVoice = nil then Exit;
  if Active then
  begin
    FSpVoice.Skip('Sentence', MaxInt);
    Say(' ', True);
  end;
  FText := '';
end;

procedure TLuSpeech.Say(const aText: WideString; aPurge: Boolean);
var
  LFlag: Integer;
  LText: string;
begin
  LFlag := SVSFlagsAsync;
  LText := aText;
  if aPurge then
    LFlag := LFlag or SVSFPurgeBeforeSpeak;
  DoSpeak(LText, LFlag);
end;

function  TLuSpeech.Active: Boolean;
begin
  Result := False;
  if FSpVoice = nil then Exit;
  Result := Boolean(FSpVoice.Status.RunningState <> SRSEDone);
end;

procedure TLuSpeech.Pause;
begin
  if FSpVoice = nil then Exit;
  FSpVoice.Pause;
  FPaused := True;
end;

procedure TLuSpeech.Resume;
begin
  if FSpVoice = nil then Exit;
  FSpVoice.Resume;
  FPaused := False;
end;

procedure TLuSpeech.Reset;
begin
  Clear;
  FreeAndNil(FSpVoice);
  FPaused := False;
  FText := '';
  FWord := '';
  FSpVoice := TSpVoice.Create(nil);
  FSpVoice.EventInterests := SVEAllEvents;
  EnumVoices;
  //FSpVoice.OnStartStream := OnStartStream;
  FSpVoice.OnWord := OnWord;
  FSubList.Clear;
end;

procedure TLuSpeech.SubstituteWord(const aWord: WideString; const aSubstituteWord: WideString);
var
  LWord: string;
  LSubstituteWord: string;
begin
  LWord := aWord;
  LSubstituteWord := aSubstituteWord;
  if LWord.IsEmpty then Exit;
  if LSubstituteWord.IsEmpty then Exit;
  FSubList.TryAdd(LWord, LSubstituteWord);
end;

{$ENDREGION}

{$REGION 'Luna.CloudDb'}
{ TLuCloudDb }
procedure TLuCloudDb.SetMacroValue(const aName, aValue: string);
begin
  FPrepairedSQL := FPrepairedSQL.Replace('&'+aName, aValue);
end;

procedure TLuCloudDb.SetParamValue(const aName, aValue: string);
begin
  FPrepairedSQL := FPrepairedSQL.Replace(':'+aName, ''''+aValue+'''');
end;

procedure TLuCloudDb.Prepair;
var
  LKey: string;
begin
  FPrepairedSQL := FSQL.Text;

  // substitue macros
  for LKey in FMacros.Keys do
  begin
    SetMacroValue(LKey, FMacros.Items[LKey]);
  end;

  // substitue field params
  for LKey in FParams.Keys do
  begin
    SetParamValue(LKey, FParams.Items[LKey]);
  end;

end;

constructor  TLuCloudDb.Create;
begin
  inherited;
  FSQL := TStringList.Create;
  FHttp := THTTPClient.Create;
  FMacros := TDictionary<string, string>.Create;
  FParams := TDictionary<string, string>.Create;
end;

destructor TLuCloudDb.Destroy;
begin
  if Assigned(FJson) then Game.FreeNilObject(FJson);
  Game.FreeNilObject(FParams);
  Game.FreeNilObject(FMacros);
  Game.FreeNilObject(FHttp);
  Game.FreeNilObject(FSQL);
  inherited;
end;

procedure TLuCloudDb.Setup(const aURL, aApiKey, aDatabase: string);
begin
  FUrl := aURL + cURL;
  FApiKey := aApiKey;
  FDatabase := aDatabase;
end;

procedure TLuCloudDb.ClearSQLText;
begin
  FSQL.Clear;
end;

procedure TLuCloudDb.AddSQLText(const aText: string; const aArgs: array of const);
begin
  FSQL.Add(Format(aText, aArgs));
end;

function  TLuCloudDb.GetSQLText: string;
begin
  Result := FSQL.Text;
end;

procedure TLuCloudDb.SetSQLText(const aText: string);
begin
  FSQL.Text := aText;
end;

function  TLuCloudDb.GetMacro(const aName: string): string;
begin
  FMacros.TryGetValue(aName, Result);
end;

procedure TLuCloudDb.SetMacro(const aName, aValue: string);
begin
  FMacros.AddOrSetValue(aName, aValue);
end;

function  TLuCloudDb.GetParam(const aName: string): string;
begin
  FParams.TryGetValue(aName, Result);
end;

procedure TLuCloudDb.SetParam(const aName, aValue: string);
begin
  FParams.AddOrSetValue(aName, aValue);
end;

function  TLuCloudDb.RecordCount: Integer;
begin
  Result := 0;
  if not Assigned(FDataset) then Exit;
  Result := FDataset.Count;
end;

function  TLuCloudDb.GetField(const aIndex: Cardinal; const aName: string): string;
begin
  Result := '';
  if not Assigned(FDataset) then Exit;
  if aIndex > Cardinal(FDataset.Count-1) then Exit;
  Result := FDataset.Items[aIndex].GetValue<string>(aName);
end;

function  TLuCloudDb.GetQueryURL(const aSQL: string): string;
begin
  Result := Format(FUrl, [FApiKey, FDatabase, aSQL]);
end;

function  TLuCloudDb.GetPrepairedSQL: string;
begin
  Result := FPrepairedSQL;
end;

function TLuCloudDb.Execute: Boolean;
begin
  Prepair;
  Result := ExecuteSQL(FPrepairedSQL);
end;

function  TLuCloudDb.ExecuteSQL(const aSQL: string): Boolean;
var
  LResponse: IHTTPResponse;
begin
  Result := False;
  if aSQL.IsEmpty then Exit;
  LResponse := FHttp.Get(GetQueryURL(aSQL));
  FResponseText := LResponse.ContentAsString;
  if Assigned(FJson) then
  begin
    Game.FreeNilObject(FJson);
    FDataset := nil;
  end;
  FJson := TJSONObject.ParseJSONValue(FResponseText) as TJSONObject;
  FLastError := FJson.GetValue('response').Value;
  Result := Boolean(FLastError.IsEmpty or SameText(FLastError, 'true'));
  if FLastError.IsEmpty then
  begin
    if Assigned(FDataset) then Game.FreeNilObject(FDataset);
    FJson.TryGetValue('response', FDataset);
  end;
  if not Assigned(FDataset) then
    Game.FreeNilObject(FJson);
end;

function TLuCloudDb.GetLastError: string;
begin
  Result := FLastError;
end;

function TLuCloudDb.GetResponseText: string;
begin
  Result:= FResponseText;
end;


{$ENDREGION}

{$REGION 'Luna.Game'}
{ Routines }
procedure LuRunGame(const aGame: TLuGameClass);
var
  LGame: TLuGame;
  LMarshaller: TMarshaller;
  LMsg: string;
begin
  try
    LGame := Game;
    try
      Game := aGame.Create;
      try
        try
          if not Game.OnStartup then Exit;
          Game.OnRun;
        finally
          Game.OnShutdown;
        end;
      finally
        Game.Free;
      end;
    finally
      Game := LGame;
    end;
  except
    on E: Exception do
    begin
      LMsg := Format('%s: %s', [E.ClassName, E.Message]);
      SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, 'Fatal Error', LMarshaller.AsUtf8(LMsg).ToPointer, nil);
    end;
  end;
end;

{ TLuGame }
constructor TLuGame.Create;
begin
  inherited;

  FOrgName := 'tinyBigGAMES';
  FAppName := 'LunaGameToolkit';

  // init master object list
  FMasterObjectList := TLuBaseObjectList.Create;
end;

destructor TLuGame.Destroy;
begin
  // free master object list
  FreeNilObject(FMasterObjectList);

  inherited;
end;

function  TLuGame.OnStartup: Boolean;
begin
  // init objects
  FSpeech := TLuSpeech.Create;

  Result := True;
end;

procedure TLuGame.OnShutdown;
begin
  // free object
  FreeNilObject(FSpeech);

  // clean master list
  FMasterObjectList.Clean;
end;

procedure TLuGame.OnRun;
begin
end;

procedure TLuGame.OnSpeechWord(const aWord, aText: string);
begin
end;

function  TLuGame.HasConsoleOutput: Boolean;
var
  LStdout: THandle;
begin
  Result := False;
  LStdout := GetStdHandle(STD_OUTPUT_HANDLE);
  if LStdout = Invalid_Handle_Value then Exit;
  Result := Boolean(LStdout <> 0);
end;

function  TLuGame.HasConsoleOnStartup: Boolean;
var
  LConsoleHWnd: THandle;
  LProcessId: DWORD;
begin
  LConsoleHWnd := GetConsoleWindow;
  if LConsoleHWnd <> 0 then
    begin
      GetWindowThreadProcessId(LConsoleHWnd, LProcessId);
      Result := GetCurrentProcessId <> LProcessId;
    end
  else
    Result := False;
end;

procedure TLuGame.WaitForAnyKey;
var
  LInputRec: TInputRecord;
  LNumRead: Cardinal;
  LOldMode: DWORD;
  LStdIn: THandle;
begin
  LStdIn := GetStdHandle(STD_INPUT_HANDLE);
  GetConsoleMode(LStdIn, LOldMode);
  SetConsoleMode(LStdIn, 0);
  repeat
    ReadConsoleInput(LStdIn, LInputRec, 1, LNumRead);
  until (LInputRec.EventType and KEY_EVENT <> 0) and LInputRec.Event.KeyEvent.bKeyDown;
  SetConsoleMode(LStdIn, LOldMode);
end;

procedure TLuGame.Pause(const aMsg: string);
begin
  if HasConsoleOutput and (not HasConsoleOnStartup) then
  begin
    WriteLn;
    if aMsg.IsEmpty then
      Write('Press any key to continue... ')
    else
      Write(aMsg);
    WaitForAnyKey;
    WriteLn;
  end;
end;

procedure TLuGame.Print(const aMsg: string);
begin
  Print(aMsg, []);
end;

procedure TLuGame.Print(const aMsg: string; const aArgs: array of const);
begin
  if not HasConsoleOutput then Exit;
  Write(Format(aMsg, aArgs));
end;

procedure TLuGame.PrintLn;
begin
  PrintLn('', []);
end;

procedure TLuGame.PrintLn(const aMsg: string);
begin
  PrintLn(aMsg, []);
end;

procedure TLuGame.PrintLn(const aMsg: string; const aArgs: array of const);
begin
  if not HasConsoleOutput then Exit;
  WriteLn(Format(aMsg, aArgs));
end;

{ Utils }
procedure TLuGame.ShellOpen(const aFilename: string);
begin
  if aFilename.IsEmpty then Exit;
  ShellExecute(0, 'OPEN', PChar(aFilename), '', '', SW_SHOWNORMAL);
end;

function  TLuGame.GetVersionInfo(aInstance: THandle; aIdent: string): string;
type
  TLang = packed record
    Lng, Page: WORD;
  end;
  TLangs = array [0 .. 10000] of TLang;
  PLangs = ^TLangs;
var
  BLngs: PLangs;
  BLngsCnt: Cardinal;
  BLangId: String;
  RM: TMemoryStream;
  RS: TResourceStream;
  BP: PChar;
  BL: Cardinal;
  BId: String;

begin
  // Assume error
  Result := '';

  RM := TMemoryStream.Create;
  try
    // Load the version resource into memory
    RS := TResourceStream.CreateFromID(aInstance, 1, RT_VERSION);
    try
      RM.CopyFrom(RS, RS.Size);
    finally
      FreeNilObject(RS);
    end;

    // Extract the translations list
    if not VerQueryValue(RM.Memory, '\\VarFileInfo\\Translation', Pointer(BLngs), BL) then
      Exit; // Failed to parse the translations table
    BLngsCnt := BL div sizeof(TLang);
    if BLngsCnt <= 0 then
      Exit; // No translations available

    // Use the first translation from the table (in most cases will be OK)
    with BLngs[0] do
      BLangId := IntToHex(Lng, 4) + IntToHex(Page, 4);

    // Extract field by parameter
    BId := '\\StringFileInfo\\' + BLangId + '\\' + aIdent;
    if not VerQueryValue(RM.Memory, PChar(BId), Pointer(BP), BL) then
      exit; // No such field

    // Prepare result
    Result := BP;
  finally
    FreeNilObject(RM);
  end;
end;

function  TLuGame.GetVersionInfo(const aFilename: string; aIdent: string): string;
begin
  Result := GetVersionInfo(GetModuleHandle(PChar(aFilename)), aIdent);
end;

procedure TLuGame.FreeNilObject(const [ref] aObject: TObject);
var
  LObject: TObject;
begin
  if not Assigned(aObject) then Exit;
  LObject := aObject;
  TObject(Pointer(@aObject)^) := nil;
  LObject.Free;
end;

function TLuGame.UnitToScalarValue(const aValue, aMaxValue: Double): Double;
var
  LGain: Double;
  LFactor: Double;
  LVolume: Double;
begin
  LGain := (EnsureRange(aValue, 0.0, 1.0) * 50) - 50;
  LFactor := Power(10, LGain * 0.05);
  LVolume := EnsureRange(aMaxValue * LFactor, 0, aMaxValue);
  Result := LVolume;
end;

function TLuGame.HttpGet(const aURL: string; aStatus: PString=nil): string;
var
  LHttp: THTTPClient;
  LResponse: IHTTPResponse;
begin
  LHttp := THTTPClient.Create;
  try
    LResponse := LHttp.Get(aURL);
    Result := LResponse.ContentAsString;
    if Assigned(aStatus) then
      aStatus^ := LResponse.StatusText;
  finally
    FreeNilObject(LHttp);
  end;
end;

{ Prefs }
function  TLuGame.GetOrgName: string;
begin
  Result := FOrgName;
end;

procedure TLuGame.SetOrgName(const aOrgName: string);
begin
  FOrgName := aOrgName;
end;

function  TLuGame.GetAppName: string;
begin
  Result := FAppName;
end;

procedure TLuGame.SetAppName(const aAppName: string);
begin
  FAppName := aAppName;
end;

function  TLuGame.GetPrefsPath: string;
begin
  Result := string(SDL_GetPrefPath(FMarshaller.AsUtf8(FOrgName).ToPointer, FMarshaller.AsUtf8(FAppName).ToPointer));
end;

procedure TLuGame.GotoPrefsPath;
begin
  ShellOpen(GetPrefsPath);
end;

{ Speech }
function  TLuGame.GetSpeechVoiceCount: Integer;
begin
  Result := TLuSpeech(FSpeech).GetVoiceCount;
end;

function  TLuGame.GetSpeechVoiceAttribute(aIndex: Integer; aAttribute: TLuSpeechVoiceAttribute): string;
begin
  Result := TLuSpeech(FSpeech).GetVoiceAttribute(aIndex, aAttribute);
end;

procedure TLuGame.ChangeSpeechVoice(aIndex: Integer);
begin
  TLuSpeech(FSpeech).ChangeVoice(aIndex);
end;

function  TLuGame.GetSpeechVoice: Integer;
begin
  Result := TLuSpeech(FSpeech).GetVoice;
end;

procedure TLuGame.SetSpeechVolume(aVolume: Single);
begin
  TLuSpeech(FSpeech).SetVolume(aVolume)
end;

function  TLuGame.GetSpeechVolume: Single;
begin
  Result := TLuSpeech(FSpeech).GetVolume;
end;

procedure TLuGame.SetSpeechRate(aRate: Single);
begin
  TLuSpeech(FSpeech).SetRate(aRate);
end;

function  TLuGame.GetSpeechRate: Single;
begin
  Result := TLuSpeech(FSpeech).GetRate;
end;

procedure TLuGame.ClearSpeech;
begin
  TLuSpeech(FSpeech).Clear;
end;

procedure TLuGame.Speak(const aText: string; aPurge: Boolean);
begin
  TLuSpeech(FSpeech).Say(aText, aPurge);
end;

function  TLuGame.SpeechActive: Boolean;
begin
  Result := TLuSpeech(FSpeech).Active;
end;

procedure TLuGame.PauseSpeech;
begin
  TLuSpeech(FSpeech).Pause;
end;

procedure TLuGame.ResumeSpeech;
begin
  TLuSpeech(FSpeech).Resume;
end;

procedure TLuGame.ResetSpeech;
begin
  TLuSpeech(FSpeech).Reset;
end;

procedure TLuGame.SubstituteSpeechWord(const aWord, aSubstituteWord: string);
begin
  TLuSpeech(FSpeech).SubstituteWord(aWord, aSubstituteWord);
end;


{$ENDREGION}

{$REGION 'Unit Init/Final'}
initialization
begin
  ReportMemoryLeaksOnShutdown := True;
  LoadDLL;
end;

finalization
begin
  UnloadDLL;
end;
{$ENDREGION}

end.
